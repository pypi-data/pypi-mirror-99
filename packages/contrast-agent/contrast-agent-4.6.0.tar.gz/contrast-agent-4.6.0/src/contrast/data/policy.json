{
  "sources": {
    "django": [
      {
        "module": "django.http.request",
        "class_name": "HttpRequest",
        "instance_method": true,
        "method_name": "get_host",
        "target": "RETURN",
        "type": "URI",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "django.http.request",
        "class_name": "HttpRequest",
        "instance_method": true,
        "method_name": "get_port",
        "target": "RETURN",
        "type": "URI",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "django.http.request",
        "class_name": "HttpRequest",
        "instance_method": true,
        "method_name": "get_full_path",
        "target": "RETURN",
        "type": "URI",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "django.http.request",
        "class_name": "HttpRequest",
        "instance_method": true,
        "method_name": "get_full_path_info",
        "target": "RETURN",
        "type": "URI",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "django.http.request",
        "class_name": "HttpRequest",
        "instance_method": true,
        "method_name": "get_raw_uri",
        "target": "RETURN",
        "type": "URI",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "django.http.request",
        "class_name": "HttpRequest",
        "instance_method": true,
        "method_name": "body",
        "target": "RETURN",
        "type": "BODY",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "django.http.request",
        "class_name": "HttpRequest",
        "instance_method": true,
        "method_name": "scheme",
        "target": "RETURN",
        "type": "OTHER",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "django.http.request",
        "class_name": "HttpRequest",
        "instance_method": true,
        "method_name": "encoding",
        "target": "RETURN",
        "type": "OTHER",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "django.http.request",
        "class_name": "HttpHeaders",
        "instance_method": true,
        "method_name": "__getitem__",
        "target": "RETURN",
        "type": "HEADER",
        "tags": [
          "NO_NEWLINES"
        ],
        "comment": "Header can't trigger XSS unless the key is Referer"
      },
      {
        "module": "django.http.request",
        "class_name": "HttpHeaders",
        "instance_method": true,
        "method_name": "keys",
        "target": "RETURN",
        "type": "HEADER_KEY",
        "tags": [
          "NO_NEWLINES"
        ],
        "comment": "Header key can't trigger XSS"
      },
      {
        "module": "django.utils.datastructures",
        "class_name": "MultiValueDict",
        "instance_method": true,
        "method_name": "__getitem__",
        "target": "RETURN",
        "type": "PARAMETER",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "django.core.files.uploadedfile",
        "class_name": "UploadedFile",
        "instance_method": true,
        "method_name": "__init__",
        "target": "ARG_0,KWARG:file",
        "type": "MULTIPART_CONTENT_DATA",
        "tags": [
          "CROSS_SITE"
        ],
        "comment": [
            "This was added to handle file uploads in Django REST Framework.",
            "For regular Django, this is redundant with the file tracker in middleware"
        ]
      }
    ],
    "flask": [
      {
        "module": "flask.wrappers",
        "class_name": "Request",
        "instance_method": true,
        "method_name": "form",
        "target": "RETURN",
        "type": "MULTIPART_FORM_DATA",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "flask.wrappers",
        "class_name": "Request",
        "instance_method": true,
        "method_name": "data",
        "target": "RETURN",
        "type": "BODY",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "flask.wrappers",
        "class_name": "Request",
        "instance_method": true,
        "method_name": "args",
        "target": "RETURN",
        "type": "QUERYSTRING",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "flask.wrappers",
        "class_name": "Request",
        "instance_method": true,
        "method_name": "cookies",
        "target": "RETURN",
        "type": "COOKIE",
        "tags": [
          "NO_NEWLINES"
        ]
      },
      {
        "module": "flask.wrappers",
        "class_name": "Request",
        "instance_method": true,
        "method_name": "headers",
        "target": "RETURN",
        "type": "HEADER",
        "tags": [
          "NO_NEWLINES"
        ]
      },
      {
        "module": "flask.wrappers",
        "class_name": "Request",
        "instance_method": true,
        "method_name": "path",
        "target": "RETURN",
        "type": "PARAMETER",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "flask.wrappers",
        "class_name": "Request",
        "instance_method": true,
        "method_name": "full_path",
        "target": "RETURN",
        "type": "PARAMETER",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "flask.wrappers",
        "class_name": "Request",
        "instance_method": true,
        "method_name": "base_url",
        "target": "RETURN",
        "type": "URI",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "flask.wrappers",
        "class_name": "Request",
        "instance_method": true,
        "method_name": "host",
        "target": "RETURN",
        "type": "URI",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "flask.wrappers",
        "class_name": "Request",
        "instance_method": true,
        "method_name": "host_url",
        "target": "RETURN",
        "type": "URI",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "flask.wrappers",
        "class_name": "Request",
        "instance_method": true,
        "method_name": "url",
        "target": "RETURN",
        "type": "URI",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "flask.wrappers",
        "class_name": "Request",
        "instance_method": true,
        "method_name": "url_root",
        "target": "RETURN",
        "type": "URI",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "werkzeug.datastructures",
        "class_name": "MultiDict",
        "instance_method": true,
        "method_name": "__getitem__",
        "target": "RETURN",
        "type": "PARAMETER",
        "tags": [
          "CROSS_SITE"
        ],
        "comment": "MultiDict is the parent class for flask.wrappers.Request that get request dict values."
      },
      {
        "module": "werkzeug.datastructures",
        "class_name": "MultiDict",
        "instance_method": true,
        "method_name": "getlist",
        "target": "RETURN",
        "type": "PARAMETER",
        "tags": [
          "CROSS_SITE"
        ],
        "comment": "getlist uses the Python dict __getitem__ so we cannot rely on __getitem__ for patching"
      },
      {
        "module": "werkzeug.datastructures",
        "class_name": "TypeConversionDict",
        "instance_method": true,
        "method_name": "get",
        "target": "RETURN",
        "type": "PARAMETER",
        "tags": [
          "CROSS_SITE"
        ],
        "comment": "Flask uses werkzeug TypeConversionDict as its dict storage class. Cannot patch __getitem__ as it uses Python's dict __getitem__"
      },
      {
        "module": "werkzeug.datastructures",
        "class_name": "EnvironHeaders",
        "instance_method": true,
        "method_name": "__getitem__",
        "target": "RETURN",
        "type": "HEADER",
        "tags": [
          "NO_NEWLINES"
        ]
      }
    ],
    "webob": [
      {
        "module": "webob.multidict",
        "class_name": "MultiDict",
        "instance_method": true,
        "method_name": "__getitem__",
        "target": "RETURN",
        "type": "PARAMETER",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "webob.multidict",
        "class_name": "MultiDict",
        "instance_method": true,
        "method_name": "getall",
        "target": "RETURN",
        "type": "PARAMETER",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "webob.multidict",
        "class_name": "MultiDict",
        "instance_method": true,
        "method_name": "mixed",
        "target": "RETURN",
        "type": "PARAMETER",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "webob.multidict",
        "class_name": "MultiDict",
        "instance_method": true,
        "method_name": "dict_of_lists",
        "target": "RETURN",
        "type": "PARAMETER",
        "tags": [
          "CROSS_SITE"
        ]
      },
      {
        "module": "webob.headers",
        "class_name": "EnvironHeaders",
        "instance_method": true,
        "method_name": "__getitem__",
        "target": "RETURN",
        "type": "HEADER",
        "tags": [
          "NO_NEWLINES"
        ]
      },
      {
        "module": "webob.cookies",
        "class_name": "RequestCookies",
        "instance_method": true,
        "method_name": "__getitem__",
        "target": "RETURN",
        "type": "COOKIE",
        "tags": [
          "NO_NEWLINES"
        ]
      },
      {
        "module": "webob.request",
        "class_name": "BaseRequest",
        "instance_method": true,
        "method_name": "query_string",
        "target": "RETURN",
        "type": "QUERYSTRING",
        "tags": [
          "NO_NEWLINES",
          "CROSS_SITE"
        ]
      },
      {
        "module": "webob.request",
        "class_name": "BaseRequest",
        "instance_method": true,
        "method_name": "host_url",
        "target": "RETURN",
        "type": "URI",
        "tags": [
          "NO_NEWLINES",
          "CROSS_SITE"
        ]
      }
    ],
    "falcon": [
    ]
  },
  "propagators": [
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "concat",
      "source": "OBJ,ARG_0",
      "target": "RETURN",
      "action": "APPEND",
      "policy_patch": false,
      "comment": "There is no kwarg corresponding to ARG_0"
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "repeat",
      "source": "OBJ",
      "target": "RETURN",
      "action": "SPLAT",
      "policy_patch": false,
      "comment": [
        "This is string multiplication",
        "TODO: PYT-1345 SPLAT makes this prone to FPs"
      ]
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "capitalize",
      "source": "OBJ",
      "target": "RETURN",
      "action": "KEEP",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "translate",
      "source": "OBJ",
      "target": "RETURN",
      "action": "SPLAT",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "casefold",
      "source": "OBJ",
      "target": "RETURN",
      "action": "KEEP",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "lower",
      "source": "OBJ",
      "target": "RETURN",
      "action": "KEEP",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "swapcase",
      "source": "OBJ",
      "target": "RETURN",
      "action": "KEEP",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "title",
      "source": "OBJ",
      "target": "RETURN",
      "action": "KEEP",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "upper",
      "source": "OBJ",
      "target": "RETURN",
      "action": "KEEP",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "encode",
      "source": "OBJ",
      "target": "RETURN",
      "action": "KEEP",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "decode",
      "source": "OBJ",
      "target": "RETURN",
      "action": "KEEP",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "ljust",
      "source": "OBJ",
      "target": "RETURN",
      "action": "APPEND",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "zfill",
      "source": "OBJ",
      "target": "RETURN",
      "action": "PREPEND",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "center",
      "source": "OBJ",
      "target": "RETURN",
      "action": "CENTER",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "rjust",
      "source": "OBJ",
      "target": "RETURN",
      "action": "PREPEND",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "replace",
      "source": "OBJ,ARG_1",
      "target": "RETURN",
      "action": "REPLACE",
      "policy_patch": false,
      "comment": "replace() takes no keyword arguments"
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "format",
      "source": "OBJ,ALL_ARGS,ALL_KWARGS",
      "target": "RETURN",
      "action": "FORMAT",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "cformat",
      "source": "OBJ,ALL_ARGS",
      "target": "RETURN",
      "action": "FORMAT",
      "policy_patch": false,
      "comment": "cformat uses the % operator, so there are no kwargs"
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "formatmap",
      "source": "OBJ,ALL_ARGS",
      "target": "RETURN",
      "action": "FORMAT",
      "policy_patch": false,
      "comment": "format_map() takes no keyword arguments"
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "fstring",
      "source": "OBJ,ARG_0",
      "target": "RETURN",
      "action": "JOIN",
      "policy_patch": false,
      "comment": "fstring formatting is accomplished with string joins, and doesn't use kwargs"
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "strip",
      "source": "OBJ",
      "target": "RETURN",
      "action": "REMOVE",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "lstrip",
      "source": "OBJ",
      "target": "RETURN",
      "action": "REMOVE",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "rstrip",
      "source": "OBJ",
      "target": "RETURN",
      "action": "REMOVE",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "removeprefix",
      "source": "OBJ",
      "target": "RETURN",
      "action": "REMOVE",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "removesuffix",
      "source": "OBJ",
      "target": "RETURN",
      "action": "REMOVE",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "subscript",
      "source": "OBJ",
      "target": "RETURN",
      "action": "SLICE",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "join",
      "source": "OBJ,ARG_0",
      "target": "RETURN",
      "action": "JOIN",
      "policy_patch": false,
      "comment": "join() takes no keyword arguments"
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "split",
      "source": "OBJ",
      "target": "RETURN",
      "action": "SPLIT",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "splitlines",
      "source": "OBJ",
      "target": "RETURN",
      "action": "SPLIT",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "rsplit",
      "source": "OBJ",
      "target": "RETURN",
      "action": "SPLIT",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "partition",
      "source": "OBJ",
      "target": "RETURN",
      "action": "SPLIT",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "rpartition",
      "source": "OBJ",
      "target": "RETURN",
      "action": "SPLIT",
      "policy_patch": false
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": false,
      "method_name": "CAST",
      "source": "ARG_0,KWARG:object,KWARG:string",
      "target": "RETURN",
      "action": "SPLAT",
      "policy_patch": false,
      "comment": [
        "This is str(), bytes(), unicode(), or bytearray(). The reported name is slightly misleading.",
        "Unicode in py2 has ARG_0 named `string`. This is undocumented!"
      ]
    },
    {
      "module": "BUILTIN",
      "class_name": "str",
      "instance_method": true,
      "method_name": "__repr__",
      "source": "OBJ",
      "target": "RETURN",
      "action": "REPR",
      "policy_patch": false
    },
    {
      "module": "re",
      "method_name": "split",
      "source": "ARG_1,KWARG:string",
      "target": "RETURN",
      "action": "REGEX_SPLIT",
      "policy_patch": true
    },
    {
      "module": "re",
      "class_name": "Pattern",
      "method_name": "split",
      "instance_method": true,
      "source": "ARG_0,KWARG:string,KWARG:source",
      "target": "RETURN",
      "action": "REGEX_SPLIT",
      "policy_patch": false,
      "comment": "The 'source' keyword was used in earlier versions of Py27 but was deprecated"
    },
    {
      "module": "re",
      "method_name": "sub",
      "source": "ARG_0,KWARG:string",
      "target": "RETURN",
      "action": "NONE",
      "policy_patch": false
    },
    {
      "module": "re",
      "method_name": "subn",
      "source": "ARG_0,KWARG:string",
      "target": "RETURN",
      "action": "NONE",
      "policy_patch": false
    },
    {
      "module": "re",
      "class_name": "Pattern",
      "method_name": "sub",
      "instance_method": true,
      "source": "ARG_0,KWARG:string",
      "target": "RETURN",
      "action": "NONE",
      "policy_patch": false
    },
    {
      "module": "re",
      "class_name": "Pattern",
      "method_name": "subn",
      "instance_method": true,
      "source": "ARG_0,KWARG:string",
      "target": "RETURN",
      "action": "NONE",
      "policy_patch": false
    },
    {
      "module": "re",
      "class_name": "Pattern",
      "method_name": "findall",
      "instance_method": true,
      "source": "ARG_0,KWARG:string",
      "target": "RETURN",
      "action": "REGEX_FINDALL",
      "policy_patch": false,
      "comment": [
          "re.findall is a simple wrapper around re.Pattern.findall so this single",
          "propagation node accounts for both"
      ]
    },
    {
      "module": "re",
      "method_name": "escape",
      "source": "ARG_0,KWARG:pattern",
      "target": "RETURN",
      "action": "SPLAT",
      "policy_patch": true
    },
    {
      "module": "re",
      "class_name": "Match",
      "method_name": "group",
      "instance_method": true,
      "source": "OBJ",
      "target": "RETURN",
      "action": "NONE",
      "policy_patch": false
    },
    {
      "module": "re",
      "class_name": "Match",
      "method_name": "groups",
      "instance_method": true,
      "source": "OBJ",
      "target": "RETURN",
      "action": "NONE",
      "policy_patch": false
    },
    {
      "module": "re",
      "class_name": "Match",
      "method_name": "groupdict",
      "instance_method": true,
      "source": "OBJ",
      "target": "RETURN",
      "action": "NONE",
      "policy_patch": false
    },
    {
      "module": "json",
      "method_name": "dumps",
      "source": "ARG_0,KWARG:obj",
      "target": "RETURN",
      "action": "JSON"
    },
    {
      "module": "json",
      "method_name": "loads",
      "source": "ARG_0,KWARG:s",
      "target": "RETURN",
      "action": "JSON"
    },
    {
      "module": "simplejson",
      "method_name": "dumps",
      "source": "ARG_0,KWARG:obj",
      "target": "RETURN",
      "action": "JSON"
    },
    {
      "module": "simplejson",
      "method_name": "loads",
      "source": "ARG_0,KWARG:s",
      "target": "RETURN",
      "action": "JSON"
    },
    {
      "module": "binascii",
      "method_name": "a2b_base64",
      "source": "ARG_0",
      "target": "RETURN",
      "action": "SPLAT",
      "untags": ["BASE64_ENCODED"],
      "comment": "a2b_base64() takes no keyword arguments"
    },
    {
      "module": "binascii",
      "method_name": "b2a_base64",
      "source": "ARG_0",
      "target": "RETURN",
      "action": "SPLAT",
      "tags": ["BASE64_ENCODED"],
      "comment": "b2a_base64() takes no keyword arguments"
    },
    {
      "module": "base64",
      "method_name": "b64decode",
      "source": "ARG_0,KWARG:s",
      "target": "RETURN",
      "action": "SPLAT",
      "untags": ["BASE64_ENCODED"]
    },
    {
      "module": "base64",
      "method_name": "b64encode",
      "source": "ARG_0,KWARG:s",
      "target": "RETURN",
      "action": "SPLAT",
      "tags": ["BASE64_ENCODED"]
    },
    {
      "module": "binascii",
      "method_name": "hexlify",
      "source": "ARG_0",
      "target": "RETURN",
      "action": "SPLAT",
      "comment": "hexlify() takes no keyword arguments"
    },
    {
      "module": "binascii",
      "method_name": "unhexlify",
      "source": "ARG_0",
      "target": "RETURN",
      "action": "SPLAT",
      "comment": "unhexlify() takes no keyword arguments"
    },
    {
      "module": "binascii",
      "method_name": "b2a_hex",
      "source": "ARG_0",
      "target": "RETURN",
      "action": "SPLAT",
      "comment": "b2a_hex() takes no keyword arguments"
    },
    {
      "module": "binascii",
      "method_name": "a2b_hex",
      "source": "ARG_0",
      "target": "RETURN",
      "action": "SPLAT",
      "comment": "a2b_hex() takes no keyword arguments"
    },
    {
      "module": "bottle",
      "method_name": "html_escape",
      "source": "ARG_0,KWARG:string",
      "target": "RETURN",
      "action": "SPLAT",
      "tags": [
        "HTML_ENCODED"
      ],
      "untags": [
        "HTML_DECODED"
      ]
    },
    {
      "module": "django.utils.html",
      "method_name": "escape",
      "source": "ARG_0,KWARG:text",
      "target": "RETURN",
      "action": "SPLAT",
      "tags": [
        "HTML_ENCODED"
      ],
      "untags": [
        "HTML_DECODED"
      ]
    },
    {
      "module": "django.utils.safestring",
      "method_name": "mark_safe",
      "source": "ARG_0,KWARG:s",
      "target": "RETURN",
      "action": "KEEP",
      "policy_patch": false,
      "comment": "Special deadzoned patch implemented outside of policy."
    },
    {
       "module": "django.utils.safestring",
       "method_name": "mark_for_escaping",
       "source": "ARG_0,KWARG:s",
       "target": "RETURN",
       "action": "KEEP"
    },
    {
       "module": "rest_framework.response",
       "class_name": "Response",
       "method_name": "rendered_content",
       "instance_method": true,
       "source": "ARG_0",
       "target": "RETURN",
       "action": "deadzone (placeholder)",
       "policy_patch": false,
       "comment": [
        "This is a deadzone property patch. See drf_patches.py.",
        "source, target, and action here have no real meaning"
      ]
    },
    {
       "module": "flask.helpers",
       "method_name": "safe_join",
       "source": "ALL_ARGS",
       "target": "RETURN",
       "action": "SAFE_JOIN",
       "tags": [
         "SAFE_PATH"
       ]
    },
    {
      "module": "html",
      "method_name": "escape",
      "source": "ARG_0,KWARG:s",
      "target": "RETURN",
      "action": "SPLAT",
      "tags": [
        "HTML_ENCODED"
      ],
      "untags": [
        "HTML_DECODED"
      ]
    },
    {
      "module": "markupsafe",
      "method_name": "escape",
      "source": "ARG_0,KWARG:s",
      "target": "RETURN",
      "action": "ENCODE_HTML_SPLAT",
      "tags": [
        "HTML_ENCODED"
      ],
      "untags": [
        "HTML_DECODED"
      ],
      "comment": [
        "markupsafe includes both a C implementation and a native python implementation",
        "escape() accepts a kwarg in the native implementation only"
      ]
    },
    {
      "module": "markupsafe",
      "method_name": "escape_silent",
      "source": "ARG_0,KWARG:s",
      "target": "RETURN",
      "action": "ENCODE_HTML_SPLAT",
      "tags": [
        "HTML_ENCODED"
      ],
      "untags": [
        "HTML_DECODED"
      ],
      "comment": [
        "Must be patched in addition to escape because if the C-implemented",
        "version of this is used we won't patch the internal call (to the",
        "C-implemented `escape`)",
        "markupsafe includes both a C implementation and a native python implementation",
        "escape_silent() accepts a kwarg in the native implementation only"
      ]
    },
    {
      "module": "markupsafe",
      "method_name": "soft_str",
      "source": "ARG_0,KWARG:s",
      "target": "RETURN",
      "action": "SPLAT",
      "comment": [
        "markupsafe includes both a C implementation and a native python implementation",
        "soft_str() accepts a kwarg in the native implementation only"
      ]
    },
    {
      "module": "markupsafe",
      "method_name": "soft_unicode",
      "source": "ARG_0,KWARG:s",
      "target": "RETURN",
      "action": "SPLAT",
      "python2_only": true,
      "comment": [
        "deprecated alias for soft_str",
        "markupsafe includes both a C implementation and a native python implementation",
        "soft_unicode() accepts a kwarg in the native implementation only",
        "this is py2-only since in py3 it's just an alias for soft_str"
      ]
    },
    {
      "module": "urllib",
      "method_name": "quote",
      "source": "ARG_0,KWARG:s",
      "target": "RETURN",
      "action": "SPLAT",
      "tags": [
        "URL_ENCODED"
      ],
      "comment": "PY2 only"
    },
    {
      "module": "urllib.parse",
      "method_name": "quote",
      "source": "ARG_0,KWARG:string",
      "target": "RETURN",
      "action": "SPLAT",
      "tags": [
        "URL_ENCODED"
      ],
      "comment": "PY3 only"
    },
    {
      "module": "urllib",
      "method_name": "quote_plus",
      "source": "ARG_0,KWARG:s",
      "target": "RETURN",
      "action": "SPLAT",
      "tags": [
        "URL_ENCODED"
      ],
      "comment": "PY2 only"
    },
    {
      "module": "urllib.parse",
      "method_name": "quote_plus",
      "source": "ARG_0,KWARG:string",
      "target": "RETURN",
      "action": "SPLAT",
      "tags": [
        "URL_ENCODED"
      ],
      "comment": "PY3 only"
    },
      {
      "module": "urllib",
      "method_name": "unquote",
      "source": "ARG_0,KWARG:s",
      "target": "RETURN",
      "action": "SPLAT",
      "untags": [
        "URL_ENCODED"
      ],
      "comment": "PY2 only"
    },
    {
      "module": "urllib.parse",
      "method_name": "unquote",
      "source": "ARG_0,KWARG:string",
      "target": "RETURN",
      "action": "SPLAT",
      "untags": [
        "URL_ENCODED"
      ],
      "comment": "PY3 only"
    },
    {
      "module": "urllib",
      "method_name": "unquote_plus",
      "source": "ARG_0,KWARG:s",
      "target": "RETURN",
      "action": "SPLAT",
      "untags": [
        "URL_ENCODED"
      ],
      "comment": "PY2 only"
    },
    {
      "module": "urllib.parse",
      "method_name": "unquote_plus",
      "source": "ARG_0,KWARG:string",
      "target": "RETURN",
      "action": "SPLAT",
      "untags": [
        "URL_ENCODED"
      ],
      "comment": "PY3 only"
    },
    {
      "module": "werkzeug.utils",
      "method_name": "secure_filename",
      "source": "ARG_0,KWARG:filename",
      "target": "RETURN",
      "action": "SPLAT",
      "tags": [
        "XPATH_ENCODED"
      ],
      "comment": [
        "XPATH_ENCODED means that the string is path-traversal safe, but",
        "it is still UNTRUSTED because it may be dangerous for other rules"
      ]
    },
    {
      "module": "werkzeug.utils",
      "method_name": "escape",
      "source": "ARG_0,KWARG:s",
      "target": "RETURN",
      "action": "ENCODE_HTML_SPLAT",
      "tags": [
        "HTML_ENCODED"
      ],
      "untags": [
        "HTML_DECODED"
      ]
    },
    {
       "module": "django.db.models.base",
       "class_name": "Model",
       "method_name": "__init__",
       "instance_method": true,
       "source": "ALL_KWARGS",
       "target": "OBJ",
       "action": "DB_WRITE",
       "tags": ["DATABASE_WRITE"]
    }
  ],
  "triggers": [
    {
      "name": "cmd-injection",
      "disallowed_tags": [
        "CUSTOM_ENCODED_CMD_INJECTION",
        "CUSTOM_ENCODED",
        "CUSTOM_VALIDATED_CMD_INJECTION",
        "CUSTOM_VALIDATED",
        "LIMITED_CHARS",
        "BASE64_ENCODED",
        "CSS_ENCODED",
        "CSV_ENCODED",
        "HTML_ENCODED",
        "JAVASCRIPT_ENCODED",
        "JAVA_ENCODED",
        "LDAP_ENCODED",
        "OS_ENCODED",
        "SQL_ENCODED",
        "URL_ENCODED",
        "VBSCRIPT_ENCODED",
        "XML_ENCODED",
        "XPATH_ENCODED"
      ],
      "nodes": [
        {
          "module": "os",
          "method_name": "popen",
          "source": "ARG_0,KWARG:cmd",
          "protect_mode": true,
          "comment": "`cmd` kwarg is PY3 only"
        },
        {
          "module": "os",
          "method_name": "system",
          "source": "ARG_0,KWARG:command",
          "protect_mode":  true,
          "comment": "`command` kwarg is PY3 only"
        },
        {
          "module": "subprocess",
          "method_name": "call",
          "source": "ARG_0,KWARG:args",
          "protect_mode":  true
        },
        {
          "module": "subprocess",
          "method_name": "check_call",
          "source": "ARG_0,KWARG:args",
          "protect_mode":  true
        },
        {
          "module": "subprocess",
          "method_name": "check_output",
          "source": "ARG_0,KWARG:args",
          "protect_mode":  true
        },
        {
          "module": "subprocess",
          "class_name": "Popen",
          "method_name": "__init__",
          "instance_method": true,
          "source": "ARG_0,KWARG:args",
          "protect_mode":  true
        }
      ]
    },
    {
      "name": "path-traversal",
      "disallowed_tags": [
        "CUSTOM_ENCODED_PATH_TRAVERSAL",
        "CUSTOM_ENCODED",
        "CUSTOM_VALIDATED_PATH_TRAVERSAL",
        "CUSTOM_VALIDATED",
        "LIMITED_CHARS",
        "NO_CONTROL_CHARS",
        "SAFE_PATH",
        "BASE64_ENCODED",
        "CSS_ENCODED",
        "CSV_ENCODED",
        "HTML_ENCODED",
        "JAVASCRIPT_ENCODED",
        "JAVA_ENCODED",
        "LDAP_ENCODED",
        "OS_ENCODED",
        "URL_ENCODED",
        "VBSCRIPT_ENCODED",
        "XML_ENCODED",
        "XPATH_ENCODED"
      ],
      "nodes": [
        {
          "module": "io",
          "method_name": "open",
          "source": "ARG_0,KWARG:file",
          "python2_only": true,
          "protect_mode": true,
          "comment": "In PY3 io.open is builtins.open"
        },
        {
          "module": "BUILTIN",
          "method_name": "open",
          "source": "ARG_0,KWARG:file,KWARG:name",
          "protect_mode": true,
          "comment": "name is the Python 2.7 kwarg while file is the PY3 kwarg"
        },
        {
          "module": "BUILTIN",
          "method_name": "execfile",
          "source": "ARG_0",
          "policy_patch": false,
          "comment": "Python 2.7 only. No keyword args accepted"
        }
      ]
    },
    {
      "name": "reflected-xss",
      "required_tags": [
        "CROSS_SITE"
      ],
      "disallowed_tags": [
        "CUSTOM_ENCODED_REFLECTED_XSS",
        "CUSTOM_ENCODED",
        "CUSTOM_VALIDATED_REFLECTED_XSS",
        "CUSTOM_VALIDATED",
        "LIMITED_CHARS",
        "BASE64_ENCODED",
        "CSS_ENCODED",
        "CSV_ENCODED",
        "HTML_ENCODED",
        "JAVASCRIPT_ENCODED",
        "JAVA_ENCODED",
        "LDAP_ENCODED",
        "OS_ENCODED",
        "SQL_ENCODED",
        "URL_ENCODED",
        "VBSCRIPT_ENCODED",
        "XML_ENCODED",
        "XPATH_ENCODED",
        "XSS_ENCODED"
      ],
      "nodes": [
      ]
    },
    {
      "name": "sql-injection",
      "disallowed_tags": [
        "CUSTOM_ENCODED_SQL_INJECTION",
        "CUSTOM_ENCODED",
        "CUSTOM_VALIDATED_SQL_INJECTION",
        "CUSTOM_VALIDATED",
        "LIMITED_CHARS",
        "SQL_ENCODED"
      ],
      "comment": [
        "The nodes for the methods in dbapi2 modules do not correspond exactly to real",
        "patch locations. Instead, we pretend that every dbapi2 cursor object is",
        "called Cursor. This is done for convenience and for storytelling purposes.",
        "Our patches (which in these cases are not controlled by policy) account for",
        "this and perform the policy lookup correctly."
      ],
      "nodes": [
        {
          "module": "sqlite3",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "execute",
          "source": "ARG_0",
          "policy_patch": false,
          "comment": [
            "ARG_1 is safe, because the SQL statement is prepared",
            "execute() takes no keyword arguments"
          ]
        },
        {
          "module": "sqlite3",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "executemany",
          "source": "ARG_0",
          "policy_patch": false,
          "comment": [
            "ARG_1 is safe, because the SQL statement is prepared",
            "executemany() takes no keyword arguments"
          ]
        },
        {
          "module": "sqlite3",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "executescript",
          "source": "ARG_0",
          "policy_patch": false,
          "comment": "executescript() takes no keyword arguments"
        },
        {
          "module": "pysqlite2.dbapi2",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "execute",
          "source": "ARG_0",
          "policy_patch": false,
          "comment": [
            "ARG_1 is safe, because the SQL statement is prepared",
            "execute() takes no keyword arguments"
          ]
        },
        {
          "module": "pysqlite2.dbapi2",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "executemany",
          "source": "ARG_0",
          "policy_patch": false,
          "comment": [
            "ARG_1 is safe, because the SQL statement is prepared",
            "executemany() takes no keyword arguments"
          ]
        },
        {
          "module": "pysqlite2.dbapi2",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "executescript",
          "source": "ARG_0",
          "policy_patch": false,
          "comment": [
            "ARG_1 is safe, because the SQL statement is prepared",
            "executescript() takes no keyword arguments"
          ]
        },
        {
          "module": "mysql.connector",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "execute",
          "source": "ARG_0,KWARG:operation",
          "policy_patch": false,
          "comment": "ARG_1 is safe, because the SQL statement is prepared"
        },
        {
          "module": "mysql.connector",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "executemany",
          "source": "ARG_0,KWARG:operation",
          "policy_patch": false,
          "comment": "ARG_1 is safe, because the SQL statement is prepared"
        },
        {
          "module": "pymysql",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "execute",
          "source": "ARG_0,KWARG:query",
          "policy_patch": false,
          "comment": "ARG_1 is safe, because the SQL statement is prepared"
        },
        {
          "module": "pymysql",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "executemany",
          "source": "ARG_0,KWARG:query",
          "policy_patch": false,
          "comment": "ARG_1 is safe, because the SQL statement is prepared"
        },
        {
          "module": "psycopg2",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "execute",
          "source": "ARG_0,KWARG:query",
          "policy_patch": false,
          "comment": "ARG_1 is safe, because the SQL statement is prepared"
        },
        {
          "module": "psycopg2",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "executemany",
          "source": "ARG_0,KWARG:query",
          "policy_patch": false,
          "comment": "ARG_1 is safe, because the SQL statement is prepared"
        },
        {
          "module": "sqlalchemy",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "execute",
          "source": "ARG_0",
          "policy_patch": false,
          "comment": "Used to handle any SQLAlchemy dialect"
        },
        {
          "module": "sqlalchemy",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "executemany",
          "source": "ARG_0",
          "policy_patch": false,
          "comment": "Used to handle any SQLAlchemy dialect"
        },
        {
          "module": "pycassa",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "get",
          "source": "ARG_0,KWARG:key,ARG_1,KWARG:columns",
          "policy_patch": false
        },
        {
          "module": "pycassa",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "insert",
          "source": "ARG_0,KWARG:key,ARG_1,KWARG:columns",
          "policy_patch": false
        },
        {
          "module": "pycassa",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "multiget",
          "source": "ARG_0,KWARG:keys,ARG_1,KWARG:columns",
          "policy_patch": false
        },
        {
          "module": "pycassa",
          "class_name": "Cursor",
          "instance_method": true,
          "method_name": "remove",
          "source": "ARG_0,KWARG:key,ARG_1,KWARG:columns",
          "policy_patch": false
        }
      ]
    },
    {
      "name": "crypto-weak-randomness",
      "dataflow": false,
      "nodes": [
        {
          "module": "random",
          "method_name": "random"
        },
        {
          "module": "random",
          "method_name": "randint"
        },
        {
          "module": "random",
          "method_name": "randrange"
        },
        {
          "module": "random",
          "method_name": "uniform"
        }
      ]
    },
    {
      "name": "crypto-bad-mac",
      "dataflow": false,
      "nodes": [
        {
          "module": "hashlib",
          "method_name": "new",
          "source": "ARG_0,KWARG:name",
          "good_value": "^(?:MDC2|RIPEMD160|SHA224|SHA256|SHA384|SHA512)"
        },
        {
          "module": "hashlib",
          "method_name": "md5"
        },
        {
          "module": "hashlib",
          "method_name": "sha"
        },
        {
          "module": "hashlib",
          "method_name": "sha1"
        }
      ]
    },
    {
      "name": "crypto-bad-ciphers",
      "dataflow": false,
      "nodes": [
        {
          "module": "Crypto.Cipher.Blowfish",
          "method_name": "new"
        },
        {
          "module": "Crypto.Cipher.DES",
          "method_name": "new"
        }
      ]
    },
    {
      "name": "redos",
      "disallowed_tags": [
        "CUSTOM_ENCODED_REDOS",
        "CUSTOM_ENCODED",
        "CUSTOM_VALIDATED_REDOS",
        "CUSTOM_VALIDATED",
        "LIMITED_CHARS"
      ],
      "comment": [
        "This rule, like SSRF, has an accompanying action to enforce an extra level",
        "of assertion on the violation, so it may not always report, depending on the",
        "value reported.",
        "Like the propagation methods for Re::Match, it also requires custom patching",
        "to instrument properly."
      ],
      "nodes": [
        {
          "module": "re",
          "method_name": "match",
          "source": "ARG_1,KWARG:string",
          "action": "REDOS",
          "comment": [
            "ARG_0 is the pattern passed in to the re method, which we verify against the REDOS action for exploitability",
            "but we do not care about its origin so it doesn't matter if it's tracked.",
            "ARG_1 is the user input which we track and verify if untrusted"
          ]
        },
        {
          "module": "re",
          "class_name": "Pattern",
          "method_name": "match",
          "instance_method": true,
          "source": "ARG_1,KWARG:string,KWARG:pattern",
          "action": "REDOS",
          "policy_patch": false,
          "comment": [
            "ARG_0 is the pattern passed in to the re method, which we verify against the REDOS action for exploitability",
            "but we do not care about its origin so it doesn't matter if it's tracked.",
            "ARG_1 is the user input which we track and verify if untrusted",
            "NOTE: because the redos action needs ARG_0 to analyze the pattern, the fact",
            "this is an instance method node is ignored in the trigger logic."
          ]
        },
        {
          "module": "re",
          "method_name": "search",
          "source": "ARG_1,KWARG:string",
          "action": "REDOS",
          "comment": [
            "ARG_0 is the pattern passed in to the re method, which we verify against the REDOS action for exploitability",
            "but we do not care about its origin so it doesn't matter if it's tracked.",
            "ARG_1 is the user input which we track and verify if untrusted"
          ]
        },
        {
          "module": "re",
          "class_name": "Pattern",
          "method_name": "search",
          "instance_method": true,
          "source": "ARG_1,KWARG:string,KWARG:pattern",
          "action": "REDOS",
          "policy_patch": false,
          "comment": [
            "ARG_0 is the pattern passed in to the re method, which we verify against the REDOS action for exploitability",
            "but we do not care about its origin so it doesn't matter if it's tracked.",
            "ARG_1 is the user input which we track and verify if untrusted",
            "NOTE: because the redos action needs ARG_0 to analyze the pattern, the fact",
            "this is an instance method node is ignored in the trigger logic."
          ]
        },
        {
          "module": "re",
          "method_name": "finditer",
          "source": "ARG_1,KWARG:string",
          "action": "REDOS",
          "comment": [
            "ARG_0 is the pattern passed in to the re method, which we verify against the REDOS action for exploitability",
            "but we do not care about its origin so it doesn't matter if it's tracked.",
            "ARG_1 is the user input which we track and verify if untrusted",
            "kwarg string is Py3 only."
          ]
        },
        {
          "module": "re",
          "class_name": "Pattern",
          "method_name": "finditer",
          "instance_method": true,
          "source": "ARG_1,KWARG:string",
          "action": "REDOS",
          "policy_patch": false,
          "comment": [
            "ARG_0 is the pattern passed in to the re method, which we verify against the REDOS action for exploitability",
            "but we do not care about its origin so it doesn't matter if it's tracked.",
            "ARG_1 is the user input which we track and verify if untrusted",
            "NOTE: because the redos action needs ARG_0 to analyze the pattern, the fact",
            "this is an instance method node is ignored in the trigger logic."
          ]
        },
        {
          "module": "re",
          "method_name": "findall",
          "source": "ARG_1,KWARG:string",
          "action": "REDOS",
          "comment": [
            "ARG_0 is the pattern passed in to the re method, which we verify against the REDOS action for exploitability",
            "but we do not care about its origin so it doesn't matter if it's tracked.",
            "ARG_1 is the user input which we track and verify if untrusted"
          ]
        },
        {
          "module": "re",
          "class_name": "Pattern",
          "method_name": "findall",
          "instance_method": true,
          "source": "ARG_1,KWARG:string,KWARG:source",
          "action": "REDOS",
          "policy_patch": false,
          "comment": [
            "ARG_0 is the pattern passed in to the re method, which we verify against the REDOS action for exploitability",
            "but we do not care about its origin so it doesn't matter if it's tracked.",
            "ARG_1 is the user input which we track and verify if untrusted",
            "NOTE: because the redos action needs ARG_0 to analyze the pattern, the fact",
            "this is an instance method node is ignored in the trigger logic."
          ]
        },
        {
          "module": "re",
          "method_name": "fullmatch",
          "source": "ARG_1,KWARG:string",
          "action": "REDOS",
          "comment": [
            "ARG_0 is the pattern passed in to the re method, which we verify against the REDOS action for exploitability",
            "but we do not care about its origin so it doesn't matter if it's tracked.",
            "ARG_1 is the user input which we track and verify if untrusted"
          ]
        },
        {
          "module": "re",
          "class_name": "Pattern",
          "method_name": "fullmatch",
          "instance_method": true,
          "source": "ARG_1,KWARG:string",
          "action": "REDOS",
          "policy_patch": false,
          "comment": [
            "ARG_0 is the pattern passed in to the re method, which we verify against the REDOS action for exploitability",
            "but we do not care about its origin so it doesn't matter if it's tracked.",
            "ARG_1 is the user input which we track and verify if untrusted",
            "NOTE: because the redos action needs ARG_0 to analyze the pattern, the fact",
            "this is an instance method node is ignored in the trigger logic."
          ]
        },
        {
          "module": "re",
          "method_name": "sub",
          "source": "ARG_2,KWARG:string",
          "action": "REDOS",
          "policy_patch": false,
          "comment": [
            "ARG_0 is the pattern passed in to the re method, which we verify against the REDOS action for exploitability",
            "but we do not care about its origin so it doesn't matter if it's tracked.",
            "ARG_2 is the user input which we track and verify if untrusted"
          ]
        },
        {
          "module": "re",
          "class_name": "Pattern",
          "method_name": "sub",
          "instance_method": true,
          "source": "ARG_2,KWARG:string",
          "action": "REDOS",
          "policy_patch": false,
          "comment": [
            "ARG_0 is the pattern passed in to the re method, which we verify against the REDOS action for exploitability",
            "but we do not care about its origin so it doesn't matter if it's tracked.",
            "ARG_1 is the user input which we track and verify if untrusted",
            "NOTE: because the redos action needs ARG_0 to analyze the pattern, the fact",
            "this is an instance method node is ignored in the trigger logic."
          ]
        },
        {
          "module": "re",
          "method_name": "subn",
          "source": "ARG_2,KWARG:string",
          "action": "REDOS",
          "policy_patch": false,
          "comment": [
            "ARG_0 is the pattern passed in to the re method, which we verify against the REDOS action for exploitability",
            "but we do not care about its origin so it doesn't matter if it's tracked.",
            "ARG_2 is the user input which we track and verify if untrusted"
          ]
        },
        {
          "module": "re",
          "class_name": "Pattern",
          "method_name": "subn",
          "instance_method": true,
          "source": "ARG_2,KWARG:string",
          "action": "REDOS",
          "policy_patch": false,
          "comment": [
            "ARG_0 is the pattern passed in to the re method, which we verify against the REDOS action for exploitability",
            "but we do not care about its origin so it doesn't matter if it's tracked.",
            "ARG_1 is the user input which we track and verify if untrusted",
            "NOTE: because the redos action needs ARG_0 to analyze the pattern, the fact",
            "this is an instance method node is ignored in the trigger logic."
          ]
        },
        {
          "module": "re",
          "method_name": "split",
          "source": "ARG_1,KWARG:string,KWARG:source",
          "action": "REDOS",
          "comment": [
            "ARG_0 is the pattern passed in to the re method, which we verify against the REDOS action for exploitability",
            "but we do not care about its origin so it doesn't matter if it's tracked.",
            "ARG_1 is the user input which we track and verify if untrusted"
          ]
        },
        {
          "module": "re",
          "class_name": "Pattern",
          "method_name": "split",
          "instance_method": true,
          "source": "ARG_1,KWARG:string,KWARG:source",
          "action": "REDOS",
          "policy_patch": false,
          "comment": [
            "ARG_0 is the pattern passed in to the re method, which we verify against the REDOS action for exploitability",
            "but we do not care about its origin so it doesn't matter if it's tracked.",
            "ARG_1 is the user input which we track and verify if untrusted",
            "NOTE: because the redos action needs ARG_0 to analyze the pattern, the fact",
            "this is an instance method node is ignored in the trigger logic.",
            "The 'source' keyword was used in earlier versions of Py27 but was deprecated"
          ]
        }
      ]
    },
    {
      "name": "ssrf",
      "disallowed_tags": [
        "CUSTOM_ENCODED_SSRF",
        "CUSTOM_ENCODED",
        "CUSTOM_VALIDATED_SSRF",
        "CUSTOM_VALIDATED",
        "LIMITED_CHARS"
      ],
      "nodes": [
        {
          "module": "urllib",
          "method_name": "urlopen",
          "source": "ARG_0,KWARG:url",
          "action": "SSRF",
          "protect_mode": true,
          "comment": "Python 2 version of this function"
        },
        {
          "module": "urllib.request",
          "method_name": "urlopen",
          "source": "ARG_0,KWARG:url",
          "action": "SSRF",
          "protect_mode": true,
          "comment": "Python 3 version of this function"
        },
        {
          "module": "urllib2",
          "method_name": "urlopen",
          "source": "ARG_0,KWARG:url",
          "action": "SSRF",
          "protect_mode": true,
          "comment": "Python 2 only"
        },
        {
          "module": "http.client",
          "class_name": "HTTPConnection",
          "instance_method": true,
          "method_name": "__init__",
          "source": "ARG_0,KWARG:host",
          "action": "DEFAULT",
          "comment": "Py3"
        },
        {
          "module": "http.client",
          "class_name": "HTTPConnection",
          "instance_method": true,
          "method_name": "putrequest",
          "source": "ARG_0,KWARG:method",
          "action": "DEFAULT",
          "protect_mode": true,
          "comment": [
            "Py3. This also serves as a trigger for the request method.",
            "ARG_0 is HTTP method, so no regex is used to evaluate.",
            "ARG_1 is a path + querystring only, which isn't vulnerable to SSRF"
          ]
        },
        {
          "module": "httplib",
          "class_name": "HTTPConnection",
          "instance_method": true,
          "method_name": "__init__",
          "source": "ARG_0,KWARG:host",
          "action": "DEFAULT",
          "comment": "Py2"
        },
        {
          "module": "httplib",
          "class_name": "HTTPConnection",
          "instance_method": true,
          "method_name": "putrequest",
          "source": "ARG_0,KWARG:method",
          "action": "DEFAULT",
          "protect_mode": true,
          "comment": [
            "Py2. This also serves as a trigger for the request method.",
            "ARG_0 is HTTP method, so no regex is used to evaluate.",
            "ARG_1 is a path + querystring only, which isn't vulnerable to SSRF"
          ]
        }
      ]
    },
    {
      "name": "nosql-injection",
      "disallowed_tags": [
        "CUSTOM_ENCODED_NOSQL_INJECTION",
        "CUSTOM_ENCODED",
        "CUSTOM_VALIDATED_NOSQL_INJECTION",
        "CUSTOM_VALIDATED",
        "LIMITED_CHARS",
        "JS_ENCODED"
      ],
      "nodes": [
        {
          "module": "pymongo.collection",
          "class_name": "Collection",
          "instance_method": true,
          "method_name": "find",
          "source": "ARG_0,KWARG:filter",
          "protect_mode": true
        },
        {
          "module": "pymongo.collection",
          "class_name": "Collection",
          "instance_method": true,
          "method_name": "insert_one",
          "source": "ARG_0,KWARG:document",
          "protect_mode": true
        },
        {
          "module": "pymongo.collection",
          "class_name": "Collection",
          "instance_method": true,
          "method_name": "insert_many",
          "source": "ARG_0,KWARG:documents",
          "protect_mode": true
        },
        {
          "module": "pymongo.collection",
          "class_name": "Collection",
          "instance_method": true,
          "method_name": "_delete_retryable",
          "source": "ARG_0,KWARG:criteria",
          "protect_mode": true
        },
        {
          "module": "pymongo.collection",
          "class_name": "Collection",
          "instance_method": true,
          "method_name": "_update_retryable",
          "source": "ARG_1,KWARG:document",
          "protect_mode": true
        }
      ]
    },
    {
      "name": "xxe",
      "disallowed_tags": [
        "CUSTOM_ENCODED_XXE",
        "CUSTOM_ENCODED",
        "CUSTOM_VALIDATED_XXE",
        "CUSTOM_VALIDATED",
        "LIMITED_CHARS",
        "XMLIF_VALIDATED_XXE"
      ],
      "nodes": [
        {
          "module": "lxml.etree",
          "method_name": "fromstring",
          "source": "ARG_0,KWARG:text",
          "protect_mode": true
        },
        {
          "module": "xml.dom.pulldom",
          "method_name": "parseString",
          "source": "ARG_0,KWARG:string",
          "protect_mode": true
        },
        {
          "module": "xml.sax",
          "method_name": "parseString",
          "source": "ARG_0,KWARG:string",
          "protect_mode": true
        }
      ]
    },
    {
      "name": "unsafe-code-execution",
      "disallowed_tags": [
        "CUSTOM_ENCODED_TRUST_BOUNDARY_VIOLATION",
        "CUSTOM_ENCODED",
        "CUSTOM_VALIDATED_TRUST_BOUNDARY_VIOLATION",
        "CUSTOM_VALIDATED",
        "LIMITED_CHARS"
      ],
      "nodes": [
        {
          "module": "BUILTIN",
          "method_name": "exec",
          "source": "ARG_0",
          "policy_patch": false,
          "comment": "Takes no keyword arguments"
        },
        {
          "module": "BUILTIN",
          "method_name": "eval",
          "source": "ARG_0",
          "policy_patch": false,
          "comment": "Takes no keyword arguments"
        },
        {
          "module": "BUILTIN",
          "method_name": "compile",
          "source": "ARG_0,KWARG:source"
        }
      ]
    },
    {
      "name": "untrusted-deserialization",
      "disallowed_tags": [
        "CUSTOM_ENCODED_TRUST_BOUNDARY_VIOLATION",
        "CUSTOM_ENCODED",
        "CUSTOM_VALIDATED_TRUST_BOUNDARY_VIOLATION",
        "CUSTOM_VALIDATED",
        "LIMITED_CHARS"
      ],
      "nodes": [
        {
          "module": "pickle",
          "method_name": "load",
          "source": "ARG_0,KWARG:file",
          "protect_mode": true
        },
        {
          "module": "pickle",
          "method_name": "loads",
          "source": "ARG_0,KWARG:data",
          "protect_mode": true
        },
        {
          "module": "yaml.loader",
          "class_name": "BaseLoader",
          "method_name": "__init__",
          "source": "ARG_0,KWARG:stream",
          "protect_mode": true
        },
        {
          "module": "yaml.loader",
          "class_name": "Loader",
          "method_name": "__init__",
          "source": "ARG_0,KWARG:stream",
          "protect_mode": true
        },
        {
          "module": "yaml.loader",
          "class_name": "UnsafeLoader",
          "method_name": "__init__",
          "source": "ARG_0,KWARG:stream",
          "protect_mode": true
        },
        {
          "module": "yaml.loader",
          "class_name": "FullLoader",
          "method_name": "__init__",
          "source": "ARG_0,KWARG:stream",
          "protect_mode": true
        }
      ]
    },
    {
      "name": "unvalidated-redirect",
      "disallowed_tags":["URL_ENCODED"],
      "nodes": [
        {
          "module": "django.http.response",
          "class_name": "HttpResponseRedirectBase",
          "method_name": "__init__",
          "instance_method": true,
          "source": "ARG_0,KWARG:redirect_to"
        },
        {
          "module": "pyramid.httpexceptions",
          "class_name": "_HTTPMove",
          "method_name": "__init__",
          "instance_method": true,
          "source": "ARG_0,KWARG:location",
          "comment": "Base class for redirects in pyramid"
        },
        {
          "module": "webob.exc",
          "class_name": "_HTTPMove",
          "method_name": "__init__",
          "instance_method": true,
          "source": "ARG_4,KWARG:location",
          "comment": "Base class for redirects in webob. Not the same as pyramid."
        },
        {
          "module": "werkzeug.utils",
          "method_name": "redirect",
          "source": "ARG_0,KWARG:location"
        },
        {
          "module": "bottle",
          "method_name": "redirect",
          "source": "ARG_0,KWARG:url"
        },
        {
          "module": "falcon",
          "class_name": "HTTPMovedPermanently",
          "method_name": "__init__",
          "instance_method": true,
          "source": "ARG_0,KWARG:location"
        },
        {
          "module": "falcon",
          "class_name": "HTTPFound",
          "method_name": "__init__",
          "instance_method": true,
          "source": "ARG_0,KWARG:location"
        },
        {
          "module": "falcon",
          "class_name": "HTTPSeeOther",
          "method_name": "__init__",
          "instance_method": true,
          "source": "ARG_0,KWARG:location"
        },
        {
          "module": "falcon",
          "class_name": "HTTPTemporaryRedirect",
          "method_name": "__init__",
          "instance_method": true,
          "source": "ARG_0,KWARG:location"
        },
        {
          "module": "falcon",
          "class_name": "HTTPPermanentRedirect",
          "method_name": "__init__",
          "instance_method": true,
          "source": "ARG_0,KWARG:location"
        }
      ]
    },
    {
      "name": "xpath-injection",
      "disallowed_tags": [
        "CUSTOM_ENCODED_XPATH_INJECTION",
        "CUSTOM_ENCODED",
        "CUSTOM_VALIDATED_XPATH_INJECTION",
        "CUSTOM_VALIDATED",
        "LIMITED_CHARS",
        "XPATH_ENCODED"
      ],
      "nodes": [
        {
          "module": "xml.etree.ElementTree",
          "class_name": "Element",
          "method_name": "find",
          "source": "ARG_0"
        },
        {
          "module": "xml.etree.ElementTree",
          "class_name": "Element",
          "method_name": "findall",
          "source": "ARG_0"
        },
        {
          "module": "xml.etree.ElementTree",
          "class_name": "Element",
          "method_name": "findtext",
          "source": "ARG_0"
        },
        {
          "module": "lxml.etree",
          "class_name": "_Element",
          "method_name": "find",
          "source": "ARG_0"
        },
        {
          "module": "lxml.etree",
          "class_name": "_Element",
          "method_name": "findall",
          "source": "ARG_0"
        },
        {
          "module": "lxml.etree",
          "class_name": "_Element",
          "method_name": "findtext",
          "source": "ARG_0"
        },
        {
          "module": "lxml.etree",
          "class_name": "_Element",
          "method_name": "xpath",
          "source": "ARG_0"
        },
        {
          "module": "lxml.etree",
          "class_name": "_ElementTree",
          "method_name": "xpath",
          "source": "ARG_0"
        },
        {
          "module": "lxml.etree",
          "class_name": "XPath",
          "method_name": "__init__",
          "source": "ARG_0",
          "policy_patch": false
        },
        {
          "module": "lxml.etree",
          "class_name": "XPathElementEvaluator",
          "method_name": "__call__",
          "source": "ARG_0",
          "policy_patch": false
        },
        {
          "module": "lxml.etree",
          "class_name": "XPathDocumentEvaluator",
          "method_name": "__call__",
          "source": "ARG_0",
          "policy_patch": false
        }
      ]
    },
    {
      "name": "httponly",
      "nodes": [
        {
          "module": "pyramid.session",
          "method_name": "BaseCookieSessionFactory",
          "source": "KWARG:httponly",
          "policy_patch": false
        },
        {
          "module": "beaker.session",
          "class_name": "Session",
          "method_name": "__init__",
          "source": "KWARG:httponly",
          "comment": "Used by pylons for sessions"
        },
        {
          "module": "bottle_session",
          "class_name": "Session",
          "method_name": "__init__",
          "source": "ARG_4,KWARG:cookie_httponly",
          "comment": "Used by bottle for sessions"
        }
      ]
    },
    {
      "name": "session-timeout",
      "nodes": [
        {
          "module": "pyramid.session",
          "method_name": "BaseCookieSessionFactory",
          "source": "KWARG:timeout",
          "policy_patch": false
        },
        {
          "module": "beaker.session",
          "class_name": "Session",
          "method_name": "__init__",
          "source": "KWARG:timeout",
          "comment": "Used by pylons for sessions"
        },
        {
          "module": "bottle_session",
          "class_name": "Session",
          "method_name": "__init__",
          "source": "ARG_2,KWARG:cookie_lifetime",
          "comment": "Used by bottle for sessions"
        }
      ]
    },
    {
      "name": "secure-flag-missing",
      "nodes": [
        {
          "module": "pyramid.session",
          "method_name": "BaseCookieSessionFactory",
          "source": "KWARG:secure",
          "policy_patch": false
        },
        {
          "module": "beaker.session",
          "class_name": "Session",
          "method_name": "__init__",
          "source": "KWARG:secure",
          "comment": "Used by pylons for sessions"
        },
        {
          "module": "bottle_session",
          "class_name": "Session",
          "method_name": "__init__",
          "source": "ARG_4,KWARG:cookie_secure",
          "comment": "Used by bottle for sessions"
        }
      ]
    },
    {
      "name": "trust-boundary-violation",
      "disallowed_tags":[
         "CUSTOM_ENCODED_TRUST_BOUNDARY_VIOLATION",
         "CUSTOM_VALIDATED_TRUST_BOUNDARY_VIOLATION",
         "CUSTOM_VALIDATED",
         "LIMITED_CHARS",
         "BASE64_ENCODED",
         "CSS_ENCODED",
         "CSV_ENCODED",
         "HTML_ENCODED",
         "JAVASCRIPT_ENCODED",
         "JAVA_ENCODED",
         "LDAP_ENCODED",
         "OS_ENCODED",
         "SQL_ENCODED",
         "URL_ENCODED",
         "VBSCRIPT_ENCODED",
         "XML_ENCODED",
         "XPATH_ENCODED"
      ],
      "nodes": [
        {
          "module": "bottle_session",
          "class_name": "Session",
          "method_name": "__setitem__",
          "source": "ARG_1",
          "comment": "Used by bottle for sessions. No keyword arguments"
        },
        {
          "module": "beaker.session",
          "class_name": "Session",
          "method_name": "__setitem__",
          "source": "ARG_1",
          "comment": "Used by pylons/bottle for sessions. No keyword arguments"
        },
        {
          "module": "beaker.session",
          "class_name": "Session",
          "method_name": "setdefault",
          "source": "ARG_1",
          "comment": "Used by pylons/bottle for sessions. No keyword arguments"
        },
        {
          "module": "django.contrib.sessions.backends.base",
          "class_name": "SessionBase",
          "method_name": "__setitem__",
          "source": "ARG_1",
          "comment": "No keyword arguments"
        },
        {
          "module": "django.contrib.sessions.backends.base",
          "class_name": "SessionBase",
          "method_name": "setdefault",
          "source": "ARG_1",
          "comment": "No keyword arguments"
        },
        {
          "module": "flask.sessions",
          "class_name": "SecureCookieSession",
          "method_name": "__setitem__",
          "source": "ARG_1",
          "comment": "No keyword arguments"
        },
        {
          "module": "flask.sessions",
          "class_name": "SecureCookieSession",
          "method_name": "setdefault",
          "source": "ARG_1",
          "comment": "No keyword arguments"
        },
        {
          "module": "pyramid.session",
          "class_name": "CookieSession",
          "method_name": "__setitem__",
          "source": "ARG_1",
          "policy_patch": false,
          "comment": "No keyword arguments"
        },
        {
          "module": "pyramid.session",
          "class_name": "CookieSession",
          "method_name": "setdefault",
          "source": "ARG_1",
          "policy_patch": false,
          "comment": "No keyword arguments"
        }
      ]
    },
    {
      "name": "session-rewriting",
      "nodes": [
        {
          "module": "beaker.session",
          "class_name": "Session",
          "method_name": "__init__",
          "source": "ARG_3,KWARG:use_cookies"
        }
      ]
    }
  ],
  "deadzones": [
    {
      "module": "logging",
      "class_name": "StreamHandler",
      "method_name": "emit",
      "instance_method": true,
      "policy_patch": true,
      "comment": [
            "Prevent recursive propagation when logging in assess",
            "We run the risk of recursively logging propagation events inside of log",
            "statements. This is because the logging module sometimes uses streams to",
            "output logs, and these logging events can inadvertently cause additional",
            "log output that we use for debugging within our assess code. We want to",
            "prevent this from occurring. Part of the reason for this is that we now",
            "instrument stream reads and writes, but we also are aware that StringIO",
            "is implemented with a lot of string building under the hood."
      ]
    },
    {
      "module": "werkzeug.formparser",
      "class_name": "FormDataParser",
      "method_name": "parse",
      "instance_method": true,
      "comment": [
        "Werkzeug's request body parser (used by flask.request.files) causes a lot of",
        "propagation. We deadzone this, but we have source nodes / logic for tracking",
        "all resulting objects."
      ]
    }
  ]
}
