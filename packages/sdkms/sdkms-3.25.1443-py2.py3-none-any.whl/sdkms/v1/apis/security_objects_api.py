# coding: utf-8

"""
    Fortanix SDKMS REST API

    This is a set of REST APIs for accessing the Fortanix Self-Defending Key Management System. This includes APIs for managing accounts, and for performing cryptographic and key management operations. 

    OpenAPI spec version: 1.0.0-20200608
    Contact: support@fortanix.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    
        http://www.apache.org/licenses/LICENSE-2.0
    
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..api_client import ApiClient


# NOTE: This class is auto generated by the swagger code generator program.
# Do not edit the class manually.
# Ref: https://github.com/swagger-api/swagger-codegen
class SecurityObjectsApi(object):
    """
    @undocumented: activate_security_object_with_http_info
    @undocumented: agree_key_with_http_info
    @undocumented: delete_private_key_with_http_info
    @undocumented: delete_security_object_with_http_info
    @undocumented: derive_key_with_http_info
    @undocumented: derive_key_ex_with_http_info
    @undocumented: destroy_security_object_with_http_info
    @undocumented: export_sobject_components_with_http_info
    @undocumented: generate_security_object_with_http_info
    @undocumented: get_security_object_with_http_info
    @undocumented: get_security_object_digest_with_http_info
    @undocumented: get_security_object_kcv_with_http_info
    @undocumented: get_security_object_value_with_http_info
    @undocumented: get_security_object_value_ex_with_http_info
    @undocumented: get_security_objects_with_http_info
    @undocumented: import_security_object_with_http_info
    @undocumented: import_sobject_components_with_http_info
    @undocumented: persist_security_object_with_http_info
    @undocumented: revert_history_item_with_http_info
    @undocumented: revoke_security_object_with_http_info
    @undocumented: rotate_security_object_with_http_info
    @undocumented: update_security_object_with_http_info
    @undocumented: verify_kcv_with_http_info
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def activate_security_object(self, key_id, async_call=False, **kwargs):
        """
        Trigger the transition of a security object to Active state. 
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @rtype: None
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.activate_security_object_with_http_info(key_id, async_call=async_call, **kwargs)
        else:
            (data) = self.activate_security_object_with_http_info(key_id, async_call=async_call, **kwargs)
            return data

    def activate_security_object_with_http_info(self, key_id, async_call=False, **kwargs):
        """
        Trigger the transition of a security object to Active state. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.activate_security_object_with_http_info(key_id, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @rtype: None
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method activate_security_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `activate_security_object`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}/activate', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def agree_key(self, body, async_call=False, **kwargs):
        """
        This does a cryptographic key agreement operation between a public and private key. Both keys must have been generated from the same parameters (e.g. the same elliptic curve). Both keys must allow the AGREEKEY operation. The request body contains the requested properties for the new key as well as the mechanism (e.g. Diffie-Hellman) to be used to produce the key material for the new key. The output of this API should not be used directly as a cryptographic key. The target object type should be HMAC or Secret, and a key derivation procedure should be used to derive the actual key material. 
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{AgreeKeyRequest}
        @param body: Template of the agreed-upon security object (required)
        @rtype: L{KeyObject}
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.agree_key_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.agree_key_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def agree_key_with_http_info(self, body, async_call=False, **kwargs):
        """
        This does a cryptographic key agreement operation between a public and private key. Both keys must have been generated from the same parameters (e.g. the same elliptic curve). Both keys must allow the AGREEKEY operation. The request body contains the requested properties for the new key as well as the mechanism (e.g. Diffie-Hellman) to be used to produce the key material for the new key. The output of this API should not be used directly as a cryptographic key. The target object type should be HMAC or Secret, and a key derivation procedure should be used to derive the actual key material. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.agree_key_with_http_info(body, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{AgreeKeyRequest}
        @param body: Template of the agreed-upon security object (required)
        @rtype: L{KeyObject}
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method agree_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `agree_key`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/agree', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KeyObject',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_private_key(self, key_id, async_call=False, **kwargs):
        """
        Removes the private portion of an asymmetric key from SDKMS. After this operation is performed, operations that require the private key, such as encryption and generating signatures, may no longer be performed. 
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @rtype: None
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.delete_private_key_with_http_info(key_id, async_call=async_call, **kwargs)
        else:
            (data) = self.delete_private_key_with_http_info(key_id, async_call=async_call, **kwargs)
            return data

    def delete_private_key_with_http_info(self, key_id, async_call=False, **kwargs):
        """
        Removes the private portion of an asymmetric key from SDKMS. After this operation is performed, operations that require the private key, such as encryption and generating signatures, may no longer be performed. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.delete_private_key_with_http_info(key_id, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @rtype: None
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_private_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `delete_private_key`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}/private', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_security_object(self, key_id, async_call=False, **kwargs):
        """
        Delete a specified security object.
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @rtype: None
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.delete_security_object_with_http_info(key_id, async_call=async_call, **kwargs)
        else:
            (data) = self.delete_security_object_with_http_info(key_id, async_call=async_call, **kwargs)
            return data

    def delete_security_object_with_http_info(self, key_id, async_call=False, **kwargs):
        """
        Delete a specified security object.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.delete_security_object_with_http_info(key_id, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @rtype: None
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_security_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `delete_security_object`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def derive_key(self, key_id, body, async_call=False, **kwargs):
        """
        This derives a key from an existing key and returns the properties of the new key. The request body contains the requested properties for the new as well as the mechanism to be used to produce the key material for the new key. 
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @type body: L{DeriveKeyRequest}
        @param body: Name of security object (required)
        @rtype: L{KeyObject}
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.derive_key_with_http_info(key_id, body, async_call=async_call, **kwargs)
        else:
            (data) = self.derive_key_with_http_info(key_id, body, async_call=async_call, **kwargs)
            return data

    def derive_key_with_http_info(self, key_id, body, async_call=False, **kwargs):
        """
        This derives a key from an existing key and returns the properties of the new key. The request body contains the requested properties for the new as well as the mechanism to be used to produce the key material for the new key. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.derive_key_with_http_info(key_id, body, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @type body: L{DeriveKeyRequest}
        @param body: Name of security object (required)
        @rtype: L{KeyObject}
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id', 'body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method derive_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `derive_key`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `derive_key`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}/derive', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KeyObject',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def derive_key_ex(self, body, async_call=False, **kwargs):
        """
        This derives a key from an existing key and returns the properties of the new key. The request body contains the requested properties for the new as well as the mechanism to be used to produce the key material for the new key. 
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{DeriveKeyRequestEx}
        @param body: Name of security object (required)
        @rtype: L{KeyObject}
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.derive_key_ex_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.derive_key_ex_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def derive_key_ex_with_http_info(self, body, async_call=False, **kwargs):
        """
        This derives a key from an existing key and returns the properties of the new key. The request body contains the requested properties for the new as well as the mechanism to be used to produce the key material for the new key. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.derive_key_ex_with_http_info(body, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{DeriveKeyRequestEx}
        @param body: Name of security object (required)
        @rtype: L{KeyObject}
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method derive_key_ex" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `derive_key_ex`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/derive', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KeyObject',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def destroy_security_object(self, key_id, async_call=False, **kwargs):
        """
        Destroys a security object. Objects in the `Destroyed` state cannot be used in any cryptographic operation. Their metadata however, remains present. 
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @rtype: None
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.destroy_security_object_with_http_info(key_id, async_call=async_call, **kwargs)
        else:
            (data) = self.destroy_security_object_with_http_info(key_id, async_call=async_call, **kwargs)
            return data

    def destroy_security_object_with_http_info(self, key_id, async_call=False, **kwargs):
        """
        Destroys a security object. Objects in the `Destroyed` state cannot be used in any cryptographic operation. Their metadata however, remains present. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.destroy_security_object_with_http_info(key_id, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @rtype: None
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method destroy_security_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `destroy_security_object`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}/destroy', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def export_sobject_components(self, body, async_call=False, **kwargs):
        """
        
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{ExportSobjectComponentsRequest}
        @param body: Request to export a security object componsnts (required)
        @rtype: L{ExportComponentsResponse}
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.export_sobject_components_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.export_sobject_components_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def export_sobject_components_with_http_info(self, body, async_call=False, **kwargs):
        """
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.export_sobject_components_with_http_info(body, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{ExportSobjectComponentsRequest}
        @param body: Request to export a security object componsnts (required)
        @rtype: L{ExportComponentsResponse}
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_sobject_components" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `export_sobject_components`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/components/export', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ExportComponentsResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def generate_security_object(self, body, async_call=False, **kwargs):
        """
        Generate a new security object (such as an RSA key pair or an AES key) of the requested size or elliptic curve. <br> By default, all key operations except for Export that are implemented for that type of key will be enabled. These may be overridden by requesting specific operations in the key creation request. <br> Objects of type Opaque may not be generated with this API. They must be imported via the importSecurityObject API. 
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{SobjectRequest}
        @param body: Request to create, update, or import security object (required)
        @rtype: L{KeyObject}
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.generate_security_object_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.generate_security_object_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def generate_security_object_with_http_info(self, body, async_call=False, **kwargs):
        """
        Generate a new security object (such as an RSA key pair or an AES key) of the requested size or elliptic curve. <br> By default, all key operations except for Export that are implemented for that type of key will be enabled. These may be overridden by requesting specific operations in the key creation request. <br> Objects of type Opaque may not be generated with this API. They must be imported via the importSecurityObject API. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.generate_security_object_with_http_info(body, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{SobjectRequest}
        @param body: Request to create, update, or import security object (required)
        @rtype: L{KeyObject}
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_security_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `generate_security_object`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KeyObject',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_security_object(self, key_id, view=None, show_destroyed=None, show_deleted=None, async_call=False, **kwargs):
        """
        Get the details of a particular security object. 
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @type view: L{str}
        @param view: The encoding the value of an opaque object or certificate
        @type show_destroyed: L{bool}
        @param show_destroyed: Whether security objects in the `Destroyed` state should be returned
        @type show_deleted: L{bool}
        @param show_deleted: Whether security objects in the `Deleted` state should be returned
        @rtype: L{KeyObject}
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.get_security_object_with_http_info(key_id, view=view, show_destroyed=show_destroyed, show_deleted=show_deleted, async_call=async_call, **kwargs)
        else:
            (data) = self.get_security_object_with_http_info(key_id, view=view, show_destroyed=show_destroyed, show_deleted=show_deleted, async_call=async_call, **kwargs)
            return data

    def get_security_object_with_http_info(self, key_id, view=None, show_destroyed=None, show_deleted=None, async_call=False, **kwargs):
        """
        Get the details of a particular security object. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.get_security_object_with_http_info(key_id, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @type view: L{str}
        @param view: The encoding the value of an opaque object or certificate
        @type show_destroyed: L{bool}
        @param show_destroyed: Whether security objects in the `Destroyed` state should be returned
        @type show_deleted: L{bool}
        @param show_deleted: Whether security objects in the `Deleted` state should be returned
        @rtype: L{KeyObject}
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id', 'view', 'show_destroyed', 'show_deleted']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `get_security_object`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []
        if 'view' in params:
            query_params.append(('view', params['view']))
        if 'show_destroyed' in params:
            query_params.append(('show_destroyed', params['show_destroyed']))
        if 'show_deleted' in params:
            query_params.append(('show_deleted', params['show_deleted']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KeyObject',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_security_object_digest(self, body, async_call=False, **kwargs):
        """
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{ObjectDigestRequest}
        @param body: Object digest request (required)
        @rtype: L{DigestResponse}
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.get_security_object_digest_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.get_security_object_digest_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def get_security_object_digest_with_http_info(self, body, async_call=False, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.get_security_object_digest_with_http_info(body, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{ObjectDigestRequest}
        @param body: Object digest request (required)
        @rtype: L{DigestResponse}
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security_object_digest" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_security_object_digest`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/digest', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DigestResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_security_object_kcv(self, body, async_call=False, **kwargs):
        """
        Get the key check value (KCV) of a symmetric key
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{SobjectDescriptor}
        @param body: Request to export a security object (required)
        @rtype: L{KeyCheckValueResponse}
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.get_security_object_kcv_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.get_security_object_kcv_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def get_security_object_kcv_with_http_info(self, body, async_call=False, **kwargs):
        """
        Get the key check value (KCV) of a symmetric key
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.get_security_object_kcv_with_http_info(body, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{SobjectDescriptor}
        @param body: Request to export a security object (required)
        @rtype: L{KeyCheckValueResponse}
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security_object_kcv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_security_object_kcv`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/kcv', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KeyCheckValueResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_security_object_value(self, key_id, async_call=False, **kwargs):
        """
        Get the details and value of a particular exportable security object. 
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @rtype: L{KeyObject}
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.get_security_object_value_with_http_info(key_id, async_call=async_call, **kwargs)
        else:
            (data) = self.get_security_object_value_with_http_info(key_id, async_call=async_call, **kwargs)
            return data

    def get_security_object_value_with_http_info(self, key_id, async_call=False, **kwargs):
        """
        Get the details and value of a particular exportable security object. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.get_security_object_value_with_http_info(key_id, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @rtype: L{KeyObject}
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security_object_value" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `get_security_object_value`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}/export', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KeyObject',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_security_object_value_ex(self, body, async_call=False, **kwargs):
        """
        Get the details and value of a particular exportable security object. 
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{SobjectDescriptor}
        @param body: Request to export a security object (required)
        @rtype: L{KeyObject}
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.get_security_object_value_ex_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.get_security_object_value_ex_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def get_security_object_value_ex_with_http_info(self, body, async_call=False, **kwargs):
        """
        Get the details and value of a particular exportable security object. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.get_security_object_value_ex_with_http_info(body, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{SobjectDescriptor}
        @param body: Request to export a security object (required)
        @rtype: L{KeyObject}
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security_object_value_ex" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_security_object_value_ex`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/export', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KeyObject',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_security_objects(self, name=None, group_id=None, creator=None, sort=None, compliant_with_policies=None, start=None, limit=None, offset=None, show_destroyed=None, show_deleted=None, async_call=False, **kwargs):
        """
        Return detailed information about the security objects stored in Fortanix SDKMS. 
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type name: L{str}
        @param name: Only retrieve the security object with this name.
        @type group_id: L{str}
        @param group_id: Only retrieve security objects in the specified group.
        @type creator: L{str}
        @param creator: Only retrieve security objects created by the user or application with the specified id.
        @type sort: L{str}
        @param sort: This specifies the property (`kid` or `name`) and order (ascending or descending) with which to sort the security objects. By default, security objects are sorted by `kid` in ascending order. The syntax is \"<property>:[asc|desc]\" (e.g. \"kid:desc\") or just \"<property>\" (ascending order by default). 
        @type compliant_with_policies: L{bool}
        @param compliant_with_policies: Whether this security object is compliant with cryptographic policies or not.
        @type start: L{str}
        @param start: If provided, this must be a value of the property specified in `sort`. Returned security objects will begin just above or just below this value (for asc/desc order resp.). 
        @type limit: L{int}
        @param limit: Maximum number of security objects to return. If not provided, the limit is 100.
        @type offset: L{int}
        @param offset: Number of security objects past `start` to skip.
        @type show_destroyed: L{bool}
        @param show_destroyed: Whether security objects in the `Destroyed` state should be returned
        @type show_deleted: L{bool}
        @param show_deleted: Whether security objects in the `Deleted` state should be returned
        @rtype: list[L{KeyObject}]
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.get_security_objects_with_http_info(name=name, group_id=group_id, creator=creator, sort=sort, compliant_with_policies=compliant_with_policies, start=start, limit=limit, offset=offset, show_destroyed=show_destroyed, show_deleted=show_deleted, async_call=async_call, **kwargs)
        else:
            (data) = self.get_security_objects_with_http_info(name=name, group_id=group_id, creator=creator, sort=sort, compliant_with_policies=compliant_with_policies, start=start, limit=limit, offset=offset, show_destroyed=show_destroyed, show_deleted=show_deleted, async_call=async_call, **kwargs)
            return data

    def get_security_objects_with_http_info(self, name=None, group_id=None, creator=None, sort=None, compliant_with_policies=None, start=None, limit=None, offset=None, show_destroyed=None, show_deleted=None, async_call=False, **kwargs):
        """
        Return detailed information about the security objects stored in Fortanix SDKMS. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.get_security_objects_with_http_info(async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type name: L{str}
        @param name: Only retrieve the security object with this name.
        @type group_id: L{str}
        @param group_id: Only retrieve security objects in the specified group.
        @type creator: L{str}
        @param creator: Only retrieve security objects created by the user or application with the specified id.
        @type sort: L{str}
        @param sort: This specifies the property (`kid` or `name`) and order (ascending or descending) with which to sort the security objects. By default, security objects are sorted by `kid` in ascending order. The syntax is \"<property>:[asc|desc]\" (e.g. \"kid:desc\") or just \"<property>\" (ascending order by default). 
        @type compliant_with_policies: L{bool}
        @param compliant_with_policies: Whether this security object is compliant with cryptographic policies or not.
        @type start: L{str}
        @param start: If provided, this must be a value of the property specified in `sort`. Returned security objects will begin just above or just below this value (for asc/desc order resp.). 
        @type limit: L{int}
        @param limit: Maximum number of security objects to return. If not provided, the limit is 100.
        @type offset: L{int}
        @param offset: Number of security objects past `start` to skip.
        @type show_destroyed: L{bool}
        @param show_destroyed: Whether security objects in the `Destroyed` state should be returned
        @type show_deleted: L{bool}
        @param show_deleted: Whether security objects in the `Deleted` state should be returned
        @rtype: list[L{KeyObject}]
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['name', 'group_id', 'creator', 'sort', 'compliant_with_policies', 'start', 'limit', 'offset', 'show_destroyed', 'show_deleted']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security_objects" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))
        if 'group_id' in params:
            query_params.append(('group_id', params['group_id']))
        if 'creator' in params:
            query_params.append(('creator', params['creator']))
        if 'sort' in params:
            query_params.append(('sort', params['sort']))
        if 'compliant_with_policies' in params:
            query_params.append(('compliant_with_policies', params['compliant_with_policies']))
        if 'start' in params:
            query_params.append(('start', params['start']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'offset' in params:
            query_params.append(('offset', params['offset']))
        if 'show_destroyed' in params:
            query_params.append(('show_destroyed', params['show_destroyed']))
        if 'show_deleted' in params:
            query_params.append(('show_deleted', params['show_deleted']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[KeyObject]',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def import_security_object(self, body, async_call=False, **kwargs):
        """
        Import a security object into SDKMS. <br> By default, all key operations except that are implemented for that type of key will be enabled. These may be overridden by requesting specific operations in the key import request. <br> For symmetric and asymmetric keys, value is base64-encoding of the key material in DER format. 
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{SobjectRequest}
        @param body: Request to create, update, or import security object (required)
        @rtype: L{KeyObject}
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.import_security_object_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.import_security_object_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def import_security_object_with_http_info(self, body, async_call=False, **kwargs):
        """
        Import a security object into SDKMS. <br> By default, all key operations except that are implemented for that type of key will be enabled. These may be overridden by requesting specific operations in the key import request. <br> For symmetric and asymmetric keys, value is base64-encoding of the key material in DER format. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.import_security_object_with_http_info(body, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{SobjectRequest}
        @param body: Request to create, update, or import security object (required)
        @rtype: L{KeyObject}
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_security_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `import_security_object`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KeyObject',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def import_sobject_components(self, body, async_call=False, **kwargs):
        """
        
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{ImportSobjectComponentsRequest}
        @param body: Request to import a security object componsnts (required)
        @rtype: L{KeyObject}
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.import_sobject_components_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.import_sobject_components_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def import_sobject_components_with_http_info(self, body, async_call=False, **kwargs):
        """
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.import_sobject_components_with_http_info(body, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{ImportSobjectComponentsRequest}
        @param body: Request to import a security object componsnts (required)
        @rtype: L{KeyObject}
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_sobject_components" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `import_sobject_components`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/components/import', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KeyObject',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def persist_security_object(self, body, async_call=False, **kwargs):
        """
        This API copies a transient key into a persisted security object in SDKMS. If the transient key's origin is \"FortanixHSM\", the origin of the persisted key will be \"Transient\". If the transient key's origin is \"External\", the origin of the persisted key will be \"External\". 
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{PersistTransientKeyRequest}
        @param body: Persist transient key request (required)
        @rtype: L{KeyObject}
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.persist_security_object_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.persist_security_object_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def persist_security_object_with_http_info(self, body, async_call=False, **kwargs):
        """
        This API copies a transient key into a persisted security object in SDKMS. If the transient key's origin is \"FortanixHSM\", the origin of the persisted key will be \"Transient\". If the transient key's origin is \"External\", the origin of the persisted key will be \"External\". 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.persist_security_object_with_http_info(body, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{PersistTransientKeyRequest}
        @param body: Persist transient key request (required)
        @rtype: L{KeyObject}
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method persist_security_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `persist_security_object`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/persist', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KeyObject',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def revert_history_item(self, key_id, body, async_call=False, **kwargs):
        """
        When a Key Undo Policy is in place, security objects maintain a list of history items. Using this API endpoint, clients may revert the security object to a previous (non-expired) history item. 
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @type body: L{SobjectRequest}
        @param body: Request to create, update, or import security object (required)
        @rtype: None
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.revert_history_item_with_http_info(key_id, body, async_call=async_call, **kwargs)
        else:
            (data) = self.revert_history_item_with_http_info(key_id, body, async_call=async_call, **kwargs)
            return data

    def revert_history_item_with_http_info(self, key_id, body, async_call=False, **kwargs):
        """
        When a Key Undo Policy is in place, security objects maintain a list of history items. Using this API endpoint, clients may revert the security object to a previous (non-expired) history item. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.revert_history_item_with_http_info(key_id, body, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @type body: L{SobjectRequest}
        @param body: Request to create, update, or import security object (required)
        @rtype: None
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id', 'body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revert_history_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `revert_history_item`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `revert_history_item`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}/revert', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def revoke_security_object(self, key_id, body, async_call=False, **kwargs):
        """
        Trigger the transition of a security object to Deactivated or Compromised state depending on the RevocationReason Code. 
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @type body: L{RevocationReason}
        @param body: Reason to revoke a security object (required)
        @rtype: None
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.revoke_security_object_with_http_info(key_id, body, async_call=async_call, **kwargs)
        else:
            (data) = self.revoke_security_object_with_http_info(key_id, body, async_call=async_call, **kwargs)
            return data

    def revoke_security_object_with_http_info(self, key_id, body, async_call=False, **kwargs):
        """
        Trigger the transition of a security object to Deactivated or Compromised state depending on the RevocationReason Code. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.revoke_security_object_with_http_info(key_id, body, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @type body: L{RevocationReason}
        @param body: Reason to revoke a security object (required)
        @rtype: None
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id', 'body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revoke_security_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `revoke_security_object`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `revoke_security_object`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}/revoke', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def rotate_security_object(self, body, async_call=False, **kwargs):
        """
        Rotate an existing security object.
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{SobjectRequest}
        @param body: Request to create, update, or import security object (required)
        @rtype: L{KeyObject}
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.rotate_security_object_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.rotate_security_object_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def rotate_security_object_with_http_info(self, body, async_call=False, **kwargs):
        """
        Rotate an existing security object.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.rotate_security_object_with_http_info(body, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{SobjectRequest}
        @param body: Request to create, update, or import security object (required)
        @rtype: L{KeyObject}
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rotate_security_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `rotate_security_object`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/rekey', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KeyObject',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_security_object(self, key_id, body, async_call=False, **kwargs):
        """
        Update the properties of a security object. 
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @type body: L{SobjectRequest}
        @param body: Request to create, update, or import security object (required)
        @rtype: L{KeyObject}
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.update_security_object_with_http_info(key_id, body, async_call=async_call, **kwargs)
        else:
            (data) = self.update_security_object_with_http_info(key_id, body, async_call=async_call, **kwargs)
            return data

    def update_security_object_with_http_info(self, key_id, body, async_call=False, **kwargs):
        """
        Update the properties of a security object. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.update_security_object_with_http_info(key_id, body, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type key_id: L{str}
        @param key_id: kid of security object (required)
        @type body: L{SobjectRequest}
        @param body: Request to create, update, or import security object (required)
        @rtype: L{KeyObject}
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id', 'body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_security_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `update_security_object`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_security_object`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KeyObject',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def verify_kcv(self, body, async_call=False, **kwargs):
        """
        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{VerifyKcvRequest}
        @param body: Verify KCV request (required)
        @rtype: L{VerifyKcvResponse}
        @return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.verify_kcv_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.verify_kcv_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def verify_kcv_with_http_info(self, body, async_call=False, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::
            >>> thread = api.verify_kcv_with_http_info(body, async_call=True)
            >>> result = thread.get()

        @type async_call: bool
        @param async_call: Whether the call should be performed asynchronously. (Default is False).
        @type body: L{VerifyKcvRequest}
        @param body: Verify KCV request (required)
        @rtype: L{VerifyKcvResponse}
        @return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_kcv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `verify_kcv`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/kcv/verify', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerifyKcvResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
