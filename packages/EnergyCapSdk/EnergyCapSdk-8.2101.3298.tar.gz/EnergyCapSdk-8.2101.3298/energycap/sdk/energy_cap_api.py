# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.service_client import ServiceClient
from msrest import Configuration, Serializer, Deserializer
from .version import VERSION
from msrest.pipeline import ClientRawResponse
from msrest.exceptions import HttpOperationError
from . import models


class EnergyCapApiConfiguration(Configuration):
    """Configuration for EnergyCapApi
    Note that all parameters used to create this instance are saved as instance
    attributes.

    :param str base_url: Service URL
    """

    def __init__(
            self, base_url=None):

        if not base_url:
            base_url = 'http://localhost'

        super(EnergyCapApiConfiguration, self).__init__(base_url)

        self.add_user_agent('EnergyCapSdk/{}'.format(VERSION))


class EnergyCapApi(object):
    """Document used to generate the EnergyCAP SDK

    :ivar config: Configuration for client.
    :vartype config: EnergyCapApiConfiguration

    :param str base_url: Service URL
    """

    def __init__(
            self, base_url=None):

        self.config = EnergyCapApiConfiguration(base_url)
        self._client = ServiceClient(None, self.config)

        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
        self.api_version = '8.2101'
        self._serialize = Serializer(client_models)
        self._deserialize = Deserializer(client_models)


    def get_account(
            self, account_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves one account.

        :param account_id: The account identifier for the account being
         retrieved
        :type account_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AccountResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.AccountResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_account.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AccountResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_account.metadata = {'url': '/api/v3/account/{accountId}'}

    def edit_account(
            self, account_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits an account.

        :param account_id: The identifier for the account being edited
        :type account_id: int
        :param body: Data representing the account being edited
        :type body: ~energycap.sdk.models.AccountEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AccountResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.AccountResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_account.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'AccountEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AccountResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_account.metadata = {'url': '/api/v3/account/{accountId}'}

    def delete_account(
            self, account_id, delete_bills=None, custom_headers=None, raw=False, **operation_config):
        """Deletes an account. Currently NO confirmation is required.

        :param account_id: The identifier for the account being deleted
        :type account_id: int
        :param delete_bills: Should this cascade to delete any bills
         associated with this meter
        :type delete_bills: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_account.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if delete_bills is not None:
            query_parameters['deleteBills'] = self._serialize.query("delete_bills", delete_bills, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_account.metadata = {'url': '/api/v3/account/{accountId}'}

    def get_accounts(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves all accounts.

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.AccountResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_accounts.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[AccountResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_accounts.metadata = {'url': '/api/v3/account'}

    def create_account(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates an account.

        :param body: Data representing the account being created
        :type body: ~energycap.sdk.models.AccountCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AccountResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.AccountResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_account.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'AccountCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AccountResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_account.metadata = {'url': '/api/v3/account'}

    def search_accounts(
            self, query=None, include_inactive_accounts=None, custom_headers=None, raw=False, **operation_config):
        """Search for accounts
        Search for accounts whose account code, address, old account code,
        meter serial number, or meter address contains "query".

        :param query: The string to search for
        :type query: str
        :param include_inactive_accounts: Flag to determine if inactive
         accounts should be included in the search results
        :type include_inactive_accounts: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.SearchAccountMeterBillEntry] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.search_accounts.metadata['url']

        # Construct parameters
        query_parameters = {}
        if query is not None:
            query_parameters['query'] = self._serialize.query("query", query, 'str')
        if include_inactive_accounts is not None:
            query_parameters['includeInactiveAccounts'] = self._serialize.query("include_inactive_accounts", include_inactive_accounts, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[SearchAccountMeterBillEntry]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    search_accounts.metadata = {'url': '/api/v3/account/search'}

    def edit_account_ud_fs(
            self, account_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits a account udf values.

        :param account_id: The identifier for the account being edited
        :type account_id: int
        :param body: Data representing the account udfs being edited
        :type body: list[~energycap.sdk.models.UDFValue]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.UDFFieldChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_account_ud_fs.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[UDFValue]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UDFFieldChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_account_ud_fs.metadata = {'url': '/api/v3/account/{accountId}/udf'}

    def get_account_udfs(
            self, account_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all UDFs for a particular account.

        :param account_id: The account identifier for which UDF values are
         being retrieved
        :type account_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.UDFFieldChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_account_udfs.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UDFFieldChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_account_udfs.metadata = {'url': '/api/v3/account/{accountId}/udf'}

    def get_accounts_udfs(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves all UDFs for all accounts.

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.AccountUDFResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_accounts_udfs.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[AccountUDFResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_accounts_udfs.metadata = {'url': '/api/v3/account/udf'}

    def get_account_rates(
            self, account_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all rates for a particular account.

        :param account_id: The account identifier for which rate values are
         being retrieved
        :type account_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.AccountRateResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_account_rates.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[AccountRateResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_account_rates.metadata = {'url': '/api/v3/account/{accountId}/rate'}

    def get_account_templates(
            self, account_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all templates for a particular account.

        :param account_id: The account identifier for which template values
         are being retrieved
        :type account_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.AccountTemplateResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_account_templates.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[AccountTemplateResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_account_templates.metadata = {'url': '/api/v3/account/{accountId}/template'}

    def get_account_alerts(
            self, account_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all alerts for an account.

        :param account_id: The identifier for the account
        :type account_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.AccountAlertResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_account_alerts.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[AccountAlertResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_account_alerts.metadata = {'url': '/api/v3/account/{accountId}/alert'}

    def create_account_alert(
            self, account_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates an account alert.

        :param account_id: The identifier for the account to create alert is
         on
        :type account_id: int
        :param body: Data representing the account alert being created
        :type body: ~energycap.sdk.models.AccountAlertRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AccountAlertResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.AccountAlertResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_account_alert.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'AccountAlertRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AccountAlertResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_account_alert.metadata = {'url': '/api/v3/account/{accountId}/alert'}

    def get_account_alert(
            self, account_id, alert_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves an alert for an account.

        :param account_id: The identifier for the account the alert is on
        :type account_id: int
        :param alert_id: The identifier for the alert to return
        :type alert_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AccountAlertResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.AccountAlertResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_account_alert.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'alertId': self._serialize.url("alert_id", alert_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AccountAlertResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_account_alert.metadata = {'url': '/api/v3/account/{accountId}/alert/{alertId}'}

    def delete_account_alert(
            self, account_id, alert_id, custom_headers=None, raw=False, **operation_config):
        """Deletes an account alert.

        :param account_id: The identifier for the account the alert is on
        :type account_id: int
        :param alert_id: The identifier for the alert to delete
        :type alert_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_account_alert.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'alertId': self._serialize.url("alert_id", alert_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_account_alert.metadata = {'url': '/api/v3/account/{accountId}/alert/{alertId}'}

    def update_account_alert(
            self, account_id, alert_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Updates an account alert.

        :param account_id: The identifier for the account the alert to update
         is on
        :type account_id: int
        :param alert_id: The identifier for the account alert to update
        :type alert_id: int
        :param body: Data representing the account alert being created
        :type body: ~energycap.sdk.models.AccountAlertRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AccountAlertResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.AccountAlertResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_account_alert.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'alertId': self._serialize.url("alert_id", alert_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'AccountAlertRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AccountAlertResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    update_account_alert.metadata = {'url': '/api/v3/account/{accountId}/alert/{alertId}'}

    def get_default_billing_period(
            self, account_id, start_date=None, end_date=None, custom_headers=None, raw=False, **operation_config):
        """For a given accountId, startDate and endDates for a bill get a billing
        period recommendation
        The billing period will be in YYYYMM format YYYY represents the 4 digit
        year and MM is the two digit month 01 for Jan to 12 for Dec.

        :param account_id: The identifier for the account for which bill is
         being created
        :type account_id: int
        :param start_date: The start date of the bill
        :type start_date: datetime
        :param end_date: The end date of the bill
        :type end_date: datetime
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SingleValue or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SingleValue or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_default_billing_period.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if start_date is not None:
            query_parameters['startDate'] = self._serialize.query("start_date", start_date, 'iso-8601')
        if end_date is not None:
            query_parameters['endDate'] = self._serialize.query("end_date", end_date, 'iso-8601')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SingleValue', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_default_billing_period.metadata = {'url': '/api/v3/account/{accountId}/billingPeriod'}

    def move_account(
            self, parent_cost_center_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Move list of accounts to be under parentCostCenterId.

        :param parent_cost_center_id: The identifier for the new parent
         costCenter
        :type parent_cost_center_id: int
        :param body: List of accountIds to move under the parentCostCenterId
        :type body: list[int]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.move_account.metadata['url']
        path_format_arguments = {
            'parentCostCenterId': self._serialize.url("parent_cost_center_id", parent_cost_center_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[int]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    move_account.metadata = {'url': '/api/v3/parentCostCenter/{parentCostCenterId}/account'}

    def edit_account_code_version(
            self, account_id, body=None, custom_headers=None, raw=False, **operation_config):
        """

        :param account_id:
        :type account_id: int
        :param body:
        :type body: ~energycap.sdk.models.AccountCodeHistoryRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AccountCodeHistoryResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.AccountCodeHistoryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_account_code_version.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'AccountCodeHistoryRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AccountCodeHistoryResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_account_code_version.metadata = {'url': '/api/v3/account/{accountId}/codeversion'}

    def get_account_actual_yearly_list(
            self, number_of_years=4, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data by account for a given number
        of years- Result includes cost, use, unit cost on an yearly basis. It
        also includes commodity level break up.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.AccountDigestActualYearlyResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_account_actual_yearly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[AccountDigestActualYearlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_account_actual_yearly_list.metadata = {'url': '/api/v3/account/digest/actual/yearly'}

    def get_account_actual_yearly(
            self, account_id, number_of_years=4, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data by account for a given number
        of years- Result includes cost, use, unit cost on an yearly basis. It
        also includes commodity level break up.

        :param account_id: The account to retrieve data for
        :type account_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AccountDigestActualYearlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.AccountDigestActualYearlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_account_actual_yearly.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AccountDigestActualYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_account_actual_yearly.metadata = {'url': '/api/v3/account/{accountId}/digest/actual/yearly'}

    def get_account_actual_monthly_list(
            self, number_of_years=2, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data by account for a given number
        of years- Result includes cost, use, unit cost on a monthly basis. It
        also includes commodity level break up.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 24 months
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.AccountDigestActualMonthlyResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_account_actual_monthly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[AccountDigestActualMonthlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_account_actual_monthly_list.metadata = {'url': '/api/v3/account/digest/actual/monthly'}

    def get_account_actual_monthly(
            self, account_id, number_of_years=2, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data by account for a given number
        of years- Result includes cost, use, unit cost on a monthly basis. It
        also includes commodity level break up.

        :param account_id: The account to retrieve data for
        :type account_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 24 months
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AccountDigestActualMonthlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.AccountDigestActualMonthlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_account_actual_monthly.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AccountDigestActualMonthlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_account_actual_monthly.metadata = {'url': '/api/v3/account/{accountId}/digest/actual/monthly'}

    def create_account_meter(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Links an account and meter together.  Meters must be linked to an
        active account to be usable in EnergyCAP.  Once an account and meter
        are created individually,
        they must be linked with this API.

        :param body: Data representing the account and meter being linked
        :type body: list[~energycap.sdk.models.AccountMeterRequest]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.AccountMeterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_account_meter.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[AccountMeterRequest]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[AccountMeterResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_account_meter.metadata = {'url': '/api/v3/accountmeter'}

    def edit_account_meter(
            self, account_meter_id, delete_bills=None, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit an account meter relationship.

        :param account_meter_id: The id of the account meter record to edit
        :type account_meter_id: int
        :param delete_bills: A true value means delete all bills that have at
         least 1 line for this account and meter and a bill start date greater
         than or equal to the new account and meter relationship end date.
         WARNING: Bills for this account may include other meters.  The ENTIRE
         bill is deleted.
         This flag can only be true when:
         Editing the most recent relationship between this account and meter
         The end date has been changed but not the begin date
        :type delete_bills: bool
        :param body: Data used to update the account and meter
        :type body: ~energycap.sdk.models.AccountMeterEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AccountMeterResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.AccountMeterResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_account_meter.metadata['url']
        path_format_arguments = {
            'accountMeterId': self._serialize.url("account_meter_id", account_meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if delete_bills is not None:
            query_parameters['deleteBills'] = self._serialize.query("delete_bills", delete_bills, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'AccountMeterEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AccountMeterResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_account_meter.metadata = {'url': '/api/v3/accountmeter/{accountMeterId}'}

    def delete_account_meter(
            self, account_meter_id, delete_bills=None, custom_headers=None, raw=False, **operation_config):
        """Delete an account meter.  Cannot be part of an EnergyCAP version 3 or
        version 6 chargeback.

        :param account_meter_id:
        :type account_meter_id: int
        :param delete_bills: A true value means delete all bills that have at
         least 1 line for this account and meter
         WARNING: Bills for this account include other meters.  The ENTIRE bill
         is deleted.
         This flag can only be true when:
         There is a single relationship between the specified account and meter
        :type delete_bills: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_account_meter.metadata['url']
        path_format_arguments = {
            'accountMeterId': self._serialize.url("account_meter_id", account_meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if delete_bills is not None:
            query_parameters['deleteBills'] = self._serialize.query("delete_bills", delete_bills, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_account_meter.metadata = {'url': '/api/v3/accountmeter/{accountMeterId}'}

    def create_account_rate(
            self, account_meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates an AccountRate Relationship.  Linking AccountMeter and Rate.

        :param account_meter_id:
        :type account_meter_id: int
        :param body:
        :type body: ~energycap.sdk.models.AccountRateRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AccountMeterRateResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.AccountMeterRateResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_account_rate.metadata['url']
        path_format_arguments = {
            'accountMeterId': self._serialize.url("account_meter_id", account_meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'AccountRateRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AccountMeterRateResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_account_rate.metadata = {'url': '/api/v3/accountmeter/{accountMeterId}/rate'}

    def edit_account_rate_list(
            self, account_meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit all AccountRate relationships.

        :param account_meter_id:
        :type account_meter_id: int
        :param body:
        :type body: list[~energycap.sdk.models.AccountRateRequest]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.AccountMeterRateResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_account_rate_list.metadata['url']
        path_format_arguments = {
            'accountMeterId': self._serialize.url("account_meter_id", account_meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[AccountRateRequest]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[AccountMeterRateResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_account_rate_list.metadata = {'url': '/api/v3/accountmeter/{accountMeterId}/rate'}

    def create_form_template(
            self, account_meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Assigns a new template to an account meter.
        The new template's begin date must be after the begin date of all
        existing template assignments.

        :param account_meter_id:
        :type account_meter_id: int
        :param body:
        :type body: ~energycap.sdk.models.FormTemplateRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: FormTemplateResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.FormTemplateResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_form_template.metadata['url']
        path_format_arguments = {
            'accountMeterId': self._serialize.url("account_meter_id", account_meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'FormTemplateRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FormTemplateResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_form_template.metadata = {'url': '/api/v3/accountmeter/{accountMeterId}/template'}

    def edit_form_template_list(
            self, account_meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit all FormTemplate relationships.

        :param account_meter_id:
        :type account_meter_id: int
        :param body:
        :type body: list[~energycap.sdk.models.FormTemplateRequest]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.FormTemplateResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_form_template_list.metadata['url']
        path_format_arguments = {
            'accountMeterId': self._serialize.url("account_meter_id", account_meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[FormTemplateRequest]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[FormTemplateResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_form_template_list.metadata = {'url': '/api/v3/accountmeter/{accountMeterId}/template'}

    def delete_template_assignment(
            self, account_meter_id, form_template_id, custom_headers=None, raw=False, **operation_config):
        """Delete an template assignment from an account meter
        If we are deleting a template assignment in the middle of two other
        template assignments, then we will move back the next template's start
        date
        If we are deleting the last template(current template), the extend
        second last template's end date to match the account meter's end date
        If we are deleting the first template pull the second template's begin
        date to match account meter's begin date.

        :param account_meter_id:
        :type account_meter_id: int
        :param form_template_id:
        :type form_template_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_template_assignment.metadata['url']
        path_format_arguments = {
            'accountMeterId': self._serialize.url("account_meter_id", account_meter_id, 'int'),
            'formTemplateId': self._serialize.url("form_template_id", form_template_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_template_assignment.metadata = {'url': '/api/v3/accountmeter/{accountMeterId}/template/{formTemplateId}'}

    def process_accruals(
            self, filter=None, body=None, custom_headers=None, raw=False, **operation_config):
        """Run the accrual processor engine using the supplied settings to
        generate accrual bills.

        :param filter: Accrual data selection filters
        :type filter: str
        :param body: Accrual processor settings
        :type body: ~energycap.sdk.models.AccrualProcessorRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GuidResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GuidResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.process_accruals.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'AccrualProcessorRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GuidResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    process_accruals.metadata = {'url': '/api/v3/accrual'}

    def void_accrual_task(
            self, task_id, custom_headers=None, raw=False, **operation_config):
        """Void all bills created by the Accrual task
        If any bills have already been exported they will still be voided.

        :param task_id: Identifier for the accrual task
        :type task_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.void_accrual_task.metadata['url']
        path_format_arguments = {
            'taskId': self._serialize.url("task_id", task_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    void_accrual_task.metadata = {'url': '/api/v3/accrual/{taskId}/void'}

    def delete_accrual_task(
            self, task_id, custom_headers=None, raw=False, **operation_config):
        """Delete all bills created by the Accrual task
        If any bills have already been exported they will still be deleted.

        :param task_id: Identifier for the accrual task
        :type task_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_accrual_task.metadata['url']
        path_format_arguments = {
            'taskId': self._serialize.url("task_id", task_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_accrual_task.metadata = {'url': '/api/v3/accrual/{taskId}/delete'}

    def get_accrual_settings(
            self, custom_headers=None, raw=False, **operation_config):
        """Get Accrual settings.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AccrualSettingsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.AccrualSettingsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_accrual_settings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AccrualSettingsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_accrual_settings.metadata = {'url': '/api/v3/accrual/setting'}

    def get_bill_activity(
            self, date_parameter=None, custom_headers=None, raw=False, **operation_config):
        """List of a bill IDs that were created or modified since the given date.

        :param date_parameter: Created or modified datetime; Defaults to
         yesterday at the current time
        :type date_parameter: datetime
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.Activity] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_activity.metadata['url']

        # Construct parameters
        query_parameters = {}
        if date_parameter is not None:
            query_parameters['date'] = self._serialize.query("date_parameter", date_parameter, 'iso-8601')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[Activity]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill_activity.metadata = {'url': '/api/v3/activity/bill'}

    def get_system_settings(
            self, custom_headers=None, raw=False, **operation_config):
        """

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.AdminSettingsResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_system_settings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[AdminSettingsResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_system_settings.metadata = {'url': '/api/v3/admin/systemsetting'}

    def update_system_settings(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """

        :param body:
        :type body: list[~energycap.sdk.models.AdminSettingsRequest]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.AdminSettingsResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_system_settings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[AdminSettingsRequest]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[AdminSettingsResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    update_system_settings.metadata = {'url': '/api/v3/admin/systemsetting'}

    def get_accounting_settings(
            self, custom_headers=None, raw=False, **operation_config):
        """Get accounting settings.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AccountingSettingsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.AccountingSettingsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_accounting_settings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AccountingSettingsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_accounting_settings.metadata = {'url': '/api/v3/admin/accounting'}

    def edit_accounting_settings(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit accounting settings.

        :param body:
        :type body: ~energycap.sdk.models.AccountingSettingsRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AccountingSettingsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.AccountingSettingsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_accounting_settings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'AccountingSettingsRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AccountingSettingsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_accounting_settings.metadata = {'url': '/api/v3/admin/accounting'}

    def get_account_periods(
            self, custom_headers=None, raw=False, **operation_config):
        """Get the list of account periods.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.AccountPeriodResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_account_periods.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[AccountPeriodResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_account_periods.metadata = {'url': '/api/v3/admin/accountperiod'}

    def get_organization_logo(
            self, custom_headers=None, raw=False, **operation_config):
        """Retrieve the organization logo, if configured. Only URLs or JPEG, PNG,
        and SVG images are acceptable organization logos. If the saved base64
        image is of a different file type, it will return an error.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SingleValue or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SingleValue or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_organization_logo.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SingleValue', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_organization_logo.metadata = {'url': '/api/v3/admin/logo'}

    def get_system_settings_new(
            self, custom_headers=None, raw=False, **operation_config):
        """Get system settings.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SystemSettingsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SystemSettingsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_system_settings_new.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SystemSettingsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_system_settings_new.metadata = {'url': '/api/v3/admin/systemSettings'}

    def edit_system_settings_new(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit system settings.

        :param body:
        :type body: ~energycap.sdk.models.SystemSettingsRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SystemSettingsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SystemSettingsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_system_settings_new.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'SystemSettingsRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SystemSettingsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_system_settings_new.metadata = {'url': '/api/v3/admin/systemSettings'}

    def get_license_details(
            self, custom_headers=None, raw=False, **operation_config):
        """Get license details.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: LicenseResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.LicenseResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_license_details.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LicenseResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_license_details.metadata = {'url': '/api/v3/admin/license'}

    def edit_license_details(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit the license details.

        :param body:
        :type body: ~energycap.sdk.models.LicenseRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: LicenseResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.LicenseResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_license_details.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'LicenseRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LicenseResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_license_details.metadata = {'url': '/api/v3/admin/license'}

    def process_custom_app_action(
            self, webhook_id, custom_headers=None, raw=False, **operation_config):
        """Fire a custom application action webhook.

        :param webhook_id: The identifier for the webhook being fired
        :type webhook_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: WebhookLogDetailsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.WebhookLogDetailsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.process_custom_app_action.metadata['url']
        path_format_arguments = {
            'webhookId': self._serialize.url("webhook_id", webhook_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('WebhookLogDetailsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    process_custom_app_action.metadata = {'url': '/api/v3/admin/customapplicationaction/{webhookId}'}

    def create_api_key(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a new API key.

        :param body:
        :type body: ~energycap.sdk.models.ApiKeyCreateRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ApiKeyCreateResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ApiKeyCreateResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_api_key.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ApiKeyCreateRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ApiKeyCreateResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_api_key.metadata = {'url': '/api/v3/apiKey'}

    def get_api_keys(
            self, filter=None, custom_headers=None, raw=False, **operation_config):
        """Get a list of all available API keys.

        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.ApiKeyResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_api_keys.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ApiKeyResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_api_keys.metadata = {'url': '/api/v3/apiKey'}

    def get_api_key(
            self, api_key_id, custom_headers=None, raw=False, **operation_config):
        """Get an API key.

        :param api_key_id:
        :type api_key_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ApiKeyResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ApiKeyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_api_key.metadata['url']
        path_format_arguments = {
            'apiKeyId': self._serialize.url("api_key_id", api_key_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ApiKeyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_api_key.metadata = {'url': '/api/v3/apiKey/{apiKeyId}'}

    def delete_api_key(
            self, api_key_id, custom_headers=None, raw=False, **operation_config):
        """Delete an API key.

        :param api_key_id:
        :type api_key_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_api_key.metadata['url']
        path_format_arguments = {
            'apiKeyId': self._serialize.url("api_key_id", api_key_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_api_key.metadata = {'url': '/api/v3/apiKey/{apiKeyId}'}

    def edit_api_key(
            self, api_key_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit the name and description of an api key.

        :param api_key_id:
        :type api_key_id: int
        :param body:
        :type body: ~energycap.sdk.models.ApiKeyEditRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ApiKeyResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ApiKeyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_api_key.metadata['url']
        path_format_arguments = {
            'apiKeyId': self._serialize.url("api_key_id", api_key_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ApiKeyEditRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ApiKeyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_api_key.metadata = {'url': '/api/v3/apiKey/{apiKeyId}'}

    def get_audit_settings(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets all audit settings.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AuditSettings or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.AuditSettings or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_audit_settings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AuditSettings', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_audit_settings.metadata = {'url': '/api/v3/audit'}

    def update_audit_settings(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Update audit settings.

        __Setting Status Descriptions:__
        | Setting Status | Description |
        | -------------- | ----------- |
        | Check          | If this audit fails affected bills are flagged  |
        | Hold           | If this audit fails affected bills are flagged and
        held from export  |
        | Skip           | This audit is skipped  |.

        :param body: The new state of the audit settings
        :type body: ~energycap.sdk.models.AuditSettings
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AuditSettings or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.AuditSettings or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_audit_settings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'AuditSettings')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AuditSettings', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    update_audit_settings.metadata = {'url': '/api/v3/audit'}

    def exec_audit_engine(
            self, list_id=None, custom_headers=None, raw=False, **operation_config):
        """

        :param list_id:
        :type list_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.exec_audit_engine.metadata['url']

        # Construct parameters
        query_parameters = {}
        if list_id is not None:
            query_parameters['listId'] = self._serialize.query("list_id", list_id, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    exec_audit_engine.metadata = {'url': '/api/v3/audit/exec'}

    def login(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """

        :param body:
        :type body: ~energycap.sdk.models.LoginRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: LoginResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.LoginResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.login.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'LoginRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LoginResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    login.metadata = {'url': '/api/v3/login'}

    def beta(
            self, custom_headers=None, raw=False, **operation_config):
        """

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: dict or ClientRawResponse if raw=true
        :rtype: dict[str, bool] or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.beta.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('{bool}', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    beta.metadata = {'url': '/api/internal/beta'}

    def logout(
            self, custom_headers=None, raw=False, **operation_config):
        """Logout user- if they were logged in using a cookie.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.logout.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    logout.metadata = {'url': '/api/v3/logout'}

    def create_token_for_partition(
            self, partition=None, custom_headers=None, raw=False, **operation_config):
        """My.EnergyCap.Com needs a way to get a token from a partition name. Pass
        in a partition, create and return a token for provided partition.

        :param partition:
        :type partition: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SingleValue or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SingleValue or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_token_for_partition.metadata['url']

        # Construct parameters
        query_parameters = {}
        if partition is not None:
            query_parameters['partition'] = self._serialize.query("partition", partition, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SingleValue', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_token_for_partition.metadata = {'url': '/api/v3/exchange/eco'}

    def open_batch(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """

        :param body:
        :type body: ~energycap.sdk.models.BatchCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BatchResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BatchResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.open_batch.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BatchCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BatchResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    open_batch.metadata = {'url': '/api/v3/batch'}

    def get_batches(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BatchResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_batches.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[BatchResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_batches.metadata = {'url': '/api/v3/batch'}

    def get_batch(
            self, batch_id, custom_headers=None, raw=False, **operation_config):
        """

        :param batch_id:
        :type batch_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BatchResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BatchResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_batch.metadata['url']
        path_format_arguments = {
            'batchId': self._serialize.url("batch_id", batch_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BatchResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_batch.metadata = {'url': '/api/v3/batch/{batchId}'}

    def edit_batch(
            self, batch_id, body=None, custom_headers=None, raw=False, **operation_config):
        """

        :param batch_id:
        :type batch_id: int
        :param body:
        :type body: ~energycap.sdk.models.BatchEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BatchResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BatchResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_batch.metadata['url']
        path_format_arguments = {
            'batchId': self._serialize.url("batch_id", batch_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BatchEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BatchResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_batch.metadata = {'url': '/api/v3/batch/{batchId}'}

    def delete_batch(
            self, batch_id, custom_headers=None, raw=False, **operation_config):
        """

        :param batch_id:
        :type batch_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_batch.metadata['url']
        path_format_arguments = {
            'batchId': self._serialize.url("batch_id", batch_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_batch.metadata = {'url': '/api/v3/batch/{batchId}'}

    def close_batch(
            self, batch_id, custom_headers=None, raw=False, **operation_config):
        """

        :param batch_id:
        :type batch_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BatchResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BatchResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.close_batch.metadata['url']
        path_format_arguments = {
            'batchId': self._serialize.url("batch_id", batch_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BatchResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    close_batch.metadata = {'url': '/api/v3/batch/close/{batchId}'}

    def get_bills(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves an array of bills. The array of bills can be filtered by a
        number of criteria. See the filter property for more details.

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BillResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bills.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[BillResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_bills.metadata = {'url': '/api/v3/bill'}

    def create_bill(
            self, save_as_resolved=False, comment="", body=None, custom_headers=None, raw=False, **operation_config):
        """Create a new bill.

        Creates a bill.
        The created bill gets audited.
        If any audits fail, the bill will get flagged.
        If the audit setting for any of the failed audits is set to Fail and
        Hold, the bill will be set as "Hold from Accounting Export"
        If saveAsResolved property is set to true, the flagged bill will be
        automatically resolved and Released for Accounting Export.

        :param save_as_resolved: Controls whether or not any failed audits
         automatically get marked as resolved
        :type save_as_resolved: bool
        :param comment: Optional comment to explain why the audit is being
         auto resolved
        :type comment: str
        :param body:
        :type body: ~energycap.sdk.models.BillCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BillIdResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BillIdResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_bill.metadata['url']

        # Construct parameters
        query_parameters = {}
        if save_as_resolved is not None:
            query_parameters['saveAsResolved'] = self._serialize.query("save_as_resolved", save_as_resolved, 'bool')
        if comment is not None:
            query_parameters['comment'] = self._serialize.query("comment", comment, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BillIdResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_bill.metadata = {'url': '/api/v3/bill'}

    def get_bill(
            self, bill_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves one bill.

        :param bill_id: The bill identifier
        :type bill_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BillResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BillResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill.metadata['url']
        path_format_arguments = {
            'billId': self._serialize.url("bill_id", bill_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BillResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill.metadata = {'url': '/api/v3/bill/{billId}'}

    def edit_bill(
            self, bill_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit an existing bill.

        If enabled, audits will be processed for the edited bill.
        Below are some clarifications regarding the rules for editing an
        existing bill:
        * Bills which are marked as "void" may not be edited
        * Users without UpdateApprovedBills.Edit permission may not edit bills
        marked as "Approved"
        * Users without ExportBills.Edit permission may not edit bills exported
        to AP or GL
        * Bills must have at least one line item
        * If configured, required bill headers will be enforced.

        :param bill_id:
        :type bill_id: int
        :param body:
        :type body: ~energycap.sdk.models.BillEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BillIdResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BillIdResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_bill.metadata['url']
        path_format_arguments = {
            'billId': self._serialize.url("bill_id", bill_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BillIdResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_bill.metadata = {'url': '/api/v3/bill/{billId}'}

    def get_bill_bodylines(
            self, bill_id, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves one bill's bodylines.

        :param bill_id: The bill identifier
        :type bill_id: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BodylineResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_bodylines.metadata['url']
        path_format_arguments = {
            'billId': self._serialize.url("bill_id", bill_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[BodylineResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_bill_bodylines.metadata = {'url': '/api/v3/bill/{billId}/bodyline'}

    def get_all_bills_bodylines(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves all bill's bodylines.

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BodylineResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_all_bills_bodylines.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[BodylineResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_all_bills_bodylines.metadata = {'url': '/api/v3/bill/bodyline'}

    def bill_action_void_method(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Update void flag for the given billIDs.

        :param body: Void action
        :type body: ~energycap.sdk.models.BillActionVoid
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.bill_action_void_method.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillActionVoid')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    bill_action_void_method.metadata = {'url': '/api/v3/bill/void'}

    def bill_action_update_headers(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Update all headers for a given list of bills
        If a new begin date or end date is being set, bills that would have end
        dates on or before their begin date will not be updated
        If the user does not have permission to edit exported or approved
        bills, those bills will not be updated
        Bill audits won't be fired.

        :param body: Bill header update action
        :type body: ~energycap.sdk.models.BillActionHeaderUpdate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.bill_action_update_headers.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillActionHeaderUpdate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    bill_action_update_headers.metadata = {'url': '/api/v3/bill/billHeaders'}

    def bill_action_approve_method(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Update approved flag for the given billIDs.

        :param body: approve action
        :type body: ~energycap.sdk.models.BillActionApprove
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.bill_action_approve_method.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillActionApprove')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    bill_action_approve_method.metadata = {'url': '/api/v3/bill/approve'}

    def bill_action_export_hold_method(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Update export hold flag for the given billIDs.

        :param body: export hold action
        :type body: ~energycap.sdk.models.BillActionExportHold
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.bill_action_export_hold_method.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillActionExportHold')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    bill_action_export_hold_method.metadata = {'url': '/api/v3/bill/exporthold'}

    def bill_action_delete_method(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Delete given billIDs.

        :param body:
        :type body: ~energycap.sdk.models.BillActionDelete
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BillDeleteActionResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BillDeleteActionResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.bill_action_delete_method.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillActionDelete')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BillDeleteActionResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    bill_action_delete_method.metadata = {'url': '/api/v3/bill/delete'}

    def get_possible_destination_accounts(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves a list of accounts that contain meters of ALL of the
        commodities represented by the given Bills.

        :param body: List of Bill Ids to be used to determine the commodities
         to be matched on the destination accounts.
        :type body: ~energycap.sdk.models.ListIds
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MoveBillsDestination or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.MoveBillsDestination or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_possible_destination_accounts.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListIds')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MoveBillsDestination', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_possible_destination_accounts.metadata = {'url': '/api/v3/bill/possibleDestinationAccounts'}

    def move_bills_to_account(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Moves the list of given bills to the specified destination account and
        meters. Each source Meter will be matched with
        a corresponding destination Meter based on commodity.

        :param body: DTO containing a list of Bill Ids, the destination
         Account Id, the destination AcountMeter Ids, a flag
         indicating whether the Account GL information should be updated, and a
         flag indicating whether the Meter GL information
         should be updated.
        :type body: ~energycap.sdk.models.BillActionMove
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.move_bills_to_account.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillActionMove')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    move_bills_to_account.metadata = {'url': '/api/v3/bill/moveBills'}

    def get_bill_account_meters_actual(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves bill account meter records.

        :param filter: Number of years of data to return includes the current
         year - Defaults to 4
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BillAccountMeterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_account_meters_actual.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[BillAccountMeterResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_bill_account_meters_actual.metadata = {'url': '/api/v3/bill/billaccountmeter/actual'}

    def get_bill_account_meter_actual_by_bill_id(
            self, bill_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves bill account meter record for a specific billId.

        :param bill_id: The bill identifier
        :type bill_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BillAccountMeterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_account_meter_actual_by_bill_id.metadata['url']
        path_format_arguments = {
            'billId': self._serialize.url("bill_id", bill_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[BillAccountMeterResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill_account_meter_actual_by_bill_id.metadata = {'url': '/api/v3/bill/{billId}/billaccountmeter/actual'}

    def get_bill_account_meters_calendarized(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves bill account meter calendarized records.

        :param filter: Number of years of data to return includes the current
         year - Defaults to 4
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BillAccountMeterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_account_meters_calendarized.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[BillAccountMeterResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_bill_account_meters_calendarized.metadata = {'url': '/api/v3/bill/billaccountmeter/calendarized'}

    def get_bill_account_meter_calendarized_by_bill_id(
            self, bill_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves bill account meter calendarized record for a specific billId.

        :param bill_id: The bill identifier
        :type bill_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BillAccountMeterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_account_meter_calendarized_by_bill_id.metadata['url']
        path_format_arguments = {
            'billId': self._serialize.url("bill_id", bill_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[BillAccountMeterResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill_account_meter_calendarized_by_bill_id.metadata = {'url': '/api/v3/bill/{billId}/billaccountmeter/calendarized'}

    def get_bill_account_meters_normalized(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves bill account meter normalized records.

        :param filter: Number of years of data to return includes the current
         year - Defaults to 4
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BillAccountMeterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_account_meters_normalized.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[BillAccountMeterResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_bill_account_meters_normalized.metadata = {'url': '/api/v3/bill/billaccountmeter/normalized'}

    def get_bill_account_meter_normalized_by_bill_id(
            self, bill_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves bill account meter normalized record for a specific billId.

        :param bill_id: The bill identifier
        :type bill_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BillAccountMeterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_account_meter_normalized_by_bill_id.metadata['url']
        path_format_arguments = {
            'billId': self._serialize.url("bill_id", bill_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[BillAccountMeterResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill_account_meter_normalized_by_bill_id.metadata = {'url': '/api/v3/bill/{billId}/billaccountmeter/normalized'}

    def get_bill_account_meters_statistics(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves bill account meter statistics records.

        :param filter: Number of years of data to return includes the current
         year - Defaults to 4
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BillAccountMeterStatisticsResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_account_meters_statistics.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[BillAccountMeterStatisticsResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_bill_account_meters_statistics.metadata = {'url': '/api/v3/bill/billaccountmeter/statistics'}

    def get_bill_account_meter_statistics_by_bill_id(
            self, bill_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves bill account meter statistics record for a specific billId.

        :param bill_id: The bill identifier
        :type bill_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BillAccountMeterStatisticsResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_account_meter_statistics_by_bill_id.metadata['url']
        path_format_arguments = {
            'billId': self._serialize.url("bill_id", bill_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[BillAccountMeterStatisticsResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill_account_meter_statistics_by_bill_id.metadata = {'url': '/api/v3/bill/{billId}/billaccountmeter/statistics'}

    def get_bill_entry_data(
            self, account_id, begin_date=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves all data necessary to load the bill entry screen.

        :param account_id:
        :type account_id: int
        :param begin_date:
        :type begin_date: datetime
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BillEntryResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BillEntryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_entry_data.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if begin_date is not None:
            query_parameters['beginDate'] = self._serialize.query("begin_date", begin_date, 'iso-8601')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BillEntryResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill_entry_data.metadata = {'url': '/api/v3/account/{accountId}/billEntry'}

    def get_account_bill_history(
            self, account_id, billing_period=None, number_of_years=5, include_void=False, include_accrual=False, custom_headers=None, raw=False, **operation_config):
        """Retrieves bill history for an account.

        :param account_id: accountId to get bill history for
        :type account_id: int
        :param billing_period: required: billingPeriod in yyyymm format to
         return history from
        :type billing_period: int
        :param number_of_years: optional: Number of years of history to
         return.  Defaults to 5
        :type number_of_years: int
        :param include_void: optional: Should voided bills be included.
         Defaults to false
        :type include_void: bool
        :param include_accrual: optional: Should accrual bills be included.
         Defaults to false
        :type include_accrual: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BillHistoryResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_account_bill_history.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if billing_period is not None:
            query_parameters['billingPeriod'] = self._serialize.query("billing_period", billing_period, 'int')
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if include_void is not None:
            query_parameters['includeVoid'] = self._serialize.query("include_void", include_void, 'bool')
        if include_accrual is not None:
            query_parameters['includeAccrual'] = self._serialize.query("include_accrual", include_accrual, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[BillHistoryResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_account_bill_history.metadata = {'url': '/api/v3/account/{accountId}/billHistory'}

    def get_bill_entry_data_by_bill_id(
            self, bill_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all data necessary to load the bill entry screen.

        :param bill_id:
        :type bill_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BillEntryResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BillEntryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_entry_data_by_bill_id.metadata['url']
        path_format_arguments = {
            'billId': self._serialize.url("bill_id", bill_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BillEntryResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill_entry_data_by_bill_id.metadata = {'url': '/api/v3/bill/{billId}/billEntry'}

    def get_bill_history(
            self, bill_id, number_of_years=5, include_void=False, include_accrual=False, custom_headers=None, raw=False, **operation_config):
        """Retrieves bill history from starting at the billId billing period.

        :param bill_id: billId to get bill history for
        :type bill_id: int
        :param number_of_years: optional: Number of years of history to
         return.  Defaults to 5
        :type number_of_years: int
        :param include_void: optional: Should voided bills be included.
         Defaults to false
        :type include_void: bool
        :param include_accrual: optional: Should accrual bills be included.
         Defaults to false
        :type include_accrual: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BillHistoryResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_history.metadata['url']
        path_format_arguments = {
            'billId': self._serialize.url("bill_id", bill_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if include_void is not None:
            query_parameters['includeVoid'] = self._serialize.query("include_void", include_void, 'bool')
        if include_accrual is not None:
            query_parameters['includeAccrual'] = self._serialize.query("include_accrual", include_accrual, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[BillHistoryResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill_history.metadata = {'url': '/api/v3/bill/{billId}/billHistory'}

    def export_bills_method(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves text of a standard EnergyCAP bill export file for AP and GL
        purposes.
        Only bills with the following conditions are included in the export
        file:
        1) approved bills (if the approval system is enabled in workflow
        settings)
        2) bill is in a closed batch (if after batch or after batch approval is
        set in the workflow settings)
        3) bill is not held for export
        4) bill is not void
        5) bill is within the user's topmost setting.
        6) bill in not already exported.

        :param body:
        :type body: ~energycap.sdk.models.BillExport
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.export_bills_method.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillExport')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    export_bills_method.metadata = {'url': '/api/v3/bill/export'}

    def unexport_bills(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Marks one or more bills as unexported.

        :param body: An array of bill ids to be marked as unexported and
         export mode
        :type body: ~energycap.sdk.models.BillUnexport
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.unexport_bills.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillUnexport')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    unexport_bills.metadata = {'url': '/api/v3/bill/unexport'}

    def unexport_bills_by_guid(
            self, bill_export_guid, custom_headers=None, raw=False, **operation_config):
        """Marks one or more bills as unexported. The bills to be unexported are
        selected based on the guid passed in.
        The guid is generated when bills are exported via the bill export end
        point, and the guid is returned in the header of the response in a
        field named Ec-Guid.

        :param bill_export_guid: The identifier for the bills to be unexported
        :type bill_export_guid: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.unexport_bills_by_guid.metadata['url']
        path_format_arguments = {
            'billExportGuid': self._serialize.url("bill_export_guid", bill_export_guid, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    unexport_bills_by_guid.metadata = {'url': '/api/v3/bill/unexport/{billExportGuid}'}

    def export_bill_profile(
            self, export_mode="ap", custom_headers=None, raw=False, **operation_config):
        """Retrieves the text of a standard EnergyCAP bill export ini file for AP
        and GL purposes.

        :param export_mode: Specifies whether the profile should be for AP or
         GL. Pass in "AP" for AP Profile, and pass in "GL" for GL Profile. If
         this is not included in the request, it defaults to AP.
        :type export_mode: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.export_bill_profile.metadata['url']

        # Construct parameters
        query_parameters = {}
        if export_mode is not None:
            query_parameters['exportMode'] = self._serialize.query("export_mode", export_mode, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    export_bill_profile.metadata = {'url': '/api/v3/bill/exportProfile'}

    def bill_action_split_method(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Run the bill split processor on the given list of bills.
        Optional note can be provided.
        Optional batch settings can be provided that will allow custom
        batchcode and bill headers for the destination bills.

        :param body:
        :type body: ~energycap.sdk.models.BillActionSplit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChargebackTaskResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChargebackTaskResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.bill_action_split_method.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillActionSplit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChargebackTaskResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    bill_action_split_method.metadata = {'url': '/api/v3/bill/split'}

    def clean_dirty_bills(
            self, custom_headers=None, raw=False, **operation_config):
        """Cleans all dirty bills, and any bills created outside of version 7.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.clean_dirty_bills.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    clean_dirty_bills.metadata = {'url': '/api/v3/bill/cleanBill'}

    def clean_abill(
            self, bill_id, custom_headers=None, raw=False, **operation_config):
        """Cleans a single bill. The dirty flag of the bill is not taken into
        account.

        :param bill_id:
        :type bill_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.clean_abill.metadata['url']
        path_format_arguments = {
            'billId': self._serialize.url("bill_id", bill_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    clean_abill.metadata = {'url': '/api/v3/bill/cleanBill/{billId}'}

    def process_bill_custom_action(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Fires a custom bill action. Custom bill actions are setup as webhooks.

        :param body:
        :type body: ~energycap.sdk.models.BillActionCustom
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: WebhookLogDetailsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.WebhookLogDetailsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.process_bill_custom_action.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillActionCustom')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('WebhookLogDetailsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    process_bill_custom_action.metadata = {'url': '/api/v3/bill/customAction'}

    def reverse_bills(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates reversal bills for the given bill ids.

        :param body:
        :type body: ~energycap.sdk.models.BillReversalRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.reverse_bills.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillReversalRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    reverse_bills.metadata = {'url': '/api/v3/bill/reverse'}

    def set_bill_accrual_exclusion(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Excludes or undoes exclusion of bills from accruals.

        :param body:
        :type body: ~energycap.sdk.models.BillAccrualExclusionRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.set_bill_accrual_exclusion.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillAccrualExclusionRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    set_bill_accrual_exclusion.metadata = {'url': '/api/v3/bill/accrualExclusion'}

    def get_bill_split_versions(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Get a list of bill split versions which match the provided filter
        conditions.

        :param filter: API filter string containing conditions
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.DistributionVersionResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_split_versions.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[DistributionVersionResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_bill_split_versions.metadata = {'url': '/api/v3/billSplit'}

    def get_bill_splits(
            self, account_id, custom_headers=None, raw=False, **operation_config):
        """Get a list of bill split versions on an account.

        :param account_id: ID of the account to get all assigned bill split
         versions
        :type account_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.DistributionVersionResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_splits.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[DistributionVersionResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill_splits.metadata = {'url': '/api/v3/account/{accountId}/billSplit'}

    def get_bill_split_version_history(
            self, account_id, meter_id, custom_headers=None, raw=False, **operation_config):
        """Get a list of bill split versions on this account and meter
        relationship.

        :param account_id: ID of the account to get all assigned bill split
         versions
        :type account_id: int
        :param meter_id: ID of the meter to get all assigned bill split
         versions
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.DistributionVersionResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_split_version_history.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[DistributionVersionResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill_split_version_history.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/billSplit'}

    def manage_bill_split_version_history(
            self, account_id, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Manage a bill split's version history
        All bill split versions to save on this account and meter relationship
        should be passed
        If versionId is passed, this version will be updated to the request
        body values
        If copyVersionId is passed, a new version will be created and all
        instructions and inputs on the copyVersionId will be copied
        If versionId and copyVersionId are null a new version will be created
        Versions cannot overlap
        If a bill split version currently exists in the database, but is not
        passed in it will be deleted
        Only versions that are not currently associated with any bills can be
        deleted
        If any part of the create, update, or delete process fails, the entire
        process is rolled back.

        :param account_id: ID of the account whose bill split versions will be
         updated
        :type account_id: int
        :param meter_id: ID of the meter whose bill split versions will be
         updated
        :type meter_id: int
        :param body: List of bill split distribution versions to add or edit
        :type body: list[~energycap.sdk.models.DistributionVersionManage]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.DistributionVersionResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.manage_bill_split_version_history.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[DistributionVersionManage]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[DistributionVersionResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    manage_bill_split_version_history.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/billSplit'}

    def get_bill_split_details(
            self, account_id, meter_id, version_id, custom_headers=None, raw=False, **operation_config):
        """Get details for a bill split distribution.

        :param account_id: ID of the account
        :type account_id: int
        :param meter_id: ID of the meter
        :type meter_id: int
        :param version_id: ID of the distribution version
        :type version_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BillSplitDetailsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BillSplitDetailsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_split_details.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BillSplitDetailsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill_split_details.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/billSplit/{versionId}'}

    def manage_bill_split_details(
            self, account_id, meter_id, version_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Manage details for a bill split distribution.

        :param account_id: ID of the master account
        :type account_id: int
        :param meter_id: ID of the master meter
        :type meter_id: int
        :param version_id: ID of the version to update bill split details
        :type version_id: int
        :param body: Definition of details for bill split
        :type body: ~energycap.sdk.models.BillSplitDetailsRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BillSplitDetailsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BillSplitDetailsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.manage_bill_split_details.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillSplitDetailsRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BillSplitDetailsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    manage_bill_split_details.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/billSplit/{versionId}'}

    def get_bill_split_chargeback_task_by_version(
            self, account_id, meter_id, version_id, custom_headers=None, raw=False, **operation_config):
        """Get all chargeback tasks with details for a specific version on an
        account and meter.

        :param account_id: ID of the account
        :type account_id: int
        :param meter_id: ID of the meter
        :type meter_id: int
        :param version_id: ID of the distribution version
        :type version_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.ChargebackTaskVersionResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_split_chargeback_task_by_version.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ChargebackTaskVersionResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill_split_chargeback_task_by_version.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/billSplit/{versionId}/chargebackTask'}

    def get_account_bill_split_parent_details(
            self, account_id, custom_headers=None, raw=False, **operation_config):
        """Get bill split parent information for an account.

        :param account_id: ID of the account
        :type account_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BillSplitParentDetailsResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_account_bill_split_parent_details.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[BillSplitParentDetailsResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_account_bill_split_parent_details.metadata = {'url': '/api/v3/account/{accountId}/billSplit/parent'}

    def get_meter_bill_split_parent_details(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Get bill split parent information for a meter.

        :param meter_id: ID of the meter
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BillSplitParentDetailsResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_bill_split_parent_details.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[BillSplitParentDetailsResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_bill_split_parent_details.metadata = {'url': '/api/v3/meter/{meterId}/billSplit/parent'}

    def get_bill_view(
            self, bill_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves properties for bill view.

        :param bill_id: The bill identifier
        :type bill_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BillViewResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BillViewResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_view.metadata['url']
        path_format_arguments = {
            'billId': self._serialize.url("bill_id", bill_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BillViewResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill_view.metadata = {'url': '/api/v3/billView/{billId}'}

    def get_calculated_bill_versions(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Get a list of calculated bill versions which match the provided filter
        conditions.

        :param filter: API filter string containing conditions
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.DistributionVersionResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_calculated_bill_versions.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[DistributionVersionResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_calculated_bill_versions.metadata = {'url': '/api/v3/calculatedBill'}

    def get_calculated_bills(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Get a list of calculated bill versions on a meter.

        :param meter_id: ID of the meter to get all assigned calculated bill
         versions
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.DistributionVersionResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_calculated_bills.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[DistributionVersionResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_calculated_bills.metadata = {'url': '/api/v3/meter/{meterId}/calculatedBill'}

    def get_calculated_bill_version_history(
            self, account_id, meter_id, custom_headers=None, raw=False, **operation_config):
        """Get a list of calculated bill versions on this account and meter
        relationship.

        :param account_id: ID of the account to get all assigned calculated
         bill versions
        :type account_id: int
        :param meter_id: ID of the meter to get all assigned calculated bill
         versions
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.DistributionVersionResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_calculated_bill_version_history.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[DistributionVersionResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_calculated_bill_version_history.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/calculatedBill'}

    def manage_calculated_bill_version_history(
            self, account_id, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Manage a calculated bill's version history
        All calculated bill versions to save on this account and meter
        relationship should be passed
        If versionId is passed, this version will be updated to the request
        body values
        If copyVersionId is passed, a new version will be created and all
        instructions and inputs on the copyVersionId will be copied
        If versionId and copyVersionId are null a new version will be created
        Versions cannot overlap
        If a calculated bill version currently exists in the database, but is
        not passed in it will be deleted
        Only versions that are not currently associated with any bills can be
        deleted
        If any part of the create, update, or delete process fails, the entire
        process is rolled back.

        :param account_id: ID of the account to receive calculated bill
         details
        :type account_id: int
        :param meter_id: ID of the meter to receive calculated bill details
        :type meter_id: int
        :param body: List of calculated bill distribution versions to add or
         edit
        :type body: list[~energycap.sdk.models.DistributionVersionManage]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.DistributionVersionResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.manage_calculated_bill_version_history.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[DistributionVersionManage]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[DistributionVersionResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    manage_calculated_bill_version_history.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/calculatedBill'}

    def get_calculate_bill_details(
            self, account_id, meter_id, version_id, custom_headers=None, raw=False, **operation_config):
        """All details related to calculated bill setup including use, cost, meter
        line items, and account line items.

        :param account_id: ID of the account to receive calculated bill
         details
        :type account_id: int
        :param meter_id: ID of the meter to receive calculated bill details
        :type meter_id: int
        :param version_id: ID of the calculated bill distribution version
        :type version_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CalculatedBillDetailsResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.CalculatedBillDetailsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_calculate_bill_details.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CalculatedBillDetailsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_calculate_bill_details.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/calculatedBill/{versionId}'}

    def manage_calculate_bill_use(
            self, account_id, meter_id, version_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Manage calculated bill's use
        * If use does not exist on the distribution it will be added
        * If use already exists it will be saved as the option sent in and any
        existing inputs will be deleted
        * Since use is required for the calculated bill distribution to work,
        one option is always required and cannot be deleted.

        :param account_id: ID of the account to receive calculated bill
         details
        :type account_id: int
        :param meter_id: ID of the meter to receive calculated bill details
        :type meter_id: int
        :param version_id: ID of the calculated bill distribution version
        :type version_id: int
        :param body: Definition of how the meter will calculate its use
        :type body: ~energycap.sdk.models.CalculatedBillUseRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CalculatedBillUseResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.CalculatedBillUseResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.manage_calculate_bill_use.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'CalculatedBillUseRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CalculatedBillUseResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    manage_calculate_bill_use.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/calculatedBill/{versionId}/use'}

    def get_calculate_bill_use(
            self, account_id, meter_id, version_id, custom_headers=None, raw=False, **operation_config):
        """Get calculated use details.

        :param account_id: ID of the account to receive calculated bill
         details
        :type account_id: int
        :param meter_id: ID of the meter to receive calculated bill details
        :type meter_id: int
        :param version_id: ID of the calculated bill distribution version
        :type version_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CalculatedBillUseResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.CalculatedBillUseResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_calculate_bill_use.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CalculatedBillUseResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_calculate_bill_use.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/calculatedBill/{versionId}/use'}

    def manage_calculate_bill_cost(
            self, account_id, meter_id, version_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Manage calculated bill's cost
        If cost does not exist on the distribution it will be added
        If one exists it will be saved as the option sent in
        Since cost is required for the calculated bill distribution to work.
        One option is always required and cannot be deleted.

        :param account_id: ID of the account to receive calculated bill
         details
        :type account_id: int
        :param meter_id: ID of the meter to receive calculated bill details
        :type meter_id: int
        :param version_id: ID of the calculated bill distribution version
        :type version_id: int
        :param body: Definition of how the meter will calculate its cost
        :type body: ~energycap.sdk.models.CalculatedBillCostRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CalculatedBillCostResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.CalculatedBillCostResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.manage_calculate_bill_cost.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'CalculatedBillCostRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CalculatedBillCostResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    manage_calculate_bill_cost.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/calculatedBill/{versionId}/cost'}

    def get_calculate_bill_cost(
            self, account_id, meter_id, version_id, custom_headers=None, raw=False, **operation_config):
        """Get calculated cost details.

        :param account_id: ID of the account to receive calculated bill
         details
        :type account_id: int
        :param meter_id: ID of the meter to receive calculated bill details
        :type meter_id: int
        :param version_id: ID of the calculated bill distribution version
        :type version_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CalculatedBillCostResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.CalculatedBillCostResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_calculate_bill_cost.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CalculatedBillCostResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_calculate_bill_cost.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/calculatedBill/{versionId}/cost'}

    def manage_calculate_bill_demand(
            self, account_id, meter_id, version_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Manage calculated bill's demand
        If demand does not exist on the distribution it will be added
        If one exists it will be saved as the option sent in
        If the dto sends null for both (channel and fixed), then demand will
        get cleared.

        :param account_id: ID of the account to receive calculated bill
         details
        :type account_id: int
        :param meter_id: ID of the meter to receive calculated bill details
        :type meter_id: int
        :param version_id: ID of the calculated bill distribution version
        :type version_id: int
        :param body: Definition of how the meter will calculate its demand
        :type body: ~energycap.sdk.models.CalculatedBillDemandRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CalculatedBillDemandResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.CalculatedBillDemandResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.manage_calculate_bill_demand.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'CalculatedBillDemandRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CalculatedBillDemandResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    manage_calculate_bill_demand.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/calculatedBill/{versionId}/demand'}

    def get_calculate_bill_demand(
            self, account_id, meter_id, version_id, custom_headers=None, raw=False, **operation_config):
        """Get calculated demand details.

        :param account_id: ID of the account to receive calculated bill
         details
        :type account_id: int
        :param meter_id: ID of the meter to receive calculated bill details
        :type meter_id: int
        :param version_id: ID of the calculated bill distribution version
        :type version_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CalculatedBillDemandResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.CalculatedBillDemandResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_calculate_bill_demand.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CalculatedBillDemandResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_calculate_bill_demand.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/calculatedBill/{versionId}/demand'}

    def manage_meter_line_items(
            self, account_id, meter_id, version_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Manage calculated bill meter line items
        The order of items in the list defines the calculation order
        All line items to save should be passed
        If a line currently exists and is not passed in it will be deleted
        If any part of the create, update, or delete process fails, the entire
        process is rolled back.

        :param account_id: ID of the account to receive calculated bill
         details
        :type account_id: int
        :param meter_id: ID of the meter to receive calculated bill details
        :type meter_id: int
        :param version_id: ID of the calculated bill distribution version
        :type version_id: int
        :param body: Definition of the meter line items
        :type body: list[~energycap.sdk.models.GenericBodylineRequest]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.GenericBodylineResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.manage_meter_line_items.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[GenericBodylineRequest]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GenericBodylineResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    manage_meter_line_items.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/calculatedBill/{versionId}/meterLineItem'}

    def get_meter_line_items(
            self, account_id, meter_id, version_id, custom_headers=None, raw=False, **operation_config):
        """Get calculated bill meter line items.

        :param account_id: ID of the account to receive calculated bill
         details
        :type account_id: int
        :param meter_id: ID of the meter to receive calculated bill details
        :type meter_id: int
        :param version_id: ID of the calculated bill distribution version
        :type version_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.GenericBodylineResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_line_items.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GenericBodylineResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_line_items.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/calculatedBill/{versionId}/meterLineItem'}

    def manage_account_line_items(
            self, account_id, meter_id, version_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Manage calculated bill account line items
        The order of items in the list defines the calculation order
        All line items to save should be passed
        If a line currently exists and is not passed in it will be deleted
        If any part of the create, update, or delete process fails, the entire
        process is rolled back.

        :param account_id: ID of the account to receive calculated bill
         details
        :type account_id: int
        :param meter_id: ID of the meter to receive calculated bill details
        :type meter_id: int
        :param version_id: ID of the calculated bill distribution version
        :type version_id: int
        :param body: Definition of the account line items.
        :type body: list[~energycap.sdk.models.GenericBodylineRequest]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.GenericBodylineResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.manage_account_line_items.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[GenericBodylineRequest]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GenericBodylineResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    manage_account_line_items.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/calculatedBill/{versionId}/accountLineItem'}

    def get_account_line_items(
            self, account_id, meter_id, version_id, custom_headers=None, raw=False, **operation_config):
        """Get calculated bill account line items.

        :param account_id: ID of the account to receive calculated bill
         details
        :type account_id: int
        :param meter_id: ID of the meter to receive calculated bill details
        :type meter_id: int
        :param version_id: ID of the calculated bill distribution version
        :type version_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.GenericBodylineResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_account_line_items.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GenericBodylineResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_account_line_items.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/calculatedBill/{versionId}/accountLineItem'}

    def get_calculated_bill_chargeback_task_by_version(
            self, account_id, meter_id, version_id, custom_headers=None, raw=False, **operation_config):
        """Get all chargeback tasks with details for a specific version on an
        account and meter.

        :param account_id: ID of the account
        :type account_id: int
        :param meter_id: ID of the meter
        :type meter_id: int
        :param version_id: ID of the distribution version
        :type version_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.ChargebackTaskVersionResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_calculated_bill_chargeback_task_by_version.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ChargebackTaskVersionResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_calculated_bill_chargeback_task_by_version.metadata = {'url': '/api/v3/account/{accountId}/meter/{meterId}/calculatedBill/{versionId}/chargebackTask'}

    def recalculate_chargeback_flags(
            self, custom_headers=None, raw=False, **operation_config):
        """Forces all Account and Meter Chargeback flags in the system to be
        recalculated.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.recalculate_chargeback_flags.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    recalculate_chargeback_flags.metadata = {'url': '/api/v3/recalculateChargebackFlags'}

    def get_meter_channels(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all channel and channel versions linked to a meter.

        :param meter_id: Id of the meter to retrieve the channel information
         for
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.ChannelResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_channels.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ChannelResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_channels.metadata = {'url': '/api/v202101/meter/{meterId}/channel'}

    def create_meter_channel(
            self, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates and assigns a channel to a meter.

        :param meter_id: Id of the meter to link the channel to
        :type meter_id: int
        :param body: Data representing the channel being created
        :type body: ~energycap.sdk.models.ChannelCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChannelResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChannelResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_meter_channel.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ChannelCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChannelResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_meter_channel.metadata = {'url': '/api/v202101/meter/{meterId}/channel'}

    def get_meter_channel(
            self, meter_id, channel_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves a channel and its channel versions linked to a meter.

        :param meter_id: Id of the linked meter to retrieve the channel
         information for
        :type meter_id: int
        :param channel_id: Id of the channel to retrieve information for
        :type channel_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChannelResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChannelResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_channel.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'channelId': self._serialize.url("channel_id", channel_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChannelResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_channel.metadata = {'url': '/api/v202101/meter/{meterId}/channel/{channelId}'}

    def edit_meter_channel(
            self, meter_id, channel_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Updates a meter's channel
        If a channel version exists and is not passed into the request body it
        will continue to exist and no data will be changed.
        To delete a specific channel version call DELETE
        meter/{meterId}/channel/{channelId}/version/{versionId}.

        :param meter_id: Id of the meter the channel is linked to
        :type meter_id: int
        :param channel_id: Id of the channel to update
        :type channel_id: int
        :param body:
        :type body: ~energycap.sdk.models.ChannelEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChannelResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChannelResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_meter_channel.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'channelId': self._serialize.url("channel_id", channel_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ChannelEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChannelResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_meter_channel.metadata = {'url': '/api/v202101/meter/{meterId}/channel/{channelId}'}

    def delete_meter_channel(
            self, meter_id, channel_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a meter's channel
        All readings linked to this channel will also be deleted.
        A channel that is part of a distribution cannot be deleted.

        :param meter_id: Id of the meter the channel is linked to
        :type meter_id: int
        :param channel_id: Id of the channel to delete
        :type channel_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_meter_channel.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'channelId': self._serialize.url("channel_id", channel_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_meter_channel.metadata = {'url': '/api/v202101/meter/{meterId}/channel/{channelId}'}

    def create_channel_version(
            self, meter_id, channel_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a new channel version.

        :param meter_id: Id of the meter the channel is linked to
        :type meter_id: int
        :param channel_id: Id of the channel to add the version to
        :type channel_id: int
        :param body:
        :type body: ~energycap.sdk.models.ChannelVersionWithBeginDateRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChannelResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChannelResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_channel_version.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'channelId': self._serialize.url("channel_id", channel_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ChannelVersionWithBeginDateRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChannelResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_channel_version.metadata = {'url': '/api/v202101/meter/{meterId}/channel/{channelId}/version'}

    def edit_channel_version(
            self, meter_id, channel_id, version_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Update a channel version.

        :param meter_id: Id of the meter the channel is linked to
        :type meter_id: int
        :param channel_id: Id of the channel the version is linked to
        :type channel_id: int
        :param version_id: Id of the channel version to update
        :type version_id: int
        :param body:
        :type body: ~energycap.sdk.models.ChannelVersionWithBeginDateRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChannelResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChannelResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_channel_version.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'channelId': self._serialize.url("channel_id", channel_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ChannelVersionWithBeginDateRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChannelResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_channel_version.metadata = {'url': '/api/v202101/meter/{meterId}/channel/{channelId}/version/{versionId}'}

    def delete_channel_version(
            self, meter_id, channel_id, version_id, custom_headers=None, raw=False, **operation_config):
        """Delete a channel version
        There must always be one version on a channel
        If you try and delete the only version on a channel an exception will
        occur.

        :param meter_id: Id of the meter the channel is linked to
        :type meter_id: int
        :param channel_id: Id of the channel the version is linked to
        :type channel_id: int
        :param version_id: Id of the channel version to delete
        :type version_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_channel_version.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'channelId': self._serialize.url("channel_id", channel_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_channel_version.metadata = {'url': '/api/v202101/meter/{meterId}/channel/{channelId}/version/{versionId}'}

    def execute_bill_split_processor(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Process one or more Bill Split distributions for a specific billing
        period.

        :param body:
        :type body: ~energycap.sdk.models.ChargebackProcessorSettings
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChargebackTaskResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChargebackTaskResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.execute_bill_split_processor.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ChargebackProcessorSettings')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChargebackTaskResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    execute_bill_split_processor.metadata = {'url': '/api/v3/billSplit/exec'}

    def execute_calculate_bill_processor(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Process one or more Calculated Bill distributions for a specific
        billing period.

        :param body:
        :type body: ~energycap.sdk.models.ChargebackProcessorSettings
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChargebackTaskResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChargebackTaskResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.execute_calculate_bill_processor.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ChargebackProcessorSettings')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChargebackTaskResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    execute_calculate_bill_processor.metadata = {'url': '/api/v3/calculatedBill/exec'}

    def execute_processor_by_workflow_step(
            self, chargeback_workflow_step_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Process distributions assigned to a chargeback workflow step for a
        specific billing period.

        :param chargeback_workflow_step_id: The chargeback workflow step id.
        :type chargeback_workflow_step_id: int
        :param body: The other processor settings.
        :type body:
         ~energycap.sdk.models.ChargebackProcessorSettingsWithoutFilters
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChargebackTaskResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChargebackTaskResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.execute_processor_by_workflow_step.metadata['url']
        path_format_arguments = {
            'chargebackWorkflowStepId': self._serialize.url("chargeback_workflow_step_id", chargeback_workflow_step_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ChargebackProcessorSettingsWithoutFilters')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChargebackTaskResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    execute_processor_by_workflow_step.metadata = {'url': '/api/v3/chargebackWorkflowStep/{chargebackWorkflowStepId}/exec'}

    def void_chargeback_task(
            self, task_id, custom_headers=None, raw=False, **operation_config):
        """Void all bills created by the chargeback task
        If this is a split task, any source bills will be reset to has not been
        split
        If any bills have already been exported they will still be voided.

        :param task_id: Identifier for the chargeback task
        :type task_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.void_chargeback_task.metadata['url']
        path_format_arguments = {
            'taskId': self._serialize.url("task_id", task_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    void_chargeback_task.metadata = {'url': '/api/v3/chargebackTask/{taskId}/void'}

    def delete_chargeback_task(
            self, task_id, custom_headers=None, raw=False, **operation_config):
        """Delete all bills created by the chargeback task
        If this is a split task, any source bills will be reset to has not been
        split
        If any bills have already been exported they will still be deleted.

        :param task_id: Identifier for the chargeback task
        :type task_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_chargeback_task.metadata['url']
        path_format_arguments = {
            'taskId': self._serialize.url("task_id", task_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_chargeback_task.metadata = {'url': '/api/v3/chargebackTask/{taskId}/delete'}

    def get_chargeback_tasks(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Get all chargeback tasks with details.

        :param filter: Filters to apply
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.ChargebackTaskResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_chargeback_tasks.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[ChargebackTaskResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_chargeback_tasks.metadata = {'url': '/api/v3/chargebackTask'}

    def update_chargeback_task(
            self, task_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Update a chargeback task's comment.

        :param task_id: Identifier for the chargeback task to update
        :type task_id: int
        :param body: Data representing the comment
        :type body: ~energycap.sdk.models.ChargebackTaskRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChargebackTaskResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChargebackTaskResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_chargeback_task.metadata['url']
        path_format_arguments = {
            'taskId': self._serialize.url("task_id", task_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ChargebackTaskRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChargebackTaskResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    update_chargeback_task.metadata = {'url': '/api/v3/chargebackTask/{taskId}'}

    def get_chargeback_task(
            self, task_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves a chargeback task with details.

        :param task_id: Identifier for the chargeback task
        :type task_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChargebackTaskResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChargebackTaskResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_chargeback_task.metadata['url']
        path_format_arguments = {
            'taskId': self._serialize.url("task_id", task_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChargebackTaskResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_chargeback_task.metadata = {'url': '/api/v3/chargebackTask/{taskId}'}

    def get_chargeback_task_error_file(
            self, task_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves a chargeback task's error log as an EXCEL file.

        :param task_id: Identifier for the chargeback task
        :type task_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_chargeback_task_error_file.metadata['url']
        path_format_arguments = {
            'taskId': self._serialize.url("task_id", task_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    get_chargeback_task_error_file.metadata = {'url': '/api/v3/chargebackTask/{taskId}/errorOutput'}

    def get_chargeback_workflows(
            self, custom_headers=None, raw=False, **operation_config):
        """Get a list of chargeback workflows.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.ChargebackWorkflowResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_chargeback_workflows.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ChargebackWorkflowResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_chargeback_workflows.metadata = {'url': '/api/v3/chargebackWorkflow'}

    def create_chargeback_workflow(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a chargeback workflow.

        :param body: Definition for chargeback workflow
        :type body: ~energycap.sdk.models.ChargebackWorkflowCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChargebackWorkflowResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChargebackWorkflowResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_chargeback_workflow.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ChargebackWorkflowCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChargebackWorkflowResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_chargeback_workflow.metadata = {'url': '/api/v3/chargebackWorkflow'}

    def get_chargeback_workflow(
            self, chargeback_workflow_id, custom_headers=None, raw=False, **operation_config):
        """Get a chargeback workflow.

        :param chargeback_workflow_id: Chargeback workflow id
        :type chargeback_workflow_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChargebackWorkflowResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChargebackWorkflowResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_chargeback_workflow.metadata['url']
        path_format_arguments = {
            'chargebackWorkflowId': self._serialize.url("chargeback_workflow_id", chargeback_workflow_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChargebackWorkflowResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_chargeback_workflow.metadata = {'url': '/api/v3/chargebackWorkflow/{chargebackWorkflowId}'}

    def edit_chargeback_workflow(
            self, chargeback_workflow_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit a chargeback workflow.

        :param chargeback_workflow_id: Chargeback workflow id
        :type chargeback_workflow_id: int
        :param body: Definition for chargeback workflow
        :type body: ~energycap.sdk.models.ChargebackWorkflowEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChargebackWorkflowResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChargebackWorkflowResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_chargeback_workflow.metadata['url']
        path_format_arguments = {
            'chargebackWorkflowId': self._serialize.url("chargeback_workflow_id", chargeback_workflow_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ChargebackWorkflowEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChargebackWorkflowResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_chargeback_workflow.metadata = {'url': '/api/v3/chargebackWorkflow/{chargebackWorkflowId}'}

    def delete_chargeback_workflow(
            self, chargeback_workflow_id, custom_headers=None, raw=False, **operation_config):
        """Delete a chargeback workflow.

        :param chargeback_workflow_id: Chargeback workflow id
        :type chargeback_workflow_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_chargeback_workflow.metadata['url']
        path_format_arguments = {
            'chargebackWorkflowId': self._serialize.url("chargeback_workflow_id", chargeback_workflow_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_chargeback_workflow.metadata = {'url': '/api/v3/chargebackWorkflow/{chargebackWorkflowId}'}

    def get_chargeback_workflow_steps(
            self, chargeback_workflow_type=None, custom_headers=None, raw=False, **operation_config):
        """Get a list of chargeback workflow steps.

        :param chargeback_workflow_type: Pass either "split" or "calculation"
         to filter workflow steps
        :type chargeback_workflow_type: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.ChargebackWorkflowStepChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_chargeback_workflow_steps.metadata['url']

        # Construct parameters
        query_parameters = {}
        if chargeback_workflow_type is not None:
            query_parameters['chargebackWorkflowType'] = self._serialize.query("chargeback_workflow_type", chargeback_workflow_type, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ChargebackWorkflowStepChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_chargeback_workflow_steps.metadata = {'url': '/api/v3/chargebackWorkflowStep'}

    def get_chargeback_workflow_step(
            self, chargeback_workflow_step_id, custom_headers=None, raw=False, **operation_config):
        """Get a single chargeback workflow step.

        :param chargeback_workflow_step_id: Workflow step ID
        :type chargeback_workflow_step_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChargebackWorkflowStepChild or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChargebackWorkflowStepChild or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_chargeback_workflow_step.metadata['url']
        path_format_arguments = {
            'chargebackWorkflowStepId': self._serialize.url("chargeback_workflow_step_id", chargeback_workflow_step_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChargebackWorkflowStepChild', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_chargeback_workflow_step.metadata = {'url': '/api/v3/chargebackWorkflowStep/{chargebackWorkflowStepId}'}

    def assign_versions_to_step_method(
            self, chargeback_workflow_step_id, billing_period, body=None, custom_headers=None, raw=False, **operation_config):
        """Assign a list of bill split or calculate bill versions to a chargeback
        workflow step of the same type.

        :param chargeback_workflow_step_id: ID of the chargeback workflow step
         to which the versions will be assigned
        :type chargeback_workflow_step_id: int
        :param billing_period: The billing period to validate that the
         provided versions are effective
        :type billing_period: int
        :param body: The chargeback versions to assign to the provided
         chargeback workflow step
        :type body: ~energycap.sdk.models.AssignVersionsToStep
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChargebackWorkflowStepChild or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChargebackWorkflowStepChild or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.assign_versions_to_step_method.metadata['url']
        path_format_arguments = {
            'chargebackWorkflowStepId': self._serialize.url("chargeback_workflow_step_id", chargeback_workflow_step_id, 'int'),
            'billingPeriod': self._serialize.url("billing_period", billing_period, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'AssignVersionsToStep')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChargebackWorkflowStepChild', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    assign_versions_to_step_method.metadata = {'url': '/api/v3/chargebackWorkflowStep/{chargebackWorkflowStepId}/billingPeriod/{billingPeriod}/version'}

    def void_chargeback_workflow_steps(
            self, chargeback_workflow_step_id, billing_period=None, custom_headers=None, raw=False, **operation_config):
        """Void all bills created by a chargeback workflow step for a particular
        billing period
        If this workflow step was run multiple times, all bills created across
        all runs for the billing period will be voided
        If this is a split step, any source bills will be reset to has not been
        split
        If any bills have already been exported they will still be voided.

        :param chargeback_workflow_step_id: Chargeback Workflow Step ID
        :type chargeback_workflow_step_id: int
        :param billing_period: Billing period to undo
        :type billing_period: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.void_chargeback_workflow_steps.metadata['url']
        path_format_arguments = {
            'chargebackWorkflowStepId': self._serialize.url("chargeback_workflow_step_id", chargeback_workflow_step_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if billing_period is not None:
            query_parameters['billingPeriod'] = self._serialize.query("billing_period", billing_period, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    void_chargeback_workflow_steps.metadata = {'url': '/api/v3/chargebackWorkflowStep/{chargebackWorkflowStepId}/void'}

    def delete_chargeback_workflow_steps(
            self, chargeback_workflow_step_id, billing_period=None, custom_headers=None, raw=False, **operation_config):
        """Delete all bills created by a chargeback workflow step
        If this workflow step was run multiple times, all bills created across
        all runs for the billing period will be voided
        If this is a split step, any source bills will be reset to has not been
        split
        If any bills have already been exported they will still be deleted.

        :param chargeback_workflow_step_id: Chargeback Workflow Step ID
        :type chargeback_workflow_step_id: int
        :param billing_period: Billing period to undo
        :type billing_period: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_chargeback_workflow_steps.metadata['url']
        path_format_arguments = {
            'chargebackWorkflowStepId': self._serialize.url("chargeback_workflow_step_id", chargeback_workflow_step_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if billing_period is not None:
            query_parameters['billingPeriod'] = self._serialize.query("billing_period", billing_period, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_chargeback_workflow_steps.metadata = {'url': '/api/v3/chargebackWorkflowStep/{chargebackWorkflowStepId}/delete'}

    def get_chargeback_workflow_digest(
            self, chargeback_workflow_step_id, billing_period=None, custom_headers=None, raw=False, **operation_config):
        """Get a digest of all bills by meter for all meters involved in a
        chargeback workflow step for a given billing period.

        :param chargeback_workflow_step_id: The id of the chargeback workflow
         step.
        :type chargeback_workflow_step_id: int
        :param billing_period: The billing period of the digest.
        :type billing_period: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChargebackWorkflowDigestResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.ChargebackWorkflowDigestResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_chargeback_workflow_digest.metadata['url']
        path_format_arguments = {
            'chargebackWorkflowStepId': self._serialize.url("chargeback_workflow_step_id", chargeback_workflow_step_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if billing_period is not None:
            query_parameters['billingPeriod'] = self._serialize.query("billing_period", billing_period, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChargebackWorkflowDigestResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_chargeback_workflow_digest.metadata = {'url': '/api/v3/chargebackWorkflow/{chargebackWorkflowStepId}/digest'}

    def get_units_by_commodity(
            self, commodity_id, class_code="", noun_code="", unit_type_code="", custom_headers=None, raw=False, **operation_config):
        """Returns a list of units by a specific commodity.

        :param commodity_id: The specific commodity ID
        :type commodity_id: int
        :param class_code: (Optional) A grouping of classes for the units.
         Valid values are 'use', 'cost', 'demand'.
        :type class_code: str
        :param noun_code: (Optional) A specific class for units
        :type noun_code: str
        :param unit_type_code: (Optional) A specific unity type
        :type unit_type_code: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.UnitChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_units_by_commodity.metadata['url']
        path_format_arguments = {
            'commodityId': self._serialize.url("commodity_id", commodity_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if class_code is not None:
            query_parameters['classCode'] = self._serialize.query("class_code", class_code, 'str')
        if noun_code is not None:
            query_parameters['nounCode'] = self._serialize.query("noun_code", noun_code, 'str')
        if unit_type_code is not None:
            query_parameters['unitTypeCode'] = self._serialize.query("unit_type_code", unit_type_code, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UnitChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_units_by_commodity.metadata = {'url': '/api/v3/commodity/{commodityId}/unit'}

    def get_commodities(
            self, custom_headers=None, raw=False, **operation_config):
        """Returns a list of commodities available with their common units and if
        they are currently in use.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.Commodity] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_commodities.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[Commodity]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_commodities.metadata = {'url': '/api/v3/commodity'}

    def get_commodity(
            self, commodity_id, custom_headers=None, raw=False, **operation_config):
        """Returns a commodity with its common units and if it is currently in
        use.

        :param commodity_id: The specific commodity ID
        :type commodity_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Commodity or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.Commodity or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_commodity.metadata['url']
        path_format_arguments = {
            'commodityId': self._serialize.url("commodity_id", commodity_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Commodity', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_commodity.metadata = {'url': '/api/v3/commodity/{commodityId}'}

    def get_commodity_actual_yearly(
            self, commodity_id, number_of_years=4, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data by commodities for a given
        number of years- Result includes cost, use, unit cost on an yearly
        basis.

        :param commodity_id: The commodity to retrieve data for
        :type commodity_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CommodityDigestActualYearlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.CommodityDigestActualYearlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_commodity_actual_yearly.metadata['url']
        path_format_arguments = {
            'commodityId': self._serialize.url("commodity_id", commodity_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CommodityDigestActualYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_commodity_actual_yearly.metadata = {'url': '/api/v3/commodity/{commodityId}/digest/actual/yearly'}

    def get_cost_centers(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves all the cost centers.

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.CostCenterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_cost_centers.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[CostCenterResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_cost_centers.metadata = {'url': '/api/v3/costcenter'}

    def create_cost_center(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates a Cost Center.

        :param body: Date representing the cost center being created
        :type body: ~energycap.sdk.models.CostCenterCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CostCenterResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.CostCenterResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_cost_center.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'CostCenterCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CostCenterResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_cost_center.metadata = {'url': '/api/v3/costcenter'}

    def get_cost_center(
            self, cost_center_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves the cost center by ID.

        :param cost_center_id: The identifier for the cost center being
         retrieved
        :type cost_center_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CostCenterResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.CostCenterResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_cost_center.metadata['url']
        path_format_arguments = {
            'costCenterId': self._serialize.url("cost_center_id", cost_center_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CostCenterResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_cost_center.metadata = {'url': '/api/v3/costcenter/{costCenterId}'}

    def edit_cost_center(
            self, cost_center_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits a cost center.

        :param cost_center_id: The identifier for the cost center being edited
        :type cost_center_id: int
        :param body: Data representing the cost center being edited
        :type body: ~energycap.sdk.models.CostCenterCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CostCenterResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.CostCenterResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_cost_center.metadata['url']
        path_format_arguments = {
            'costCenterId': self._serialize.url("cost_center_id", cost_center_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'CostCenterCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CostCenterResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_cost_center.metadata = {'url': '/api/v3/costcenter/{costCenterId}'}

    def delete_cost_center(
            self, cost_center_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a cost center.

        :param cost_center_id: The identifier for the cost center being
         deleted
        :type cost_center_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_cost_center.metadata['url']
        path_format_arguments = {
            'costCenterId': self._serialize.url("cost_center_id", cost_center_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_cost_center.metadata = {'url': '/api/v3/costcenter/{costCenterId}'}

    def move_cost_center(
            self, parent_cost_center_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Move list of costCenters to be under parentCostCenterId.

        :param parent_cost_center_id: The identifier for the new parent
         costCenter
        :type parent_cost_center_id: int
        :param body: List of costCenterIds to move under the
         parentCostCenterId
        :type body: list[int]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.move_cost_center.metadata['url']
        path_format_arguments = {
            'parentCostCenterId': self._serialize.url("parent_cost_center_id", parent_cost_center_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[int]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    move_cost_center.metadata = {'url': '/api/v3/parentCostCenter/{parentCostCenterId}/costCenter'}

    def get_cost_center_actual_yearly_list(
            self, number_of_years=4, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data by costCenter for a given
        number of years- Result includes cost, use, unit cost on an yearly
        basis. It also includes commodity level break up.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.CostCenterDigestActualYearlyResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_cost_center_actual_yearly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[CostCenterDigestActualYearlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_cost_center_actual_yearly_list.metadata = {'url': '/api/v3/costCenter/digest/actual/yearly'}

    def get_cost_center_actual_yearly(
            self, cost_center_id, number_of_years=4, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data by costCenter for a given
        number of years- Result includes cost, use, unit cost on an yearly
        basis. It also includes commodity level break up.

        :param cost_center_id: The costCenter to retrieve data for
        :type cost_center_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CostCenterDigestActualYearlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.CostCenterDigestActualYearlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_cost_center_actual_yearly.metadata['url']
        path_format_arguments = {
            'costCenterId': self._serialize.url("cost_center_id", cost_center_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('CostCenterDigestActualYearlyResponse', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_cost_center_actual_yearly.metadata = {'url': '/api/v3/costCenter/{costCenterId}/digest/actual/yearly'}

    def get_cost_center_actual_monthly_list(
            self, number_of_years=2, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data by costCenter for a given
        number of years- Result includes cost, use, unit cost on a monthly
        basis. It also includes commodity level break up.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 24 months
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.CostCenterDigestActualMonthlyResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_cost_center_actual_monthly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[CostCenterDigestActualMonthlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_cost_center_actual_monthly_list.metadata = {'url': '/api/v3/costCenter/digest/actual/monthly'}

    def get_cost_center_actual_monthly(
            self, cost_center_id, number_of_years=2, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data by costCenter for a given
        number of years- Result includes cost, use, unit cost on a monthly
        basis. It also includes commodity level break up.

        :param cost_center_id: The costCenter to retrieve data for
        :type cost_center_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 24 months
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CostCenterDigestActualMonthlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.CostCenterDigestActualMonthlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_cost_center_actual_monthly.metadata['url']
        path_format_arguments = {
            'costCenterId': self._serialize.url("cost_center_id", cost_center_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CostCenterDigestActualMonthlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_cost_center_actual_monthly.metadata = {'url': '/api/v3/costCenter/{costCenterId}/digest/actual/monthly'}

    def get_countries(
            self, custom_headers=None, raw=False, **operation_config):
        """Retrieves a list of all possible countries.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.Country] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_countries.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[Country]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_countries.metadata = {'url': '/api/v3/country'}

    def get_customers(
            self, filter=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves an array of customers.

        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.CustomerResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_customers.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[CustomerResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_customers.metadata = {'url': '/api/v3/customer'}

    def get_dashboards(
            self, filter=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves an array of dashboards. The array of dashboards can be
        filtered by a number of criteria. See the filter property for more
        details
        For a dashboard to be returned you must have created the dashboard
        or have DashboardAdministrator Manage permission and the dashboard is
        shared at all
        or have DashboardAdministrator Manage permission and the dashboard is
        public
        or have SharedDashboardsOrMaps View permission and the dashboard is
        shared with you.

        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.DashboardResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_dashboards.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[DashboardResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_dashboards.metadata = {'url': '/api/v3/dashboard'}

    def create_dashboard(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates a dashboard.

        :param body:
        :type body: ~energycap.sdk.models.DashboardCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DashboardResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.DashboardResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_dashboard.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'DashboardCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DashboardResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_dashboard.metadata = {'url': '/api/v3/dashboard'}

    def get_dashboard(
            self, dashboard_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves a dashboard.
        For a dashboard to be returned you must have created the dashboard
        or have DashboardAdministrator Manage permission and the dashboard is
        shared at all
        or have DashboardAdministrator Manage permission and the dashboard is
        public
        or have SharedDashboardsOrMaps View permission and the dashboard is
        shared with you.

        :param dashboard_id: Specific dashboard
        :type dashboard_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DashboardResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.DashboardResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_dashboard.metadata['url']
        path_format_arguments = {
            'dashboardId': self._serialize.url("dashboard_id", dashboard_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DashboardResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_dashboard.metadata = {'url': '/api/v3/dashboard/{dashboardId}'}

    def edit_dashboard(
            self, dashboard_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit a dashboard
        To edit a dashboard you must have created the dashboard
        or have DashboardAdministrator Manage permission and the dashboard is
        shared at all
        or have DashboardAdministrator Manage permission and the dashboard is
        public
        or have SharedDashboardsOrMaps Edit permission and the dashboard is
        shared with you.

        :param dashboard_id:
        :type dashboard_id: int
        :param body:
        :type body: ~energycap.sdk.models.DashboardEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DashboardResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.DashboardResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_dashboard.metadata['url']
        path_format_arguments = {
            'dashboardId': self._serialize.url("dashboard_id", dashboard_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'DashboardEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DashboardResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_dashboard.metadata = {'url': '/api/v3/dashboard/{dashboardId}'}

    def delete_dashboard(
            self, dashboard_id, custom_headers=None, raw=False, **operation_config):
        """Delete a dashboard
        To delete a dashboard you must have created it
        or have DashboardAdministrator Manage permission and the dashboard is
        shared at all
        or have DashboardAdministrator Manage permission and the dashboard is
        public.

        :param dashboard_id: Specific dashboard
        :type dashboard_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_dashboard.metadata['url']
        path_format_arguments = {
            'dashboardId': self._serialize.url("dashboard_id", dashboard_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_dashboard.metadata = {'url': '/api/v3/dashboard/{dashboardId}'}

    def copy_dashboard(
            self, dashboard_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Copy a dashboard
        To copy a dashboard you must have created the dashboard
        or have DashboardAdministrator Manage permission and the dashboard is
        shared at all
        or have DashboardAdministrator Manage permission and the dashboard is
        public
        or have SharedDashboardsOrMaps View permission and the dashboard is
        shared with you.

        :param dashboard_id: Specific dashboard
        :type dashboard_id: int
        :param body: Request object
        :type body: ~energycap.sdk.models.DashboardCopy
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DashboardResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.DashboardResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.copy_dashboard.metadata['url']
        path_format_arguments = {
            'dashboardId': self._serialize.url("dashboard_id", dashboard_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'DashboardCopy')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DashboardResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    copy_dashboard.metadata = {'url': '/api/v3/dashboard/{dashboardId}/copy'}

    def get_dashboard_widgets(
            self, dashboard_id, custom_headers=None, raw=False, **operation_config):
        """Get all widgets on a dashboard
        For a dashboard to be returned you must have created the dashboard
        or have DashboardAdministrator Manage permission and the dashboard is
        shared at all
        or have DashboardAdministrator Manage permission and the dashboard is
        public
        or have SharedDashboardsOrMaps View permission and the dashboard is
        shared with you.

        :param dashboard_id: Dashboard Identifier
        :type dashboard_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.SpecificWidgetResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_dashboard_widgets.metadata['url']
        path_format_arguments = {
            'dashboardId': self._serialize.url("dashboard_id", dashboard_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[SpecificWidgetResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_dashboard_widgets.metadata = {'url': '/api/v3/dashboard/{dashboardId}/widget'}

    def add_widget(
            self, dashboard_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Add a widget to a dashboard
        To add widgets to a dashboard you must have created the dashboard
        or have DashboardAdministrator Manage permission and the dashboard is
        shared at all
        or have DashboardAdministrator Manage permission and the dashboard is
        public
        or have SharedDashboardsOrMaps Edit permission and the dashboard is
        shared with you.

        :param dashboard_id: dashboard
        :type dashboard_id: int
        :param body: Request object
        :type body: ~energycap.sdk.models.WidgetCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SpecificWidgetResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SpecificWidgetResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.add_widget.metadata['url']
        path_format_arguments = {
            'dashboardId': self._serialize.url("dashboard_id", dashboard_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'WidgetCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SpecificWidgetResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    add_widget.metadata = {'url': '/api/v3/dashboard/{dashboardId}/widget'}

    def edit_dashboard_widgets(
            self, dashboard_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Reorder, edit, and delete specific widgets on a dashboard.
        To edit dashboard widgets you must have created the dashboard
        or have DashboardAdministrator Manage permission and the dashboard is
        shared at all
        or have DashboardAdministrator Manage permission and the dashboard is
        public
        or have SharedDashboardsOrMaps Edit permission and the dashboard is
        shared with you.

        :param dashboard_id: dashboard
        :type dashboard_id: int
        :param body: Request object
        :type body: list[~energycap.sdk.models.WidgetEdit]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.SpecificWidgetResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_dashboard_widgets.metadata['url']
        path_format_arguments = {
            'dashboardId': self._serialize.url("dashboard_id", dashboard_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[WidgetEdit]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[SpecificWidgetResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_dashboard_widgets.metadata = {'url': '/api/v3/dashboard/{dashboardId}/widget'}

    def get_dashboard_share(
            self, dashboard_id, custom_headers=None, raw=False, **operation_config):
        """Get the individual users and user groups a dashboard is shared with
        In order to get this information for a particular dashboardId,
        You must have created the dashboard and have SharedDashboardsOrMaps
        Create permission
        or have DashboardAdministrator Manage permission and the dashboard must
        be shared at all
        or have DashboardAdministrator Manage permission and the dashboard is
        public.

        :param dashboard_id: Dashboard Identifier
        :type dashboard_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ShareResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ShareResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_dashboard_share.metadata['url']
        path_format_arguments = {
            'dashboardId': self._serialize.url("dashboard_id", dashboard_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ShareResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_dashboard_share.metadata = {'url': '/api/v3/dashboard/{dashboardId}/share'}

    def edit_dashboard_share(
            self, dashboard_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Update the shared users and user groups for a dashboard
        To remove sharing completely set SharedWithEveryone to false,
        SharedUserIds to [], and SharedUserGroupIds to []
        You must have created the dashboard and have SharedDashboardsOrMaps
        Create permission
        or have DashboardAdministrator Manage permission and the dashboard must
        be shared at all
        or have DashboardAdministrator Manage permission and the dashboard is
        public.

        :param dashboard_id: Dashboard Identifier
        :type dashboard_id: int
        :param body: users and user groups to share the dashboard with
        :type body: ~energycap.sdk.models.ShareRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ShareResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ShareResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_dashboard_share.metadata['url']
        path_format_arguments = {
            'dashboardId': self._serialize.url("dashboard_id", dashboard_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ShareRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ShareResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_dashboard_share.metadata = {'url': '/api/v3/dashboard/{dashboardId}/share'}

    def dashboard_action_visible(
            self, dashboard_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Update the visibility of a dashboard for the current user
        This must be a dashboard you can see
        Which means you must have created the dashboard
        or have DashboardAdministrator Manage permission and the dashboard is
        shared at all
        or have DashboardAdministrator Manage permission and the dashboard is
        public
        or have SharedDashboardsOrMaps View permission and the dashboard is
        shared with you.

        :param dashboard_id: Specific dashboard
        :type dashboard_id: int
        :param body: Set Visibility
        :type body: ~energycap.sdk.models.ToggleVisible
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DashboardResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.DashboardResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.dashboard_action_visible.metadata['url']
        path_format_arguments = {
            'dashboardId': self._serialize.url("dashboard_id", dashboard_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ToggleVisible')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DashboardResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    dashboard_action_visible.metadata = {'url': '/api/v3/dashboard/{dashboardId}/visible'}

    def get_energy_project(
            self, project_id, custom_headers=None, raw=False, **operation_config):
        """Get an energy project.

        :param project_id: The identifier for the energy project to retrieve
        :type project_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EnergyProjectResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.EnergyProjectResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_energy_project.metadata['url']
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EnergyProjectResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_energy_project.metadata = {'url': '/api/v3/energyproject/{projectId}'}

    def edit_energy_project(
            self, project_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits an Energy Project.

        :param project_id: The identifier for the energy project being edited
        :type project_id: int
        :param body:
        :type body: ~energycap.sdk.models.EnergyProjectEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EnergyProjectResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.EnergyProjectResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_energy_project.metadata['url']
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'EnergyProjectEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EnergyProjectResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_energy_project.metadata = {'url': '/api/v3/energyproject/{projectId}'}

    def delete_energy_project(
            self, project_id, custom_headers=None, raw=False, **operation_config):
        """Deletes an Energy Project.

        :param project_id: The identifier for the energy project being deleted
        :type project_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_energy_project.metadata['url']
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_energy_project.metadata = {'url': '/api/v3/energyproject/{projectId}'}

    def create_energy_project(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates an Energy Project.

        :param body: Data representing the Energy project being created
        :type body: ~energycap.sdk.models.EnergyProjectCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EnergyProjectResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.EnergyProjectResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_energy_project.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'EnergyProjectCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EnergyProjectResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_energy_project.metadata = {'url': '/api/v3/energyproject'}

    def get_energy_project_types(
            self, custom_headers=None, raw=False, **operation_config):
        """Get all the energy project types.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.EnergyProjectType] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_energy_project_types.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[EnergyProjectType]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_energy_project_types.metadata = {'url': '/api/v3/energyproject/energyprojecttype'}

    def create_energy_project_type(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a energy project type.

        :param body:
        :type body: ~energycap.sdk.models.EnergyProjectTypeCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EnergyProjectType or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.EnergyProjectType or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_energy_project_type.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'EnergyProjectTypeCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EnergyProjectType', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_energy_project_type.metadata = {'url': '/api/v3/energyproject/energyprojecttype'}

    def get_energy_project_manager(
            self, query=None, custom_headers=None, raw=False, **operation_config):
        """Get the energy project managers.

        :param query:
        :type query: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.ProjectManagerResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_energy_project_manager.metadata['url']

        # Construct parameters
        query_parameters = {}
        if query is not None:
            query_parameters['query'] = self._serialize.query("query", query, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ProjectManagerResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_energy_project_manager.metadata = {'url': '/api/v3/energyproject/projectmanager'}

    def get_energy_star_settings(
            self, custom_headers=None, raw=False, **operation_config):
        """Get settings for ENERGY STAR submissions
        If not configured, response will be null.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EnergyStarSettingsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.EnergyStarSettingsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_energy_star_settings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EnergyStarSettingsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_energy_star_settings.metadata = {'url': '/api/v3/energyStar/setting'}

    def edit_energy_star_settings(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit settings for ENERGY STAR submissions.

        :param body: ENERGY STAR settings
        :type body: ~energycap.sdk.models.EnergyStarSettingsRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EnergyStarSettingsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.EnergyStarSettingsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_energy_star_settings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'EnergyStarSettingsRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EnergyStarSettingsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_energy_star_settings.metadata = {'url': '/api/v3/energyStar/setting'}

    def get_portfolio_manager_properties(
            self, include_only_unlinked=False, verbose=True, custom_headers=None, raw=False, **operation_config):
        """Get list of Portfolio Manager properties.

        :param include_only_unlinked: Include only unlinked properties
        :type include_only_unlinked: bool
        :param verbose: true by default.
         When set to false the API will perform faster but will only retrieve
         PmPropertyId and PmPropertyName from Portfolio Manager.
         PmPropertyUseType, PmFloorArea, PmFloorAreaUnits will be null.
        :type verbose: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.EnergyStarPmProperty] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_portfolio_manager_properties.metadata['url']

        # Construct parameters
        query_parameters = {}
        if include_only_unlinked is not None:
            query_parameters['includeOnlyUnlinked'] = self._serialize.query("include_only_unlinked", include_only_unlinked, 'bool')
        if verbose is not None:
            query_parameters['verbose'] = self._serialize.query("verbose", verbose, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[EnergyStarPmProperty]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_portfolio_manager_properties.metadata = {'url': '/api/v3/energyStar/pmProperty'}

    def get_portfolio_manager_property(
            self, pm_property_id, verbose=True, custom_headers=None, raw=False, **operation_config):
        """Get a Portfolio Manager property.

        :param pm_property_id: Portfolio Manager property identifier
        :type pm_property_id: long
        :param verbose: true by default.
         When set to false the API will perform faster but will only retrieve
         PmPropertyId and PmPropertyName from Portfolio Manager.
         PmPropertyUseType, PmFloorArea, PmFloorAreaUnits will be null.
        :type verbose: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EnergyStarPmProperty or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.EnergyStarPmProperty or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_portfolio_manager_property.metadata['url']
        path_format_arguments = {
            'pmPropertyId': self._serialize.url("pm_property_id", pm_property_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if verbose is not None:
            query_parameters['verbose'] = self._serialize.query("verbose", verbose, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EnergyStarPmProperty', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_portfolio_manager_property.metadata = {'url': '/api/v3/energyStar/pmProperty/{pmPropertyId}'}

    def get_portfolio_manager_property_meters(
            self, pm_property_id, include_only_unlinked=False, verbose=True, custom_headers=None, raw=False, **operation_config):
        """Get list of Portfolio Manager meters for a property.

        :param pm_property_id: Portfolio Manager property identifier
        :type pm_property_id: long
        :param include_only_unlinked: Include only unlinked meters
        :type include_only_unlinked: bool
        :param verbose: true by default.
         When set to false the API will perform faster but will only retrieve
         PmMeterId and PmMeterName from Portfolio Manager.
         PmCommodityCode and PmUnitCode will be null.
        :type verbose: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.EnergyStarPmMeter] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_portfolio_manager_property_meters.metadata['url']
        path_format_arguments = {
            'pmPropertyId': self._serialize.url("pm_property_id", pm_property_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if include_only_unlinked is not None:
            query_parameters['includeOnlyUnlinked'] = self._serialize.query("include_only_unlinked", include_only_unlinked, 'bool')
        if verbose is not None:
            query_parameters['verbose'] = self._serialize.query("verbose", verbose, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[EnergyStarPmMeter]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_portfolio_manager_property_meters.metadata = {'url': '/api/v3/energyStar/pmProperty/{pmPropertyId}/pmMeter'}

    def get_energy_star_submission_status_list(
            self, submission_begin_period, submission_end_period, filter=None, custom_headers=None, raw=False, **operation_config):
        """Get the submission status for places by submission period.
        Places that do not match the filter criteria will not be returned.
        NOTE: Deleting/voiding bills that have already been submitted will not
        cause submission status to change from "submitted".

        Returned submission status:
        Submitted  - submission has been made for this place and submission
        period and no bills have been created or modified since the last
        submission
        No Data    - no submission has been made for this place and submission
        period and current submission period has no billing data
        Incomplete - no submission has been made for this place and submission
        period and current billing data is incomplete (some meters may not have
        data or some days in submission period may not have data)
        Ready      - no submission has been made for this place and submission
        period and current billing data is complete (every meter has data for
        every day of this period), or submission has been made but billing data
        has been added or modified since the last submission.

        :param submission_begin_period: The beginning submission period to
         select
        :type submission_begin_period: int
        :param submission_end_period: The ending submission period to select;
         set equal to beginning submission period get one period
        :type submission_end_period: int
        :param filter: API filter string containing conditions
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.EnergyStarPlaceSubmissionStatusResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_energy_star_submission_status_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['submissionBeginPeriod'] = self._serialize.query("submission_begin_period", submission_begin_period, 'int')
        query_parameters['submissionEndPeriod'] = self._serialize.query("submission_end_period", submission_end_period, 'int')
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[EnergyStarPlaceSubmissionStatusResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_energy_star_submission_status_list.metadata = {'url': '/api/v3/energyStar/submissionStatus'}

    def get_energy_star_tasks(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Get a list of ENERGY STAR tasks with their details.

        :param filter: Filters to apply
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.EnergyStarTaskResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_energy_star_tasks.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[EnergyStarTaskResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_energy_star_tasks.metadata = {'url': '/api/v3/energyStar/task'}

    def get_energy_star_task(
            self, energy_star_task_id, custom_headers=None, raw=False, **operation_config):
        """Get an ENERGY STAR task with its details.

        :param energy_star_task_id:
        :type energy_star_task_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EnergyStarTaskResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.EnergyStarTaskResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_energy_star_task.metadata['url']
        path_format_arguments = {
            'energyStarTaskId': self._serialize.url("energy_star_task_id", energy_star_task_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EnergyStarTaskResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_energy_star_task.metadata = {'url': '/api/v3/energyStar/task/{energyStarTaskId}'}

    def create_energy_star_submission(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Initiate (create) a submission of place data to ENERGY STAR.

        :param body:
        :type body: ~energycap.sdk.models.EnergyStarSubmissionRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EnergyStarTaskResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.EnergyStarTaskResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_energy_star_submission.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'EnergyStarSubmissionRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EnergyStarTaskResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_energy_star_submission.metadata = {'url': '/api/v3/energyStar/submit'}

    def update_energy_star_metrics(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Update ENERGY STAR metrics for the places matching the request
        criteria.

        :param body: Periods and list of place identifiers for which to update
         metrics
        :type body: ~energycap.sdk.models.EnergyStarPlaceMetricsRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EnergyStarTaskResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.EnergyStarTaskResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_energy_star_metrics.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'EnergyStarPlaceMetricsRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EnergyStarTaskResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    update_energy_star_metrics.metadata = {'url': '/api/v3/energyStar/metrics'}

    def get_energy_star_commodity_mappings(
            self, custom_headers=None, raw=False, **operation_config):
        """Get a list of all commodities and, if configured, their mappings in
        ENERGY STAR.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.EnergyStarCommodityMapping] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_energy_star_commodity_mappings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[EnergyStarCommodityMapping]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_energy_star_commodity_mappings.metadata = {'url': '/api/v3/energyStar/commodity'}

    def empty(
            self, custom_headers=None, raw=False, **operation_config):
        """

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.empty.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    empty.metadata = {'url': '/api/v3/empty'}

    def environment_method(
            self, custom_headers=None, raw=False, **operation_config):
        """

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Environment or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.Environment or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.environment_method.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Environment', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    environment_method.metadata = {'url': '/api/v3/environment'}

    def export_historical_bills(
            self, export_file_name=None, body=None, custom_headers=None, raw=False, **operation_config):
        """

        :param export_file_name:
        :type export_file_name: str
        :param body:
        :type body: ~energycap.sdk.models.BillActionHistoricalExport
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or ClientRawResponse if raw=true
        :rtype: str or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.export_historical_bills.metadata['url']

        # Construct parameters
        query_parameters = {}
        if export_file_name is not None:
            query_parameters['exportFileName'] = self._serialize.query("export_file_name", export_file_name, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillActionHistoricalExport')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    export_historical_bills.metadata = {'url': '/api/v3/generatebillimport'}

    def get_filter_data(
            self, data_field_id, search=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves list of values for data filter.

        :param data_field_id:
        :type data_field_id: int
        :param search:
        :type search: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.FilterDataResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_filter_data.metadata['url']
        path_format_arguments = {
            'dataFieldId': self._serialize.url("data_field_id", data_field_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if search is not None:
            query_parameters['search'] = self._serialize.query("search", search, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[FilterDataResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_filter_data.metadata = {'url': '/api/v3/filterData/{dataFieldId}'}

    def get_flag(
            self, entity_type, entity_id, custom_headers=None, raw=False, **operation_config):
        """Get flag data for a specified entity.

        :param entity_type: The type of entity the flag is being request for.
         Supported values are: "Bill"
        :type entity_type: str
        :param entity_id: The identifier of the entity
        :type entity_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: FlagResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.FlagResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_flag.metadata['url']
        path_format_arguments = {
            'entityType': self._serialize.url("entity_type", entity_type, 'str'),
            'entityId': self._serialize.url("entity_id", entity_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FlagResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_flag.metadata = {'url': '/api/v3/flag/{entityType}/{entityId}'}

    def edit_flag(
            self, entity_type, entity_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit flag data for a specified entity.

        This API supports a wide variety of Flag-related actions. Below are
        summaries of expected outcomes for possible combinations of property
        values.
        Create Flag(the entity is not yet flagged, therefore there is no
        "modified" info)
        |        FlagTypeId        |       FlagStatusId       |
        CostRecovery       |        Assignees         |         Comment
        |    HoldFromExport    |  ReleaseExportHold   |
        Action
        |
        | ------------------------ | ------------------------ |
        ------------------------ | ------------------------ |
        ------------------------ | -------------------- | --------------------
        |
        -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        |
        | null                     | null                     | null
        | null                     | **non-null**             | **true**
        | **true**             | Exception, cannot set both HoldFromExport and
        ReleaseExportHold at once
        |
        | null                     | null                     | null
        | null                     | null                     | **non-null**
        | **non-null**         | Exception, must have at least one set
        |
        | null                     | null                     | null
        | null                     | null                     | null
        | null                 | Exception, must provided a non-null value for
        HoldFromExport or ReleaseExportHold
        |
        | null                     | **not null**             | **not null**
        | **not null**             | **not null**             | false
        | false                | Exception, must have a type
        |
        | **not null**             | null                     | null
        | null                     | null                     | false
        | false                | Flagged, unresolved, specified type
        |
        | **not null**             | **not null**             | null
        | null                     | null                     | false
        | false                | Flagged, unresolved(ignoring specified
        status), specified type
        |
        | **not null**             | null                     | **not null**
        | null                     | null                     | false
        | false                | Flagged, unresolved, specified type, cost
        recovery
        |
        | **not null**             | null                     | null
        | **not null**<sup>1</sup> | null                     | false
        | false                | Flagged, unresolved, specified type<br
        /><sup>1</sup>If assignees not empty, assigned
        |
        | **not null**             | null                     | null
        | null                     | **not null**             | false
        | false                | Flagged, unresolved, specified type, comment
        |
        | **not null**<sup>1</sup> | **not null**<sup>1</sup> | **not
        null**<sup>1</sup> | **not null**<sup>2</sup> | **not
        null**<sup>1</sup> | **true**<sup>1</sup> | false                |
        <sup>1</sup>Flagged, unresolved (ignoring specified status), specified
        type, cost recovery, comment, held from export<br /><sup>2</sup>If
        assignees not empty, assigned, comment
        |
        | **not null**<sup>1</sup> | **not null**<sup>1</sup> | **not
        null**<sup>1</sup> | **not null**<sup>2</sup> | **not
        null**<sup>1</sup> | false                | **true**<sup>3</sup> |
        <sup>1</sup>Flagged, unresolved (ignoring specified status), specified
        type, cost recovery, comment<br /><sup>2</sup>If assignees not empty,
        assigned, comment<br /><sup>3</sup>No action; will not release a newly
        flagged bill for export |
        Edit Unresolved Flag (the entity is already flagged)
        |        FlagTypeId        |       FlagStatusId       |
        CostRecovery       |        Assignees         |         Comment
        |    HoldFromExport    | ReleaseExportHold |
        Action
        |
        | ------------------------ | ------------------------ |
        ------------------------ | ------------------------ |
        ------------------------ | -------------------- | ----------------- |
        ---------------------------------------------------------------------------------------------------------------------------------------------------
        |
        | null                     | null                     | null
        | null                     | **non-null**             | **true**
        | **true**          | Exception, cannot set both HoldFromExport and
        ReleaseExportHold at once
        |
        | null                     | null                     | null
        | null                     | null                     | **non-null**
        | **non-null**      | Exception, must have at least one set
        |
        | null                     | null                     | null
        | null                     | null                     | false
        | false             | Exception, must provided a non-null value for
        HoldFromExport or ReleaseExportHold
        |
        | **system or user type**  | null                     | null
        | null                     | null                     | false
        | false             | Flag type updated
        |
        | null                     | **resolved**             | null
        | null                     | null                     | false
        | false             | Resolved
        |
        | null                     | **resolved**             | null
        | null                     | null                     | false
        | **true**          | Resolved, released for export
        |
        | null                     | null                     | **not null**
        | null                     | null                     | false
        | false             | Updated, cost recovery
        |
        | null                     | null                     | null
        | **not null**             | null                     | false
        | false             | Assigned
        |
        | null                     | null                     | null
        | null                     | **not null**             | false
        | false             | Updated, comment
        |
        | **not null**<sup>1</sup> | **not null**<sup>3</sup> | **not
        null**<sup>1</sup> | **not null**<sup>2</sup> | **not
        null**<sup>1</sup> | false                | false             |
        <sup>1</sup>Updated, specified type, cost recovery, comment<br
        /><sup>2</sup>Assigned, comment<br /><sup>3</sup>Resolved, comment
        |
        | **not null**<sup>1</sup> | **not null**<sup>3</sup> | **not
        null**<sup>1</sup> | **not null**<sup>2</sup> | **not
        null**<sup>1</sup> | **true**<sup>1</sup> | false             |
        <sup>1</sup>Updated, specified type, cost recovery, comment, held from
        export<br /><sup>2</sup>Assigned, comment<br /><sup>3</sup>Resolved,
        comment |
        Edit Resolved Flag (the entity is already flagged)
        |        FlagTypeId        |        FlagStatusId        |
        CostRecovery       |        Assignees         |         Comment
        |    HoldFromExport    |  ReleaseExportHold   |
        Action                                                               |
        | ------------------------ | -------------------------- |
        ------------------------ | ------------------------ |
        ------------------------ | -------------------- | --------------------
        |
        ---------------------------------------------------------------------------------------------------------------------------------
        |
        | null                     | null                       | null
        | null                     | **non-null**             | **true**
        | **true**             | Exception, cannot set both HoldFromExport and
        ReleaseExportHold at once
        |
        | null                     | null                       | null
        | null                     | null                     | **non-null**
        | **non-null**         | Exception, must have at least one set
        |
        | null                     | null                       | null
        | null                     | null                     | false
        | false                | Exception, must provided a non-null value for
        HoldFromExport or ReleaseExportHold
        |
        | **system or user type**  | null                       | null
        | null                     | null                     | false
        | false                | Updated, specified type
        |
        | null                     | **non-null**               | null
        | null                     | null                     | false
        | false                | Exception; must provide flag type (cannot
        change flag status of a resolved flag; instead must "re-flag" it)
        |
        | null                     | null                       | **not null**
        | null                     | null                     | false
        | false                | Exception; must provide flag type (cannot
        change flag status of a resolved flag; instead must "re-flag" it)
        |
        | null                     | null                       | null
        | **not null**             | null                     | false
        | false                | Exception; must provide flag type (cannot
        change flag status of a resolved flag; instead must "re-flag" it)
        |
        | null                     | null                       | null
        | null                     | **not null**             | false
        | false                | Exception; must provide flag type (cannot
        change flag status of a resolved flag; instead must "re-flag" it)
        |
        | **not null**<sup>1</sup> | **not null**<sup>3</sup>   | **not
        null**<sup>1</sup> | **not null**<sup>2</sup> | **not
        null**<sup>1</sup> | false                | false                |
        <sup>1</sup>Updated, specified type, cost recovery, comment<br
        /><sup>2</sup>Assigned, comment<br /><sup>3</sup>Resolved, comment |
        | **not null**<sup>1</sup> | **unresolved**<sup>3</sup> | **not
        null**<sup>1</sup> | **not null**<sup>2</sup> | **not
        null**<sup>1</sup> | **true**<sup>1</sup> | false                |
        <sup>1</sup>Flagged, specified type, cost recovery, comment, no export
        hold action<br /><sup>2</sup>Assigned, comment<br />       |
        | **not null**<sup>1</sup> | **resolved**<sup>3</sup>   | **not
        null**<sup>1</sup> | **not null**<sup>2</sup> | **not
        null**<sup>1</sup> | false                | **true**<sup>1</sup> |
        <sup>1</sup>Resolved, specified type, cost recovery, comment, no export
        hold action<br /><sup>2</sup>Assigned, comment<br />      |
        | **not null**<sup>1</sup> | **unresolved**<sup>3</sup> | **not
        null**<sup>1</sup> | **not null**<sup>2</sup> | **not
        null**<sup>1</sup> | **true**<sup>1</sup> | false                |
        <sup>1</sup>Flagged, specified type, cost recovery, comment, held from
        export<br /><sup>2</sup>Assigned, comment<br />            |
        | **not null**<sup>1</sup> | **resolved**<sup>3</sup>   | **not
        null**<sup>1</sup> | **not null**<sup>2</sup> | **not
        null**<sup>1</sup> | false                | **true**<sup>1</sup> |
        <sup>1</sup>Resolved, specified type, cost recovery, comment, released
        from export<br /><sup>2</sup>Assigned, comment<br />       |.

        :param entity_type: The type of entity the flag is being request for.
         Supported values are: "Bill"
        :type entity_type: str
        :param entity_id: The identifier of the entity
        :type entity_id: int
        :param body: The flag edit request
        :type body: ~energycap.sdk.models.FlagEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: FlagResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.FlagResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_flag.metadata['url']
        path_format_arguments = {
            'entityType': self._serialize.url("entity_type", entity_type, 'str'),
            'entityId': self._serialize.url("entity_id", entity_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'FlagEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FlagResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_flag.metadata = {'url': '/api/v3/flag/{entityType}/{entityId}'}

    def get_flag_types(
            self, custom_headers=None, raw=False, **operation_config):
        """Get a list of all available flag types.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.FlagTypeChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_flag_types.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[FlagTypeChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_flag_types.metadata = {'url': '/api/v3/flag/flagType'}

    def create_flag_type(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a flag type.

        :param body: Contains the name of the flag type being created
        :type body: ~energycap.sdk.models.FlagTypeCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: FlagTypeChild or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.FlagTypeChild or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_flag_type.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'FlagTypeCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FlagTypeChild', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_flag_type.metadata = {'url': '/api/v3/flag/flagType'}

    def delete_flag_type(
            self, flag_type_id, custom_headers=None, raw=False, **operation_config):
        """Delete a flag type. System flag types cannot be deleted.

        :param flag_type_id: The identifier for the flag type being deleted
        :type flag_type_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_flag_type.metadata['url']
        path_format_arguments = {
            'flagTypeId': self._serialize.url("flag_type_id", flag_type_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_flag_type.metadata = {'url': '/api/v3/flag/flagType/{flagTypeId}'}

    def flag_action(
            self, entity_type, body=None, custom_headers=None, raw=False, **operation_config):
        """Updates flags for a given list of entities. If the entity does not
        currently have a flag, one will be created.

        :param entity_type: The type of entity the flag is being request for.
         Supported values are: "Bill"
        :type entity_type: str
        :param body: The changes to be made to the flags
        :type body: ~energycap.sdk.models.FlagListAction
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.flag_action.metadata['url']
        path_format_arguments = {
            'entityType': self._serialize.url("entity_type", entity_type, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'FlagListAction')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    flag_action.metadata = {'url': '/api/v3/flag/{entityType}/flagAction'}

    def flag_in_place_hierarchy(
            self, place_id, custom_headers=None, raw=False, **operation_config):
        """Checks a given place and it's child places, meters, and bills for the
        existence of a flag
        For bill flags, void bills are excluded.

        :param place_id:
        :type place_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SingleBoolean or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SingleBoolean or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.flag_in_place_hierarchy.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SingleBoolean', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    flag_in_place_hierarchy.metadata = {'url': '/api/v3/flag/place/{placeId}/hierarchy'}

    def flag_in_cost_center_hierarchy(
            self, cost_center_id, custom_headers=None, raw=False, **operation_config):
        """Checks a given cost center and it's child cost centers, accounts, and
        bills for the existence of a flag
        For bill flags, void bills are excluded.

        :param cost_center_id:
        :type cost_center_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SingleBoolean or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SingleBoolean or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.flag_in_cost_center_hierarchy.metadata['url']
        path_format_arguments = {
            'costCenterId': self._serialize.url("cost_center_id", cost_center_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SingleBoolean', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    flag_in_cost_center_hierarchy.metadata = {'url': '/api/v3/flag/costCenter/{costCenterId}/hierarchy'}

    def flag_in_meter_hierarchy(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Checks a given meter and it's bills for the existence of a flag
        For bill flags, void bills are excluded.

        :param meter_id:
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SingleBoolean or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SingleBoolean or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.flag_in_meter_hierarchy.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SingleBoolean', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    flag_in_meter_hierarchy.metadata = {'url': '/api/v3/flag/meter/{meterId}/hierarchy'}

    def flag_in_account_hierarchy(
            self, account_id, custom_headers=None, raw=False, **operation_config):
        """Checks a given account and it's bills for the existence of a flag
        For bill flags, void bills are excluded.

        :param account_id:
        :type account_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SingleBoolean or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SingleBoolean or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.flag_in_account_hierarchy.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SingleBoolean', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    flag_in_account_hierarchy.metadata = {'url': '/api/v3/flag/account/{accountId}/hierarchy'}

    def bill_flag_summary_by_account(
            self, cost_center_id, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Returns a tabular flag summary by Account for all the accounts under
        the given cost center.

        :param cost_center_id: Parent cost center identifier
        :type cost_center_id: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: FlagWidget or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.FlagWidget or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.bill_flag_summary_by_account.metadata['url']
        path_format_arguments = {
            'costCenterId': self._serialize.url("cost_center_id", cost_center_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('FlagWidget', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    bill_flag_summary_by_account.metadata = {'url': '/api/v3/flag/costcenter/{costCenterId}/billFlagSummary'}

    def bill_flag_summary_by_meter(
            self, place_id, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Returns a tabular flag summary by Meter for all the meters under the
        given place.

        :param place_id: Parent place identifier
        :type place_id: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: FlagWidget or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.FlagWidget or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.bill_flag_summary_by_meter.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('FlagWidget', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    bill_flag_summary_by_meter.metadata = {'url': '/api/v3/flag/place/{placeId}/billFlagSummary'}

    def get_gl_sub_codes(
            self, custom_headers=None, raw=False, **operation_config):
        """Retrieves all General Ledger SubCode definitions.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.GLSubcodeResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_gl_sub_codes.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GLSubcodeResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_gl_sub_codes.metadata = {'url': '/api/v3/glsubcode'}

    def edit_gl_sub_codes(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit General Ledger Subcode definitions - update name, type and if
        "list" type edit (add/delete/edit) pick list values.
        One or more subcodes can be edited.

        :param body: Provide the subcode definition
        :type body: list[~energycap.sdk.models.GLSubcodeRequest]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.GLSubcodeResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_gl_sub_codes.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[GLSubcodeRequest]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GLSubcodeResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_gl_sub_codes.metadata = {'url': '/api/v3/glsubcode'}

    def get_gl_sub_code(
            self, sub_code_index, custom_headers=None, raw=False, **operation_config):
        """Retrieves specific General Ledger Subcode definition.

        :param sub_code_index: The index of the subCode being retrieved
        :type sub_code_index: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GLSubcodeResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GLSubcodeResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_gl_sub_code.metadata['url']
        path_format_arguments = {
            'subCodeIndex': self._serialize.url("sub_code_index", sub_code_index, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GLSubcodeResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_gl_sub_code.metadata = {'url': '/api/v3/glsubcode/{subCodeIndex}'}

    def get_gl_sub_code_values(
            self, sub_code_index, custom_headers=None, raw=False, **operation_config):
        """Retrieves unique General Ledger Subcode values.

        :param sub_code_index: The index of the subCode whose values are being
         retrieved
        :type sub_code_index: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[str] or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_gl_sub_code_values.metadata['url']
        path_format_arguments = {
            'subCodeIndex': self._serialize.url("sub_code_index", sub_code_index, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[str]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_gl_sub_code_values.metadata = {'url': '/api/v3/glsubcode/{subCodeIndex}/savedValues'}

    def get_general_ledgers(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves all General Ledgers.

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.GeneralLedgerResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_general_ledgers.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[GeneralLedgerResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_general_ledgers.metadata = {'url': '/api/v3/generalledger'}

    def create_general_ledger(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates a General Ledger.

        :param body: Data representing the general ledger being created
        :type body: ~energycap.sdk.models.GeneralLedgerRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GeneralLedgerResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GeneralLedgerResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_general_ledger.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'GeneralLedgerRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GeneralLedgerResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_general_ledger.metadata = {'url': '/api/v3/generalledger'}

    def get_general_ledger(
            self, general_ledger_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves a specific General Ledger.

        :param general_ledger_id: General Ledger ID to return
        :type general_ledger_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GeneralLedgerResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GeneralLedgerResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_general_ledger.metadata['url']
        path_format_arguments = {
            'generalLedgerId': self._serialize.url("general_ledger_id", general_ledger_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GeneralLedgerResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_general_ledger.metadata = {'url': '/api/v3/generalledger/{generalLedgerId}'}

    def edit_general_ledger(
            self, general_ledger_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Updates a General Ledger.

        :param general_ledger_id: General Ledger ID to update
        :type general_ledger_id: int
        :param body: Data representing the general ledger to update
        :type body: ~energycap.sdk.models.GeneralLedgerRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GeneralLedgerResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GeneralLedgerResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_general_ledger.metadata['url']
        path_format_arguments = {
            'generalLedgerId': self._serialize.url("general_ledger_id", general_ledger_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'GeneralLedgerRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GeneralLedgerResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_general_ledger.metadata = {'url': '/api/v3/generalledger/{generalLedgerId}'}

    def make_factor_links(
            self, custom_headers=None, raw=False, **operation_config):
        """Updates GHG factor links for all meters.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.make_factor_links.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    make_factor_links.metadata = {'url': '/api/v3/ghg/makefactorlinks'}

    def hierarchical_ancestry_places(
            self, place_id, custom_headers=None, raw=False, **operation_config):
        """Returns place ancestry information, useful for populating a tree of
        places.

        :param place_id: Place ID
        :type place_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: HierarchicalPlaces or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.HierarchicalPlaces or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.hierarchical_ancestry_places.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HierarchicalPlaces', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    hierarchical_ancestry_places.metadata = {'url': '/api/v3/hierarchy/ancestry/place/{placeId}'}

    def hierarchical_ancestry_meters(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Returns meter ancestry information, useful for populating a tree of
        places.

        :param meter_id: Meter ID
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: HierarchicalPlaces or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.HierarchicalPlaces or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.hierarchical_ancestry_meters.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HierarchicalPlaces', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    hierarchical_ancestry_meters.metadata = {'url': '/api/v3/hierarchy/ancestry/meter/{meterId}'}

    def hierarchical_place(
            self, place_id, custom_headers=None, raw=False, **operation_config):
        """Returns place descendant information, useful for expanding a place
        node.

        :param place_id: Place ID
        :type place_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: HierarchicalPlaces or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.HierarchicalPlaces or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.hierarchical_place.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HierarchicalPlaces', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    hierarchical_place.metadata = {'url': '/api/v3/hierarchy/place/{placeId}'}

    def hierarchical_ancestry_cost_centers(
            self, cost_center_id, custom_headers=None, raw=False, **operation_config):
        """Returns cost center ancestry information, useful for populating a tree
        of cost centers.

        :param cost_center_id: CostCenter ID
        :type cost_center_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: HierarchicalCostCenters or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.HierarchicalCostCenters or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.hierarchical_ancestry_cost_centers.metadata['url']
        path_format_arguments = {
            'costCenterId': self._serialize.url("cost_center_id", cost_center_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HierarchicalCostCenters', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    hierarchical_ancestry_cost_centers.metadata = {'url': '/api/v3/hierarchy/ancestry/costCenter/{costCenterId}'}

    def hierarchical_ancestry_accounts(
            self, account_id, custom_headers=None, raw=False, **operation_config):
        """Returns account ancestry information, useful for populating a tree of
        costCenters.

        :param account_id: Account ID
        :type account_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: HierarchicalCostCenters or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.HierarchicalCostCenters or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.hierarchical_ancestry_accounts.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HierarchicalCostCenters', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    hierarchical_ancestry_accounts.metadata = {'url': '/api/v3/hierarchy/ancestry/account/{accountId}'}

    def hierarchical_cost_center(
            self, cost_center_id, custom_headers=None, raw=False, **operation_config):
        """Returns costCenter descendant information, useful for expanding a
        costCenter node.

        :param cost_center_id: CostCenter ID
        :type cost_center_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: HierarchicalCostCenters or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.HierarchicalCostCenters or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.hierarchical_cost_center.metadata['url']
        path_format_arguments = {
            'costCenterId': self._serialize.url("cost_center_id", cost_center_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HierarchicalCostCenters', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    hierarchical_cost_center.metadata = {'url': '/api/v3/hierarchy/costCenter/{costCenterId}'}

    def available_places_for_topmost_cost_centers(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """For a list of topmost cost centers, get associated topmost places.

        :param body:
        :type body: list[int]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PlaceChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.available_places_for_topmost_cost_centers.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[int]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    available_places_for_topmost_cost_centers.metadata = {'url': '/api/v3/hierarchy/costCenter/availablePlaces'}

    def available_cost_centers_for_topmost_places(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """For a list of topmost places, get associated topmost cost centers.

        :param body:
        :type body: list[int]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.CostCenterChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.available_cost_centers_for_topmost_places.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[int]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[CostCenterChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    available_cost_centers_for_topmost_places.metadata = {'url': '/api/v3/hierarchy/place/availableCostCenters'}

    def bill_import(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """This endpoint allows the import of an EnergyCAP Advanced or a profile
        mapped file. The file can be comma separated file (CSV/DAT/TXT) or
        EXCEL (XLSX) or a collection of files (ZIP). The file should be base64
        encoded with a UTF8 character set.

        :param body: DTO containing the data to import, filename with
         extension, optional profileCode to map input file to advanced format,
         optional batch settings, optional import note/comment, and optional
         properties to automatically resolve audit failures and reason for
         resolution
        :type body: ~energycap.sdk.models.BillImportRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GuidResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GuidResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.bill_import.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillImportRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GuidResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    bill_import.metadata = {'url': '/api/v3/import/bill'}

    def reading_import(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """This endpoint allows the import of a channel reading ("interval") data
        import file. The file should be a base64-encoded delimited text file
        with a UTF8 character set.

        :param body: DTO containing the data to export and the profile that
         defines the structure.
        :type body: ~energycap.sdk.models.ReadingImportRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GuidResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GuidResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.reading_import.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ReadingImportRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GuidResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    reading_import.metadata = {'url': '/api/v3/import/reading'}

    def create_reading_import_profile(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates an interval data import profile.

        :param body: The details about the profile being created
        :type body: ~energycap.sdk.models.ReadingImportProfileRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ReadingImportProfileResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ReadingImportProfileResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_reading_import_profile.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ReadingImportProfileRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReadingImportProfileResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_reading_import_profile.metadata = {'url': '/api/v3/import/reading/profile'}

    def get_reading_import_profiles(
            self, custom_headers=None, raw=False, **operation_config):
        """Returns all Reading Import profiles.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.ReadingImportProfileResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_reading_import_profiles.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ReadingImportProfileResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_reading_import_profiles.metadata = {'url': '/api/v3/import/reading/profile'}

    def get_reading_import_profile(
            self, profile_id, custom_headers=None, raw=False, **operation_config):
        """Returns one reading import profile.

        :param profile_id:
        :type profile_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ReadingImportProfileResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ReadingImportProfileResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_reading_import_profile.metadata['url']
        path_format_arguments = {
            'profileId': self._serialize.url("profile_id", profile_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReadingImportProfileResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_reading_import_profile.metadata = {'url': '/api/v3/import/reading/profile/{profileId}'}

    def edit_reading_import_profile(
            self, profile_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits an interval data import profile.

        :param profile_id: The identifier for the profile being edited
        :type profile_id: int
        :param body: The details about the profile being edited
        :type body: ~energycap.sdk.models.ReadingImportProfileRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ReadingImportProfileResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ReadingImportProfileResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_reading_import_profile.metadata['url']
        path_format_arguments = {
            'profileId': self._serialize.url("profile_id", profile_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ReadingImportProfileRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReadingImportProfileResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_reading_import_profile.metadata = {'url': '/api/v3/import/reading/profile/{profileId}'}

    def delete_reading_import_profile(
            self, profile_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a reading import profile.

        :param profile_id: The identifier for the profile being deleted
        :type profile_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_reading_import_profile.metadata['url']
        path_format_arguments = {
            'profileId': self._serialize.url("profile_id", profile_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_reading_import_profile.metadata = {'url': '/api/v3/import/reading/profile/{profileId}'}

    def get_bill_import_profiles(
            self, custom_headers=None, raw=False, **operation_config):
        """Get all bill import profiles.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BillImportProfileResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_import_profiles.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[BillImportProfileResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill_import_profiles.metadata = {'url': '/api/v3/import/bill/profile'}

    def write_bill_import_profile(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates a bill import profile.

        :param body: The details about the profile being created
        :type body: ~energycap.sdk.models.BillImportProfileRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BillImportProfileResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BillImportProfileResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.write_bill_import_profile.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillImportProfileRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BillImportProfileResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    write_bill_import_profile.metadata = {'url': '/api/v3/import/bill/profile'}

    def get_bill_import_profile(
            self, profile_id, custom_headers=None, raw=False, **operation_config):
        """Get a bill import profile.

        :param profile_id: The identifier for the profile to get
        :type profile_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BillImportProfileResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BillImportProfileResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_import_profile.metadata['url']
        path_format_arguments = {
            'profileId': self._serialize.url("profile_id", profile_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BillImportProfileResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill_import_profile.metadata = {'url': '/api/v3/import/bill/profile/{profileId}'}

    def delete_bill_import_profile(
            self, profile_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a bill import profile.

        :param profile_id: The identifier for the profile being deleted
        :type profile_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_bill_import_profile.metadata['url']
        path_format_arguments = {
            'profileId': self._serialize.url("profile_id", profile_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_bill_import_profile.metadata = {'url': '/api/v3/import/bill/profile/{profileId}'}

    def edit_bill_import_profile(
            self, profile_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit a bill import profile.

        :param profile_id: The identifier for the profile being edited
        :type profile_id: int
        :param body: The details about the profile being edited
        :type body: ~energycap.sdk.models.BillImportProfileRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BillImportProfileResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BillImportProfileResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_bill_import_profile.metadata['url']
        path_format_arguments = {
            'profileId': self._serialize.url("profile_id", profile_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillImportProfileRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BillImportProfileResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_bill_import_profile.metadata = {'url': '/api/v3/import/bill/profile/{profileId}'}

    def account_list(
            self, account_id, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Get the account bills list.

        :param account_id: The account identifier to retrieve bills list for
        :type account_id: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ListResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ListResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.account_list.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('ListResponse', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    account_list.metadata = {'url': '/api/v3/account/{accountId}/list/bill'}

    def account_bill_list_export(
            self, account_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Export all account bills to ap or gl.

        :param account_id: The account to export all bills
        :type account_id: int
        :param body: Bill Export Options
        :type body: ~energycap.sdk.models.BillExportOptions
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.account_bill_list_export.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillExportOptions')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    account_bill_list_export.metadata = {'url': '/api/v3/account/{accountId}/list/bill/export'}

    def account_bill_list_unexport(
            self, account_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Unexport account bills.

        :param account_id: The account for which to unexport all bills
        :type account_id: int
        :param body: Value of "ap" for A/P unexport, or "gl" for GL unexport
        :type body: ~energycap.sdk.models.BillUnexportOptions
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.account_bill_list_unexport.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillUnexportOptions')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    account_bill_list_unexport.metadata = {'url': '/api/v3/account/{accountId}/list/bill/unexport'}

    def account_bill_list_approve(
            self, account_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Approve/unapprove account bills.

        :param account_id: The account to approve/unapprove all bills
        :type account_id: int
        :param body: Boolean representing approve flag
        :type body: ~energycap.sdk.models.ListActionApprove
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.account_bill_list_approve.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionApprove')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    account_bill_list_approve.metadata = {'url': '/api/v3/account/{accountId}/list/bill/approve'}

    def account_bill_list_delete_bills(
            self, account_id, custom_headers=None, raw=False, **operation_config):
        """Delete all bills for account.

        :param account_id: The account to delete all bills from
        :type account_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BillDeleteActionResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BillDeleteActionResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.account_bill_list_delete_bills.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BillDeleteActionResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    account_bill_list_delete_bills.metadata = {'url': '/api/v3/account/{accountId}/list/bill/data'}

    def account_bill_list_export_hold(
            self, account_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Hold/release account bills for export.

        :param account_id: The account to set the export hold flag on all
         bills
        :type account_id: int
        :param body: Boolean representing exportHold flag
        :type body: ~energycap.sdk.models.ListActionExportHold
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.account_bill_list_export_hold.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionExportHold')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    account_bill_list_export_hold.metadata = {'url': '/api/v3/account/{accountId}/list/bill/exporthold'}

    def account_bill_list_void(
            self, account_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Void/unvoid account bills.

        :param account_id: The account to void/unvoid all bills
        :type account_id: int
        :param body: Boolean representing void flag
        :type body: ~energycap.sdk.models.ListActionVoid
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.account_bill_list_void.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionVoid')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    account_bill_list_void.metadata = {'url': '/api/v3/account/{accountId}/list/bill/void'}

    def account_bill_list_excel_export(
            self, account_id, custom_headers=None, raw=False, **operation_config):
        """Export list data to excel spreadsheet format.

        :param account_id: The account to export bills
        :type account_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.account_bill_list_excel_export.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    account_bill_list_excel_export.metadata = {'url': '/api/v3/account/{accountId}/list/bill/excelexport'}

    def get_possible_destination_accounts_for_account_list(
            self, account_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves a list of Accounts that contain meters of ALL of the
        commodities represented by the given Account's Bill List.

        :param account_id: A specific Account that should be used for finding
         matching Accounts (uses all Bills on the Account Bill List).
        :type account_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MoveBillsDestination or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.MoveBillsDestination or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_possible_destination_accounts_for_account_list.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MoveBillsDestination', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_possible_destination_accounts_for_account_list.metadata = {'url': '/api/v3/account/{accountId}/list/bill/possibleDestinationAccounts'}

    def move_bills_to_account_from_account_list(
            self, account_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Moves the bills from the given Account's Bill List to the specified
        destination Account and Meters. Each source Meter
        will be matched with a corresponding destination Meter based on
        commodity.
        <param name="accountId">
        Account for the Bill List containing a list of bills that should be
        moved. All bills from this Account's Bill List will be moved.
        </param><param name="dto">
        DTO containing the destination Account Id, the destination AcountMeter
        Ids, a flag indicating whether the Account GL
        information should be updated, and a flag indicating whether the Meter
        GL information should be updated.
        </param>.

        :param account_id:
        :type account_id: int
        :param body:
        :type body: ~energycap.sdk.models.BillActionMoveList
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.move_bills_to_account_from_account_list.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillActionMoveList')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    move_bills_to_account_from_account_list.metadata = {'url': '/api/v3/account/{accountId}/list/bill/moveBills'}

    def account_bill_list_custom_action(
            self, account_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Fires a custom bill action on an account bill list. Custom bill actions
        are setup as webhooks.

        :param account_id: The account against which all of its bills will
         have the custom action performed
        :type account_id: int
        :param body:
        :type body: ~energycap.sdk.models.ListActionCustom
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: WebhookLogDetailsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.WebhookLogDetailsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.account_bill_list_custom_action.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionCustom')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('WebhookLogDetailsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    account_bill_list_custom_action.metadata = {'url': '/api/v3/account/{accountId}/list/bill/customAction'}

    def reverse_account_bill_list(
            self, account_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Reverses all bills on an account bill list.

        :param account_id: The account that all bills will be reversed on
        :type account_id: int
        :param body: Batch settings for the reversed bills. If not provided,
         bills will be placed in the currently open batch.
        :type body: ~energycap.sdk.models.ListActionReverse
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.reverse_account_bill_list.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionReverse')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    reverse_account_bill_list.metadata = {'url': '/api/v3/account/{accountId}/list/bill/reverse'}

    def set_account_bill_list_accrual_exclusion(
            self, account_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Excludes or undoes exclusion of bills from accruals.

        :param account_id: The account whose bills will be excluded or have
         exclusion undone
        :type account_id: int
        :param body: Indicates whether or not the bills should be excluded
         from accruals or should have exclusion undone
        :type body: ~energycap.sdk.models.ListActionAccrualExclusion
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.set_account_bill_list_accrual_exclusion.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionAccrualExclusion')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    set_account_bill_list_accrual_exclusion.metadata = {'url': '/api/v3/account/{accountId}/list/bill/accrualExclusion'}

    def update_account_bill_list_headers(
            self, account_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Updates bill headers for the bills for an account's bill list
        Audits won't be fired.

        :param account_id: The account whose bills will have header updates
         applied
        :type account_id: int
        :param body: Indicates which headers need to be updated
        :type body: ~energycap.sdk.models.BillHeaderUpdate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_account_bill_list_headers.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillHeaderUpdate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    update_account_bill_list_headers.metadata = {'url': '/api/v3/account/{accountId}/list/bill/billHeaders'}

    def meter_bill_list(
            self, meter_id, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Get the meter bills list.

        :param meter_id: The meter identifier to retrieve bills list for
        :type meter_id: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ListResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ListResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.meter_bill_list.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('ListResponse', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    meter_bill_list.metadata = {'url': '/api/v3/meter/{meterId}/list/bill'}

    def meter_bill_list_export(
            self, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Export all meter bills to ap or gl.

        :param meter_id: The meter to export all bills
        :type meter_id: int
        :param body: Bill Export Options
        :type body: ~energycap.sdk.models.BillExportOptions
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.meter_bill_list_export.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillExportOptions')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    meter_bill_list_export.metadata = {'url': '/api/v3/meter/{meterId}/list/bill/export'}

    def meter_bill_list_unexport(
            self, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Unexport meter bills.

        :param meter_id: The meter for which to unexport all bills
        :type meter_id: int
        :param body: Value of "ap" for A/P unexport, or "gl" for GL unexport
        :type body: ~energycap.sdk.models.BillUnexportOptions
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.meter_bill_list_unexport.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillUnexportOptions')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    meter_bill_list_unexport.metadata = {'url': '/api/v3/meter/{meterId}/list/bill/unexport'}

    def meter_bill_list_approve(
            self, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Approve/unapprove meter bills.

        :param meter_id: The meter to approve/unapprove all bills
        :type meter_id: int
        :param body: Boolean representing approve flag
        :type body: ~energycap.sdk.models.ListActionApprove
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.meter_bill_list_approve.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionApprove')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    meter_bill_list_approve.metadata = {'url': '/api/v3/meter/{meterId}/list/bill/approve'}

    def meter_bill_list_delete_bills(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Delete all bills for meter.

        :param meter_id: The meter to delete all bills from
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BillDeleteActionResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BillDeleteActionResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.meter_bill_list_delete_bills.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BillDeleteActionResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    meter_bill_list_delete_bills.metadata = {'url': '/api/v3/meter/{meterId}/list/bill/data'}

    def meter_bill_list_export_hold(
            self, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Hold/release meter bills for export.

        :param meter_id: The meter to set the export hold flag on all bills
        :type meter_id: int
        :param body: Boolean representing exportHold flag
        :type body: ~energycap.sdk.models.ListActionExportHold
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.meter_bill_list_export_hold.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionExportHold')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    meter_bill_list_export_hold.metadata = {'url': '/api/v3/meter/{meterId}/list/bill/exporthold'}

    def meter_bill_list_void(
            self, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Void/unvoid meter bills.

        :param meter_id: The meter to void/unvoid all bills
        :type meter_id: int
        :param body: Boolean representing void flag
        :type body: ~energycap.sdk.models.ListActionVoid
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.meter_bill_list_void.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionVoid')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    meter_bill_list_void.metadata = {'url': '/api/v3/meter/{meterId}/list/bill/void'}

    def meter_bill_list_excel_export(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Export list data to excel spreadsheet format.

        :param meter_id: The meter to export bills from
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.meter_bill_list_excel_export.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    meter_bill_list_excel_export.metadata = {'url': '/api/v3/meter/{meterId}/list/bill/excelexport'}

    def meter_bill_list_custom_action(
            self, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Fires a custom bill action on a meter bill list. Custom bill actions
        are setup as webhooks.

        :param meter_id: The meter against which all of its bills will have
         the custom action performed
        :type meter_id: int
        :param body:
        :type body: ~energycap.sdk.models.ListActionCustom
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: WebhookLogDetailsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.WebhookLogDetailsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.meter_bill_list_custom_action.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionCustom')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('WebhookLogDetailsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    meter_bill_list_custom_action.metadata = {'url': '/api/v3/meter/{meterId}/list/bill/customAction'}

    def reverse_meter_bill_list(
            self, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Reverses all bills on a meter bill list.

        :param meter_id: The meter that all bills will be reversed on
        :type meter_id: int
        :param body: Batch settings for the reversed bills. If not provided,
         bills will be placed in the currently open batch.
        :type body: ~energycap.sdk.models.ListActionReverse
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.reverse_meter_bill_list.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionReverse')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    reverse_meter_bill_list.metadata = {'url': '/api/v3/meter/{meterId}/list/bill/reverse'}

    def set_meter_bill_list_accrual_exclusion(
            self, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Excludes or undoes exclusion of bills from accruals.

        :param meter_id: The meter whose bills will be excluded or have
         exclusion undone
        :type meter_id: int
        :param body: Indicates whether or not the bills should be excluded
         from accruals or should have exclusion undone
        :type body: ~energycap.sdk.models.ListActionAccrualExclusion
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.set_meter_bill_list_accrual_exclusion.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionAccrualExclusion')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    set_meter_bill_list_accrual_exclusion.metadata = {'url': '/api/v3/meter/{meterId}/list/bill/accrualExclusion'}

    def update_meter_bill_list_headers(
            self, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Updates bill headers for all bills on a meter bill list
        Audits won't be fired.

        :param meter_id: The meter whose bills will have header updates
         applied
        :type meter_id: int
        :param body: Indicates which headers need to be updated
        :type body: ~energycap.sdk.models.BillHeaderUpdate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_meter_bill_list_headers.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillHeaderUpdate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    update_meter_bill_list_headers.metadata = {'url': '/api/v3/meter/{meterId}/list/bill/billHeaders'}

    def get_dynamic_list_with_data(
            self, list_type_id, page_size=None, page_number=None, body=None, custom_headers=None, raw=False, **operation_config):
        """Get the definition and data for a list type.

        :param list_type_id: The list type for which the definition and data
         are to be retrieved
        :type list_type_id: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param body: DTO containing the list of initial filters to apply and a
         flag indicating whether to reset the current columns.
         Only one list of the specified list type exists, so columns and
         filters are shared for every dynamic list of the list type.
         Filters provided will be saved to the database.
        :type body: ~energycap.sdk.models.DynamicListRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ListResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ListResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_dynamic_list_with_data.metadata['url']
        path_format_arguments = {
            'listTypeId': self._serialize.url("list_type_id", list_type_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'DynamicListRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('ListResponse', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_dynamic_list_with_data.metadata = {'url': '/api/v3/dynamiclist/{listTypeId}'}

    def edit_list_filters(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Set list filters
        If a filter exists in the database, but is not passed in it will be
        deleted.
        For list filters to be edited you must have created the list
        or have BillListAdministrator Manage permission and the list is shared
        with anyone
        or have SharedBillList Edit permission and the list is shared with you.

        :param list_id: The list identifier
        :type list_id: int
        :param body: List of filters being set
        :type body: list[~energycap.sdk.models.FilterEdit]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.FilterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_list_filters.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[FilterEdit]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[FilterResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_list_filters.metadata = {'url': '/api/v3/list/{listId}/filter'}

    def get_list_filters(
            self, list_id, custom_headers=None, raw=False, **operation_config):
        """Get the filters for a list.

        :param list_id: The list for which the filters are to be retrieved
        :type list_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.FilterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_list_filters.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[FilterResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_list_filters.metadata = {'url': '/api/v3/list/{listId}/filter'}

    def edit_list_columns(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit the column definition for the list.
        For list columns to be edited you must have created the list
        or have BillListAdministrator Manage permission and the list is shared
        with anyone
        or have SharedBillList Edit permission and the list is shared with you.

        :param list_id: The list identifier
        :type list_id: int
        :param body:
        :type body: list[~energycap.sdk.models.ListColumnEdit]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.ListResponseListField] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_list_columns.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[ListColumnEdit]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ListResponseListField]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_list_columns.metadata = {'url': '/api/v3/list/{listId}/column'}

    def reset_list(
            self, list_id, custom_headers=None, raw=False, **operation_config):
        """Reset a list to its default columns and filters.
        For a list to be reset you must have created the list
        or have BillListAdministrator Manage permission and the list is shared
        with anyone
        or have SharedBillList Edit permission and the list is shared with you.

        :param list_id: The list identifier
        :type list_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.reset_list.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    reset_list.metadata = {'url': '/api/v3/list/{listId}/reset'}

    def create_and_copy_list(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a new list as a copy of an existing list.

        :param list_id: The list identifier of the existing list
        :type list_id: int
        :param body: The list create properties
        :type body: ~energycap.sdk.models.ListCopy
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ListCreateResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ListCreateResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_and_copy_list.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListCopy')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ListCreateResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_and_copy_list.metadata = {'url': '/api/v3/list/{listId}'}

    def edit_list(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit a list.

        :param list_id: The list identifier of the existing list
        :type list_id: int
        :param body: The list edit properties
        :type body: ~energycap.sdk.models.ListEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ListCreateResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ListCreateResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_list.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ListCreateResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_list.metadata = {'url': '/api/v3/list/{listId}'}

    def delete_list(
            self, list_id, custom_headers=None, raw=False, **operation_config):
        """Delete a list.
        For a list to be deleted you must have created the list
        or have BillListAdministrator Manage permission and the list is shared
        with anyone.

        :param list_id: The id of the list to delete
        :type list_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_list.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_list.metadata = {'url': '/api/v3/list/{listId}'}

    def create_default_list(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a new list with default list settings.

        :param body: The list create properties
        :type body: ~energycap.sdk.models.ListCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ListCreateResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ListCreateResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_default_list.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ListCreateResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_default_list.metadata = {'url': '/api/v3/list'}

    def get_lists(
            self, list_type_id=None, custom_headers=None, raw=False, **operation_config):
        """Get a list of bill lists.
        For a list to be returned you must have created the list
        or have BillListAdministrator Manage permission and the list is shared
        with anyone
        or have SharedBillList View permission and the list is shared with you.

        :param list_type_id: Type of list
        :type list_type_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.ListCreateResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_lists.metadata['url']

        # Construct parameters
        query_parameters = {}
        if list_type_id is not None:
            query_parameters['listTypeId'] = self._serialize.query("list_type_id", list_type_id, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ListCreateResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_lists.metadata = {'url': '/api/v3/list'}

    def get_list_with_data(
            self, list_id, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Get the definition and data for a list.
        For a list to be returned you must have created the list
        or have BillListAdministrator Manage permission and the list is shared
        with anyone
        or have SharedBillList View permission and the list is shared with you.

        :param list_id: The list for which the definition and data are to be
         retrieved
        :type list_id: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ListResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ListResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_list_with_data.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('ListResponse', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_list_with_data.metadata = {'url': '/api/v3/list/{listId}/data'}

    def delete_bills_in_bill_list(
            self, list_id, custom_headers=None, raw=False, **operation_config):
        """Delete all bills in a bill list.

        :param list_id: The list identifier
        :type list_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BillDeleteActionResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BillDeleteActionResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_bills_in_bill_list.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BillDeleteActionResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    delete_bills_in_bill_list.metadata = {'url': '/api/v3/list/{listId}/data'}

    def export_bill_list(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Export all bills in a list to ap or gl.

        :param list_id: The list identifier
        :type list_id: int
        :param body: Bill Export Options
        :type body: ~energycap.sdk.models.BillExportOptions
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.export_bill_list.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillExportOptions')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    export_bill_list.metadata = {'url': '/api/v3/list/{listId}/export'}

    def approve_bill_list(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Approve/unapprove bill list.

        :param list_id: The list identifier
        :type list_id: int
        :param body: Boolean representing approve flag
        :type body: ~energycap.sdk.models.ListActionApprove
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.approve_bill_list.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionApprove')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    approve_bill_list.metadata = {'url': '/api/v3/list/{listId}/approve'}

    def export_hold_bill_list(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Hold/release bill list for export.

        :param list_id: The list identifier
        :type list_id: int
        :param body: Boolean representing exportHold flag
        :type body: ~energycap.sdk.models.ListActionExportHold
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.export_hold_bill_list.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionExportHold')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    export_hold_bill_list.metadata = {'url': '/api/v3/list/{listId}/exporthold'}

    def void_bill_list(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Void/unvoid bill list.

        :param list_id: The list identifier
        :type list_id: int
        :param body: Boolean representing void flag
        :type body: ~energycap.sdk.models.ListActionVoid
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.void_bill_list.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionVoid')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    void_bill_list.metadata = {'url': '/api/v3/list/{listId}/void'}

    def update_bill_list_headers(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Update all headers for a bill list
        If a new begin date or end date is being set, bills that would have end
        dates on or before their begin date will not be updated
        If the user does not have permission to edit exported or approved
        bills, those bills will not be updated
        Bills audits won't be fired.

        :param list_id: The list identifier
        :type list_id: int
        :param body: Bill list header update action
        :type body: ~energycap.sdk.models.BillHeaderUpdate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_bill_list_headers.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillHeaderUpdate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    update_bill_list_headers.metadata = {'url': '/api/v3/list/{listId}/billHeaders'}

    def list_export(
            self, list_id, custom_headers=None, raw=False, **operation_config):
        """Export list data to excel spreadsheet format.

        :param list_id: The list identifier
        :type list_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.list_export.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    list_export.metadata = {'url': '/api/v3/list/{listId}/data/excelexport'}

    def get_possible_destination_accounts_for_list(
            self, list_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves a list of accounts that contain meters of ALL of the
        commodities represented by the given Bill List.

        :param list_id: A specific Bill List that should be used for finding
         matching Accounts.
        :type list_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MoveBillsDestination or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.MoveBillsDestination or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_possible_destination_accounts_for_list.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MoveBillsDestination', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_possible_destination_accounts_for_list.metadata = {'url': '/api/v3/list/{listId}/possibleDestinationAccounts'}

    def move_bills_to_account_from_list(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Moves the bills from the given Bill List to the specified destination
        Account and Meters. Each source Meter will be matched with
        a corresponding destination Meter based on commodity.
        <param name="listId">
        Bill List containing a list of bills that should be moved. All bills
        from this list will be moved.
        </param><param name="dto">
        DTO containing the destination Account Id, the destination AcountMeter
        Ids, a flag indicating whether the Account GL
        information should be updated, and a flag indicating whether the Meter
        GL information should be updated.
        </param>.

        :param list_id:
        :type list_id: int
        :param body:
        :type body: ~energycap.sdk.models.BillActionMoveList
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.move_bills_to_account_from_list.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillActionMoveList')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    move_bills_to_account_from_list.metadata = {'url': '/api/v3/list/{listId}/moveBills'}

    def flag_bill_list_action(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Create and/or update flags for all bills in a list.

        :param list_id: Bill list containing a list of bills that will have
         flags created or updated
        :type list_id: int
        :param body: DTO containing the new state of the flags on each bill in
         the list
        :type body: ~energycap.sdk.models.FlagEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.flag_bill_list_action.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'FlagEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    flag_bill_list_action.metadata = {'url': '/api/v3/list/{listId}/flagAction'}

    def export_historical_bill_list(
            self, list_id, custom_headers=None, raw=False, **operation_config):
        """Generate a bill import file from bills in a list.

        :param list_id: The id of the list to get bills from
        :type list_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or ClientRawResponse if raw=true
        :rtype: str or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.export_historical_bill_list.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    export_historical_bill_list.metadata = {'url': '/api/v3/list/{listId}/bill/generateimport'}

    def account_export_historical_bill_list(
            self, account_id, custom_headers=None, raw=False, **operation_config):
        """Generate a bill import file from all bills in an account bill list.

        :param account_id: The account from which to get all bills
        :type account_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or ClientRawResponse if raw=true
        :rtype: str or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.account_export_historical_bill_list.metadata['url']
        path_format_arguments = {
            'accountId': self._serialize.url("account_id", account_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    account_export_historical_bill_list.metadata = {'url': '/api/v3/account/{accountId}/list/bill/generateimport'}

    def meter_export_historical_bill_list(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Generate a bill import file from all bills in a meter bill list.

        :param meter_id: The meter from which to get all bills
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or ClientRawResponse if raw=true
        :rtype: str or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.meter_export_historical_bill_list.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    meter_export_historical_bill_list.metadata = {'url': '/api/v3/meter/{meterId}/list/bill/generateimport'}

    def unexport_bill_list(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Unexport bill list.

        :param list_id: The list identifier
        :type list_id: int
        :param body: Value of "ap" for A/P unexport, or "gl" for GL unexport
        :type body: ~energycap.sdk.models.BillUnexportOptions
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.unexport_bill_list.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BillUnexportOptions')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    unexport_bill_list.metadata = {'url': '/api/v3/list/{listId}/unexport'}

    def split_bill_list(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Split all bills eligible to be split in a bill list.

        :param list_id: The list identifier
        :type list_id: int
        :param body: Optional note and batch settings can be provided. Batch
         Settings will allow custom batchcode and bill headers for the
         destination bills
        :type body: ~energycap.sdk.models.ChargebackProcessorSettingsForSplits
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChargebackTaskResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChargebackTaskResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.split_bill_list.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ChargebackProcessorSettingsForSplits')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChargebackTaskResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    split_bill_list.metadata = {'url': '/api/v3/list/{listId}/split'}

    def get_list_share(
            self, list_id, custom_headers=None, raw=False, **operation_config):
        """Get the shared users and user groups for a list.
        You must have created the list and have SharedBillLists Create
        permission
        or have BillListAdministrator Manage permission and the list is shared
        with anyone.

        :param list_id: The list identifier
        :type list_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ShareResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ShareResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_list_share.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ShareResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_list_share.metadata = {'url': '/api/v3/list/{listId}/share'}

    def edit_list_share(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Update the shared users and user groups for a list.
        To remove sharing completely set SharedWithEveryone to false,
        SharedUserIds to [], and SharedUserGroupIds to [].
        You must have created the list
        or have BillListAdministrator Manage permission and the list is shared
        with anyone
        or have SharedBillList Create permission and the list is shared with
        you.

        :param list_id: The list identifier
        :type list_id: int
        :param body: Users and user groups to share the list with
        :type body: ~energycap.sdk.models.ShareRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ShareResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ShareResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_list_share.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ShareRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ShareResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_list_share.metadata = {'url': '/api/v3/list/{listId}/share'}

    def edit_list_share_visibility(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Update the visibility of a list for the current user
        This must be a list you can see, which means
        you must have created the list
        or have BillListAdministrator Manage permission and the list is shared
        with anyone
        or have SharedBillLists View permission and the list is shared with
        you.

        :param list_id: The shared list identifier
        :type list_id: int
        :param body: Set shared list visibility
        :type body: ~energycap.sdk.models.ToggleVisible
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ListCreateResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ListCreateResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_list_share_visibility.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ToggleVisible')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ListCreateResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_list_share_visibility.metadata = {'url': '/api/v3/list/{listId}/visible'}

    def bill_list_custom_action(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Fires a custom bill action on a bill list.

        :param list_id: The bill list against which all of its bills will have
         the custom action performed
        :type list_id: int
        :param body:
        :type body: ~energycap.sdk.models.ListActionCustom
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: WebhookLogDetailsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.WebhookLogDetailsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.bill_list_custom_action.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionCustom')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('WebhookLogDetailsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    bill_list_custom_action.metadata = {'url': '/api/v3/list/{listId}/customAction'}

    def reverse_bill_list(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Reverses all bills on a bill list.

        :param list_id: The bill list that all bills will be reversed on
        :type list_id: int
        :param body: Batch settings for the reversed bill. If not provided,
         bills will be placed in the currently open batch.
        :type body: ~energycap.sdk.models.ListActionReverse
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.reverse_bill_list.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionReverse')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    reverse_bill_list.metadata = {'url': '/api/v3/list/{listId}/reverse'}

    def set_bill_list_accrual_exclusion(
            self, list_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Excludes or undoes exclusion of bills from accruals.

        :param list_id: The list whose bills will be excluded or have
         exclusion undone
        :type list_id: int
        :param body: Indicates whether or not the provided list should be
         excluded from accruals or should have exclusion undone
        :type body: ~energycap.sdk.models.ListActionAccrualExclusion
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.set_bill_list_accrual_exclusion.metadata['url']
        path_format_arguments = {
            'listId': self._serialize.url("list_id", list_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListActionAccrualExclusion')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    set_bill_list_accrual_exclusion.metadata = {'url': '/api/v3/list/{listId}/accrualExclusion'}

    def upgrade(
            self, custom_headers=None, raw=False, **operation_config):
        """Runs all applicable application upgrades.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.upgrade.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    upgrade.metadata = {'url': '/api/v3/me/upgrade'}

    def me_method(
            self, custom_headers=None, raw=False, **operation_config):
        """Initial session starting point. Support authorization via a api key,
        bearer token, or session cookie.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Me or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.Me or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.me_method.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Me', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    me_method.metadata = {'url': '/api/v3/me'}

    def update_me(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """

        :param body:
        :type body: ~energycap.sdk.models.MeRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Me or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.Me or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_me.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'MeRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Me', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    update_me.metadata = {'url': '/api/v3/me'}

    def create_meter(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates a meter.

        :param body: Data representing the meter being created
        :type body: ~energycap.sdk.models.MeterCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.MeterResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_meter.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'MeterCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_meter.metadata = {'url': '/api/v3/meter'}

    def get_meters(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves all meters.

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.MeterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meters.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_meters.metadata = {'url': '/api/v3/meter'}

    def get_meter(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves one meter.

        :param meter_id: The meter identifier for the meter being retrieved
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.MeterResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter.metadata = {'url': '/api/v3/meter/{meterId}'}

    def edit_meter(
            self, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits a meter.

        :param meter_id: The meter identifier for the meter being edited
        :type meter_id: int
        :param body: Data representing the meter being edited
        :type body: ~energycap.sdk.models.MeterEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.MeterResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_meter.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'MeterEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_meter.metadata = {'url': '/api/v3/meter/{meterId}'}

    def delete_meter(
            self, meter_id, delete_bills=None, custom_headers=None, raw=False, **operation_config):
        """Deletes a meter.

        :param meter_id: The identifier for the meter being deleted
        :type meter_id: int
        :param delete_bills: Should this cascade to delete any bills
         associated with this meter
        :type delete_bills: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_meter.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if delete_bills is not None:
            query_parameters['deleteBills'] = self._serialize.query("delete_bills", delete_bills, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_meter.metadata = {'url': '/api/v3/meter/{meterId}'}

    def edit_meter_ud_fs(
            self, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits a meter UDF values.

        :param meter_id: The identifier for the meter being edited
        :type meter_id: int
        :param body: Data representing the meter UDFs being edited
        :type body: list[~energycap.sdk.models.UDFValue]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.UDFFieldChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_meter_ud_fs.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[UDFValue]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UDFFieldChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_meter_ud_fs.metadata = {'url': '/api/v3/meter/{meterId}/udf'}

    def get_meter_udfs(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all UDFs for a particular meter.

        :param meter_id: The meter identifier for which UDF values are being
         retrieved
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.UDFFieldChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_udfs.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UDFFieldChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_udfs.metadata = {'url': '/api/v3/meter/{meterId}/udf'}

    def get_meters_udfs(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves all UDFs for all meters.

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.MeterUDFResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meters_udfs.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterUDFResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_meters_udfs.metadata = {'url': '/api/v3/meter/udf'}

    def get_meter_groups(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all Meter Groups for a particular meter.

        :param meter_id: The meter identifier for which group values are being
         retrieved
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.MeterGroupResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_groups.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterGroupResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_groups.metadata = {'url': '/api/v3/meter/{meterId}/group'}

    def edit_meter_group_membership(
            self, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits a meter's group memberships.
        Note that all groups a meter should belong to must be passed in.
        Passing in one group means that the meter will belong to one group
        only,
        even if it previously belonged to several.
        Only manual groups assignments can be changed; auto groups are
        unaffected.

        :param meter_id: The meter identifier whose group memberships are
         being edited
        :type meter_id: int
        :param body: The groups the meter will belong to
        :type body: list[~energycap.sdk.models.MeterGroupMember]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.MeterGroupResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_meter_group_membership.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[MeterGroupMember]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterGroupResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_meter_group_membership.metadata = {'url': '/api/v3/meter/{meterId}/group'}

    def get_meter_rates(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all rates for a particular meter.

        :param meter_id: The meter identifier for which rate values are being
         retrieved
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.MeterRateResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_rates.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterRateResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_rates.metadata = {'url': '/api/v3/meter/{meterId}/rate'}

    def get_meter_templates(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all templates for a particular meter.

        :param meter_id: The meter identifier for which template values are
         being retrieved
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.MeterTemplateResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_templates.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterTemplateResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_templates.metadata = {'url': '/api/v3/meter/{meterId}/template'}

    def get_meter_bills(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all bills for a particular meter.

        :param meter_id: The meter identifier for which bill values are being
         retrieved
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.MeterBillResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_bills.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterBillResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_bills.metadata = {'url': '/api/v3/meter/{meterId}/bill'}

    def get_ghg_meter_factors(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Get the ghg meter factors.

        :param meter_id: The meter identifier for ghg factors are being
         retrieved
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.GHGFactorsResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_ghg_meter_factors.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GHGFactorsResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_ghg_meter_factors.metadata = {'url': '/api/v3/meter/{meterId}/ghg/factor'}

    def get_calendarized_use_vs_weather_data(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Get calendarized Use vs Weather data.

        :param meter_id: The meter identifier
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.MeterCalendarizedUseVsWeatherResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_calendarized_use_vs_weather_data.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterCalendarizedUseVsWeatherResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_calendarized_use_vs_weather_data.metadata = {'url': '/api/v3/meter/{meterId}/usevsweather/calendarized'}

    def move_meter(
            self, parent_place_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Move list of meters to be under parentPlaceId.

        :param parent_place_id: The identifier for the new parent place
        :type parent_place_id: int
        :param body: List of meterIds to move under the parentPlaceId
        :type body: list[int]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.move_meter.metadata['url']
        path_format_arguments = {
            'parentPlaceId': self._serialize.url("parent_place_id", parent_place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[int]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    move_meter.metadata = {'url': '/api/v3/parentPlace/{parentPlaceId}/meter'}

    def edit_meter_serial_number_version(
            self, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """

        :param meter_id:
        :type meter_id: int
        :param body:
        :type body: ~energycap.sdk.models.MeterSerialNumberHistoryRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterSerialNumberHistoryResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.MeterSerialNumberHistoryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_meter_serial_number_version.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'MeterSerialNumberHistoryRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterSerialNumberHistoryResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_meter_serial_number_version.metadata = {'url': '/api/v3/meter/{meterId}/serialnumberversion'}

    def get_meter_actual_yearly_list(
            self, number_of_years=4, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up billing data by meter for a given range of years-
        Result includes cost, use, unit cost on an yearly basis.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.MeterDigestActualAndCalendarizedYearlyResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_actual_yearly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterDigestActualAndCalendarizedYearlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_meter_actual_yearly_list.metadata = {'url': '/api/v3/meter/digest/actual/yearly'}

    def get_meter_actual_yearly(
            self, meter_id, number_of_years=4, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data for a given meter for a given
        range of years- Result includes cost, use, unit cost on an yearly
        basis.

        :param meter_id: The identifier for the meter being retrieved
        :type meter_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterDigestActualAndCalendarizedYearlyResponse or
         ClientRawResponse if raw=true
        :rtype:
         ~energycap.sdk.models.MeterDigestActualAndCalendarizedYearlyResponse
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_actual_yearly.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterDigestActualAndCalendarizedYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_actual_yearly.metadata = {'url': '/api/v3/meter/{meterId}/digest/actual/yearly'}

    def get_meter_calendarized_yearly_list(
            self, number_of_years=4, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up calendarized data by meter for a given range of
        years- Result includes cost, use, unit cost on an yearly basis.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.MeterDigestActualAndCalendarizedYearlyResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_calendarized_yearly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterDigestActualAndCalendarizedYearlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_meter_calendarized_yearly_list.metadata = {'url': '/api/v3/meter/digest/calendarized/yearly'}

    def get_meter_calendarized_yearly(
            self, meter_id, number_of_years=4, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up calendarized billing data for a given meter for a
        given range of years- Result includes cost, use, unit cost on an yearly
        basis.

        :param meter_id: The identifier for the meter being retrieved
        :type meter_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterDigestActualAndCalendarizedYearlyResponse or
         ClientRawResponse if raw=true
        :rtype:
         ~energycap.sdk.models.MeterDigestActualAndCalendarizedYearlyResponse
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_calendarized_yearly.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterDigestActualAndCalendarizedYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_calendarized_yearly.metadata = {'url': '/api/v3/meter/{meterId}/digest/calendarized/yearly'}

    def get_meter_normalized_yearly_list(
            self, number_of_years=4, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up normalized data by meter for a given range of
        years- Result includes cost, use, unit cost on an yearly basis.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.MeterDigestNormalizedYearlyResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_normalized_yearly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterDigestNormalizedYearlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_meter_normalized_yearly_list.metadata = {'url': '/api/v3/meter/digest/normalized/yearly'}

    def get_meter_normalized_yearly(
            self, meter_id, number_of_years=4, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up normalized billing data for a given meter for a
        given range of years- Result includes cost, use, unit cost on an yearly
        basis.

        :param meter_id: The identifier for the meter being retrieved
        :type meter_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterDigestNormalizedYearlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.MeterDigestNormalizedYearlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_normalized_yearly.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterDigestNormalizedYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_normalized_yearly.metadata = {'url': '/api/v3/meter/{meterId}/digest/normalized/yearly'}

    def get_meter_savings_yearly_list(
            self, number_of_years=4, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves savings data by meter for a given number of years.

        :param number_of_years: Number of years of data to return including
         the current year - Defaults to 4
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.MeterDigestSavingsYearlyResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_savings_yearly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterDigestSavingsYearlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_meter_savings_yearly_list.metadata = {'url': '/api/v3/meter/digest/savings/yearly'}

    def get_meter_savings_yearly(
            self, meter_id, number_of_years=4, custom_headers=None, raw=False, **operation_config):
        """Retrieves savings data for a single meter for a given number of years.

        :param meter_id: The meter for which to return data
        :type meter_id: int
        :param number_of_years: Number of years of data to return including
         the current year - Defaults to 4
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterDigestSavingsYearlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.MeterDigestSavingsYearlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_savings_yearly.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterDigestSavingsYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_savings_yearly.metadata = {'url': '/api/v3/meter/{meterId}/digest/savings/yearly'}

    def get_meter_ghg_yearly_list(
            self, number_of_years=4, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves Greenhouse Gas data by meter for a given number of years.

        :param number_of_years: Number of years of data to return including
         the current year - Defaults to 4
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.MeterDigestGHGYearlyResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_ghg_yearly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterDigestGHGYearlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_meter_ghg_yearly_list.metadata = {'url': '/api/v3/meter/digest/ghg/yearly'}

    def get_meter_ghg_yearly(
            self, meter_id, number_of_years=4, custom_headers=None, raw=False, **operation_config):
        """Retrieves Greenhouse Gas data for a single meter for a given number of
        years.

        :param meter_id: The meter for which to return data
        :type meter_id: int
        :param number_of_years: Number of years of data to return including
         the current year - Defaults to 4
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterDigestGHGYearlyResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.MeterDigestGHGYearlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_ghg_yearly.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterDigestGHGYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_ghg_yearly.metadata = {'url': '/api/v3/meter/{meterId}/digest/ghg/yearly'}

    def get_meter_actual_monthly_list(
            self, number_of_years=2, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data by meter for a given range of
        months- Result includes cost, use, unit cost on a monthly basis.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years of months (24 for actual and
         savings, and 24 or 26 (if 13 accounting periods) for calendarized and
         normalized)
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.MeterDigestActualAndCalendarizedMonthlyResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_actual_monthly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterDigestActualAndCalendarizedMonthlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_meter_actual_monthly_list.metadata = {'url': '/api/v3/meter/digest/actual/monthly'}

    def get_meter_actual_monthly(
            self, meter_id, number_of_years=2, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data for a given meter for a given
        range of months- Result includes cost, use, unit cost on a monthly
        basis.

        :param meter_id: The identifier for the meter being retrieved
        :type meter_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years of months (24 for actual and
         savings, and 24 or 26 (if 13 accounting periods) for calendarized and
         normalized)
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterDigestActualAndCalendarizedMonthlyResponse or
         ClientRawResponse if raw=true
        :rtype:
         ~energycap.sdk.models.MeterDigestActualAndCalendarizedMonthlyResponse
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_actual_monthly.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterDigestActualAndCalendarizedMonthlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_actual_monthly.metadata = {'url': '/api/v3/meter/{meterId}/digest/actual/monthly'}

    def get_meter_calendarized_monthly_list(
            self, number_of_years=2, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up calendarized billing data by meter for a given
        range of months- Result includes cost, use, unit cost on a monthly
        basis.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years of months (24 for actual and
         savings, and 24 or 26 (if 13 accounting periods) for calendarized and
         normalized)
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.MeterDigestActualAndCalendarizedMonthlyResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_calendarized_monthly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterDigestActualAndCalendarizedMonthlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_meter_calendarized_monthly_list.metadata = {'url': '/api/v3/meter/digest/calendarized/monthly'}

    def get_meter_calendarized_monthly(
            self, meter_id, number_of_years=2, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up calendarized billing data for a given meter for a
        given range of months- Result includes cost, use, unit cost on a
        monthly basis.

        :param meter_id: The identifier for the meter being retrieved
        :type meter_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years of months (24 for actual and
         savings, and 24 or 26 (if 13 accounting periods) for calendarized and
         normalized)
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterDigestActualAndCalendarizedMonthlyResponse or
         ClientRawResponse if raw=true
        :rtype:
         ~energycap.sdk.models.MeterDigestActualAndCalendarizedMonthlyResponse
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_calendarized_monthly.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterDigestActualAndCalendarizedMonthlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_calendarized_monthly.metadata = {'url': '/api/v3/meter/{meterId}/digest/calendarized/monthly'}

    def get_meter_calendarized_trend(
            self, meter_id, number_of_years=2, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up calendarized billing data for a given meter for a
        given range of months- Result includes cost, use, unit cost on a
        monthly basis.

        :param meter_id: The identifier for the meter being retrieved
        :type meter_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years of months (24 for actual and
         savings, and 24 or 26 (if 13 accounting periods) for calendarized and
         normalized)
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterDigestCalendarizedTrendResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.MeterDigestCalendarizedTrendResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_calendarized_trend.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterDigestCalendarizedTrendResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_calendarized_trend.metadata = {'url': '/api/v3/meter/{meterId}/digest/calendarized/trend'}

    def get_meter_normalized_monthly_list(
            self, number_of_years=2, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up normalized billing data by meter for a given range
        of months- Result includes cost, use, unit cost on a monthly basis.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years of months (24 for actual and
         savings, and 24 or 26 (if 13 accounting periods) for calendarized and
         normalized)
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.MeterDigestNormalizedMonthlyResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_normalized_monthly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterDigestNormalizedMonthlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_meter_normalized_monthly_list.metadata = {'url': '/api/v3/meter/digest/normalized/monthly'}

    def get_meter_normalized_monthly(
            self, meter_id, number_of_years=2, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up normalized billing data for a given meter for a
        given range of months- Result includes cost, use, unit cost on a
        monthly basis.

        :param meter_id: The identifier for the meter being retrieved
        :type meter_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years of months (24 for actual and
         savings, and 24 or 26 (if 13 accounting periods) for calendarized and
         normalized)
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterDigestNormalizedMonthlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.MeterDigestNormalizedMonthlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_normalized_monthly.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterDigestNormalizedMonthlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_normalized_monthly.metadata = {'url': '/api/v3/meter/{meterId}/digest/normalized/monthly'}

    def get_meter_savings_monthly_list(
            self, number_of_years=2, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up savings billing data by meter for a given number of
        years- Result includes cost and use savings on a monthly basis.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years/24 months
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.MeterDigestSavingsMonthlyResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_savings_monthly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterDigestSavingsMonthlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_meter_savings_monthly_list.metadata = {'url': '/api/v3/meter/digest/savings/monthly'}

    def get_meter_savings_monthly(
            self, meter_id, number_of_years=2, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up savings billing data for a given meter for a given
        number of years- Result includes cost and use savings on a monthly
        basis.

        :param meter_id: The identifier for the meter being retrieved
        :type meter_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years/24 months
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterDigestSavingsMonthlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.MeterDigestSavingsMonthlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_savings_monthly.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterDigestSavingsMonthlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_savings_monthly.metadata = {'url': '/api/v3/meter/{meterId}/digest/savings/monthly'}

    def get_all_meter_groups(
            self, filter=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of meter groups.

        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.GroupMeterGroupResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_all_meter_groups.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GroupMeterGroupResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_all_meter_groups.metadata = {'url': '/api/v3/meterGroup'}

    def create_meter_group(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a meter group.

        :param body: Data representing the meter group being created
        :type body: ~energycap.sdk.models.MeterGroupRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GroupMeterGroupResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GroupMeterGroupResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_meter_group.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'MeterGroupRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GroupMeterGroupResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_meter_group.metadata = {'url': '/api/v3/meterGroup'}

    def get_meter_group(
            self, meter_group_id, custom_headers=None, raw=False, **operation_config):
        """Gets a meter group.

        :param meter_group_id:
        :type meter_group_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GroupMeterGroupResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GroupMeterGroupResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_group.metadata['url']
        path_format_arguments = {
            'meterGroupId': self._serialize.url("meter_group_id", meter_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GroupMeterGroupResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_group.metadata = {'url': '/api/v3/meterGroup/{meterGroupId}'}

    def delete_meter_group(
            self, meter_group_id, custom_headers=None, raw=False, **operation_config):
        """Delete a user-created meter group.

        :param meter_group_id:
        :type meter_group_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_meter_group.metadata['url']
        path_format_arguments = {
            'meterGroupId': self._serialize.url("meter_group_id", meter_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_meter_group.metadata = {'url': '/api/v3/meterGroup/{meterGroupId}'}

    def edit_meter_group(
            self, meter_group_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit a meter group.

        :param meter_group_id: Id of the group to edit
        :type meter_group_id: int
        :param body: Data representing the meter group being edited
        :type body: ~energycap.sdk.models.MeterGroupRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GroupMeterGroupResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GroupMeterGroupResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_meter_group.metadata['url']
        path_format_arguments = {
            'meterGroupId': self._serialize.url("meter_group_id", meter_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'MeterGroupRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GroupMeterGroupResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_meter_group.metadata = {'url': '/api/v3/meterGroup/{meterGroupId}'}

    def get_meter_categories(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of meter categories.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.MeterCategoryResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_categories.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterCategoryResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_categories.metadata = {'url': '/api/v3/meterGroup/category'}

    def create_meter_category(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a meter group category.

        :param body: Data representing the meter group category being created
        :type body: ~energycap.sdk.models.MeterCategoryRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterCategoryResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.MeterCategoryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_meter_category.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'MeterCategoryRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterCategoryResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_meter_category.metadata = {'url': '/api/v3/meterGroup/category'}

    def get_meter_category(
            self, category_id, custom_headers=None, raw=False, **operation_config):
        """Retrieve a meter group category.

        :param category_id: The identifier for the meter group category being
         retrieved
        :type category_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterCategoryResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.MeterCategoryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_category.metadata['url']
        path_format_arguments = {
            'categoryId': self._serialize.url("category_id", category_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterCategoryResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_category.metadata = {'url': '/api/v3/meterGroup/category/{categoryId}'}

    def edit_meter_category(
            self, category_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Update a meter group category.

        :param category_id: Id of the category to update
        :type category_id: int
        :param body: Data to update the meter group category
        :type body: ~energycap.sdk.models.MeterCategoryRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterCategoryResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.MeterCategoryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_meter_category.metadata['url']
        path_format_arguments = {
            'categoryId': self._serialize.url("category_id", category_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'MeterCategoryRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterCategoryResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_meter_category.metadata = {'url': '/api/v3/meterGroup/category/{categoryId}'}

    def delete_meter_category(
            self, category_id, custom_headers=None, raw=False, **operation_config):
        """Delete a meter group category.

        :param category_id: Id of the category to delete
        :type category_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_meter_category.metadata['url']
        path_format_arguments = {
            'categoryId': self._serialize.url("category_id", category_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_meter_category.metadata = {'url': '/api/v3/meterGroup/category/{categoryId}'}

    def get_meter_group_members(
            self, group_id, always_limit_by_topmost=False, custom_headers=None, raw=False, **operation_config):
        """Gets a list of meter group members.

        :param group_id:
        :type group_id: int
        :param always_limit_by_topmost:
        :type always_limit_by_topmost: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.MeterGroupMemberChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_group_members.metadata['url']
        path_format_arguments = {
            'groupId': self._serialize.url("group_id", group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if always_limit_by_topmost is not None:
            query_parameters['alwaysLimitByTopmost'] = self._serialize.query("always_limit_by_topmost", always_limit_by_topmost, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterGroupMemberChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_group_members.metadata = {'url': '/api/v3/meterGroup/{groupId}/member'}

    def update_meter_group_member(
            self, meter_group_id, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Update a group member's include in charts flag.

        :param meter_group_id:
        :type meter_group_id: int
        :param meter_id:
        :type meter_id: int
        :param body:
        :type body: ~energycap.sdk.models.GroupMemberRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: MeterGroupMemberChild or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.MeterGroupMemberChild or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_meter_group_member.metadata['url']
        path_format_arguments = {
            'meterGroupId': self._serialize.url("meter_group_id", meter_group_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'GroupMemberRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterGroupMemberChild', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    update_meter_group_member.metadata = {'url': '/api/v3/meterGroup/{meterGroupId}/member/{meterId}'}

    def include_all_meter_group_member_in_charts(
            self, meter_group_id, custom_headers=None, raw=False, **operation_config):
        """Include all group members in charts.

        :param meter_group_id:
        :type meter_group_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.include_all_meter_group_member_in_charts.metadata['url']
        path_format_arguments = {
            'meterGroupId': self._serialize.url("meter_group_id", meter_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    include_all_meter_group_member_in_charts.metadata = {'url': '/api/v3/meterGroup/{meterGroupId}/member/includeInCharts'}

    def get_user_defined_auto_meter_group_filters(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of filters that can be used to create Meter Groups.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.FilterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_user_defined_auto_meter_group_filters.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[FilterResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_user_defined_auto_meter_group_filters.metadata = {'url': '/api/v3/meterGroup/filters'}

    def recalculate_user_meter_auto_group_memebership(
            self, meter_group_id, custom_headers=None, raw=False, **operation_config):
        """Refreshes group membership for a user defined auto group.

        :param meter_group_id: The meter group to refresh
        :type meter_group_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GroupMeterGroupResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GroupMeterGroupResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.recalculate_user_meter_auto_group_memebership.metadata['url']
        path_format_arguments = {
            'meterGroupId': self._serialize.url("meter_group_id", meter_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GroupMeterGroupResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    recalculate_user_meter_auto_group_memebership.metadata = {'url': '/api/v3/meterGroup/{meterGroupId}/updateUserAutoGroup'}

    def recalculate_all_user_meter_auto_groups_membership(
            self, custom_headers=None, raw=False, **operation_config):
        """Refreshes group membership for all user defined auto groups.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.recalculate_all_user_meter_auto_groups_membership.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    recalculate_all_user_meter_auto_groups_membership.metadata = {'url': '/api/v3/meterGroup/updateUserAutoGroups'}

    def get_meter_group_ranking(
            self, group_id, data_view, chart, billing_period_option=None, start_period=None, end_period=None, commodity_id=None, high_to_low_ranking=None, show_excluded_members=None, show_zero_averages=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves cost, use, unit cost or demand per day ranking data by meter
        group.

        Specify values for any query parameters whose database values are to be
        overridden.
        **PLEASE NOTE: As shown in the table below, this API endpoint returns
        different response types based on the "chart" value. Despite what you
        see below regarding HTTP status codes for each response type, _all_ of
        these response types will return 200 OK.**
        |  Chart   |              Response Type               |
        | -------- | ---------------------------------------- |
        | cost     | MeterGroupDigestRankingResponseDTO       |
        | use      | MeterGroupDigestRankingResponseDTO       |
        | unitCost | MeterGroupDigestRankingResponseDTO       |
        | demand   | MeterGroupDigestDemandRankingResponseDTO |.

        :param group_id: The meter group to retrieve data for
        :type group_id: int
        :param data_view: The desired data view - actual, calendarized,
         normalized. Possible values include: 'actual', 'calendarized',
         'normalized'
        :type data_view: str
        :param chart: The desired chart - cost, use, unitcost, demand.
         Possible values include: 'cost', 'use', 'demand', 'unitCost'
        :type chart: str
        :param billing_period_option: The billing period option -
         last12periods, lastyear, lastfiscalyear, custom (optional). Possible
         values include: 'last12Periods', 'lastYear', 'lastFiscalYear',
         'custom'
        :type billing_period_option: str
        :param start_period: The custom start period (optional)
        :type start_period: int
        :param end_period: The custom end period (optional)
        :type end_period: int
        :param commodity_id: Id of commodity to filter by (optional)
        :type commodity_id: int
        :param high_to_low_ranking: Ranking from high to low, or low to high?
         (optional)
        :type high_to_low_ranking: bool
        :param show_excluded_members: Show group members excluded from the
         group? (optional)
        :type show_excluded_members: bool
        :param show_zero_averages: Show group members whose ranking averages
         are zero? (optional)
        :type show_zero_averages: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_meter_group_ranking.metadata['url']
        path_format_arguments = {
            'groupId': self._serialize.url("group_id", group_id, 'int'),
            'dataView': self._serialize.url("data_view", data_view, 'str'),
            'chart': self._serialize.url("chart", chart, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if billing_period_option is not None:
            query_parameters['billingPeriodOption'] = self._serialize.query("billing_period_option", billing_period_option, 'str')
        if start_period is not None:
            query_parameters['startPeriod'] = self._serialize.query("start_period", start_period, 'int')
        if end_period is not None:
            query_parameters['endPeriod'] = self._serialize.query("end_period", end_period, 'int')
        if commodity_id is not None:
            query_parameters['commodityId'] = self._serialize.query("commodity_id", commodity_id, 'int')
        if high_to_low_ranking is not None:
            query_parameters['highToLowRanking'] = self._serialize.query("high_to_low_ranking", high_to_low_ranking, 'bool')
        if show_excluded_members is not None:
            query_parameters['showExcludedMembers'] = self._serialize.query("show_excluded_members", show_excluded_members, 'bool')
        if show_zero_averages is not None:
            query_parameters['showZeroAverages'] = self._serialize.query("show_zero_averages", show_zero_averages, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MeterGroupDigestRankingResponse', response)
        if response.status_code == 201:
            deserialized = self._deserialize('MeterGroupDigestDemandRankingResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_meter_group_ranking.metadata = {'url': '/api/v3/meterGroup/{groupId}/digest/{dataView}/{chart}'}

    def create_readings(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates new readings.

        :param body: Data representing the readings being imported
        :type body: list[~energycap.sdk.models.ReadingCreate]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ReadingResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ReadingResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_readings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[ReadingCreate]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReadingResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_readings.metadata = {'url': '/api/v3/reading'}

    def delete_readings(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Deletes one or more sets of meter readings.
        Each set of meter readings to be deleted is on one channel and covers a
        time range signified by a begin and end date and time.
        The time range includes all readings greater than the begin time and
        less than or equal to the end date and time.
        To delete only one reading, set the begin and end date and time to the
        same value.

        :param body: The channel id, begin date and time and end date and time
         of the set of meter readings to be deleted
        :type body: list[~energycap.sdk.models.ReadingDelete]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DeleteReadingResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.DeleteReadingResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_readings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[ReadingDelete]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DeleteReadingResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    delete_readings.metadata = {'url': '/api/v3/reading'}

    def get_readings(
            self, channel_id, begin_date=None, end_date=None, original_value=False, custom_headers=None, raw=False, **operation_config):
        """Retrieves an array of readings.

        :param channel_id: Specific Channel ID
        :type channel_id: int
        :param begin_date: The starting date of readings to return
        :type begin_date: datetime
        :param end_date: The end date of readings to return
        :type end_date: datetime
        :param original_value: If 'true', returns the original observation
         value. If 'false' returns the computed observation value based on the
         channel type. NOTE: this parameter is no longer used and has been
         deprecated.
        :type original_value: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Readings or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.Readings or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_readings.metadata['url']
        path_format_arguments = {
            'channelId': self._serialize.url("channel_id", channel_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if begin_date is not None:
            query_parameters['beginDate'] = self._serialize.query("begin_date", begin_date, 'iso-8601')
        if end_date is not None:
            query_parameters['endDate'] = self._serialize.query("end_date", end_date, 'iso-8601')
        if original_value is not None:
            query_parameters['originalValue'] = self._serialize.query("original_value", original_value, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Readings', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_readings.metadata = {'url': '/api/v3/channel/{channelId}/reading'}

    def delete_single_reading(
            self, reading_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a single interval data reading by its ID.

        :param reading_id: Unique ID of the reading to delete
        :type reading_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_single_reading.metadata['url']
        path_format_arguments = {
            'readingId': self._serialize.url("reading_id", reading_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_single_reading.metadata = {'url': '/api/v3/reading/{readingId}'}

    def edit_single_reading(
            self, reading_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits a single interval data reading.
        Duplicate timestamps are not allowed for readings on a given channel.
        If the reading being edited has the same timestamp as another reading
        on the same channel, this end point throws an error.

        :param reading_id: Unique ID of the reading to edit
        :type reading_id: long
        :param body: Updated reading properties
        :type body: ~energycap.sdk.models.Reading
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ReadingsObservation or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ReadingsObservation or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_single_reading.metadata['url']
        path_format_arguments = {
            'readingId': self._serialize.url("reading_id", reading_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'Reading')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReadingsObservation', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_single_reading.metadata = {'url': '/api/v3/reading/{readingId}'}

    def get_observation_types(
            self, filter=None, custom_headers=None, raw=False, **operation_config):
        """Get the observation types for a given noun class code and/or noun code.

        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.ObservationTypeChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_observation_types.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ObservationTypeChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_observation_types.metadata = {'url': '/api/v3/observationtype'}

    def get_place(
            self, place_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves one place.

        :param place_id: The identifier for the place being retrieved
        :type place_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.PlaceResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place.metadata = {'url': '/api/v3/place/{placeId}'}

    def edit_place(
            self, place_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits a place.

        :param place_id: The identifier for the place being edited
        :type place_id: int
        :param body: Data representing the place being edited
        :type body: ~energycap.sdk.models.PlaceEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.PlaceResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_place.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'PlaceEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_place.metadata = {'url': '/api/v3/place/{placeId}'}

    def delete_place(
            self, place_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a place.

        :param place_id: The identifier for the place being deleted
        :type place_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_place.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_place.metadata = {'url': '/api/v3/place/{placeId}'}

    def get_places(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves all places.

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PlaceResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_places.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_places.metadata = {'url': '/api/v3/place'}

    def create_place(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates a place.

        :param body: Data representing the place being created
        :type body: ~energycap.sdk.models.PlaceCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.PlaceResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_place.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'PlaceCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_place.metadata = {'url': '/api/v3/place'}

    def edit_place_ud_fs(
            self, place_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits a place UDF values.

        :param place_id: The identifier for the place being edited
        :type place_id: int
        :param body: Data representing the place UDFs being edited
        :type body: list[~energycap.sdk.models.UDFValue]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.UDFFieldChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_place_ud_fs.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[UDFValue]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UDFFieldChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_place_ud_fs.metadata = {'url': '/api/v3/place/{placeId}/udf'}

    def get_place_udfs(
            self, place_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all UDFs for a particular place.

        :param place_id: The place identifier for which UDF values are being
         retrieved
        :type place_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.UDFFieldChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_udfs.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UDFFieldChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_udfs.metadata = {'url': '/api/v3/place/{placeId}/udf'}

    def get_place_sizes(
            self, place_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all place size records for a particular place.

        :param place_id: The identifier for the place being retrieved
        :type place_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PlaceSizeChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_sizes.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceSizeChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_sizes.metadata = {'url': '/api/v3/place/{placeId}/size'}

    def create_place_size(
            self, place_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates a place size version
        If a preceding place size version exists, the preceding record's end
        date will be changed to match the created record's begin date
        If a succeeding place size version exists the created records end date
        will match the succeeding version's begin date.

        :param place_id: The identifier of the place to add a place size to
        :type place_id: int
        :param body: Data representing the place size being created
        :type body: ~energycap.sdk.models.PlaceSizeCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceSizeChild or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.PlaceSizeChild or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_place_size.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'PlaceSizeCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceSizeChild', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_place_size.metadata = {'url': '/api/v3/place/{placeId}/size'}

    def edit_place_size_list(
            self, place_id, body=None, custom_headers=None, raw=False, **operation_config):
        """API endpoint which takes care of Create, Edit and Delete of new place
        sizes in bulk.

        :param place_id: The identifier of the place
        :type place_id: int
        :param body: Data representing the place size being created
        :type body: list[~energycap.sdk.models.PlaceSizeCreate]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PlaceSizeChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_place_size_list.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[PlaceSizeCreate]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceSizeChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_place_size_list.metadata = {'url': '/api/v3/place/{placeId}/size'}

    def get_place_size(
            self, place_id, place_size_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves a place size record for a particular place.

        :param place_id: The identifier for the place being retrieved
        :type place_id: int
        :param place_size_id: The identifier for the place size being
         retrieved
        :type place_size_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceSizeChild or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.PlaceSizeChild or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_size.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int'),
            'placeSizeId': self._serialize.url("place_size_id", place_size_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceSizeChild', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_size.metadata = {'url': '/api/v3/place/{placeId}/size/{placeSizeId}'}

    def delete_place_size(
            self, place_id, place_size_id, custom_headers=None, raw=False, **operation_config):
        """Delete a place size version
        The preceding version's end date will be shifted to the deleted
        record's end date to prevent any gaps.

        :param place_id: The identifier of the place
        :type place_id: int
        :param place_size_id: The identifier of the place size
        :type place_size_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_place_size.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int'),
            'placeSizeId': self._serialize.url("place_size_id", place_size_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_place_size.metadata = {'url': '/api/v3/place/{placeId}/size/{placeSizeId}'}

    def get_place_types(
            self, filter=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves all place types.

        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PlaceTypeResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_types.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceTypeResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_types.metadata = {'url': '/api/v3/place/placetype'}

    def create_place_type(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a place type.

        New place types will not be considered structures.

        :param body: Definition of new place type
        :type body: ~energycap.sdk.models.PlaceTypeRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceTypeResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.PlaceTypeResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_place_type.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'PlaceTypeRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceTypeResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_place_type.metadata = {'url': '/api/v3/place/placetype'}

    def get_place_type(
            self, place_type_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves one place type.

        :param place_type_id: Unique identifier for the place type
        :type place_type_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceTypeResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.PlaceTypeResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_type.metadata['url']
        path_format_arguments = {
            'placeTypeId': self._serialize.url("place_type_id", place_type_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceTypeResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_type.metadata = {'url': '/api/v3/place/placetype/{placeTypeId}'}

    def edit_place_type(
            self, place_type_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit a current place type.

        :param place_type_id: Unique identifier for the place type
        :type place_type_id: int
        :param body: Definition of new place type
        :type body: ~energycap.sdk.models.PlaceTypeRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceTypeResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.PlaceTypeResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_place_type.metadata['url']
        path_format_arguments = {
            'placeTypeId': self._serialize.url("place_type_id", place_type_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'PlaceTypeRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceTypeResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_place_type.metadata = {'url': '/api/v3/place/placetype/{placeTypeId}'}

    def delete_place_type(
            self, place_type_id, custom_headers=None, raw=False, **operation_config):
        """Deletes the place type.

        :param place_type_id: Unique identifier for the place type
        :type place_type_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_place_type.metadata['url']
        path_format_arguments = {
            'placeTypeId': self._serialize.url("place_type_id", place_type_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_place_type.metadata = {'url': '/api/v3/place/placetype/{placeTypeId}'}

    def get_places_udfs(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves all UDFs for all places.

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PlaceUDFResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_places_udfs.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceUDFResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_places_udfs.metadata = {'url': '/api/v3/place/udf'}

    def get_place_groups(
            self, place_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all Place Groups for a particular place by placeId.

        :param place_id: The place identifier for which group values are being
         retrieved
        :type place_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PlaceGroupResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_groups.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceGroupResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_groups.metadata = {'url': '/api/v3/place/{placeId}/group'}

    def edit_place_group_membership(
            self, place_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits a place's group memberships.
        Note that all groups a place should belong to must be passed in.
        Passing in one group means that the place will belong to one group
        only,
        even if it previously belonged to several.
        Only manual groups assignments can be changed; auto groups are
        unaffected.

        :param place_id: The place identifier whose group memberships are
         being edited
        :type place_id: int
        :param body: The groups the place will belong to
        :type body: list[~energycap.sdk.models.PlaceGroupMember]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PlaceGroupResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_place_group_membership.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[PlaceGroupMember]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceGroupResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_place_group_membership.metadata = {'url': '/api/v3/place/{placeId}/group'}

    def get_energy_projects_for_place(
            self, place_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all Energy Projects for a particular place by placeId. For
        organizations it will be the rollup of its children's energy projects.

        :param place_id: The place identifier for which energy projects are
         being retrieved
        :type place_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.EnergyProjectResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_energy_projects_for_place.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[EnergyProjectResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_energy_projects_for_place.metadata = {'url': '/api/v3/place/{placeId}/project'}

    def move_place(
            self, parent_place_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Move list of places to be under parentPlaceId.

        :param parent_place_id: The identifier for the new parent place
        :type parent_place_id: int
        :param body: List of placeIds to move under the parentPlaceId
        :type body: list[int]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UpdateResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UpdateResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.move_place.metadata['url']
        path_format_arguments = {
            'parentPlaceId': self._serialize.url("parent_place_id", parent_place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[int]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpdateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    move_place.metadata = {'url': '/api/v3/parentPlace/{parentPlaceId}/place'}

    def get_energy_star_place_link(
            self, place_id, custom_headers=None, raw=False, **operation_config):
        """Get the ENERGY STAR linking information for this place and its meters.
        PmPropertyId and PmMeterId will be null if no link yet exists.

        :param place_id: The place identifier
        :type place_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EnergyStarPlaceLinkResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.EnergyStarPlaceLinkResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_energy_star_place_link.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EnergyStarPlaceLinkResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_energy_star_place_link.metadata = {'url': '/api/v3/place/{placeId}/energyStar/link'}

    def edit_energy_star_place_link(
            self, place_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit the ENERGY STAR linking information for this place and its meters.
        Set PmPropertyId/PmMeterId to null to unlink a property/meter.

        :param place_id: The place identifier
        :type place_id: int
        :param body: Data representing the place link being edited
        :type body: ~energycap.sdk.models.EnergyStarPlaceLinkRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EnergyStarPlaceLinkResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.EnergyStarPlaceLinkResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_energy_star_place_link.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'EnergyStarPlaceLinkRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EnergyStarPlaceLinkResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_energy_star_place_link.metadata = {'url': '/api/v3/place/{placeId}/energyStar/link'}

    def get_energy_star_place_hierarchy(
            self, place_id, custom_headers=None, raw=False, **operation_config):
        """Get this place's ENERGY STAR child places.

        :param place_id: The place identifier
        :type place_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.EnergyStarPlaceHierarchyResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_energy_star_place_hierarchy.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[EnergyStarPlaceHierarchyResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_energy_star_place_hierarchy.metadata = {'url': '/api/v3/place/{placeId}/energyStar/hierarchy'}

    def get_energy_star_place(
            self, place_id, verbose=True, custom_headers=None, raw=False, **operation_config):
        """Get the ENERGY STAR info for a place.

        :param place_id: The place identifier
        :type place_id: int
        :param verbose: true by default.
         When set to false the API will perform faster but will only retrieve
         PmPropertyId and PmPropertyName from Portfolio Manager.
         PmPropertyUseType, PmFloorArea, PmFloorAreaUnits will be null.
        :type verbose: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EnergyStarPmProperty or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.EnergyStarPmProperty or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_energy_star_place.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if verbose is not None:
            query_parameters['verbose'] = self._serialize.query("verbose", verbose, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EnergyStarPmProperty', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_energy_star_place.metadata = {'url': '/api/v3/place/{placeId}/energyStar'}

    def get_energy_star_place_metrics(
            self, place_id, number_of_years=2, custom_headers=None, raw=False, **operation_config):
        """Get the ENERGY STAR metrics for a place.

        :param place_id: The place identifier
        :type place_id: int
        :param number_of_years: The number of years to go back from most
         recent score. Defaults to 2 years. If 0 is provided, will only include
         current score.
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EnergyStarPlaceHierarchyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.EnergyStarPlaceHierarchyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_energy_star_place_metrics.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int', maximum=2147483647, minimum=0)

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EnergyStarPlaceHierarchyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_energy_star_place_metrics.metadata = {'url': '/api/v3/place/{placeId}/energyStar/metrics'}

    def get_place_benchmark_settings(
            self, custom_headers=None, raw=False, **operation_config):
        """Get all the place benchmark names and categories for the owner.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BenchmarkSettingsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BenchmarkSettingsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_benchmark_settings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BenchmarkSettingsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_benchmark_settings.metadata = {'url': '/api/v3/placeBenchmark/setting'}

    def edit_place_benchmark_settings(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """The user can edit the category and name for each benchmark
        If a benchmark has not been configured, it is configured
        User cannot delete a benchmark from this endpoint
        If the benchmark dto is null or not passed the API will ignore it
        If the benchmark dto is not null, the category and name are required.

        :param body: Dto containing what to edit on benchmark
        :type body: ~energycap.sdk.models.BenchmarkSettingsEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BenchmarkSettingsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BenchmarkSettingsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_place_benchmark_settings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BenchmarkSettingsEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BenchmarkSettingsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_place_benchmark_settings.metadata = {'url': '/api/v3/placeBenchmark/setting'}

    def delete_place_benchmark_setting(
            self, benchmark_indicator, custom_headers=None, raw=False, **operation_config):
        """Delete the settings for the place benchmark defined by the
        benchmarkIndicator.
        Deletes all corresponding place benchmark values that were defined for
        that indicator.
        Updates user-defined autogroup membership for groups that contained
        filters for that indicator.

        :param benchmark_indicator: Indicator for the benchmark
        :type benchmark_indicator: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_place_benchmark_setting.metadata['url']
        path_format_arguments = {
            'benchmarkIndicator': self._serialize.url("benchmark_indicator", benchmark_indicator, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_place_benchmark_setting.metadata = {'url': '/api/v3/placeBenchmark/{benchmarkIndicator}/setting'}

    def get_place_benchmark_categories(
            self, custom_headers=None, raw=False, **operation_config):
        """Get all place benchmark categories in the database.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BenchmarkCategoryResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_benchmark_categories.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[BenchmarkCategoryResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_benchmark_categories.metadata = {'url': '/api/v3/placeBenchmark/category'}

    def edit_place_benchmark_values(
            self, benchmark_indicator, place_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit all values for a benchmark factor on a place.

        :param benchmark_indicator: Indicator for the benchmark
        :type benchmark_indicator: int
        :param place_id:
        :type place_id: int
        :param body:
        :type body: list[~energycap.sdk.models.BenchmarkValueRequest]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BenchmarkValuesResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BenchmarkValuesResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_place_benchmark_values.metadata['url']
        path_format_arguments = {
            'benchmarkIndicator': self._serialize.url("benchmark_indicator", benchmark_indicator, 'int'),
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[BenchmarkValueRequest]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BenchmarkValuesResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_place_benchmark_values.metadata = {'url': '/api/v3/placeBenchmark/{benchmarkIndicator}/place/{placeId}'}

    def get_benchmark_values(
            self, benchmark_indicator, place_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves benchmark values for a place.

        :param benchmark_indicator: Indicator for the benchmark
        :type benchmark_indicator: int
        :param place_id: Identifier for the place
        :type place_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BenchmarkValuesResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BenchmarkValuesResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_benchmark_values.metadata['url']
        path_format_arguments = {
            'benchmarkIndicator': self._serialize.url("benchmark_indicator", benchmark_indicator, 'int'),
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BenchmarkValuesResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_benchmark_values.metadata = {'url': '/api/v3/placeBenchmark/{benchmarkIndicator}/place/{placeId}/benchmarkValue'}

    def create_place_benchmark_value(
            self, benchmark_indicator, place_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates a place benchmark value
        If a preceding benchmark value exists, the preceding record's end date
        will be changed to match the created records begin date
        If a succeeding benchmark value exists, the created record's end date
        will match the succeeding benchmarks begin date.

        :param benchmark_indicator: Indicator for the benchmark, can be 1, 2,
         or 3
        :type benchmark_indicator: int
        :param place_id: The place that the benchmark is on
        :type place_id: int
        :param body: The new begin date and value for the benchmark
        :type body: ~energycap.sdk.models.BenchmarkValueRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BenchmarkValuesResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BenchmarkValuesResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_place_benchmark_value.metadata['url']
        path_format_arguments = {
            'benchmarkIndicator': self._serialize.url("benchmark_indicator", benchmark_indicator, 'int'),
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BenchmarkValueRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BenchmarkValuesResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_place_benchmark_value.metadata = {'url': '/api/v3/placeBenchmark/{benchmarkIndicator}/place/{placeId}/benchmarkValue'}

    def delete_benchmark_value(
            self, benchmark_indicator, place_id, place_benchmark_id, custom_headers=None, raw=False, **operation_config):
        """Delete a single benchmark value.
        If a preceding benchmark value exists, the preceding records end date
        will be changed to prevent any gaps in benchmark values.

        :param benchmark_indicator: Indicator for the benchmark
        :type benchmark_indicator: int
        :param place_id: Indicator for the place
        :type place_id: int
        :param place_benchmark_id: Indicator for the individual benchmark
         value
        :type place_benchmark_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_benchmark_value.metadata['url']
        path_format_arguments = {
            'benchmarkIndicator': self._serialize.url("benchmark_indicator", benchmark_indicator, 'int'),
            'placeId': self._serialize.url("place_id", place_id, 'int'),
            'placeBenchmarkId': self._serialize.url("place_benchmark_id", place_benchmark_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_benchmark_value.metadata = {'url': '/api/v3/placeBenchmark/{benchmarkIndicator}/place/{placeId}/benchmarkValue/{placeBenchmarkId}'}

    def update_place_benchmark_value(
            self, benchmark_indicator, place_id, place_benchmark_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Updates a place benchmark value
        If the begin date is being modified, the following will happen:
        * Records that now precede and previously preceded this benchmark will
        have their end dates modified to prevent gaps in benchmarks
        * If a succeeding benchmark value exists for the new begin date, the
        end date will be modified to match the succeeding benchmarks end date.

        :param benchmark_indicator: Indicator for the benchmark, can be 1, 2,
         or 3
        :type benchmark_indicator: int
        :param place_id: The place that the benchmark is on
        :type place_id: int
        :param place_benchmark_id: The identifier for the benchmark being
         updated
        :type place_benchmark_id: int
        :param body: The new begin date and value for the benchmark
        :type body: ~energycap.sdk.models.BenchmarkValueRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BenchmarkValuesResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BenchmarkValuesResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_place_benchmark_value.metadata['url']
        path_format_arguments = {
            'benchmarkIndicator': self._serialize.url("benchmark_indicator", benchmark_indicator, 'int'),
            'placeId': self._serialize.url("place_id", place_id, 'int'),
            'placeBenchmarkId': self._serialize.url("place_benchmark_id", place_benchmark_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BenchmarkValueRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BenchmarkValuesResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    update_place_benchmark_value.metadata = {'url': '/api/v3/placeBenchmark/{benchmarkIndicator}/place/{placeId}/benchmarkValue/{placeBenchmarkId}'}

    def get_place_actual_yearly_list(
            self, number_of_years=4, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data by building/organization for a
        given number of years- Result includes cost, use, unit cost on an
        yearly basis. It also includes target comparison data and commodity
        level break up.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.PlaceDigestActualAndCalendarizedYearlyResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_actual_yearly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceDigestActualAndCalendarizedYearlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_place_actual_yearly_list.metadata = {'url': '/api/v3/place/digest/actual/yearly'}

    def get_place_actual_yearly(
            self, place_id, number_of_years=4, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data by building/organization for a
        given number of years- Result includes cost, use, unit cost on an
        yearly basis. It also includes target comparison data and commodity
        level break up.

        :param place_id: The place to retrieve data for
        :type place_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceDigestActualAndCalendarizedYearlyResponse or
         ClientRawResponse if raw=true
        :rtype:
         ~energycap.sdk.models.PlaceDigestActualAndCalendarizedYearlyResponse
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_actual_yearly.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceDigestActualAndCalendarizedYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_actual_yearly.metadata = {'url': '/api/v3/place/{placeId}/digest/actual/yearly'}

    def get_place_calendarized_yearly_list(
            self, number_of_years=4, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up calendarized billing data by building/organization
        for a given number of years- Result includes cost, use, unit cost on an
        yearly basis. It also includes target comparison data and commodity
        level break up.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.PlaceDigestActualAndCalendarizedYearlyResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_calendarized_yearly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceDigestActualAndCalendarizedYearlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_place_calendarized_yearly_list.metadata = {'url': '/api/v3/place/digest/calendarized/yearly'}

    def get_place_calendarized_yearly(
            self, place_id, number_of_years=4, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up calendarized billing data by building/organization
        for a given number of years- Result includes cost, use, unit cost on an
        yearly basis. It also includes target comparison data and commodity
        level break up.

        :param place_id: The place to retrieve data for
        :type place_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceDigestActualAndCalendarizedYearlyResponse or
         ClientRawResponse if raw=true
        :rtype:
         ~energycap.sdk.models.PlaceDigestActualAndCalendarizedYearlyResponse
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_calendarized_yearly.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceDigestActualAndCalendarizedYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_calendarized_yearly.metadata = {'url': '/api/v3/place/{placeId}/digest/calendarized/yearly'}

    def get_place_normalized_yearly_list(
            self, number_of_years=4, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up normalized billing data by building/organization
        for a given number of years- Result include use on an yearly basis. It
        also includes target comparison data and commodity level break up.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.PlaceDigestNormalizedYearlyResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_normalized_yearly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceDigestNormalizedYearlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_place_normalized_yearly_list.metadata = {'url': '/api/v3/place/digest/normalized/yearly'}

    def get_place_normalized_yearly(
            self, place_id, number_of_years=4, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up normalized billing data by building/organization
        for a given number of years- Result includes cost, use, unit cost on an
        yearly basis. It also includes target comparison data and commodity
        level break up.

        :param place_id: The place to retrieve data for
        :type place_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceDigestNormalizedYearlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.PlaceDigestNormalizedYearlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_normalized_yearly.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceDigestNormalizedYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_normalized_yearly.metadata = {'url': '/api/v3/place/{placeId}/digest/normalized/yearly'}

    def get_place_savings_yearly_list(
            self, number_of_years=4, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up savings billing data by building/organization for a
        given number of years- Result includes cost, use, unit cost on an
        yearly basis. It also includes a commodity level break up.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PlaceDigestSavingsYearlyResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_savings_yearly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceDigestSavingsYearlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_place_savings_yearly_list.metadata = {'url': '/api/v3/place/digest/savings/yearly'}

    def get_place_savings_yearly(
            self, place_id, number_of_years=4, custom_headers=None, raw=False, **operation_config):
        """

        :param place_id:
        :type place_id: int
        :param number_of_years:
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceDigestSavingsYearlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.PlaceDigestSavingsYearlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_savings_yearly.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceDigestSavingsYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_savings_yearly.metadata = {'url': '/api/v3/place/{placeId}/digest/savings/yearly'}

    def get_place_actual_monthly_list(
            self, number_of_years=2, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data by building/organization for a
        given number of years- Result includes cost, use, unit cost on a
        monthly basis. It also includes target comparison data and commodity
        level break up.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years of months (24 for actual and
         savings, and 24 or 26 (if 13 accounting periods) for calendarized and
         normalized)
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.PlaceDigestActualAndCalendarizedMonthlyResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_actual_monthly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceDigestActualAndCalendarizedMonthlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_place_actual_monthly_list.metadata = {'url': '/api/v3/place/digest/actual/monthly'}

    def get_place_actual_monthly(
            self, place_id, number_of_years=2, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data by building/organization for a
        given number of years- Result includes cost, use, unit cost on a
        monthly basis. It also includes target comparison data and commodity
        level break up.

        :param place_id: The place to retrieve data for
        :type place_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years of months (24 for actual and
         savings, and 24 or 26 (if 13 accounting periods) for calendarized and
         normalized)
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceDigestActualAndCalendarizedMonthlyResponse or
         ClientRawResponse if raw=true
        :rtype:
         ~energycap.sdk.models.PlaceDigestActualAndCalendarizedMonthlyResponse
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_actual_monthly.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceDigestActualAndCalendarizedMonthlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_actual_monthly.metadata = {'url': '/api/v3/place/{placeId}/digest/actual/monthly'}

    def get_place_calendarized_monthly_list(
            self, number_of_years=2, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up calendarized billing data by building/organization
        for a given number of years- Result includes cost, use, unit cost on a
        monthly basis. It also includes target comparison data and commodity
        level break up.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years of months (24 for calendarized
         and savings, and 24 or 26 (if 13 accounting periods) for calendarized
         and normalized)
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.PlaceDigestActualAndCalendarizedMonthlyResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_calendarized_monthly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceDigestActualAndCalendarizedMonthlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_place_calendarized_monthly_list.metadata = {'url': '/api/v3/place/digest/calendarized/monthly'}

    def get_place_calendarized_monthly(
            self, place_id, number_of_years=2, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up calendarized billing data by building/organization
        for a given number of years- Result includes cost, use, unit cost on a
        monthly basis. It also includes target comparison data and commodity
        level break up.

        :param place_id: The place to retrieve data for
        :type place_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years of months (24 for calendarized
         and savings, and 24 or 26 (if 13 accounting periods) for calendarized
         and normalized)
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceDigestActualAndCalendarizedMonthlyResponse or
         ClientRawResponse if raw=true
        :rtype:
         ~energycap.sdk.models.PlaceDigestActualAndCalendarizedMonthlyResponse
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_calendarized_monthly.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceDigestActualAndCalendarizedMonthlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_calendarized_monthly.metadata = {'url': '/api/v3/place/{placeId}/digest/calendarized/monthly'}

    def get_place_nomalized_monthly_list(
            self, number_of_years=2, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up normalized billing data by building/organization
        for a given number of years- Result includes use on a monthly basis. It
        also includes target comparison data and commodity level break up.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years of months (24 for normalized and
         savings, and 24 or 26 (if 13 accounting periods) for normalized and
         normalized)
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.PlaceDigestNormalizedMonthlyResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_nomalized_monthly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceDigestNormalizedMonthlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_place_nomalized_monthly_list.metadata = {'url': '/api/v3/place/digest/normalized/monthly'}

    def get_place_nomalized_monthly(
            self, place_id, number_of_years=2, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up normalized billing data by building/organization
        for a given number of years- Result includes cost, use, unit cost on a
        monthly basis. It also includes target comparison data and commodity
        level break up.

        :param place_id: The place to retrieve data for
        :type place_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years of months (24 for normalized and
         savings, and 24 or 26 (if 13 accounting periods) for normalized and
         normalized)
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceDigestNormalizedMonthlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.PlaceDigestNormalizedMonthlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_nomalized_monthly.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceDigestNormalizedMonthlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_nomalized_monthly.metadata = {'url': '/api/v3/place/{placeId}/digest/normalized/monthly'}

    def get_place_savings_monthly_list(
            self, number_of_years=2, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up savings data by building/organization for a given
        number of years- Result includes cost and use savings on a monthly
        basis.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years/24 months
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PlaceDigestSavingsMonthlyResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_savings_monthly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceDigestSavingsMonthlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_place_savings_monthly_list.metadata = {'url': '/api/v3/place/digest/savings/monthly'}

    def get_place_savings_monthly(
            self, place_id, number_of_years=2, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up savings data by building/organization for a given
        number of years- Result includes cost, use, unit cost on a monthly
        basis. It also includes target comparison data and commodity level
        break up.

        :param place_id: The place to retrieve data for
        :type place_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to two years of months (24 for actual and
         savings, and 24 or 26 (if 13 accounting periods) for calendarized and
         normalized)
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceDigestSavingsMonthlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.PlaceDigestSavingsMonthlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_savings_monthly.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceDigestSavingsMonthlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_savings_monthly.metadata = {'url': '/api/v3/place/{placeId}/digest/savings/monthly'}

    def get_place_ghg_yearly_list(
            self, number_of_years=4, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up ghg  billing data by building/organization for a
        given number of years- Result includes use broken down by type and
        scope.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PlaceDigestGHGYearlyResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_ghg_yearly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceDigestGHGYearlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_place_ghg_yearly_list.metadata = {'url': '/api/v3/place/digest/ghg/yearly'}

    def get_place_ghg_yearly(
            self, place_id, number_of_years=4, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up ghg  billing data by building/organization for a
        given number of years- Result includes use broken down by type and
        scope.

        :param place_id: The place to retrieve data for
        :type place_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceDigestGHGYearlyResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.PlaceDigestGHGYearlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_ghg_yearly.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceDigestGHGYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_ghg_yearly.metadata = {'url': '/api/v3/place/{placeId}/digest/ghg/yearly'}

    def get_place_ghg_monthly_list(
            self, number_of_years=2, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up ghg  billing data by building/organization for a
        given number of years- Result includes use broken down by type and
        scope.

        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PlaceDigestGHGMonthlyResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_ghg_monthly_list.metadata['url']

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceDigestGHGMonthlyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_place_ghg_monthly_list.metadata = {'url': '/api/v3/place/digest/ghg/monthly'}

    def get_place_ghg_monthly(
            self, place_id, number_of_years=2, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up ghg  billing data by building/organization for a
        given number of years- Result includes use broken down by type and
        scope.

        :param place_id: The place to retrieve data for
        :type place_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceDigestGHGMonthlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.PlaceDigestGHGMonthlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_ghg_monthly.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceDigestGHGMonthlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_ghg_monthly.metadata = {'url': '/api/v3/place/{placeId}/digest/ghg/monthly'}

    def get_eui_chart_data(
            self, place_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves energy use intensity data for a place.
        If data is requested for an organization, then all the places under the
        organization will be rolled up.

        :param place_id: The place to retrieve data for
        :type place_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PlaceDigestEnergyUseIntensity] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_eui_chart_data.metadata['url']
        path_format_arguments = {
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceDigestEnergyUseIntensity]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_eui_chart_data.metadata = {'url': '/api/v3/place/{placeId}/digest/energyUseIntensity'}

    def get_all_place_groups(
            self, filter=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of place groups.

        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.GroupPlaceGroupResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_all_place_groups.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GroupPlaceGroupResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_all_place_groups.metadata = {'url': '/api/v3/placeGroup'}

    def create_place_group(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a place group.

        :param body: Data representing the place group being created
        :type body: ~energycap.sdk.models.PlaceGroupRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GroupPlaceGroupResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GroupPlaceGroupResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_place_group.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'PlaceGroupRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GroupPlaceGroupResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_place_group.metadata = {'url': '/api/v3/placeGroup'}

    def get_place_group(
            self, place_group_id, custom_headers=None, raw=False, **operation_config):
        """Gets a place group.

        :param place_group_id:
        :type place_group_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GroupPlaceGroupResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GroupPlaceGroupResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_group.metadata['url']
        path_format_arguments = {
            'placeGroupId': self._serialize.url("place_group_id", place_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GroupPlaceGroupResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_group.metadata = {'url': '/api/v3/placeGroup/{placeGroupId}'}

    def delete_place_group(
            self, place_group_id, custom_headers=None, raw=False, **operation_config):
        """Delete a user-created place group.

        :param place_group_id:
        :type place_group_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_place_group.metadata['url']
        path_format_arguments = {
            'placeGroupId': self._serialize.url("place_group_id", place_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_place_group.metadata = {'url': '/api/v3/placeGroup/{placeGroupId}'}

    def edit_place_group(
            self, place_group_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit a place group.

        :param place_group_id: Id of the group to edit
        :type place_group_id: int
        :param body: Data representing the place group being edited
        :type body: ~energycap.sdk.models.PlaceGroupRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GroupPlaceGroupResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GroupPlaceGroupResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_place_group.metadata['url']
        path_format_arguments = {
            'placeGroupId': self._serialize.url("place_group_id", place_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'PlaceGroupRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GroupPlaceGroupResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_place_group.metadata = {'url': '/api/v3/placeGroup/{placeGroupId}'}

    def get_place_categories(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of place categories.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PlaceCategoryResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_categories.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceCategoryResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_categories.metadata = {'url': '/api/v3/placeGroup/category'}

    def create_place_category(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates a place group category.

        :param body: Data representing the place group category being created
        :type body: ~energycap.sdk.models.PlaceCategoryRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceCategoryResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.PlaceCategoryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_place_category.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'PlaceCategoryRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceCategoryResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_place_category.metadata = {'url': '/api/v3/placeGroup/category'}

    def get_place_group_members(
            self, place_group_id, always_limit_by_topmost=False, custom_headers=None, raw=False, **operation_config):
        """Gets a list of place group members.

        :param place_group_id:
        :type place_group_id: int
        :param always_limit_by_topmost:
        :type always_limit_by_topmost: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.GroupPlaceGroupMember] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_group_members.metadata['url']
        path_format_arguments = {
            'placeGroupId': self._serialize.url("place_group_id", place_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if always_limit_by_topmost is not None:
            query_parameters['alwaysLimitByTopmost'] = self._serialize.query("always_limit_by_topmost", always_limit_by_topmost, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GroupPlaceGroupMember]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_group_members.metadata = {'url': '/api/v3/placeGroup/{placeGroupId}/member'}

    def update_place_group_member(
            self, place_group_id, place_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Update a group member's include in charts flag.

        :param place_group_id:
        :type place_group_id: int
        :param place_id:
        :type place_id: int
        :param body:
        :type body: ~energycap.sdk.models.GroupMemberRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GroupPlaceGroupMember or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GroupPlaceGroupMember or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_place_group_member.metadata['url']
        path_format_arguments = {
            'placeGroupId': self._serialize.url("place_group_id", place_group_id, 'int'),
            'placeId': self._serialize.url("place_id", place_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'GroupMemberRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GroupPlaceGroupMember', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    update_place_group_member.metadata = {'url': '/api/v3/placeGroup/{placeGroupId}/member/{placeId}'}

    def include_all_place_group_member_in_charts(
            self, place_group_id, custom_headers=None, raw=False, **operation_config):
        """Include all group members in charts.

        :param place_group_id:
        :type place_group_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.include_all_place_group_member_in_charts.metadata['url']
        path_format_arguments = {
            'placeGroupId': self._serialize.url("place_group_id", place_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    include_all_place_group_member_in_charts.metadata = {'url': '/api/v3/placeGroup/{placeGroupId}/member/includeInCharts'}

    def get_place_category(
            self, category_id, custom_headers=None, raw=False, **operation_config):
        """Retrieve a Place Group Category.

        :param category_id: The identifier for the place group category being
         retrieved
        :type category_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceCategoryResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.PlaceCategoryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_category.metadata['url']
        path_format_arguments = {
            'categoryId': self._serialize.url("category_id", category_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceCategoryResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_category.metadata = {'url': '/api/v3/placeGroup/category/{categoryId}'}

    def edit_place_category(
            self, category_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Update a place group category.

        :param category_id: Id of the category to update
        :type category_id: int
        :param body: Data to update the place group category
        :type body: ~energycap.sdk.models.PlaceCategoryRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceCategoryResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.PlaceCategoryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_place_category.metadata['url']
        path_format_arguments = {
            'categoryId': self._serialize.url("category_id", category_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'PlaceCategoryRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceCategoryResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_place_category.metadata = {'url': '/api/v3/placeGroup/category/{categoryId}'}

    def delete_place_category(
            self, category_id, custom_headers=None, raw=False, **operation_config):
        """Delete a place group category.

        :param category_id: Id of the category to delete
        :type category_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_place_category.metadata['url']
        path_format_arguments = {
            'categoryId': self._serialize.url("category_id", category_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_place_category.metadata = {'url': '/api/v3/placeGroup/category/{categoryId}'}

    def get_user_defined_auto_place_group_filters(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of filters that can be used to create Place Groups.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.FilterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_user_defined_auto_place_group_filters.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[FilterResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_user_defined_auto_place_group_filters.metadata = {'url': '/api/v3/placeGroup/filters'}

    def recalculate_user_place_auto_group_memebership(
            self, place_group_id, custom_headers=None, raw=False, **operation_config):
        """Refreshes group membership for a user defined auto group.

        :param place_group_id: The place group to refresh
        :type place_group_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GroupPlaceGroupResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GroupPlaceGroupResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.recalculate_user_place_auto_group_memebership.metadata['url']
        path_format_arguments = {
            'placeGroupId': self._serialize.url("place_group_id", place_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GroupPlaceGroupResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    recalculate_user_place_auto_group_memebership.metadata = {'url': '/api/v3/placeGroup/{placeGroupId}/updateUserAutoGroup'}

    def recalculate_all_user_place_auto_groups_membership(
            self, custom_headers=None, raw=False, **operation_config):
        """Refreshes group membership for all user defined auto groups.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.recalculate_all_user_place_auto_groups_membership.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    recalculate_all_user_place_auto_groups_membership.metadata = {'url': '/api/v3/placeGroup/updateUserAutoGroups'}

    def get_place_group_ranking(
            self, group_id, data_view, chart, billing_period_option=None, start_period=None, end_period=None, commodity_id=None, high_to_low_ranking=None, show_excluded_members=None, show_zero_averages=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves ranking data by place group.

        Depending on the "chart" parameter retrieved ranking data could be
        cost, use, or demand per area, cost or use per day, heating sensitivity
        or cooling sensitivity
        Specify values for any query parameters whose database values are to be
        overridden.
        For the heating sensitivity and cooling sensitivity charts we sort by
        weather sensitivity (slope) and exclude non-weather meters
        **PLEASE NOTE: As shown in the table above, this API endpoint returns
        different response types based on the "chart" value. Despite what you
        see below regarding HTTP status codes for each response type, _all_ of
        these response types will return 200 OK.**
        | Chart              | Response Type                                |
        | ------------------ | -------------------------------------------- |
        | areaCost           | PlaceGroupDigestAreaRankingResponseDTO       |
        | areaUse            | PlaceGroupDigestAreaRankingResponseDTO       |
        | cost               | PlaceGroupDigestRankingResponseDTO           |
        | use                | PlaceGroupDigestRankingResponseDTO           |
        | areaDemand         | PlaceGroupDigestAreaDemandRankingResponseDTO |
        | coolingSensitivity | PlaceGroupDigestWeatherRankingResponseDTO    |
        | heatingSensitivity | PlaceGroupDigestWeatherRankingResponseDTO    |
        | benchmark1Use      | PlaceGroupDigestBenchmarkRankingResponseDTO  |
        | benchmark2Use      | PlaceGroupDigestBenchmarkRankingResponseDTO  |
        | benchmark3Use      | PlaceGroupDigestBenchmarkRankingResponseDTO  |
        | benchmark1Cost     | PlaceGroupDigestBenchmarkRankingResponseDTO  |
        | benchmark2Cost     | PlaceGroupDigestBenchmarkRankingResponseDTO  |
        | benchmark3Cost     | PlaceGroupDigestBenchmarkRankingResponseDTO  |.

        :param group_id: The place group to retrieve data for
        :type group_id: int
        :param data_view: The desired data view - actual, calendarized,
         normalized. Possible values include: 'actual', 'calendarized',
         'normalized'
        :type data_view: str
        :param chart: The desired chart - areacost, areause, areademand, cost,
         use, heatingsensitivity, coolingsensitivity, benchmark1use,
         benchmark1cost, benchmark2use, benchmark2cost, benchmark3use,
         benchmark3cost. Possible values include: 'cost', 'use', 'areaCost',
         'areaUse', 'areaDemand', 'coolingSensitivity', 'heatingSensitivity',
         'benchmark1Cost', 'benchmark2Cost', 'benchmark3Cost', 'benchmark1Use',
         'benchmark2Use', 'benchmark3Use'
        :type chart: str
        :param billing_period_option: The billing period option -
         last12periods, currentyear, lastfiscalyear, custom (optional).
         Possible values include: 'last12Periods', 'lastYear',
         'lastFiscalYear', 'custom'
        :type billing_period_option: str
        :param start_period: The custom start period (optional)
        :type start_period: int
        :param end_period: The custom end period (optional)
        :type end_period: int
        :param commodity_id: Id of commodity to filter by (optional)
        :type commodity_id: int
        :param high_to_low_ranking: Ranking from high to low, or low to high?
         (optional)
        :type high_to_low_ranking: bool
        :param show_excluded_members: Show group members excluded from the
         group? (optional)
        :type show_excluded_members: bool
        :param show_zero_averages: Show group members whose ranking averages
         are zero? (optional)
        :type show_zero_averages: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_place_group_ranking.metadata['url']
        path_format_arguments = {
            'groupId': self._serialize.url("group_id", group_id, 'int'),
            'dataView': self._serialize.url("data_view", data_view, 'str'),
            'chart': self._serialize.url("chart", chart, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if billing_period_option is not None:
            query_parameters['billingPeriodOption'] = self._serialize.query("billing_period_option", billing_period_option, 'str')
        if start_period is not None:
            query_parameters['startPeriod'] = self._serialize.query("start_period", start_period, 'int')
        if end_period is not None:
            query_parameters['endPeriod'] = self._serialize.query("end_period", end_period, 'int')
        if commodity_id is not None:
            query_parameters['commodityId'] = self._serialize.query("commodity_id", commodity_id, 'int')
        if high_to_low_ranking is not None:
            query_parameters['highToLowRanking'] = self._serialize.query("high_to_low_ranking", high_to_low_ranking, 'bool')
        if show_excluded_members is not None:
            query_parameters['showExcludedMembers'] = self._serialize.query("show_excluded_members", show_excluded_members, 'bool')
        if show_zero_averages is not None:
            query_parameters['showZeroAverages'] = self._serialize.query("show_zero_averages", show_zero_averages, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 201, 202, 203]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceGroupDigestAreaRankingResponse', response)
        if response.status_code == 201:
            deserialized = self._deserialize('PlaceGroupDigestBenchmarkRankingResponse', response)
        if response.status_code == 202:
            deserialized = self._deserialize('PlaceGroupDigestBenchmarkRankingResponse', response)
        if response.status_code == 203:
            deserialized = self._deserialize('PlaceGroupDigestWeatherRankingResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_place_group_ranking.metadata = {'url': '/api/v3/placeGroup/{groupId}/digest/{dataView}/{chart}'}

    def get_postal_code(
            self, postal_code, custom_headers=None, raw=False, **operation_config):
        """Retrieves the city, state, country, and weather station for a postal
        code.

        :param postal_code:
        :type postal_code: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PostalCodeResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.PostalCodeResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_postal_code.metadata['url']
        path_format_arguments = {
            'postalCode': self._serialize.url("postal_code", postal_code, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PostalCodeResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_postal_code.metadata = {'url': '/api/v3/postalcode/{postalCode}'}

    def get_primary_uses(
            self, filter=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves all Primary Uses. The array of Primary Uses can be filtered
        by Primary Use type. Possible values for this filter include: "meter",
        "place". See the filter property for more details.

        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PrimaryUseResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_primary_uses.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[PrimaryUseResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_primary_uses.metadata = {'url': '/api/v3/primaryuse'}

    def create_primary_use(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates a Primary Use.

        :param body: Data representing the Primary Use being created
        :type body: ~energycap.sdk.models.PrimaryUseCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PrimaryUseResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.PrimaryUseResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_primary_use.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'PrimaryUseCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PrimaryUseResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_primary_use.metadata = {'url': '/api/v3/primaryuse'}

    def delete_primary_use(
            self, primary_use_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a primary use.

        :param primary_use_id: The identifier for the primary use being
         deleted
        :type primary_use_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_primary_use.metadata['url']
        path_format_arguments = {
            'primaryUseId': self._serialize.url("primary_use_id", primary_use_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_primary_use.metadata = {'url': '/api/v3/primaryuse/{primaryUseId}'}

    def get_rate(
            self, rate_id, custom_headers=None, raw=False, **operation_config):
        """Get a rate schedule.

        :param rate_id: Unique ID of the rate schedule
        :type rate_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: RateResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.RateResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_rate.metadata['url']
        path_format_arguments = {
            'rateId': self._serialize.url("rate_id", rate_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RateResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_rate.metadata = {'url': '/api/v3/rate/{rateId}'}

    def edit_rate(
            self, rate_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit a rate.

        :param rate_id: Unique identifier of the rate schedule to be edited
        :type rate_id: int
        :param body: Updated properties of the rate schedule to be edited
        :type body: ~energycap.sdk.models.RateEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: RateResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.RateResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_rate.metadata['url']
        path_format_arguments = {
            'rateId': self._serialize.url("rate_id", rate_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'RateEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RateResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_rate.metadata = {'url': '/api/v3/rate/{rateId}'}

    def delete_rate(
            self, rate_id, custom_headers=None, raw=False, **operation_config):
        """Delete a rate schedule.

        :param rate_id: Unique identifier of the rate schedule to be deleted
        :type rate_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_rate.metadata['url']
        path_format_arguments = {
            'rateId': self._serialize.url("rate_id", rate_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_rate.metadata = {'url': '/api/v3/rate/{rateId}'}

    def get_rates(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Get a list of all rate schedules matching the provided filters.

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.RateResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_rates.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[RateResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_rates.metadata = {'url': '/api/v3/rate'}

    def create_rate(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a rate schedule.

        :param body: The properties of the rate schedule to be created
        :type body: ~energycap.sdk.models.RateCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: RateResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.RateResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_rate.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'RateCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RateResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_rate.metadata = {'url': '/api/v3/rate'}

    def get_rate_version(
            self, rate_id, version_id, custom_headers=None, raw=False, **operation_config):
        """Get a rate version with its details including dates, unit cost values,
        and bodylines.

        :param rate_id: ID of the rate schedule to retrieve
        :type rate_id: int
        :param version_id: ID of the rate schedule version to retrieve
        :type version_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: RateVersionResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.RateVersionResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_rate_version.metadata['url']
        path_format_arguments = {
            'rateId': self._serialize.url("rate_id", rate_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RateVersionResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_rate_version.metadata = {'url': '/api/v3/rate/{rateId}/version/{versionId}'}

    def edit_rate_version(
            self, rate_id, version_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit a rate schedule version.

        ### Validation
        * Effective date of the edited version
        * Must be after the effective date of the previous version
        * Must be prior to the effective date of the next version
        * Account and meter line items
        * Subtotal calculation type is not supported
        ### Other Remarks
        * Null values are acceptable for use and demand unit costs. However,
        for chargeback bills to calculate correctly, these values must be
        provided.

        :param rate_id: Unique identifier of the rate schedule whose version
         will be edited
        :type rate_id: int
        :param version_id: Unique identifier of the rate schedule version to
         be edited
        :type version_id: int
        :param body: Updated properties of the rate schedule version to be
         edited
        :type body: ~energycap.sdk.models.RateVersionRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: RateVersionResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.RateVersionResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_rate_version.metadata['url']
        path_format_arguments = {
            'rateId': self._serialize.url("rate_id", rate_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'RateVersionRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RateVersionResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_rate_version.metadata = {'url': '/api/v3/rate/{rateId}/version/{versionId}'}

    def delete_rate_version(
            self, rate_id, version_id, custom_headers=None, raw=False, **operation_config):
        """Delete a version of a rate schedule.

        ### Validation
        * The last remaining rate version may not be deleted
        ### Other Remarks
        * When a rate version is deleted, if there is a preceding rate version,
        then its end date will be reset to the end date of the deleted rate
        version.

        :param rate_id: Unique identifier of the rate schedule to which the
         version being deleted belongs
        :type rate_id: int
        :param version_id: Unique identifier of the rate schedule version to
         delete
        :type version_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_rate_version.metadata['url']
        path_format_arguments = {
            'rateId': self._serialize.url("rate_id", rate_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_rate_version.metadata = {'url': '/api/v3/rate/{rateId}/version/{versionId}'}

    def get_rate_versions(
            self, rate_id, custom_headers=None, raw=False, **operation_config):
        """Get a list of all versions for a rate schedule with their details
        including dates, unit cost values, and bodylines.

        :param rate_id: ID of the rate schedule to retrieve
        :type rate_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.RateVersionResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_rate_versions.metadata['url']
        path_format_arguments = {
            'rateId': self._serialize.url("rate_id", rate_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[RateVersionResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_rate_versions.metadata = {'url': '/api/v3/rate/{rateId}/version'}

    def create_rate_version(
            self, rate_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a rate schedule version.

        Allows the user to create a new version for a rate schedule for use in
        chargeback scenarios where use or demand cost for calculated bills must
        be created from a predefined unit cost.
        ### Validation
        * Account and meter line items
        * Subtotal calculation type is not supported
        ### Other Remarks
        * Inserting a rate version before an existing version will set the new
        version's end date to the effective date of the subsequent version.
        * Null values are acceptable for use and demand unit costs. However,
        for chargeback bills to calculate correctly, these values must be
        provided.

        :param rate_id: Unique identifier of the rate schedule to receive the
         new version
        :type rate_id: int
        :param body: The properties of the rate schedule version to be created
        :type body: ~energycap.sdk.models.RateVersionRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: RateVersionResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.RateVersionResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_rate_version.metadata['url']
        path_format_arguments = {
            'rateId': self._serialize.url("rate_id", rate_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'RateVersionRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RateVersionResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_rate_version.metadata = {'url': '/api/v3/rate/{rateId}/version'}

    def get_rate_unit(
            self, rate_id, custom_headers=None, raw=False, **operation_config):
        """Get the unit used by a rate. The unit is determined by the usage unit
        on the most recent template assigned to a meter with the given rate.

        :param rate_id: Unique identifier of the rate schedule for which the
         unit will be retrieved
        :type rate_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UnitResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UnitResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_rate_unit.metadata['url']
        path_format_arguments = {
            'rateId': self._serialize.url("rate_id", rate_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UnitResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_rate_unit.metadata = {'url': '/api/v3/rate/{rateId}/unit'}

    def get_rate_actual_yearly(
            self, rate_id, number_of_years=4, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data by rate for a given number of
        years- Result includes cost, use, unit cost on an yearly basis.

        :param rate_id: The rate to retrieve data for
        :type rate_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: RateDigestActualYearlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.RateDigestActualYearlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_rate_actual_yearly.metadata['url']
        path_format_arguments = {
            'rateId': self._serialize.url("rate_id", rate_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RateDigestActualYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_rate_actual_yearly.metadata = {'url': '/api/v3/rate/{rateId}/digest/actual/yearly'}

    def create_report_group(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """

        :param body:
        :type body: ~energycap.sdk.models.ReportGroupRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ReportGroupResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ReportGroupResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_report_group.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ReportGroupRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReportGroupResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_report_group.metadata = {'url': '/api/v3/report/reportgroup'}

    def get_report_groups(
            self, custom_headers=None, raw=False, **operation_config):
        """

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.ReportGroupResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_report_groups.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ReportGroupResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_report_groups.metadata = {'url': '/api/v3/report/reportgroup'}

    def delete_report_group(
            self, report_group_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a Report Group.

        :param report_group_id:
        :type report_group_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_report_group.metadata['url']
        path_format_arguments = {
            'reportGroupId': self._serialize.url("report_group_id", report_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_report_group.metadata = {'url': '/api/v3/report/reportgroup/{reportGroupId}'}

    def edit_report_group(
            self, report_group_id, body=None, custom_headers=None, raw=False, **operation_config):
        """

        :param report_group_id:
        :type report_group_id: int
        :param body:
        :type body: ~energycap.sdk.models.ReportGroupRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ReportGroupResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ReportGroupResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_report_group.metadata['url']
        path_format_arguments = {
            'reportGroupId': self._serialize.url("report_group_id", report_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ReportGroupRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReportGroupResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_report_group.metadata = {'url': '/api/v3/report/reportgroup/{reportGroupId}'}

    def get_report_group(
            self, report_group_id, custom_headers=None, raw=False, **operation_config):
        """

        :param report_group_id:
        :type report_group_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ReportGroupResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ReportGroupResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_report_group.metadata['url']
        path_format_arguments = {
            'reportGroupId': self._serialize.url("report_group_id", report_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReportGroupResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_report_group.metadata = {'url': '/api/v3/report/reportgroup/{reportGroupId}'}

    def get_specific_reports(
            self, filter=None, custom_headers=None, raw=False, **operation_config):
        """Get a filterable list of installed, saved, and shared reports available
        to the current user.

        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.SpecificReportResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_specific_reports.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[SpecificReportResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_specific_reports.metadata = {'url': '/api/v3/report'}

    def get_specific_report(
            self, specific_report_id, custom_headers=None, raw=False, **operation_config):
        """Get a report by its specificReportID.

        :param specific_report_id:
        :type specific_report_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SpecificReportResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SpecificReportResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_specific_report.metadata['url']
        path_format_arguments = {
            'specificReportId': self._serialize.url("specific_report_id", specific_report_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SpecificReportResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_specific_report.metadata = {'url': '/api/v3/report/{specificReportId}'}

    def edit_specific_report(
            self, specific_report_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit a specific report.

        :param specific_report_id: The specific report to edit
        :type specific_report_id: int
        :param body: The specific report edit properties
        :type body: ~energycap.sdk.models.ReportEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SpecificReportResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SpecificReportResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_specific_report.metadata['url']
        path_format_arguments = {
            'specificReportId': self._serialize.url("specific_report_id", specific_report_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ReportEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SpecificReportResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_specific_report.metadata = {'url': '/api/v3/report/{specificReportId}'}

    def delete_specific_report(
            self, specific_report_id, custom_headers=None, raw=False, **operation_config):
        """

        :param specific_report_id:
        :type specific_report_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_specific_report.metadata['url']
        path_format_arguments = {
            'specificReportId': self._serialize.url("specific_report_id", specific_report_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_specific_report.metadata = {'url': '/api/v3/report/{specificReportId}'}

    def install_reports(
            self, custom_headers=None, raw=False, **operation_config):
        """

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.install_reports.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 400]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OkResult', response)
        if response.status_code == 400:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    install_reports.metadata = {'url': '/api/v3/report/install/latest'}

    def get_report_filters(
            self, specific_report_id, custom_headers=None, raw=False, **operation_config):
        """Get the filters for a specific report.

        :param specific_report_id: The specific report for which the filters
         are to be retrieved
        :type specific_report_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.FilterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_report_filters.metadata['url']
        path_format_arguments = {
            'specificReportId': self._serialize.url("specific_report_id", specific_report_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[FilterResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_report_filters.metadata = {'url': '/api/v3/report/{specificReportId}/filter'}

    def edit_report_filters(
            self, specific_report_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit the filters for a specific report.

        :param specific_report_id: The specific report for which the filters
         are to be edited
        :type specific_report_id: int
        :param body: The list of filters to apply
        :type body: list[~energycap.sdk.models.FilterEdit]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.FilterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_report_filters.metadata['url']
        path_format_arguments = {
            'specificReportId': self._serialize.url("specific_report_id", specific_report_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[FilterEdit]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[FilterResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_report_filters.metadata = {'url': '/api/v3/report/{specificReportId}/filter'}

    def run_report(
            self, specific_report_id, format=None, custom_headers=None, raw=False, **operation_config):
        """Run a report and download in the provided format.

        :param specific_report_id: The ID of the specific report to run
        :type specific_report_id: int
        :param format: The format in which the generated report should be
         downloaded. Supported options are ["excel", "csv", "pdf", "word"]
        :type format: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.run_report.metadata['url']
        path_format_arguments = {
            'specificReportId': self._serialize.url("specific_report_id", specific_report_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if format is not None:
            query_parameters['format'] = self._serialize.query("format", format, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    run_report.metadata = {'url': '/api/v3/report/exec/{specificReportId}'}

    def distribute_report(
            self, specific_report_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Execute a report, save it in a given format, and email it to a list of
        recipients.
        If distributing reports, returns a 204 No Content if onlySendIfData is
        set to True and the report generated no data;
        returns a 200 and the generated report for download or an empty body if
        onlySendIfData is set to True.

        :param specific_report_id: The ID of the specific report to run
        :type specific_report_id: int
        :param body: Allows the user to run one report and optionally email it
         to one or more recipients. They can optionally specify whether or not
         the report(s) should be sent if they contain no data.
        :type body: ~energycap.sdk.models.DistributedReportsConfiguration
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.distribute_report.metadata['url']
        path_format_arguments = {
            'specificReportId': self._serialize.url("specific_report_id", specific_report_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'DistributedReportsConfiguration')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    distribute_report.metadata = {'url': '/api/v3/report/exec/{specificReportId}'}

    def process_report_subscriptions(
            self, custom_headers=None, raw=False, **operation_config):
        """Execute and email report subscriptions that are ready to be run.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.process_report_subscriptions.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    process_report_subscriptions.metadata = {'url': '/api/v3/report/exec/subscription'}

    def create_specific_report(
            self, specific_report_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Save a specific report to Saved Reports.

        :param specific_report_id: The specific report to save
        :type specific_report_id: int
        :param body: The specific report create properties
        :type body: ~energycap.sdk.models.ReportCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SpecificReportResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SpecificReportResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_specific_report.metadata['url']
        path_format_arguments = {
            'specificReportId': self._serialize.url("specific_report_id", specific_report_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ReportCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SpecificReportResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_specific_report.metadata = {'url': '/api/v3/report/{specificReportId}/copy'}

    def run_quick_report(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Generates a "quick report" in its preferred export format as identified
        by the provided report code and applying ONLY the filters supplied.

        :param body:
        :type body: ~energycap.sdk.models.QuickReport
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.run_quick_report.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'QuickReport')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    run_quick_report.metadata = {'url': '/api/v3/report/quick'}

    def run_report_distribution(
            self, custom_headers=None, raw=False, **operation_config):
        """Executes report distribution for report email batches that were
        configured in EnergyCAP Version 6 (Also known as the 'Installed
        Client').

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ReportDistributionResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ReportDistributionResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.run_report_distribution.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReportDistributionResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    run_report_distribution.metadata = {'url': '/api/v3/report/distribution'}

    def get_report_sharing_details(
            self, specific_report_id, custom_headers=None, raw=False, **operation_config):
        """Get sharing information for a report.

        Only the user who created the report or a report administrator is
        permitted to get sharing details for a report.

        :param specific_report_id: The specific report for which to retrieve
         sharing information
        :type specific_report_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ShareResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ShareResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_report_sharing_details.metadata['url']
        path_format_arguments = {
            'specificReportId': self._serialize.url("specific_report_id", specific_report_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ShareResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_report_sharing_details.metadata = {'url': '/api/v3/report/{specificReportId}/share'}

    def share_saved_report(
            self, specific_report_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Share a saved report with other users.

        :param specific_report_id: ID of the saved report to share
        :type specific_report_id: int
        :param body: Updated sharing details for the report
        :type body: ~energycap.sdk.models.ShareRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ShareResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ShareResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.share_saved_report.metadata['url']
        path_format_arguments = {
            'specificReportId': self._serialize.url("specific_report_id", specific_report_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ShareRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ShareResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    share_saved_report.metadata = {'url': '/api/v3/report/{specificReportId}/share'}

    def toggle_shared_report_visibility(
            self, specific_report_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Update the visibility of a report for the current user
        This must be a report you can see
        Which means you must have created the report
        or have ReportAdministrator Manage permission and the report is shared
        at all
        or have SharedReports View permission and the report is shared with
        you.

        :param specific_report_id: Specific dashboard
        :type specific_report_id: int
        :param body: Set Visibility
        :type body: ~energycap.sdk.models.ToggleVisible
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SpecificReportResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SpecificReportResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.toggle_shared_report_visibility.metadata['url']
        path_format_arguments = {
            'specificReportId': self._serialize.url("specific_report_id", specific_report_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ToggleVisible')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SpecificReportResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    toggle_shared_report_visibility.metadata = {'url': '/api/v3/report/{specificReportId}/visible'}

    def create_report_subscription(
            self, specific_report_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Subscribe to a report and receive scheduled emails
        This must be a saved report that belongs to or is shared with the
        current user
        Only SSRS reports are supported.

        :param specific_report_id:
        :type specific_report_id: int
        :param body:
        :type body: ~energycap.sdk.models.ReportSubscriptionRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SpecificReportResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SpecificReportResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_report_subscription.metadata['url']
        path_format_arguments = {
            'specificReportId': self._serialize.url("specific_report_id", specific_report_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ReportSubscriptionRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SpecificReportResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_report_subscription.metadata = {'url': '/api/v3/report/{specificReportId}/subscription'}

    def edit_report_subscription(
            self, specific_report_id, report_subscription_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit a report subscription
        This must be a subscription that belongs to the current user.

        :param specific_report_id:
        :type specific_report_id: int
        :param report_subscription_id:
        :type report_subscription_id: int
        :param body:
        :type body: ~energycap.sdk.models.ReportSubscriptionRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SpecificReportResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SpecificReportResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_report_subscription.metadata['url']
        path_format_arguments = {
            'specificReportId': self._serialize.url("specific_report_id", specific_report_id, 'int'),
            'reportSubscriptionId': self._serialize.url("report_subscription_id", report_subscription_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ReportSubscriptionRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SpecificReportResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_report_subscription.metadata = {'url': '/api/v3/report/{specificReportId}/subscription/{reportSubscriptionId}'}

    def delete_report_subscription(
            self, specific_report_id, report_subscription_id, custom_headers=None, raw=False, **operation_config):
        """Delete a report subscription
        This must be a subscription that belongs to the current user.

        :param specific_report_id:
        :type specific_report_id: int
        :param report_subscription_id:
        :type report_subscription_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_report_subscription.metadata['url']
        path_format_arguments = {
            'specificReportId': self._serialize.url("specific_report_id", specific_report_id, 'int'),
            'reportSubscriptionId': self._serialize.url("report_subscription_id", report_subscription_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_report_subscription.metadata = {'url': '/api/v3/report/{specificReportId}/subscription/{reportSubscriptionId}'}

    def get_report_subscription_schedule_types(
            self, custom_headers=None, raw=False, **operation_config):
        """Get a list of all available report subscription schedule types, and
        their day indicator values.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.ReportSubscriptionScheduleTypeResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_report_subscription_schedule_types.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ReportSubscriptionScheduleTypeResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_report_subscription_schedule_types.metadata = {'url': '/api/v3/report/subscription/scheduletype'}

    def get_routes(
            self, custom_headers=None, raw=False, **operation_config):
        """Retrieves all routes.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.RouteResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_routes.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[RouteResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_routes.metadata = {'url': '/api/v3/route'}

    def create_route(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates a new route and assigns a group of meters to it.

        :param body: Data representing the route being created
        :type body: ~energycap.sdk.models.RouteRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: RouteResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.RouteResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_route.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'RouteRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RouteResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_route.metadata = {'url': '/api/v3/route'}

    def get_route(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Retrieves one route.

        :param id: The identifier for route being retrieved
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: RouteResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.RouteResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_route.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RouteResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_route.metadata = {'url': '/api/v3/route/{id}'}

    def delete_route(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Deletes a route.

        :param id: The identifier for the route being deleted
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_route.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_route.metadata = {'url': '/api/v3/route/{id}'}

    def edit_route(
            self, id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits a route.

        :param id: The identifier for the route being edited
        :type id: int
        :param body: Data representing the route being edited
        :type body: ~energycap.sdk.models.RouteRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: RouteResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.RouteResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_route.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'RouteRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RouteResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_route.metadata = {'url': '/api/v3/route/{id}'}

    def add_meter(
            self, route_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Adds a meter to a route.

        :param route_id: The identifier for the route to add the meters to
        :type route_id: int
        :param body: Object representing meter to add to the route
        :type body: ~energycap.sdk.models.RouteMeter
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: RouteResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.RouteResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.add_meter.metadata['url']
        path_format_arguments = {
            'routeId': self._serialize.url("route_id", route_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'RouteMeter')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RouteResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    add_meter.metadata = {'url': '/api/v3/route/{routeId}/meter'}

    def remove_meter(
            self, route_id, meter_id, custom_headers=None, raw=False, **operation_config):
        """Removes a meter from a route.

        :param route_id: The identifier for the route the meter is being
         remove from
        :type route_id: int
        :param meter_id: The identifier for the meter being removed
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.remove_meter.metadata['url']
        path_format_arguments = {
            'routeId': self._serialize.url("route_id", route_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    remove_meter.metadata = {'url': '/api/v3/route/{routeId}/meter/{meterId}'}

    def get_route_details(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Retrieves one route and all the meters on that route
        The meters are ordered by display order.

        :param id: The identifier for route being retrieved
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: RouteDetailsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.RouteDetailsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_route_details.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RouteDetailsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_route_details.metadata = {'url': '/api/v3/route/{id}/details'}

    def get_routes_with_meters_channels_latest_reading(
            self, filter=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves a list of routes with their list of meters and a list of
        channels on each meter with the latest reading
        Meters are returned in order they appear on a route
        If the interval filter is passed and no channels match the filter, the
        route is not included in the response.

        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~energycap.sdk.models.RouteMeterChannelLatestReadingResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_routes_with_meters_channels_latest_reading.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[RouteMeterChannelLatestReadingResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_routes_with_meters_channels_latest_reading.metadata = {'url': '/api/v3/route/meter/channel/latestReading'}

    def get_savings_meter_bill_list(
            self, meter_id, number_of_years=5, custom_headers=None, raw=False, **operation_config):
        """Get Savings Details of usage and cost avoidance for a meter's bills.

        :param meter_id: The meter for which to retrieve data
        :type meter_id: int
        :param number_of_years: Number of years of data to return; includes
         the current year - Defaults to 5
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.SavingsMeterBillResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_savings_meter_bill_list.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[SavingsMeterBillResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_savings_meter_bill_list.metadata = {'url': '/api/v3/savings/meter/{meterId}/bill'}

    def get_savings_meter_bill(
            self, meter_id, bill_id, custom_headers=None, raw=False, **operation_config):
        """Get a single Savings Details record of usage and cost avoidance for a
        meter and bill.

        :param meter_id: The meter for which to retrieve data
        :type meter_id: int
        :param bill_id: The bill for which to retrieve data
        :type bill_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SavingsMeterBillResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SavingsMeterBillResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_savings_meter_bill.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'billId': self._serialize.url("bill_id", bill_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SavingsMeterBillResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_savings_meter_bill.metadata = {'url': '/api/v3/savings/meter/{meterId}/bill/{billId}'}

    def get_savings_meter_bill_daily(
            self, meter_id, bill_id, custom_headers=None, raw=False, **operation_config):
        """Get cost avoidance savings by day for a meter and bill.

        :param meter_id: The meter for which to retrieve data
        :type meter_id: int
        :param bill_id: The bill for which to retrieve data
        :type bill_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SavingsMeterBillDailyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.SavingsMeterBillDailyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_savings_meter_bill_daily.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'billId': self._serialize.url("bill_id", bill_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SavingsMeterBillDailyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_savings_meter_bill_daily.metadata = {'url': '/api/v3/savings/meter/{meterId}/bill/{billId}/daily'}

    def get_special_adjustment_types(
            self, custom_headers=None, raw=False, **operation_config):
        """Get Special Adjustment Types.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.SpecialAdjustmentType] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_special_adjustment_types.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[SpecialAdjustmentType]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_special_adjustment_types.metadata = {'url': '/api/v3/savings/adjustment/special/type'}

    def get_special_adjustment_methods(
            self, custom_headers=None, raw=False, **operation_config):
        """Get Special Adjustment Methods.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.SpecialAdjustmentMethod] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_special_adjustment_methods.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[SpecialAdjustmentMethod]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_special_adjustment_methods.metadata = {'url': '/api/v3/savings/adjustment/special/method'}

    def get_savings_adjusted_cost_type_list(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of the Adjusted Cost Types.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.AdjustedCostTypeResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_savings_adjusted_cost_type_list.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[AdjustedCostTypeResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_savings_adjusted_cost_type_list.metadata = {'url': '/api/v3/savings/adjustedCostType'}

    def generate_baseline(
            self, meter_id, save=False, body=None, custom_headers=None, raw=False, **operation_config):
        """Executes the baseline and cost avoidance processors with provided
        baseline and cost avoidance settings for the provided meter.
        Results are not saved unless the "save" flag is set to true.
        If "save" is true, MeterSavingsSettings-Manage permission is also
        required.

        :param meter_id: ID of the meter for which baseline will be
         reprocessed
        :type meter_id: int
        :param save: If true, the baseline results will be saved to the
         database
        :type save: bool
        :param body: Provided baseline and avoidance settings
        :type body: ~energycap.sdk.models.BaselineProcessorRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BaselineProcessorResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BaselineProcessorResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.generate_baseline.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if save is not None:
            query_parameters['save'] = self._serialize.query("save", save, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BaselineProcessorRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BaselineProcessorResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    generate_baseline.metadata = {'url': '/api/v3/savings/meter/{meterId}/baseline'}

    def generate_baseline_get(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Executes the baseline processor with stored baseline settings for the
        provided meter.

        :param meter_id: ID of the meter for which baseline data will be
         returned
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BaselineProcessorResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BaselineProcessorResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.generate_baseline_get.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BaselineProcessorResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    generate_baseline_get.metadata = {'url': '/api/v3/savings/meter/{meterId}/baseline'}

    def bulk_generate_baseline(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Regenerate cost avoidance baseline for the meters that match the filter
        conditions and then reprocess their savings.

        :param body: Settings and filter conditions for baseline processing
        :type body: ~energycap.sdk.models.BulkBaselineProcessorRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CostAvoidanceTask or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.CostAvoidanceTask or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.bulk_generate_baseline.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BulkBaselineProcessorRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CostAvoidanceTask', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    bulk_generate_baseline.metadata = {'url': '/api/v3/savings/baseline/exec'}

    def calculate_savings(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Calculate savings for the meters that match the filter conditions,
        using the provided settings.

        :param body: Settings and filter conditions for savings processing
        :type body: ~energycap.sdk.models.CalculateSavingsRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CostAvoidanceTask or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.CostAvoidanceTask or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.calculate_savings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'CalculateSavingsRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CostAvoidanceTask', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    calculate_savings.metadata = {'url': '/api/v3/savings/exec'}

    def manual_adjustment(
            self, meter_id, bill_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates or removes manual adjustments to savings for a provided meter
        and bill.

        :param meter_id: The meter for which the manual adjustment is being
         made
        :type meter_id: int
        :param bill_id: The bill for which the manual adjustment is being made
        :type bill_id: int
        :param body:
        :type body: ~energycap.sdk.models.ManualAdjustmentRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.manual_adjustment.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'billId': self._serialize.url("bill_id", bill_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ManualAdjustmentRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    manual_adjustment.metadata = {'url': '/api/v3/savings/meter/{meterId}/bill/{billId}/manualadjustment'}

    def get_special_adjustments(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Get all the special adjustments for the meter.

        :param meter_id: The meter for which to return special adjustment
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.SpecialAdjustmentResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_special_adjustments.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[SpecialAdjustmentResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_special_adjustments.metadata = {'url': '/api/v3/savings/meter/{meterId}/adjustment/special'}

    def create_special_adjustment(
            self, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a new special adjustment
        Meter Cost Avoidance Savings will be re-calculated.

        :param meter_id: The meter for which to create a special adjustment
        :type meter_id: int
        :param body: Data representing the special adjustment being created
        :type body: ~energycap.sdk.models.SpecialAdjustmentCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SpecialAdjustmentResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SpecialAdjustmentResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_special_adjustment.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'SpecialAdjustmentCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SpecialAdjustmentResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_special_adjustment.metadata = {'url': '/api/v3/savings/meter/{meterId}/adjustment/special'}

    def get_special_adjustment(
            self, meter_id, special_adjustment_id, custom_headers=None, raw=False, **operation_config):
        """Get a single special adjustment by its unique ID.

        :param meter_id: The meter for which to return the special adjustment
        :type meter_id: int
        :param special_adjustment_id: Unique ID of the special adjustment to
         return
        :type special_adjustment_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SpecialAdjustmentResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SpecialAdjustmentResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_special_adjustment.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'specialAdjustmentId': self._serialize.url("special_adjustment_id", special_adjustment_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SpecialAdjustmentResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_special_adjustment.metadata = {'url': '/api/v3/savings/meter/{meterId}/adjustment/special/{specialAdjustmentId}'}

    def delete_special_adjustment_by_id(
            self, meter_id, special_adjustment_id, custom_headers=None, raw=False, **operation_config):
        """Delete a special adjustment
        Meter Cost Avoidance Savings will be re-calculated.

        :param meter_id: The meter from which to delete the special adjustment
        :type meter_id: int
        :param special_adjustment_id: The special adjustment to delete
        :type special_adjustment_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_special_adjustment_by_id.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'specialAdjustmentId': self._serialize.url("special_adjustment_id", special_adjustment_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_special_adjustment_by_id.metadata = {'url': '/api/v3/savings/meter/{meterId}/adjustment/special/{specialAdjustmentId}'}

    def edit_special_adjustment(
            self, meter_id, special_adjustment_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit a special adjustment
        Meter Cost Avoidance Savings will be re-calculated.

        :param meter_id: The meter with the special adjustment to edit
        :type meter_id: int
        :param special_adjustment_id: The special adjustment to edit
        :type special_adjustment_id: int
        :param body: Data representing the special adjustment being edited
        :type body: ~energycap.sdk.models.SpecialAdjustmentEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SpecialAdjustmentResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SpecialAdjustmentResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_special_adjustment.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'specialAdjustmentId': self._serialize.url("special_adjustment_id", special_adjustment_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'SpecialAdjustmentEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SpecialAdjustmentResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_special_adjustment.metadata = {'url': '/api/v3/savings/meter/{meterId}/adjustment/special/{specialAdjustmentId}'}

    def create_other_savings(
            self, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Create an other savings adjustment
        Meter Cost Avoidance Savings will be re-calculated.

        :param meter_id: The meter for which the other savings is being
         created
        :type meter_id: int
        :param body: Data representing the other savings adjustment being
         created
        :type body: ~energycap.sdk.models.OtherSavingsRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: OtherSavingsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.OtherSavingsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_other_savings.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'OtherSavingsRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OtherSavingsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_other_savings.metadata = {'url': '/api/v3/savings/meter/{meterId}/adjustment/othersavings'}

    def get_all_other_savings(
            self, meter_id, custom_headers=None, raw=False, **operation_config):
        """Get a other savings for a meter.

        :param meter_id: The meter for which the other savings are being
         retrieved
        :type meter_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.OtherSavingsResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_all_other_savings.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[OtherSavingsResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_all_other_savings.metadata = {'url': '/api/v3/savings/meter/{meterId}/adjustment/othersavings'}

    def edit_other_savings(
            self, meter_id, other_savings_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit an other savings adjustment
        Meter Cost Avoidance Savings will be re-calculated.

        :param meter_id: The meter whose other savings is being edited
        :type meter_id: int
        :param other_savings_id: The other savings to edit
        :type other_savings_id: int
        :param body: Data representing the other savings adjustment being
         edited
        :type body: ~energycap.sdk.models.OtherSavingsRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: OtherSavingsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.OtherSavingsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_other_savings.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'otherSavingsId': self._serialize.url("other_savings_id", other_savings_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'OtherSavingsRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OtherSavingsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_other_savings.metadata = {'url': '/api/v3/savings/meter/{meterId}/adjustment/othersavings/{otherSavingsId}'}

    def get_one_other_savings(
            self, meter_id, other_savings_id, custom_headers=None, raw=False, **operation_config):
        """Get one other savings for a meter.

        :param meter_id: The meter for which the other savings are being
         retrieved
        :type meter_id: int
        :param other_savings_id: The identifier for the other savings record
         which is being retrieved
        :type other_savings_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: OtherSavingsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.OtherSavingsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_one_other_savings.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'otherSavingsId': self._serialize.url("other_savings_id", other_savings_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OtherSavingsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_one_other_savings.metadata = {'url': '/api/v3/savings/meter/{meterId}/adjustment/othersavings/{otherSavingsId}'}

    def delete_other_savings(
            self, meter_id, other_savings_id, custom_headers=None, raw=False, **operation_config):
        """Delete an other savings adjustment.

        :param meter_id: The meter for which the other savings is being
         deleted
        :type meter_id: int
        :param other_savings_id: The other saving identifier which is being
         deleted
        :type other_savings_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_other_savings.metadata['url']
        path_format_arguments = {
            'meterId': self._serialize.url("meter_id", meter_id, 'int'),
            'otherSavingsId': self._serialize.url("other_savings_id", other_savings_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_other_savings.metadata = {'url': '/api/v3/savings/meter/{meterId}/adjustment/othersavings/{otherSavingsId}'}

    def get_other_savings_categories(
            self, custom_headers=None, raw=False, **operation_config):
        """Get other savings categories.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.OtherSavingsCategory] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_other_savings_categories.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[OtherSavingsCategory]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_other_savings_categories.metadata = {'url': '/api/v3/savings/adjustment/othersavings/category'}

    def create_other_savings_category(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Create other savings category.

        :param body: Data representing the other saving category being created
        :type body: ~energycap.sdk.models.OtherSavingsCategoryRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: OtherSavingsCategory or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.OtherSavingsCategory or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_other_savings_category.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'OtherSavingsCategoryRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OtherSavingsCategory', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_other_savings_category.metadata = {'url': '/api/v3/savings/adjustment/othersavings/category'}

    def bulk_edit_meter_cost_avoidance_settings(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Mass update certain cost avoidance settings for meters that match the
        filter conditions
        Baseline and Savings will be reprocessed for affected meters.

        :param body: Filters and new cost avoidance setting values
        :type body: ~energycap.sdk.models.BulkMeterCostAvoidanceSettings
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CostAvoidanceTask or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.CostAvoidanceTask or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.bulk_edit_meter_cost_avoidance_settings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'BulkMeterCostAvoidanceSettings')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CostAvoidanceTask', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    bulk_edit_meter_cost_avoidance_settings.metadata = {'url': '/api/v3/savings/meter'}

    def get_cost_avoidance_meter_count(
            self, only_meters_in_cap=True, body=None, custom_headers=None, raw=False, **operation_config):
        """Count the number of meters that match the filter conditions for cost
        avoidance bulk actions.

        :param only_meters_in_cap: Whether or not to only include meters in
         the count which are already participating in cost avoidance
        :type only_meters_in_cap: bool
        :param body: The filters used when counting the meters
        :type body: list[~energycap.sdk.models.FilterEdit]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GenericCount or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.GenericCount or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_cost_avoidance_meter_count.metadata['url']

        # Construct parameters
        query_parameters = {}
        if only_meters_in_cap is not None:
            query_parameters['onlyMetersInCAP'] = self._serialize.query("only_meters_in_cap", only_meters_in_cap, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[FilterEdit]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GenericCount', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_cost_avoidance_meter_count.metadata = {'url': '/api/v3/savings/meter/count'}

    def get_auc_ranges(
            self, custom_headers=None, raw=False, **operation_config):
        """Get the average unit cost "acceptable range" values for cost avoidance
        for each commodity.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.AucRangeResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_auc_ranges.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[AucRangeResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_auc_ranges.metadata = {'url': '/api/v3/savings/auc'}

    def edit_auc_ranges(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit the average unit cost "acceptable range" values for cost avoidance
        for one or more commodities
        Cost Avoidance Savings will be re-calculated for all bills for meters
        having the affected commodities.

        :param body: Data representing one or more average unit cost ranges to
         edit
        :type body: list[~energycap.sdk.models.AucRangeRequest]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.AucRangeResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_auc_ranges.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[AucRangeRequest]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[AucRangeResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_auc_ranges.metadata = {'url': '/api/v3/savings/auc'}

    def get_savings_tasks(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Get a list of cost avoidance tasks
        NOTE: does not include cost avoidance tasks created from prior versions
        of the software.

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.CostAvoidanceTask] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_savings_tasks.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[CostAvoidanceTask]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_savings_tasks.metadata = {'url': '/api/v3/savings/task'}

    def get_savings_task(
            self, task_id, custom_headers=None, raw=False, **operation_config):
        """Get a single cost avoidance task by its unique ID.

        :param task_id:
        :type task_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CostAvoidanceTask or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.CostAvoidanceTask or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_savings_task.metadata['url']
        path_format_arguments = {
            'taskId': self._serialize.url("task_id", task_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CostAvoidanceTask', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_savings_task.metadata = {'url': '/api/v3/savings/task/{taskId}'}

    def get_cost_avoidance_settings(
            self, custom_headers=None, raw=False, **operation_config):
        """

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_cost_avoidance_settings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    get_cost_avoidance_settings.metadata = {'url': '/api/v3/savings/settings'}

    def edit_cost_avoidance_settings(
            self, custom_headers=None, raw=False, **operation_config):
        """

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_cost_avoidance_settings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    edit_cost_avoidance_settings.metadata = {'url': '/api/v3/savings/settings'}

    def get_cost_avoidance_filters(
            self, custom_headers=None, raw=False, **operation_config):
        """Return available filters for Cost Avoidance processors
        Filters:
        - Commodity ID
        - Commodity Name
        - Meter Group Name
        - Building Group Name
        - Topmost Place Code
        - Topmost Place Name.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.FilterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_cost_avoidance_filters.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[FilterResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_cost_avoidance_filters.metadata = {'url': '/api/v3/savings/filters'}

    def get_search_result(
            self, query=None, limit=10, custom_headers=None, raw=False, **operation_config):
        """Searches for Accounts, Meters, Cost Centers, Places, and Place Groups
        that match the provided query text.

        :param query: The text to search
        :type query: str
        :param limit: The maximum number of items to return per entity type.
         Defaults to 10, valid range of 0 to 100.
         0 is treated as default for backwards compatibility reasons.
        :type limit: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SearchResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SearchResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_search_result.metadata['url']

        # Construct parameters
        query_parameters = {}
        if query is not None:
            query_parameters['query'] = self._serialize.query("query", query, 'str')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', maximum=100, minimum=0)

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SearchResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_search_result.metadata = {'url': '/api/v3/search'}

    def get_setup_sheet(
            self, type=None, filter=None, custom_headers=None, raw=False, **operation_config):
        """Returns an Excel file used within SetupSheets.

        :param type: Possible values include: 'UNKNOWNTYPE',
         'CREATE_AccountsAndMeters', 'CREATE_BuildingsAndOrganizations',
         'CREATE_CostAvoidanceOtherSavings',
         'CREATE_CostAvoidanceSpecialAdjustments', 'CREATE_CostCenters',
         'CREATE_Customers', 'CREATE_ChargebackDistributionsVersions',
         'CREATE_RateSchedules', 'CREATE_Vendors', 'CREATE_Channels',
         'UPDATE_CostCenters', 'UPDATE_BuildingsAndOrganizations',
         'UPDATE_AccountingCalendar', 'UPDATE_Accounts',
         'UPDATE_CustomFieldsAccount', 'UPDATE_CostAvoidanceOtherSavings',
         'UPDATE_CostAvoidanceSpecialAdjustments', 'UPDATE_Customers',
         'CREATE_GLCodesAndSubcodes', 'UPDATE_GLCodesAndSubcodes',
         'UPDATE_Meters', 'UPDATE_CustomFieldsMeter',
         'UPDATE_CustomFieldsPlace', 'UPDATE_Users', 'UPDATE_Vendors',
         'UPDATE_CustomFieldsVendor', 'CREATE_Users', 'UPDATE_Channels',
         'UPDATE_BillCalculations', 'CREATE_BillCalculations',
         'UPDATE_BillSplits', 'CREATE_BillSplits', 'UPDATE_MeterGroups',
         'UPDATE_BuildingGroups', 'CONVERT_BillSplits',
         'CONVERT_BillCalculations', 'CREATE_Readings', 'UPDATE_Readings',
         'CREATE_MonthlyReadings', 'CREATE_PlaceBenchmarks',
         'UPDATE_PlaceBenchmarks', 'CREATE_UserGroups', 'UPDATE_UserGroups',
         'UPDATE_UserGroupMembers', 'UPDATE_PlaceEnergyStarLink',
         'CREATE_BudgetWorksheet'
        :type type: str
        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or ClientRawResponse if raw=true
        :rtype: str or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_setup_sheet.metadata['url']

        # Construct parameters
        query_parameters = {}
        if type is not None:
            query_parameters['type'] = self._serialize.query("type", type, 'str')
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_setup_sheet.metadata = {'url': '/api/v3/setup'}

    def post_setup_sheet(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Processes a SetupSheet Excel file
        Accepts a base64 string representation of an xlsx file
        File must be Microsoft Excel 2007 or later.

        :param body:
        :type body: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Setup or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.Setup or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.post_setup_sheet.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/vnd.ms-excel'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'str')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Setup', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    post_setup_sheet.metadata = {'url': '/api/v3/setup'}

    def get_setup_sheet_filters(
            self, type=None, custom_headers=None, raw=False, **operation_config):
        """Returns the applicable filters for a given type to filter down
        SetupSheet Templates.

        :param type: Possible values include: 'UNKNOWNTYPE',
         'CREATE_AccountsAndMeters', 'CREATE_BuildingsAndOrganizations',
         'CREATE_CostAvoidanceOtherSavings',
         'CREATE_CostAvoidanceSpecialAdjustments', 'CREATE_CostCenters',
         'CREATE_Customers', 'CREATE_ChargebackDistributionsVersions',
         'CREATE_RateSchedules', 'CREATE_Vendors', 'CREATE_Channels',
         'UPDATE_CostCenters', 'UPDATE_BuildingsAndOrganizations',
         'UPDATE_AccountingCalendar', 'UPDATE_Accounts',
         'UPDATE_CustomFieldsAccount', 'UPDATE_CostAvoidanceOtherSavings',
         'UPDATE_CostAvoidanceSpecialAdjustments', 'UPDATE_Customers',
         'CREATE_GLCodesAndSubcodes', 'UPDATE_GLCodesAndSubcodes',
         'UPDATE_Meters', 'UPDATE_CustomFieldsMeter',
         'UPDATE_CustomFieldsPlace', 'UPDATE_Users', 'UPDATE_Vendors',
         'UPDATE_CustomFieldsVendor', 'CREATE_Users', 'UPDATE_Channels',
         'UPDATE_BillCalculations', 'CREATE_BillCalculations',
         'UPDATE_BillSplits', 'CREATE_BillSplits', 'UPDATE_MeterGroups',
         'UPDATE_BuildingGroups', 'CONVERT_BillSplits',
         'CONVERT_BillCalculations', 'CREATE_Readings', 'UPDATE_Readings',
         'CREATE_MonthlyReadings', 'CREATE_PlaceBenchmarks',
         'UPDATE_PlaceBenchmarks', 'CREATE_UserGroups', 'UPDATE_UserGroups',
         'UPDATE_UserGroupMembers', 'UPDATE_PlaceEnergyStarLink',
         'CREATE_BudgetWorksheet'
        :type type: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.FilterResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_setup_sheet_filters.metadata['url']

        # Construct parameters
        query_parameters = {}
        if type is not None:
            query_parameters['type'] = self._serialize.query("type", type, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[FilterResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_setup_sheet_filters.metadata = {'url': '/api/v3/setup/filter'}

    def get_users(
            self, filter=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of users.
        Requires View permission for Users & Roles.
        If this permission is not available, restricted set of properties are
        returned.

        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.UserResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_users.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UserResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_users.metadata = {'url': '/api/v3/user'}

    def create_user(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a new user. Requires Manage permission for Users & Roles.

        :param body: The object defining the properties for the new user
        :type body: ~energycap.sdk.models.UserCreateRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UserResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UserResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_user.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'UserCreateRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UserResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_user.metadata = {'url': '/api/v3/user'}

    def get_user(
            self, user_id, custom_headers=None, raw=False, **operation_config):
        """Return a specific user and its properties. Requires View permission for
        Users & Roles.

        :param user_id: The ID of the user to return
        :type user_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UserResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UserResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_user.metadata['url']
        path_format_arguments = {
            'userId': self._serialize.url("user_id", user_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UserResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_user.metadata = {'url': '/api/v3/user/{userId}'}

    def edit_user(
            self, user_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit an existing user. Requires Manage permission for Users & Roles.
        Please note that password is optional; all other items are required.
        MaxApprovalAmount may be null; if there is an existing value and null
        is passed, the existing value will be overwritten.

        :param user_id: The ID of the user to edit
        :type user_id: int
        :param body: The object defining the updated properties of the
         existing user.
        :type body: ~energycap.sdk.models.UserEditRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UserResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UserResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_user.metadata['url']
        path_format_arguments = {
            'userId': self._serialize.url("user_id", user_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'UserEditRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UserResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_user.metadata = {'url': '/api/v3/user/{userId}'}

    def get_tags(
            self, filter=None, custom_headers=None, raw=False, **operation_config):
        """Get a list of tags within a tag category.

        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.TagResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_tags.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[TagResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_tags.metadata = {'url': '/api/v3/tag'}

    def get_tasks(
            self, task_type_code=None, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves a list of tasks.

        :param task_type_code: Task type code
        :type task_type_code: str
        :param filter: Filters to apply
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.TaskResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_tasks.metadata['url']

        # Construct parameters
        query_parameters = {}
        if task_type_code is not None:
            query_parameters['taskTypeCode'] = self._serialize.query("task_type_code", task_type_code, 'str')
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[TaskResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_tasks.metadata = {'url': '/api/v3/task'}

    def get_task(
            self, task_guid, custom_headers=None, raw=False, **operation_config):
        """Retrieves a task by its GUID. The output property could potentially
        contain a large amount of data. If response time or size becomes an
        issue, use field reduction to eliminate the output field.

        :param task_guid: The GUID of the task
        :type task_guid: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: TaskResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.TaskResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_task.metadata['url']
        path_format_arguments = {
            'taskGuid': self._serialize.url("task_guid", task_guid, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('TaskResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_task.metadata = {'url': '/api/v3/task/{taskGuid}'}

    def get_task_output_file(
            self, task_guid, custom_headers=None, raw=False, **operation_config):
        """Retrieves a task's error log as an EXCEL file by its GUID.
        At this time error logs can be downloaded for "ReadingImport" task type
        only.

        :param task_guid: The GUID of the task
        :type task_guid: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_task_output_file.metadata['url']
        path_format_arguments = {
            'taskGuid': self._serialize.url("task_guid", task_guid, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    get_task_output_file.metadata = {'url': '/api/v3/task/{taskGuid}/errorOutput'}

    def edit_task(
            self, task_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits the note/comment associated with a task.

        :param task_id: The identifier for the task being edited
        :type task_id: int
        :param body: Data representing the note
        :type body: ~energycap.sdk.models.TaskEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: TaskResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.TaskResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_task.metadata['url']
        path_format_arguments = {
            'taskId': self._serialize.url("task_id", task_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'TaskEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('TaskResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_task.metadata = {'url': '/api/v3/task/{taskId}'}

    def get_templates(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves all templates.

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.TemplateResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_templates.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[TemplateResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_templates.metadata = {'url': '/api/v3/template'}

    def get_template(
            self, template_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves one template.

        :param template_id: The template identifier for the template being
         retrieved
        :type template_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: TemplateResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.TemplateResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_template.metadata['url']
        path_format_arguments = {
            'templateId': self._serialize.url("template_id", template_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('TemplateResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_template.metadata = {'url': '/api/v3/template/{templateId}'}

    def get_template_versions(
            self, template_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all template versions for a given template.

        :param template_id: The template identifier for the template version
         being retrieved
        :type template_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.TemplateVersion] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_template_versions.metadata['url']
        path_format_arguments = {
            'templateId': self._serialize.url("template_id", template_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[TemplateVersion]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_template_versions.metadata = {'url': '/api/v3/template/{templateId}/version'}

    def get_template_version(
            self, template_id, version_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves one template version for a given template.

        :param template_id: The template identifier for the template version
         being retrieved
        :type template_id: int
        :param version_id: The identifier for the template version being
         retrieved
        :type version_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: TemplateVersion or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.TemplateVersion or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_template_version.metadata['url']
        path_format_arguments = {
            'templateId': self._serialize.url("template_id", template_id, 'int'),
            'versionId': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('TemplateVersion', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_template_version.metadata = {'url': '/api/v3/template/{templateId}/version/{versionId}'}

    def create_template_from_bill_method(
            self, bill_id, meter_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates a new Template from an existing Bill's line items belonging to
        the provided Meter.

        :param bill_id: Id of Bill from which to create the Template
        :type bill_id: int
        :param meter_id: Id of Meter whose bodylines from source bill will be
         used to create the Template
        :type meter_id: int
        :param body: Additional information about new Template
        :type body: ~energycap.sdk.models.CreateTemplateFromBill
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: TemplateResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.TemplateResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_template_from_bill_method.metadata['url']
        path_format_arguments = {
            'billId': self._serialize.url("bill_id", bill_id, 'int'),
            'meterId': self._serialize.url("meter_id", meter_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'CreateTemplateFromBill')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('TemplateResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_template_from_bill_method.metadata = {'url': '/api/v3/bill/{billId}/meter/{meterId}/template'}

    def update_account_meters_latest_template(
            self, template_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Update current template for all passed in accountMeterIds
        If the accountMeter is an account only record an error is thrown
        If the accountMeter has no template assigned one will be created
        If the accountMeter's latest template assignment is end dated, a new
        assignment will be created starting from the latest end date
        All must be successfully updated otherwise none are updated and an
        error is returned.

        :param template_id:
        :type template_id: int
        :param body:
        :type body: list[int]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_account_meters_latest_template.metadata['url']
        path_format_arguments = {
            'templateId': self._serialize.url("template_id", template_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[int]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    update_account_meters_latest_template.metadata = {'url': '/api/v3/template/{templateId}/accountMeter'}

    def get_time_zones(
            self, custom_headers=None, raw=False, **operation_config):
        """Retrieves the list of Time Zones.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.TimeZoneResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_time_zones.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[TimeZoneResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_time_zones.metadata = {'url': '/api/v3/timezone'}

    def get_ud_fs(
            self, filter=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves all User defined fields/custom fields.
        The array of UDFs can be filtered by UDF type.
        Possible values for this filter include: "account", "meter", "place",
        "vendor" and "channelVersion".
        See the filter property for more details.

        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.UDFResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_ud_fs.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UDFResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_ud_fs.metadata = {'url': '/api/v3/udf'}

    def create_udf(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates a User defined field / custom field.

        :param body: Data representing the UDF being created
        :type body: ~energycap.sdk.models.UDFCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UDFResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UDFResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_udf.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'UDFCreate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UDFResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_udf.metadata = {'url': '/api/v3/udf'}

    def get_udf(
            self, udf_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves one User defined field / custom field.

        :param udf_id: The UDF identifier
        :type udf_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UDFResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UDFResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_udf.metadata['url']
        path_format_arguments = {
            'udfId': self._serialize.url("udf_id", udf_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UDFResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_udf.metadata = {'url': '/api/v3/udf/{udfId}'}

    def edit_udf(
            self, udf_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits a UDF.

        :param udf_id:
        :type udf_id: int
        :param body: Data representing the UDF being edited
        :type body: ~energycap.sdk.models.UDFEdit
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UDFResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UDFResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_udf.metadata['url']
        path_format_arguments = {
            'udfId': self._serialize.url("udf_id", udf_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'UDFEdit')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UDFResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_udf.metadata = {'url': '/api/v3/udf/{udfId}'}

    def delete_udf(
            self, udf_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a UDF. Currently NO confirmation is required.

        :param udf_id: The identifier for the UDF being deleted
        :type udf_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_udf.metadata['url']
        path_format_arguments = {
            'udfId': self._serialize.url("udf_id", udf_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_udf.metadata = {'url': '/api/v3/udf/{udfId}'}

    def edit_custom_fields(
            self, udf_type, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits one User defined field / custom field.

        :param udf_type: Valid udfTypes include "Account", "Vendor", "Place",
         "Meter, and "ChannelVersion"
        :type udf_type: str
        :param body:
        :type body: list[~energycap.sdk.models.UDFUpdate]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.UDFResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_custom_fields.metadata['url']
        path_format_arguments = {
            'udfType': self._serialize.url("udf_type", udf_type, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[UDFUpdate]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UDFResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_custom_fields.metadata = {'url': '/api/v3/udf/list/{udfType}'}

    def get_units(
            self, filter=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves all units.

        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.Unit] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_units.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[Unit]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_units.metadata = {'url': '/api/v3/unit'}

    def update_use_rollup_units(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Update common and global use units.

        :param body:
        :type body: ~energycap.sdk.models.RollupUnitUpdate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: TaskResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.TaskResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_use_rollup_units.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'RollupUnitUpdate')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('TaskResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    update_use_rollup_units.metadata = {'url': '/api/v3/unit/rollup'}

    def get_user_groups(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of user groups.

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.UserGroupResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_user_groups.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[UserGroupResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_user_groups.metadata = {'url': '/api/v3/userGroup'}

    def create_user_group(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a user group.

        :param body: Data representing the user group being created
        :type body: ~energycap.sdk.models.UserGroupRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UserGroupResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UserGroupResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_user_group.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'UserGroupRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UserGroupResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_user_group.metadata = {'url': '/api/v3/userGroup'}

    def get_user_group(
            self, user_group_id, custom_headers=None, raw=False, **operation_config):
        """Gets a user group.

        :param user_group_id: Id of the user group to return
        :type user_group_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UserGroupResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UserGroupResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_user_group.metadata['url']
        path_format_arguments = {
            'userGroupId': self._serialize.url("user_group_id", user_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UserGroupResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_user_group.metadata = {'url': '/api/v3/userGroup/{userGroupId}'}

    def edit_user_group(
            self, user_group_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit a user group.

        :param user_group_id: Id of the user group to edit
        :type user_group_id: int
        :param body: Data representing the user group being edited
        :type body: ~energycap.sdk.models.UserGroupRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UserGroupResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.UserGroupResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_user_group.metadata['url']
        path_format_arguments = {
            'userGroupId': self._serialize.url("user_group_id", user_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'UserGroupRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UserGroupResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_user_group.metadata = {'url': '/api/v3/userGroup/{userGroupId}'}

    def delete_user_group(
            self, user_group_id, custom_headers=None, raw=False, **operation_config):
        """Delete a user group.

        :param user_group_id: Id of the user group to delete
        :type user_group_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_user_group.metadata['url']
        path_format_arguments = {
            'userGroupId': self._serialize.url("user_group_id", user_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_user_group.metadata = {'url': '/api/v3/userGroup/{userGroupId}'}

    def get_user_group_members(
            self, user_group_id, custom_headers=None, raw=False, **operation_config):
        """Gets a list of user group members.

        :param user_group_id: Id of the user group to get the list of members
        :type user_group_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.UserChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_user_group_members.metadata['url']
        path_format_arguments = {
            'userGroupId': self._serialize.url("user_group_id", user_group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UserChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_user_group_members.metadata = {'url': '/api/v3/userGroup/{userGroupId}/member'}

    def get_user_roles(
            self, custom_headers=None, raw=False, **operation_config):
        """

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.SystemUserRoleResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_user_roles.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[SystemUserRoleResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_user_roles.metadata = {'url': '/api/v3/userrole'}

    def create_user_role(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """

        :param body:
        :type body: ~energycap.sdk.models.SystemUserRoleRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SystemUserRoleResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SystemUserRoleResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_user_role.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'SystemUserRoleRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SystemUserRoleResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_user_role.metadata = {'url': '/api/v3/userrole'}

    def get_user_role(
            self, user_role_id, custom_headers=None, raw=False, **operation_config):
        """

        :param user_role_id:
        :type user_role_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SystemUserRoleResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SystemUserRoleResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_user_role.metadata['url']
        path_format_arguments = {
            'userRoleId': self._serialize.url("user_role_id", user_role_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SystemUserRoleResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_user_role.metadata = {'url': '/api/v3/userrole/{userRoleId}'}

    def edit_user_role(
            self, user_role_id, body=None, custom_headers=None, raw=False, **operation_config):
        """

        :param user_role_id:
        :type user_role_id: int
        :param body:
        :type body: ~energycap.sdk.models.SystemUserRoleRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SystemUserRoleResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SystemUserRoleResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_user_role.metadata['url']
        path_format_arguments = {
            'userRoleId': self._serialize.url("user_role_id", user_role_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'SystemUserRoleRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SystemUserRoleResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_user_role.metadata = {'url': '/api/v3/userrole/{userRoleId}'}

    def delete_user_role(
            self, user_role_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a user role.

        :param user_role_id: The identifier for the role being deleted
        :type user_role_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_user_role.metadata['url']
        path_format_arguments = {
            'userRoleId': self._serialize.url("user_role_id", user_role_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_user_role.metadata = {'url': '/api/v3/userrole/{userRoleId}'}

    def get_vendor(
            self, vendor_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves one vendor.

        :param vendor_id: The identifier for the vendor being retrieved
        :type vendor_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: VendorResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.VendorResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_vendor.metadata['url']
        path_format_arguments = {
            'vendorId': self._serialize.url("vendor_id", vendor_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VendorResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_vendor.metadata = {'url': '/api/v3/vendor/{vendorId}'}

    def edit_vendor(
            self, vendor_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits a vendor.

        :param vendor_id: The identifier for the vendor being edited
        :type vendor_id: int
        :param body: Data representing the vendor being edited
        :type body: ~energycap.sdk.models.VendorRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: VendorResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.VendorResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_vendor.metadata['url']
        path_format_arguments = {
            'vendorId': self._serialize.url("vendor_id", vendor_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'VendorRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VendorResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_vendor.metadata = {'url': '/api/v3/vendor/{vendorId}'}

    def delete_vendor(
            self, vendor_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a vendor.

        :param vendor_id: The identifier for the vendor being deleted
        :type vendor_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_vendor.metadata['url']
        path_format_arguments = {
            'vendorId': self._serialize.url("vendor_id", vendor_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_vendor.metadata = {'url': '/api/v3/vendor/{vendorId}'}

    def get_vendors(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves an array of vendors. The array of vendors can be filtered by
        a number of criteria. See the filter property for more details.

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.VendorResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_vendors.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[VendorResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_vendors.metadata = {'url': '/api/v3/vendor'}

    def create_vendor(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Creates a vendor.

        :param body: Data representing the vendor being created
        :type body: ~energycap.sdk.models.VendorRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: VendorResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.VendorResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_vendor.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'VendorRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VendorResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_vendor.metadata = {'url': '/api/v3/vendor'}

    def edit_vendor_ud_fs(
            self, vendor_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edits a vendor UDF values.

        :param vendor_id: The identifier for the vendor being edited
        :type vendor_id: int
        :param body: Data representing the vendor UDFs being edited
        :type body: list[~energycap.sdk.models.UDFValue]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.UDFFieldChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_vendor_ud_fs.metadata['url']
        path_format_arguments = {
            'vendorId': self._serialize.url("vendor_id", vendor_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[UDFValue]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UDFFieldChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_vendor_ud_fs.metadata = {'url': '/api/v3/vendor/{vendorId}/udf'}

    def get_vendor_udfs(
            self, vendor_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all UDFs for a particular vendor.

        :param vendor_id: The vendor identifier for which UDF values are being
         retrieved
        :type vendor_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.UDFFieldChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_vendor_udfs.metadata['url']
        path_format_arguments = {
            'vendorId': self._serialize.url("vendor_id", vendor_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UDFFieldChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_vendor_udfs.metadata = {'url': '/api/v3/vendor/{vendorId}/udf'}

    def get_vendors_udfs(
            self, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves all UDFs for all vendors.

        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.VendorUDFResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_vendors_udfs.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[VendorUDFResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_vendors_udfs.metadata = {'url': '/api/v3/vendor/udf'}

    def get_vendor_contracts(
            self, vendor_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves all Contracts for a particular vendor.

        :param vendor_id: The vendor identifier for which Contracts are being
         retrieved
        :type vendor_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.VendorContractResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_vendor_contracts.metadata['url']
        path_format_arguments = {
            'vendorId': self._serialize.url("vendor_id", vendor_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[VendorContractResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_vendor_contracts.metadata = {'url': '/api/v3/vendor/{vendorId}/contract'}

    def add_accounts(
            self, vendor_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Add accounts to a vendor.

        :param vendor_id: The identifier for the vendor to which accounts are
         being added
        :type vendor_id: int
        :param body: Data representing the accounts being added
        :type body: list[int]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.add_accounts.metadata['url']
        path_format_arguments = {
            'vendorId': self._serialize.url("vendor_id", vendor_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, '[int]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    add_accounts.metadata = {'url': '/api/v3/vendor/{vendorId}/account'}

    def get_vendor_actual_yearly(
            self, vendor_id, number_of_years=4, custom_headers=None, raw=False, **operation_config):
        """Retrieves rolled up actual billing data by vendor for a given number of
        years- Result includes cost, use, unit cost on an yearly basis. It also
        includes commodity level break up.

        :param vendor_id: The vendor to retrieve data for
        :type vendor_id: int
        :param number_of_years: Number of years of data to return includes the
         current year - Defaults to 4
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: VendorDigestActualYearlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.VendorDigestActualYearlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_vendor_actual_yearly.metadata['url']
        path_format_arguments = {
            'vendorId': self._serialize.url("vendor_id", vendor_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VendorDigestActualYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_vendor_actual_yearly.metadata = {'url': '/api/v3/vendor/{vendorId}/digest/actual/yearly'}

    def import_weather_data(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Import mean daily temperature readings for weather stations which are
        connected to EnergyCAP weather services.

        ### Other Remarks
        By default, this endpoint may be called without parameters to import
        weather for all "used" weather stations (at least one building is
        assigned to it) beginning from the current date minus 31 days.
        By providing a begin date, API users may go further back in history to
        backfill missing weather data.
        If a weather station has no readings at all, then the begin date will
        be set to 1899-12-31 so we can import history
        However the begin date is ascertained, readings will be imported from
        that date through today's date, overwriting any existing readings or
        filling in any missing readings.
        The API user may also provide a list of weather station codes. Even if
        the provided stations are not yet used, weather readings will be
        imported for them.

        :param body:
        :type body: ~energycap.sdk.models.WeatherImportSettings
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: WeatherImportResult or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.WeatherImportResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.import_weather_data.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'WeatherImportSettings')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('WeatherImportResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    import_weather_data.metadata = {'url': '/api/v3/weatherstation/import'}

    def get_weather_stations(
            self, custom_headers=None, raw=False, **operation_config):
        """Get weather stations. Includes custom-created weather stations.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.WeatherStationResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_weather_stations.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[WeatherStationResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_weather_stations.metadata = {'url': '/api/v3/weatherstation'}

    def create_webhook(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Create a new webhook.

        :param body:
        :type body: ~energycap.sdk.models.WebhookCreateRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: WebhookResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.WebhookResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_webhook.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'WebhookCreateRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('WebhookResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_webhook.metadata = {'url': '/api/v3/webhook'}

    def get_webhooks(
            self, filter=None, custom_headers=None, raw=False, **operation_config):
        """Get a list of all webhooks.

        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.WebhookResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_webhooks.metadata['url']

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[WebhookResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_webhooks.metadata = {'url': '/api/v3/webhook'}

    def edit_webhook(
            self, webhook_id, body=None, custom_headers=None, raw=False, **operation_config):
        """Edit an existing webhook.

        :param webhook_id:
        :type webhook_id: int
        :param body:
        :type body: ~energycap.sdk.models.WebhookEditRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: WebhookResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.WebhookResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_webhook.metadata['url']
        path_format_arguments = {
            'webhookId': self._serialize.url("webhook_id", webhook_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'WebhookEditRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('WebhookResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_webhook.metadata = {'url': '/api/v3/webhook/{webhookId}'}

    def delete_webhook(
            self, webhook_id, custom_headers=None, raw=False, **operation_config):
        """Delete a webhook.

        :param webhook_id:
        :type webhook_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_webhook.metadata['url']
        path_format_arguments = {
            'webhookId': self._serialize.url("webhook_id", webhook_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_webhook.metadata = {'url': '/api/v3/webhook/{webhookId}'}

    def get_webhook(
            self, webhook_id, custom_headers=None, raw=False, **operation_config):
        """Get a single webhook.

        :param webhook_id:
        :type webhook_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: WebhookResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.WebhookResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_webhook.metadata['url']
        path_format_arguments = {
            'webhookId': self._serialize.url("webhook_id", webhook_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('WebhookResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_webhook.metadata = {'url': '/api/v3/webhook/{webhookId}'}

    def get_webhook_logs(
            self, webhook_id, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Get a list of webhook event logs.

        :param webhook_id:
        :type webhook_id: int
        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.WebhookLogResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_webhook_logs.metadata['url']
        path_format_arguments = {
            'webhookId': self._serialize.url("webhook_id", webhook_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[WebhookLogResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_webhook_logs.metadata = {'url': '/api/v3/webhook/{webhookId}/log'}

    def get_webhook_log_details(
            self, webhook_id, webhook_log_id, custom_headers=None, raw=False, **operation_config):
        """Get details for a webhook log.

        :param webhook_id:
        :type webhook_id: int
        :param webhook_log_id:
        :type webhook_log_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: WebhookLogDetailsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.WebhookLogDetailsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_webhook_log_details.metadata['url']
        path_format_arguments = {
            'webhookId': self._serialize.url("webhook_id", webhook_id, 'int'),
            'webhookLogId': self._serialize.url("webhook_log_id", webhook_log_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('WebhookLogDetailsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_webhook_log_details.metadata = {'url': '/api/v3/webhook/{webhookId}/log/{webhookLogId}/detail'}

    def get_webhook_event_types(
            self, custom_headers=None, raw=False, **operation_config):
        """Get webhook event types.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.WebhookEventTypeChild] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_webhook_event_types.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[WebhookEventTypeChild]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_webhook_event_types.metadata = {'url': '/api/v3/webhook/eventType'}

    def get_widgets(
            self, custom_headers=None, raw=False, **operation_config):
        """Retrieves an array of widgets.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.WidgetResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_widgets.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[WidgetResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_widgets.metadata = {'url': '/api/v3/widget'}

    def get_eui_chart_widget_data(
            self, specific_widget_id, filter=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves energy use intensity data for a specific widget.

        :param specific_widget_id: Specific widget identifier to get the data
         for
        :type specific_widget_id: int
        :param filter: API filters
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PlaceDigestEnergyUseIntensity] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_eui_chart_widget_data.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceDigestEnergyUseIntensity]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_eui_chart_widget_data.metadata = {'url': '/api/v3/widget/eui/{specificWidgetId}'}

    def get_missing_bills(
            self, specific_widget_id, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Returns gaps in billing data for a date range specified by the  Bill
        Date Range filter.
        A gap is defined as at least one day that falls within the account's
        service dates and
        not included in any bill for that account meter.
        The Allowable Gap Days filter specifies the number of days that must be
        in the gap
        before it will be included in the results.

        :param specific_widget_id: Specific widget identifier to get the data
         for
        :type specific_widget_id: int
        :param filter:
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.MissingBillWidget] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_missing_bills.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[MissingBillWidget]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_missing_bills.metadata = {'url': '/api/v3/widget/missingbills/{specificWidgetId}'}

    def get_bills_overdue_from_vendor(
            self, specific_widget_id, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves data about bills that have not yet been received from
        vendors.
        NOTE: Does not support global dashboard filtering with Topmost Place,
        Place Group API filters.

        :param specific_widget_id: Specific widget identifier to get the data
         for
        :type specific_widget_id: int
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.BillsOverdueFromVendorResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bills_overdue_from_vendor.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[BillsOverdueFromVendorResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_bills_overdue_from_vendor.metadata = {'url': '/api/v3/widget/billsoverduefromvendor/{specificWidgetId}'}

    def get_interval_data(
            self, specific_widget_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves interval data for a specific widget
        NOTE: Does not support global dashboard filtering with Topmost Place,
        Place Group API filters.

        :param specific_widget_id: Specific widget identifier to get the data
         for
        :type specific_widget_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.Readings] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_interval_data.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[Readings]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_interval_data.metadata = {'url': '/api/v3/widget/intervaldata/{specificWidgetId}'}

    def get_map_places(
            self, specific_widget_id, custom_headers=None, raw=False, **operation_config):
        """Retrieves map data for a specific map widget
        NOTE: Does not support global dashboard filtering with Topmost Place,
        Place Group API filters.

        :param specific_widget_id: Specific widget identifier to get the data
         for
        :type specific_widget_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.MapPlace] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_map_places.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[MapPlace]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_map_places.metadata = {'url': '/api/v3/widget/map/{specificWidgetId}'}

    def get_energy_star_multiple_buildings(
            self, specific_widget_id, number_of_years=2, filter=None, page_size=None, page_number=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves a list of buildings for the Multiple ENERGY STAR Buildings
        widget.
        The widget is expecting zero, one, or many buildings, and alters its
        layout based on how many results it receives.
        Validation:
        - The provided specific widget must exist
        - The provided specific widget must be an Multiple ENERGY STAR
        Buildings widget.

        :param specific_widget_id: Identifier for a specific ENERGY STAR
         widget on a dashboard
        :type specific_widget_id: int
        :param number_of_years: Only used when a single building is returned.
         The number of years to go back from most recent score. Defaults to 2
         years. If 0 is provided, will only include current score.
        :type number_of_years: int
        :param filter: Filter string which may add to or override saved filter
         values during this request
        :type filter: str
        :param page_size: The number of elements to return in a page
        :type page_size: int
        :param page_number: The current page number
        :type page_number: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.EnergyStarPlaceHierarchyResponse]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_energy_star_multiple_buildings.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int', maximum=2147483647, minimum=0)
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if page_number is not None:
            query_parameters['pageNumber'] = self._serialize.query("page_number", page_number, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[EnergyStarPlaceHierarchyResponse]', response)
            header_dict = {
                'PageNumber': 'int',
                'TotalPages': 'int',
                'PageSize': 'int',
                'TotalNumberOfRecords': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_energy_star_multiple_buildings.metadata = {'url': '/api/v3/widget/multipleenergystarbuildings/{specificWidgetId}'}

    def get_energy_star_single_building(
            self, specific_widget_id, number_of_years=2, custom_headers=None, raw=False, **operation_config):
        """Retrieves ENERGY STAR place score history for a building
        Validation:
        - The provided specific widget must exist
        - The provided specific widget must be an ENERGY STAR Single Building
        widget.

        :param specific_widget_id: Identifier for a specific Single ENERGY
         STAR Building widget on a dashboard
        :type specific_widget_id: int
        :param number_of_years: The number of years to go back from most
         recent score. Defaults to 2 years. If 0 is provided, will only include
         current score.
        :type number_of_years: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EnergyStarPlaceHierarchyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.EnergyStarPlaceHierarchyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_energy_star_single_building.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if number_of_years is not None:
            query_parameters['numberOfYears'] = self._serialize.query("number_of_years", number_of_years, 'int', maximum=2147483647, minimum=0)

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EnergyStarPlaceHierarchyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_energy_star_single_building.metadata = {'url': '/api/v3/widget/singleenergystarbuilding/{specificWidgetId}'}

    def get_actionable_bill_counts(
            self, specific_widget_id, filter=None, custom_headers=None, raw=False, **operation_config):
        """Returns counts of bills Held from Export, bills Waiting for Export to
        AP, bills Waiting for Export to GL, bills which are Not Approved, and
        bills with unresolved flags.

        :param specific_widget_id: Identifier for a specific Bill Status
         widget on a dashboard
        :type specific_widget_id: int
        :param filter: Filter string which may add to or override saved filter
         values during this request
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ActionableBillCounts or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ActionableBillCounts or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_actionable_bill_counts.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ActionableBillCounts', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_actionable_bill_counts.metadata = {'url': '/api/v3/widget/actionablebillcounts/{specificWidgetId}'}

    def get_most_expensive_buildings(
            self, specific_widget_id, filter=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves the most expensive building data for a specific widget.

        :param specific_widget_id: Specific widget identifier to get the data
         for
        :type specific_widget_id: int
        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.PlaceCost] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_most_expensive_buildings.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[PlaceCost]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_most_expensive_buildings.metadata = {'url': '/api/v3/widget/mostexpensivebuildings/{specificWidgetId}'}

    def get_monthly_use_trend(
            self, specific_widget_id, filter=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves monthly global use trend for a dashboard widget.

        :param specific_widget_id: Specific widget identifier to get the data
         for
        :type specific_widget_id: int
        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceDigestActualAndCalendarizedMonthlyResponse or
         ClientRawResponse if raw=true
        :rtype:
         ~energycap.sdk.models.PlaceDigestActualAndCalendarizedMonthlyResponse
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_monthly_use_trend.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceDigestActualAndCalendarizedMonthlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_monthly_use_trend.metadata = {'url': '/api/v3/widget/monthlyusetrend/{specificWidgetId}'}

    def get_monthly_cost_trend(
            self, specific_widget_id, filter=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves monthly cost trend for a dashboard widget.

        :param specific_widget_id: Specific widget identifier to get the data
         for
        :type specific_widget_id: int
        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceDigestActualAndCalendarizedMonthlyResponse or
         ClientRawResponse if raw=true
        :rtype:
         ~energycap.sdk.models.PlaceDigestActualAndCalendarizedMonthlyResponse
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_monthly_cost_trend.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceDigestActualAndCalendarizedMonthlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_monthly_cost_trend.metadata = {'url': '/api/v3/widget/monthlycosttrend/{specificWidgetId}'}

    def get_carbon_footprint(
            self, specific_widget_id, filter=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves the carbon footprint data for a specific widget.

        :param specific_widget_id: Specific widget identifier to get the data
         for
        :type specific_widget_id: int
        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceDigestGHGYearlyResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.PlaceDigestGHGYearlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_carbon_footprint.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceDigestGHGYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_carbon_footprint.metadata = {'url': '/api/v3/widget/carbonfootprint/{specificWidgetId}'}

    def get_cost_avoidance_program_savings(
            self, specific_widget_id, filter=None, custom_headers=None, raw=False, **operation_config):
        """Returns Cost Avoidance Savings Program-to-date. The user can set the
        topmost place and/or commodity filters.

        :param specific_widget_id: Specific widget identifier to get the data
         for
        :type specific_widget_id: int
        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceDigestSavingsYearlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.PlaceDigestSavingsYearlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_cost_avoidance_program_savings.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceDigestSavingsYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_cost_avoidance_program_savings.metadata = {'url': '/api/v3/widget/programsavings/{specificWidgetId}'}

    def monthly_cap_trend_method(
            self, specific_widget_id, filter=None, custom_headers=None, raw=False, **operation_config):
        """Returns data for the monthly savings trend widget.

        :param specific_widget_id:
        :type specific_widget_id: int
        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.MonthlyCAPTrend] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.monthly_cap_trend_method.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[MonthlyCAPTrend]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    monthly_cap_trend_method.metadata = {'url': '/api/v3/widget/monthlysavingstrend/{specificWidgetId}'}

    def get_most_expensive_meters(
            self, specific_widget_id, filter=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves the most expensive meters data for a specific widget.

        :param specific_widget_id: Specific widget identifier to get the data
         for
        :type specific_widget_id: int
        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~energycap.sdk.models.MeterCost] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_most_expensive_meters.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[MeterCost]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_most_expensive_meters.metadata = {'url': '/api/v3/widget/mostexpensivemeters/{specificWidgetId}'}

    def get_commodity_cost(
            self, specific_widget_id, filter=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves data for commodity cost dashboard widget.

        :param specific_widget_id: Specific widget identifier to get the data
         for
        :type specific_widget_id: int
        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceDigestActualAndCalendarizedMonthlyResponse or
         ClientRawResponse if raw=true
        :rtype:
         ~energycap.sdk.models.PlaceDigestActualAndCalendarizedMonthlyResponse
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_commodity_cost.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceDigestActualAndCalendarizedMonthlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_commodity_cost.metadata = {'url': '/api/v3/widget/commoditycost/{specificWidgetId}'}

    def cost_avoidance_by_commodity(
            self, specific_widget_id, filter=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves data for cost avoidance by commodity dashboard widget.

        :param specific_widget_id: Specific widget identifier to get the data
         for
        :type specific_widget_id: int
        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PlaceDigestSavingsYearlyResponse or ClientRawResponse if
         raw=true
        :rtype: ~energycap.sdk.models.PlaceDigestSavingsYearlyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.cost_avoidance_by_commodity.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PlaceDigestSavingsYearlyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    cost_avoidance_by_commodity.metadata = {'url': '/api/v3/widget/costavoidancebycommodity/{specificWidgetId}'}

    def get_bill_count(
            self, specific_widget_id, filter=None, custom_headers=None, raw=False, **operation_config):
        """Retrieves a count of bills for the specific widget.

        :param specific_widget_id: Specific widget identifier to get the data
         for
        :type specific_widget_id: int
        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SingleValue or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.SingleValue or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_bill_count.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SingleValue', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_bill_count.metadata = {'url': '/api/v3/widget/billcount/{specificWidgetId}'}

    def execute_sproc_widget(
            self, specific_widget_id, filter=None, custom_headers=None, raw=False, **operation_config):
        """

        :param specific_widget_id:
        :type specific_widget_id: int
        :param filter:
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: FlagWidget or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.FlagWidget or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.execute_sproc_widget.metadata['url']
        path_format_arguments = {
            'specificWidgetId': self._serialize.url("specific_widget_id", specific_widget_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FlagWidget', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    execute_sproc_widget.metadata = {'url': '/api/v3/widget/exec/{specificWidgetId}'}

    def get_batch_workflow(
            self, custom_headers=None, raw=False, **operation_config):
        """

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: BatchWorkflowSettings or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.BatchWorkflowSettings or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_batch_workflow.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BatchWorkflowSettings', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_batch_workflow.metadata = {'url': '/api/v3/workflow/batch'}

    def get_export_workflow(
            self, export_mode="ap", custom_headers=None, raw=False, **operation_config):
        """

        :param export_mode:
        :type export_mode: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ExportWorkflowSettings or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ExportWorkflowSettings or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_export_workflow.metadata['url']

        # Construct parameters
        query_parameters = {}
        if export_mode is not None:
            query_parameters['exportMode'] = self._serialize.query("export_mode", export_mode, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ExportWorkflowSettings', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_export_workflow.metadata = {'url': '/api/v3/workflow/export'}

    def get_approval_workflow(
            self, custom_headers=None, raw=False, **operation_config):
        """

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ApprovalWorkflowSettings or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ApprovalWorkflowSettings or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_approval_workflow.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ApprovalWorkflowSettings', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_approval_workflow.metadata = {'url': '/api/v3/workflow/approval'}

    def get_workflow(
            self, custom_headers=None, raw=False, **operation_config):
        """

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: WorkflowSettingsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.WorkflowSettingsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_workflow.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('WorkflowSettingsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_workflow.metadata = {'url': '/api/v3/workflow'}

    def edit_workflow(
            self, body=None, custom_headers=None, raw=False, **operation_config):
        """Update bill workflow settings.

        :param body: All workflow settings
        :type body: ~energycap.sdk.models.WorkflowSettingsRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: WorkflowSettingsResponse or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.WorkflowSettingsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.edit_workflow.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'WorkflowSettingsRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('WorkflowSettingsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    edit_workflow.metadata = {'url': '/api/v3/workflow'}

    def get_chargeback_workflow_settings(
            self, custom_headers=None, raw=False, **operation_config):
        """Get chargeback workflow settings.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChargebackWorkflowSettings or ClientRawResponse if raw=true
        :rtype: ~energycap.sdk.models.ChargebackWorkflowSettings or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_chargeback_workflow_settings.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ChargebackWorkflowSettings', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_chargeback_workflow_settings.metadata = {'url': '/api/v3/workflow/chargeback'}
