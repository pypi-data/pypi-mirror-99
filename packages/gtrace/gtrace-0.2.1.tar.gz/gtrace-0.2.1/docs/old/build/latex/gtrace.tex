% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{gtrace Documentation}
\date{November 08, 2012}
\release{0.1.0}
\author{Yoichi Aso}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Introduction}
\label{intro:introduction}\label{intro:gtrace-documentation}\label{intro::doc}
gtrace is a python package to trace the propagation of Gaussian beams among optical components such as mirrors and lenses. The features of gtrace include:
\begin{itemize}
\item {} 
Automatically track the Gaussian beam propagation, i.e. q-parameter change, using the ABCD matrix method.

\item {} 
Reflection and refraction at interface surfaces are properly treated.

\item {} 
Automatically track the optical distance traveled by a beam through dielectric media.

\item {} 
Sequential or non-sequential trace modes are available.

\item {} 
Exporting the results to DXF files

\end{itemize}

The main motivation behind the development of gtrace was to help the design of the optical layout for the \href{http://gwcenter.icrr.u-tokyo.ac.jp/en/}{KAGRA} interferometer. The task is not so trivial because we had to satisfy many constraints at the same time. Manually placing mirrors on a CAD and adjusting the distances between the mirrors and their orientations was not an option. We needed a way to automatically adjust the optical layout with a computer to satisfy our requirements. In order to do this, we needed a tool to represent an optical layout convenient for computer processings. gtrace represents mirrors and beams as class objects in python. Then the propagation of the beams can be treated as interactions between the beams and the mirrors. This way, we can automate the optimization of the KAGRA optical layout.

The main ingredients of gtrace are mirrors and beams. A mirror is represented as an instance of {\hyperref[api/gtrace:gtrace.optcomp.Mirror]{\code{Mirror}}} class. You place mirrors in a 2D plane. You can set various properties of a mirror such as size, curvature, reflectivities, wedge angle etc. Then you launch a beam, an instance of {\hyperref[api/gtrace:gtrace.beam.GaussianBeam]{\code{GaussianBeam}}} class, from a certain point in the 2D plane. As the beam hits mirrors, it is divided into several sub-beams, such as reflections and deflected beams. These newly generated beam objects are available to you for further propagation. In the non-sequential mode, these sub-beams are automatically propagated until one of the termination conditions is satisfied. The termination conditions include, not hitting any mirror, power is below a certain threshold and so on. At the end of the propagation, you will have a collection of beam objects generated by the collision with the mirrors. You can export the mirrors and the beams into a DXF file.

gtrace is at this moment limited to 2D optical layouts. This limitation might be lifted in the future.


\chapter{Basic Concepts}
\label{basic_concepts:basic-concepts}\label{basic_concepts::doc}
In this section, basic concepts of gtrace will be introduced.


\section{2D plane}
\label{basic_concepts:d-plane}
In gtrace world, an optical system will be placed on a two dimentional plane. A location on the plane is specified by a set of Cartesian coordinates (x, y). This just a normal x-y plane. The origin of the axes is at the lower left of the plane. The X-axis extends horizontally to the right. The Y-axis goes up vertically. Nothing more to add here.


\section{Direction}
\label{basic_concepts:direction}
\includegraphics[height=5cm]{Direction.pdf}

While working with optical layouts, one often has to specify a direction in the 2D plane such as the orientation of a mirror or the propagation direction of a beam. In gtrace, in most cases, a direction can be specified in two ways. One way is to use an angle measured from the X-axis in counter clockwise (\code{dirAngle} in the figure above). The other way is to use a 2D vector of length 1. If a direction can be specified either way, you only have to specify it in one of those methods. For example, the {\hyperref[api/gtrace:gtrace.beam.GaussianBeam]{\code{GaussianBeam}}} class has an attribute called \code{dirVect}. It holds a 2D vector in the form of \code{numpy.Array}. The {\hyperref[api/gtrace:gtrace.beam.GaussianBeam]{\code{GaussianBeam}}} class also has an attribute called \code{dirAngle}, which holds the angle of the beam propagation direction measured from the X-axis in radian.  When one of the two attributes is changed, the other is updated automatically to be consistent with the modification. Therefore, you don't have to worry about the consistency. For the direction vector, it is also automatically normalized. Therefore, you can assign it a vector of any norm.


\section{Beam}
\label{basic_concepts:beam}
\includegraphics[height=10cm]{Beam.pdf}

A Gaussian beam is represented by an instance of {\hyperref[api/gtrace:gtrace.beam.GaussianBeam]{\code{GaussianBeam}}} class. The most fundamental properties of a beam is its position (\code{pos}) and the direction of propagation (\code{dirVect} or \code{dirAngle}).


\chapter{API References}
\label{api/modules:api-references}\label{api/modules::doc}

\section{gtrace Package}
\label{api/gtrace:gtrace-package}\label{api/gtrace::doc}

\subsection{\texttt{gtrace} Package}
\label{api/gtrace:id1}\phantomsection\label{api/gtrace:module-gtrace.__init__}\index{gtrace.\_\_init\_\_ (module)}
This package provides necessary classes and functions for tracing the propagation
of Gaussian beams among mirrors and lenses.


\subsection{\texttt{beam} Module}
\label{api/gtrace:module-gtrace.beam}\label{api/gtrace:beam-module}\index{gtrace.beam (module)}
gtrace.beam

A module to define GaussianBeam class.
\index{GaussianBeam (class in gtrace.beam)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.GaussianBeam}\pysiglinewithargsret{\strong{class }\code{gtrace.beam.}\bfcode{GaussianBeam}}{\emph{q0=2.952624674426497j, q0x=False, q0y=False, pos={[}0.0, 0.0{]}, length=1.0, dirAngle=0.0, dirVect=None, wl=1.064e-06, P=1.0, n=1.0, name='Beam', layer='main\_beam'}}{}
Bases: \code{traits.has\_traits.HasTraits}

This is a class to represent a Gaussian beam.
A GaussianBeam object has its origin (pos) and a propagation
direction (dirVect or dirAngle).
A GaussianBeam is characterized by q-parameter(s) at its origin.
The beam can be either circular or elliptic. In order to deal with
elliptic beams, some parameters are stored in pairs like (q0x, q0y).
x and y denote the axes of the cross section of the beam. x-axis is
parallel to the paper and the y-axis is perpendicular to the paper.

A beam object can be propagated through a free space or made
to interact with an optics.

As a beam propagate through optical system, optical distance and
Gouy phase are accumerated.

\emph{=== Attributes ===}
\begin{description}
\item[{\textbf{q:} q-parameter of the beam. If the beam is eliptic, q is the q-parameter}] \leavevmode
of the best matching circular mode.

\end{description}

\textbf{qx:} q-parameter of the beam in the x-direction. {[}complex float{]}

\textbf{qy:} q-parameter of the beam in the y-direction. {[}complex float{]}

\textbf{pos:} Position of the beam origin. {[}(2,) float array{]}

\textbf{dirVect:} Propagation direction vector. {[}(2,) float array{]}

\textbf{dirAngle:} Propagation direction angle measured from the positive x-axis. {[}float{]}

\textbf{length:} Length of the beam (used for DXF export) {[}float{]}

\textbf{layer:} Layer name of the beam when exported to a DXF file.

\textbf{name:} Name of the beam

\textbf{wl:} Wavelength in vacuum. Not the wavelength in the medium. {[}float{]}

\textbf{n:} Index of refraction of the medium the beam is passing through. {[}float{]}

\textbf{P:} Power {[}float{]}

\textbf{wx:} Beamwidth in x-direction {[}float{]}

\textbf{wy:} Beamwidth in y-direction {[}float{]}

\textbf{optDist:} Accumulated optical distance.

\textbf{Gouyx:} Accumulated Gouy phase in x-direction.

\textbf{Gouyy:} Accumulated Gouy phase in y-direction.
\begin{description}
\item[{\textbf{Mx:} ABCD matrix in x-direction.}] \leavevmode
This is a 2x2 matrix representing the product
of ABCD transformations applied to this beam.
It defaults to an identity matrix.
Whenever a beam experience an ABCD matrix
transformation, such as propagation in the space
or reflection by a curved mirror, the applied ABCD
matrix is multiplied to this matrix, so that we can
keep track of what kind of transformations were
made during beam propagation.

\end{description}

\textbf{My:} ABCD matrix in y-direction. The meaning is the same as Mx.
\begin{description}
\item[{\textbf{departSurfAngle:} The angle formed by x-axis and the normal vector of}] \leavevmode
the surface from which the beam is departing.
Default is None. Used by the drawing routine.

\item[{\textbf{departSurfInvROC:} Inverse of the ROC of the surface from which the beam is departing.}] \leavevmode
The ROC is positive for a concave surface seen from
the beam side.
Default is None. Used by the drawing routine.

\item[{\textbf{incSurfAngle:} The angle formed by the x-arm and the normal vector of}] \leavevmode
the surface to which the beam is incident.
Default is None. Used by the drawing routine.

\item[{\textbf{incSurfInvROC:} Inverse of the ROC of the surface to which the beam is incident.}] \leavevmode
The ROC is positive for a concave surface seen from
the beam side.
Default is None. Used by the drawing routine.

\item[{\textbf{stray\_order:} An integer indicating if this beam is a stray light or not.}] \leavevmode
The default value is 0. Every time a beam is reflected by an AR surface
or transmits an HR surface, this couter is increased by 1.

\end{description}
\index{ABCDTrans() (gtrace.beam.GaussianBeam method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.GaussianBeam.ABCDTrans}\pysiglinewithargsret{\bfcode{ABCDTrans}}{\emph{ABCDx}, \emph{ABCDy=None}}{}
Apply ABCD transformation to the beam.

\textbf{ABCDx:} ABCD matrix for x-direction

\textbf{ABCDy:} ABCD matrix for y-direction

\end{fulllineitems}

\index{R() (gtrace.beam.GaussianBeam method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.GaussianBeam.R}\pysiglinewithargsret{\bfcode{R}}{\emph{dist=0.0}}{}
Returns the beam ROC at a distance dist
from the origin of the beam.

\end{fulllineitems}

\index{copy() (gtrace.beam.GaussianBeam method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.GaussianBeam.copy}\pysiglinewithargsret{\bfcode{copy}}{}{}
Make a deep copy.

\end{fulllineitems}

\index{draw() (gtrace.beam.GaussianBeam method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.GaussianBeam.draw}\pysiglinewithargsret{\bfcode{draw}}{\emph{cv}, \emph{sigma=3.0}, \emph{mode='x'}, \emph{drawWidth=True}, \emph{fontSize=False}, \emph{drawPower=False}, \emph{drawROC=False}, \emph{drawGouy=False}, \emph{drawOptDist=False}, \emph{drawName=False}, \emph{debug=False}}{}
Draw the beam into a DXF object.

\emph{Arguments}

\textbf{cv:} draw.Canvas object.
\begin{description}
\item[{\textbf{sigma:} The width of the beam drawn is sigma * (1/e\textasciicircum{}2 radius of the beam).}] \leavevmode
The default is sigma = 3. sigma = 2.7 gives 1ppm diffraction loss.
{[}float{]}

\item[{\textbf{mode:} `avg', `x', or `y'. A beam can have different widths for x- and y-}] \leavevmode
directions. If `avg' is specified, the average of them are drawn.
`x' and `y' specifies to show the width of the respective directions.

\end{description}

\textbf{fontSize:} Size of the font used to show supplemental informations. {[}float{]}

\textbf{drawWidth:} Whether to draw width or not. {[}Boolean{]}

\textbf{drawPower:} Whether to show the beam power. {[}Boolean{]}

\textbf{drawROC:} Whether to show the ROC or not. {[}Boolean{]}

\textbf{drawGouy:} Whether to show the Gouy phase or not. {[}Boolean{]}

\textbf{drawOptDist:} Whether to show the accumulated optical distance or not. {[}Boolean{]}

\textbf{drawName:} Whether draw the name of the beam or not. {[}Boolean{]}

\end{fulllineitems}

\index{drawWidth() (gtrace.beam.GaussianBeam method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.GaussianBeam.drawWidth}\pysiglinewithargsret{\bfcode{drawWidth}}{\emph{cv}, \emph{sigma}, \emph{mode}}{}
\end{fulllineitems}

\index{drawWidthOld() (gtrace.beam.GaussianBeam method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.GaussianBeam.drawWidthOld}\pysiglinewithargsret{\bfcode{drawWidthOld}}{\emph{dxf}, \emph{sigma}, \emph{mode}}{}
\end{fulllineitems}

\index{flip() (gtrace.beam.GaussianBeam method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.GaussianBeam.flip}\pysiglinewithargsret{\bfcode{flip}}{\emph{flipDirVect=True}}{}
Change the propagation direction of the beam
by 180 degrees.
This is equivalent to the reflection of the beam
by a spherical mirror with the same ROC as the beam.

If optional argument flipDirVect is set to False,
the propagation direction of the beam is not changed.

\end{fulllineitems}

\index{propagate() (gtrace.beam.GaussianBeam method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.GaussianBeam.propagate}\pysiglinewithargsret{\bfcode{propagate}}{\emph{d}}{}
Propagate the beam by a distance d from the current position.
self.n is used as the index of refraction.
During this process, the optical distance traveled is added
to self.optDist.
self.Goux and self.Gouyy are also updated to record the Gouy
phase change.

\end{fulllineitems}

\index{rotate() (gtrace.beam.GaussianBeam method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.GaussianBeam.rotate}\pysiglinewithargsret{\bfcode{rotate}}{\emph{angle}, \emph{center=False}}{}
Rotate the beam around `center'.
If center is not given, the beam is rotated
around self.pos.

\emph{Arguments}

\textbf{angle:} Rotation angle in radians.

\textbf{center:} Center for rotation. {[}(2,) array of float{]}

\end{fulllineitems}

\index{translate() (gtrace.beam.GaussianBeam method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.GaussianBeam.translate}\pysiglinewithargsret{\bfcode{translate}}{\emph{trVect}}{}~\begin{description}
\item[{Translate the beam by the direction and the distance}] \leavevmode
specified by a vector.

\end{description}

\emph{Arguments}
\begin{quote}
\begin{description}
\item[{\textbf{trVect:} A vector to specify the translation direction and}] \leavevmode
distance. {[}(2,) float array{]}

\end{description}
\end{quote}

\end{fulllineitems}

\index{waist() (gtrace.beam.GaussianBeam method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.GaussianBeam.waist}\pysiglinewithargsret{\bfcode{waist}}{}{}
Return the tuples of waist size and distance

\end{fulllineitems}

\index{width() (gtrace.beam.GaussianBeam method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.GaussianBeam.width}\pysiglinewithargsret{\bfcode{width}}{\emph{dist}}{}
Returns the beam width at a distance dist
from the origin of the beam.
The width is the readius where the light power becomes 1/e\textasciicircum{}2.

\end{fulllineitems}


\end{fulllineitems}

\index{optFunForEndPointR() (in module gtrace.beam)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.optFunForEndPointR}\pysiglinewithargsret{\code{gtrace.beam.}\bfcode{optFunForEndPointR}}{\emph{phi}, \emph{Mrot}, \emph{R}, \emph{q0}, \emph{k}, \emph{sigma}, \emph{side}}{}
A function to return the distance between the point on
the spherical surface at an angle phi and the beam width
at the same z.

\end{fulllineitems}

\index{optFunForFlat() (in module gtrace.beam)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.optFunForFlat}\pysiglinewithargsret{\code{gtrace.beam.}\bfcode{optFunForFlat}}{\emph{a}, \emph{Mrot}, \emph{q0}, \emph{k}, \emph{sigma}, \emph{side}}{}
A function to return the distance between the point on
the spherical surface at an angle phi and the beam width
at the same z.

\end{fulllineitems}

\index{optFunForStartPointR() (in module gtrace.beam)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.optFunForStartPointR}\pysiglinewithargsret{\code{gtrace.beam.}\bfcode{optFunForStartPointR}}{\emph{phi}, \emph{Mrot}, \emph{R}, \emph{q0}, \emph{k}, \emph{sigma}, \emph{side}}{}
A function to return the distance between the point on
the spherical surface at an angle phi and the beam width
at the same z.

\end{fulllineitems}

\index{optimCrossPointFlat() (in module gtrace.beam)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.optimCrossPointFlat}\pysiglinewithargsret{\code{gtrace.beam.}\bfcode{optimCrossPointFlat}}{\emph{theta}, \emph{q0}, \emph{k}, \emph{sigma}}{}
\end{fulllineitems}

\index{optimEndPointR() (in module gtrace.beam)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.optimEndPointR}\pysiglinewithargsret{\code{gtrace.beam.}\bfcode{optimEndPointR}}{\emph{theta}, \emph{R}, \emph{q0}, \emph{k}, \emph{sigma}}{}
\end{fulllineitems}

\index{optimStartPointR() (in module gtrace.beam)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.beam.optimStartPointR}\pysiglinewithargsret{\code{gtrace.beam.}\bfcode{optimStartPointR}}{\emph{theta}, \emph{R}, \emph{q0}, \emph{k}, \emph{sigma}}{}
\end{fulllineitems}



\subsection{\texttt{hello} Module}
\label{api/gtrace:module-gtrace.hello}\label{api/gtrace:hello-module}\index{gtrace.hello (module)}\index{hello (class in gtrace.hello)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.hello.hello}\pysigline{\strong{class }\code{gtrace.hello.}\bfcode{hello}}~\index{greetings() (gtrace.hello.hello method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.hello.hello.greetings}\pysiglinewithargsret{\bfcode{greetings}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{saysomething() (in module gtrace.hello)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.hello.saysomething}\pysiglinewithargsret{\code{gtrace.hello.}\bfcode{saysomething}}{}{}
\end{fulllineitems}



\subsection{\texttt{nonsequential} Module}
\label{api/gtrace:nonsequential-module}\label{api/gtrace:module-gtrace.nonsequential}\index{gtrace.nonsequential (module)}
gtrace.nonsequential

A module to perform non-sequential trace of a beam
in an optical system.
\index{non\_seq\_trace() (in module gtrace.nonsequential)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.nonsequential.non_seq_trace}\pysiglinewithargsret{\code{gtrace.nonsequential.}\bfcode{non\_seq\_trace}}{\emph{optList}, \emph{src\_beam}, \emph{order=10}, \emph{power\_threshold=0.1}}{}
Perform non-sequential trace of the source beam, src\_beam,
through the optical system represented by a collection of optics,
optList.

The return value of this function is a list of beams.

\end{fulllineitems}



\subsection{\texttt{optcomp} Module}
\label{api/gtrace:optcomp-module}\label{api/gtrace:module-gtrace.optcomp}\index{gtrace.optcomp (module)}
Define optical components for gtrace.
\index{Mirror (class in gtrace.optcomp)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.optcomp.Mirror}\pysiglinewithargsret{\strong{class }\code{gtrace.optcomp.}\bfcode{Mirror}}{\emph{HRcenter={[}0.0, 0.0{]}, normAngleHR=0.0, normVectHR=None, diameter=0.25, thickness=0.15, wedgeAngle=0.004363323129985824, inv\_ROC\_HR=0.00014285714285714287, inv\_ROC\_AR=0.0, Refl\_HR=0.99, Trans\_HR=0.01, Refl\_AR=0.01, Trans\_AR=0.99, n=1.45, name='Mirror', HRtransmissive=False, term\_on\_HR=False}}{}
Bases: {\hyperref[api/gtrace:gtrace.optcomp.Optics]{\code{gtrace.optcomp.Optics}}}

Representing a partial reflective mirror.

=== Attributes ===
\begin{description}
\item[{HRcenter: The position of the center of the arc of the HR surface.}] \leavevmode
{[}(2,) float array{]}

\item[{HRcenterC: The position of the center of the chord of the HR surface.}] \leavevmode
{[}(2,) float array{]}

\end{description}

normVectHR: Normal vector of the HR surface.

normAngleHR: Angle of the HR normal vector.
\begin{description}
\item[{ARcenter: The position of the center of the AR surface.}] \leavevmode
{[}(2,) float array{]}

\end{description}

normVectAR: Normal vector of the HR surface.

normAngleAR: Angle of the HR normal vector.
\begin{description}
\item[{HRtransmissive: A boolean value defaults to False. If True, this mirror}] \leavevmode
is supposed to transmit beams on the HR surface. Therefore,
for the first encounter of a beam on the HR surface of this mirror
will not increase the stray\_order. This flag should be set to True for
beam splitters and input test masses.

\item[{term\_on\_HR: If this is True, a beam with stray\_order=0 will be terminated when}] \leavevmode
it hits on HR. This is to avoid the inifinite loop of non-sequencial
trace by forming a cavity.

\end{description}
\index{copy() (gtrace.optcomp.Mirror method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.optcomp.Mirror.copy}\pysiglinewithargsret{\bfcode{copy}}{}{}
\end{fulllineitems}

\index{draw() (gtrace.optcomp.Mirror method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.optcomp.Mirror.draw}\pysiglinewithargsret{\bfcode{draw}}{\emph{cv}, \emph{drawName=False}}{}
Draw itself

\end{fulllineitems}

\index{hit() (gtrace.optcomp.Mirror method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.optcomp.Mirror.hit}\pysiglinewithargsret{\bfcode{hit}}{\emph{beam}, \emph{order=0}, \emph{threshold=0.0}, \emph{face=False}}{}
A function to hit the optics with a beam.

This function attempts to hit the optics with the source beam, \code{beam}.

\textbf{Input parameters}:
\begin{quote}

\code{beam}:
A GaussianBeam object to be interacted by the optics.

\code{order}:
An integer to specify how many times the internal reflections
are computed.

\code{threshold}
The power threshold for internal reflection calculation.
If the power of an auxiliary beam falls below this threshold,
further propagation of this beam will not be performed.
\end{quote}

\textbf{Return values}
\code{(isHit, beamDict, face)}

\code{isHit}
This is a boolean to answer whether the beam hit the optics
or not.

\code{beamDict}
A dictionary containing resultant beams.
\begin{description}
\item[{\code{face}:}] \leavevmode
An optional string identifying which face of the optics was hit.
For a mirror, \code{face} is any of ``HR'', ``AR'' or ``side''.

\end{description}

\end{fulllineitems}

\index{hitFromAR() (gtrace.optcomp.Mirror method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.optcomp.Mirror.hitFromAR}\pysiglinewithargsret{\bfcode{hitFromAR}}{\emph{beam}, \emph{order=0}, \emph{threshold=0.0}, \emph{verbose=False}}{}
Compute the reflected and deflected beams when
an input beam hit the AR surface.

The internal reflections are computed as long as the number
of internal reflections are below the \code{order} and the power
of the reflected beams is over the threshold.

\end{fulllineitems}

\index{hitFromHR() (gtrace.optcomp.Mirror method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.optcomp.Mirror.hitFromHR}\pysiglinewithargsret{\bfcode{hitFromHR}}{\emph{beam}, \emph{order=0}, \emph{threshold=0.0}, \emph{verbose=False}}{}
Compute the reflected and deflected beams when
an input beam hit the HR surface.

The internal reflections are computed as long as the number
of internal reflections are below the \code{order} and the power
of the reflected beams is over the threshold.

\end{fulllineitems}

\index{isHit() (gtrace.optcomp.Mirror method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.optcomp.Mirror.isHit}\pysiglinewithargsret{\bfcode{isHit}}{\emph{beam}}{}
A function to see if a beam hits this optics or not.

\textbf{Input parameters}
\begin{quote}

\code{beam}:
A GaussianBeam object to be interacted by the optics.
\end{quote}

\textbf{Returned value}
\begin{quote}

The return value is a dictionary with the following keys:
\code{isHit, position, distance, face}

\code{isHit}:
This is a boolean to answer whether the beam hit the optics
or not.

\code{position}:
A numpy array containing the coordinate values of the intersection
point between the beam and the optics. If isHit is False, this parameter
does not mean anything.

\code{distance}
The distance between the beam origin and the intersection point.

\code{face}:
An optional string identifying which face of the optics was hit.
For example, \code{face} can be either ``HR'' or ``AR'' for a mirror.
\code{face} can also be ``side'', meaning that the beam hits a side
of the optics, which is not meant to be used, e.g. the side of a mirror.
In this case, the beam have reached a dead end.
\end{quote}

\end{fulllineitems}

\index{rotate() (gtrace.optcomp.Mirror method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.optcomp.Mirror.rotate}\pysiglinewithargsret{\bfcode{rotate}}{\emph{angle}, \emph{center=False}}{}
Rotate the mirror. If center is not specified, the center of rotation is
HRcenter. If center is given (as a vector), the center of rotation is
center. center is a position vector in the global coordinates.

\end{fulllineitems}

\index{translate() (gtrace.optcomp.Mirror method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.optcomp.Mirror.translate}\pysiglinewithargsret{\bfcode{translate}}{\emph{trVect}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Optics (class in gtrace.optcomp)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.optcomp.Optics}\pysigline{\strong{class }\code{gtrace.optcomp.}\bfcode{Optics}}
Bases: \code{traits.has\_traits.HasTraits}

A general optics class from which other specific
optics classes are derived.

=== Attributes ===
name: Name of the optics. {[}string{]}
center: Center position of the optics. {[}(2,) float array{]}
rotationAngle: This angle defines the orientation of the optics.
\index{hit() (gtrace.optcomp.Optics method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.optcomp.Optics.hit}\pysiglinewithargsret{\bfcode{hit}}{\emph{beam}, \emph{order=0}, \emph{threshold=0.0}}{}
A function to hit the optics with a beam.

This function attempts to hit the optics with the source beam, \code{beam}.

\textbf{Input parameters}:
\begin{quote}

\code{beam}:
A GaussianBeam object to be interacted by the optics.

\code{order}:
An integer to specify how many times the internal reflections
are computed.

\code{threshold}
The power threshold for internal reflection calculation.
If the power of an auxiliary beam falls below this threshold,
further propagation of this beam will not be performed.
\end{quote}

\textbf{Return values}
\code{(isHit, beamDict, face)}

\code{isHit}
This is a boolean to answer whether the beam hit the optics
or not.

\code{beamDict}
A dictionary containing resultant beams.
\begin{description}
\item[{\code{face}:}] \leavevmode
An optional string identifying which face of the optics was hit.
For a mirror, \code{face} is any of ``HR'', ``AR'' or ``side''.

\end{description}

\end{fulllineitems}

\index{isHit() (gtrace.optcomp.Optics method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.optcomp.Optics.isHit}\pysiglinewithargsret{\bfcode{isHit}}{\emph{beam}}{}
A function to see if a beam hits this optics or not.

\textbf{Input parameters}
\begin{quote}

\code{beam}:
A GaussianBeam object to be interacted by the optics.
\end{quote}

\textbf{Returned value}
\begin{quote}

The return value is a dictionary with the following keys:
\code{isHit, position, distance, face}

\code{isHit}:
This is a boolean to answer whether the beam hit the optics
or not.

\code{position}:
A numpy array containing the coordinate values of the intersection
point between the beam and the optics. If isHit is False, this parameter
does not mean anything.

\code{distance}
The distance between the beam origin and the intersection point.

\code{face}:
An optional string identifying which face of the optics was hit.
For example, \code{face} can be either ``HR'' or ``AR'' for a mirror.
\code{face} can also be ``side'', meaning that the beam hits a side
of the optics, which is not meant to be used, e.g. the side of a mirror.
In this case, the beam have reached a dead end.
\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{\texttt{unit} Module}
\label{api/gtrace:unit-module}\label{api/gtrace:module-gtrace.unit}\index{gtrace.unit (module)}\index{deg2rad() (in module gtrace.unit)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.unit.deg2rad}\pysiglinewithargsret{\code{gtrace.unit.}\bfcode{deg2rad}}{\emph{deg}}{}
\end{fulllineitems}

\index{rad2deg() (in module gtrace.unit)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace:gtrace.unit.rad2deg}\pysiglinewithargsret{\code{gtrace.unit.}\bfcode{rad2deg}}{\emph{rad}}{}
\end{fulllineitems}



\subsection{Subpackages}
\label{api/gtrace:subpackages}

\subsubsection{draw Package}
\label{api/gtrace.draw::doc}\label{api/gtrace.draw:draw-package}

\paragraph{\texttt{draw} Package}
\label{api/gtrace.draw:id1}\phantomsection\label{api/gtrace.draw:module-gtrace.draw}\index{gtrace.draw (module)}

\paragraph{\texttt{draw} Module}
\label{api/gtrace.draw:module-gtrace.draw.draw}\label{api/gtrace.draw:draw-module}\index{gtrace.draw.draw (module)}
Drawing classes for gtrace
\index{Arc (class in gtrace.draw.draw)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.draw.Arc}\pysiglinewithargsret{\strong{class }\code{gtrace.draw.draw.}\bfcode{Arc}}{\emph{center}, \emph{radius}, \emph{startangle}, \emph{stopangle}, \emph{thickness=0}, \emph{angle\_in\_rad=True}}{}
Bases: {\hyperref[api/gtrace.draw:gtrace.draw.draw.Shape]{\code{gtrace.draw.draw.Shape}}}

An arc

Note that angles are stored in rad.

\end{fulllineitems}

\index{Canvas (class in gtrace.draw.draw)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.draw.Canvas}\pysiglinewithargsret{\strong{class }\code{gtrace.draw.draw.}\bfcode{Canvas}}{\emph{unit='m'}}{}
Bases: \code{object}

Canvas class
\index{add\_layer() (gtrace.draw.draw.Canvas method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.draw.Canvas.add_layer}\pysiglinewithargsret{\bfcode{add\_layer}}{\emph{name}, \emph{color=(0}, \emph{0}, \emph{0)}}{}
\end{fulllineitems}

\index{add\_shape() (gtrace.draw.draw.Canvas method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.draw.Canvas.add_shape}\pysiglinewithargsret{\bfcode{add\_shape}}{\emph{shape}, \emph{layername}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Circle (class in gtrace.draw.draw)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.draw.Circle}\pysiglinewithargsret{\strong{class }\code{gtrace.draw.draw.}\bfcode{Circle}}{\emph{center}, \emph{radius}, \emph{thickness=0}}{}
Bases: {\hyperref[api/gtrace.draw:gtrace.draw.draw.Shape]{\code{gtrace.draw.draw.Shape}}}

A circle

\end{fulllineitems}

\index{Layer (class in gtrace.draw.draw)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.draw.Layer}\pysiglinewithargsret{\strong{class }\code{gtrace.draw.draw.}\bfcode{Layer}}{\emph{name}, \emph{color=(0}, \emph{0}, \emph{0)}}{}
Bases: \code{object}

Layer class
\index{add\_shape() (gtrace.draw.draw.Layer method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.draw.Layer.add_shape}\pysiglinewithargsret{\bfcode{add\_shape}}{\emph{shape}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Line (class in gtrace.draw.draw)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.draw.Line}\pysiglinewithargsret{\strong{class }\code{gtrace.draw.draw.}\bfcode{Line}}{\emph{start}, \emph{stop}, \emph{thickness=0}}{}
Bases: {\hyperref[api/gtrace.draw:gtrace.draw.draw.Shape]{\code{gtrace.draw.draw.Shape}}}

Line class

\end{fulllineitems}

\index{NumberOfElementError}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.draw.NumberOfElementError}\pysigline{\strong{exception }\code{gtrace.draw.draw.}\bfcode{NumberOfElementError}}
Bases: \code{exceptions.BaseException}

\end{fulllineitems}

\index{PolyLine (class in gtrace.draw.draw)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.draw.PolyLine}\pysiglinewithargsret{\strong{class }\code{gtrace.draw.draw.}\bfcode{PolyLine}}{\emph{x}, \emph{y}, \emph{thickness=0}}{}
Bases: {\hyperref[api/gtrace.draw:gtrace.draw.draw.Shape]{\code{gtrace.draw.draw.Shape}}}

A light weight poly-line

\end{fulllineitems}

\index{Rectangle (class in gtrace.draw.draw)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.draw.Rectangle}\pysiglinewithargsret{\strong{class }\code{gtrace.draw.draw.}\bfcode{Rectangle}}{\emph{point}, \emph{width}, \emph{height}, \emph{thickness=0}}{}
Bases: {\hyperref[api/gtrace.draw:gtrace.draw.draw.Shape]{\code{gtrace.draw.draw.Shape}}}

A rectangle

\end{fulllineitems}

\index{Shape (class in gtrace.draw.draw)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.draw.Shape}\pysigline{\strong{class }\code{gtrace.draw.draw.}\bfcode{Shape}}
Bases: \code{object}

Shape class

\end{fulllineitems}

\index{Text (class in gtrace.draw.draw)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.draw.Text}\pysiglinewithargsret{\strong{class }\code{gtrace.draw.draw.}\bfcode{Text}}{\emph{text}, \emph{point}, \emph{height=1.0}, \emph{rotation=0.0}, \emph{angle\_in\_rad=True}}{}
Bases: {\hyperref[api/gtrace.draw:gtrace.draw.draw.Shape]{\code{gtrace.draw.draw.Shape}}}

Text

Note that angles are stored in rad.

\end{fulllineitems}



\paragraph{\texttt{dxf} Module}
\label{api/gtrace.draw:dxf-module}\label{api/gtrace.draw:module-gtrace.draw.dxf}\index{gtrace.draw.dxf (module)}
dxf.py - a DXF export library for python

Sample code:

import dxf
d = dxf.DXF(`test.dxf')
d.add\_layer(`ABC', color=5)
d.add\_entity(dxf.Line((1.5,5), (56,-89)), `ABC')
d.save\_to\_file()
\index{Arc (class in gtrace.draw.dxf)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Arc}\pysiglinewithargsret{\strong{class }\code{gtrace.draw.dxf.}\bfcode{Arc}}{\emph{center}, \emph{radius}, \emph{startangle}, \emph{stopangle}, \emph{thickness=0}}{}
Bases: {\hyperref[api/gtrace.draw:gtrace.draw.dxf.Entity]{\code{gtrace.draw.dxf.Entity}}}

An arc entity
\index{draw() (gtrace.draw.dxf.Arc method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Arc.draw}\pysiglinewithargsret{\bfcode{draw}}{\emph{layername}}{}
\end{fulllineitems}

\index{report\_min\_max() (gtrace.draw.dxf.Arc method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Arc.report_min_max}\pysiglinewithargsret{\bfcode{report\_min\_max}}{}{}
Return the coordinates of the lower left and the upper right corners
of the drawing.
Return value: ((xmin, ymin), (xmax, ymax))

\end{fulllineitems}


\end{fulllineitems}

\index{Circle (class in gtrace.draw.dxf)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Circle}\pysiglinewithargsret{\strong{class }\code{gtrace.draw.dxf.}\bfcode{Circle}}{\emph{center}, \emph{radius}, \emph{thickness=0}}{}
Bases: {\hyperref[api/gtrace.draw:gtrace.draw.dxf.Entity]{\code{gtrace.draw.dxf.Entity}}}

A circle entity
\index{draw() (gtrace.draw.dxf.Circle method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Circle.draw}\pysiglinewithargsret{\bfcode{draw}}{\emph{layername}}{}
\end{fulllineitems}

\index{report\_min\_max() (gtrace.draw.dxf.Circle method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Circle.report_min_max}\pysiglinewithargsret{\bfcode{report\_min\_max}}{}{}
Return the coordinates of the lower left and the upper right corners
of the drawing.
Return value: ((xmin, ymin), (xmax, ymax))

\end{fulllineitems}


\end{fulllineitems}

\index{DXF (class in gtrace.draw.dxf)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.DXF}\pysiglinewithargsret{\strong{class }\code{gtrace.draw.dxf.}\bfcode{DXF}}{\emph{filename='drawing.dxf'}}{}
Bases: \code{object}

A DXF file class.
\index{add\_entity() (gtrace.draw.dxf.DXF method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.DXF.add_entity}\pysiglinewithargsret{\bfcode{add\_entity}}{\emph{entity}, \emph{layername}}{}
\end{fulllineitems}

\index{add\_layer() (gtrace.draw.dxf.DXF method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.DXF.add_layer}\pysiglinewithargsret{\bfcode{add\_layer}}{\emph{name}, \emph{color=1}, \emph{ltype='Continuous'}}{}
\end{fulllineitems}

\index{save\_to\_file() (gtrace.draw.dxf.DXF method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.DXF.save_to_file}\pysiglinewithargsret{\bfcode{save\_to\_file}}{}{}
Save the DXF file

\end{fulllineitems}


\end{fulllineitems}

\index{Entity (class in gtrace.draw.dxf)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Entity}\pysigline{\strong{class }\code{gtrace.draw.dxf.}\bfcode{Entity}}
Bases: \code{object}

A graphic entity
\index{draw() (gtrace.draw.dxf.Entity method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Entity.draw}\pysiglinewithargsret{\bfcode{draw}}{}{}
\end{fulllineitems}

\index{report\_min\_max() (gtrace.draw.dxf.Entity method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Entity.report_min_max}\pysiglinewithargsret{\bfcode{report\_min\_max}}{}{}
Return the coordinates of the lower left and the upper right corners
of the drawing.
Return value: ((xmin, ymin), (xmax, ymax))

\end{fulllineitems}

\index{set\_handle() (gtrace.draw.dxf.Entity method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Entity.set_handle}\pysiglinewithargsret{\bfcode{set\_handle}}{\emph{handle}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Layer (class in gtrace.draw.dxf)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Layer}\pysiglinewithargsret{\strong{class }\code{gtrace.draw.dxf.}\bfcode{Layer}}{\emph{name}, \emph{handle}, \emph{color=1}, \emph{ltype='Continuous'}}{}
Bases: \code{object}

Layer class
\index{add\_entity() (gtrace.draw.dxf.Layer method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Layer.add_entity}\pysiglinewithargsret{\bfcode{add\_entity}}{\emph{entity}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Line (class in gtrace.draw.dxf)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Line}\pysiglinewithargsret{\strong{class }\code{gtrace.draw.dxf.}\bfcode{Line}}{\emph{start}, \emph{stop}, \emph{thickness=0}}{}
Bases: {\hyperref[api/gtrace.draw:gtrace.draw.dxf.Entity]{\code{gtrace.draw.dxf.Entity}}}

A line entity
\index{draw() (gtrace.draw.dxf.Line method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Line.draw}\pysiglinewithargsret{\bfcode{draw}}{\emph{layername}}{}
\end{fulllineitems}

\index{report\_min\_max() (gtrace.draw.dxf.Line method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Line.report_min_max}\pysiglinewithargsret{\bfcode{report\_min\_max}}{}{}
Return the coordinates of the lower left and the upper right corners
of the drawing.
Return value: ((xmin, ymin), (xmax, ymax))

\end{fulllineitems}


\end{fulllineitems}

\index{LwPolyLine (class in gtrace.draw.dxf)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.LwPolyLine}\pysiglinewithargsret{\strong{class }\code{gtrace.draw.dxf.}\bfcode{LwPolyLine}}{\emph{x}, \emph{y}, \emph{thickness=0}}{}
Bases: {\hyperref[api/gtrace.draw:gtrace.draw.dxf.Entity]{\code{gtrace.draw.dxf.Entity}}}

A light weight poly-line
\index{draw() (gtrace.draw.dxf.LwPolyLine method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.LwPolyLine.draw}\pysiglinewithargsret{\bfcode{draw}}{\emph{layername}}{}
\end{fulllineitems}

\index{report\_min\_max() (gtrace.draw.dxf.LwPolyLine method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.LwPolyLine.report_min_max}\pysiglinewithargsret{\bfcode{report\_min\_max}}{}{}
Return the coordinates of the lower left and the upper right corners
of the drawing.
Return value: ((xmin, ymin), (xmax, ymax))

\end{fulllineitems}


\end{fulllineitems}

\index{NumberOfElementError}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.NumberOfElementError}\pysigline{\strong{exception }\code{gtrace.draw.dxf.}\bfcode{NumberOfElementError}}
Bases: \code{exceptions.BaseException}

\end{fulllineitems}

\index{Rectangle (class in gtrace.draw.dxf)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Rectangle}\pysiglinewithargsret{\strong{class }\code{gtrace.draw.dxf.}\bfcode{Rectangle}}{\emph{point}, \emph{width}, \emph{height}, \emph{thickness=0}}{}
Bases: {\hyperref[api/gtrace.draw:gtrace.draw.dxf.Entity]{\code{gtrace.draw.dxf.Entity}}}

A rectangle
\index{draw() (gtrace.draw.dxf.Rectangle method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Rectangle.draw}\pysiglinewithargsret{\bfcode{draw}}{\emph{layername}}{}
\end{fulllineitems}

\index{report\_min\_max() (gtrace.draw.dxf.Rectangle method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Rectangle.report_min_max}\pysiglinewithargsret{\bfcode{report\_min\_max}}{}{}
Return the coordinates of the lower left and the upper right corners
of the drawing.
Return value: ((xmin, ymin), (xmax, ymax))

\end{fulllineitems}


\end{fulllineitems}

\index{Text (class in gtrace.draw.dxf)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Text}\pysiglinewithargsret{\strong{class }\code{gtrace.draw.dxf.}\bfcode{Text}}{\emph{text}, \emph{point}, \emph{height=1.0}, \emph{rotation=0.0}}{}
Bases: {\hyperref[api/gtrace.draw:gtrace.draw.dxf.Entity]{\code{gtrace.draw.dxf.Entity}}}

Text
\index{draw() (gtrace.draw.dxf.Text method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Text.draw}\pysiglinewithargsret{\bfcode{draw}}{\emph{layername}}{}
\end{fulllineitems}

\index{report\_min\_max() (gtrace.draw.dxf.Text method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.Text.report_min_max}\pysiglinewithargsret{\bfcode{report\_min\_max}}{}{}
Return the coordinates of the lower left and the upper right corners
of the drawing.
Return value: ((xmin, ymin), (xmax, ymax))

\end{fulllineitems}


\end{fulllineitems}

\index{color\_encode() (in module gtrace.draw.dxf)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.color_encode}\pysiglinewithargsret{\code{gtrace.draw.dxf.}\bfcode{color\_encode}}{\emph{color}}{}
Given a set of RGB values for a color, find the closest matching
one from the pre-defined colors in the DXF specification.
Then return its color code (an integer in 1 to 255).

= Input =
color: A tuple of three numbers in the range of 0-255, i.e. (R,G,B)

= Return =
best\_color\_num: integer

\end{fulllineitems}

\index{test\_func() (in module gtrace.draw.dxf)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.dxf.test_func}\pysiglinewithargsret{\code{gtrace.draw.dxf.}\bfcode{test\_func}}{}{}
\end{fulllineitems}



\paragraph{\texttt{renderer} Module}
\label{api/gtrace.draw:renderer-module}\label{api/gtrace.draw:module-gtrace.draw.renderer}\index{gtrace.draw.renderer (module)}
Renderer module for gtrace.draw
\index{UnknownShapeError}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.renderer.UnknownShapeError}\pysigline{\strong{exception }\code{gtrace.draw.renderer.}\bfcode{UnknownShapeError}}
Bases: \code{exceptions.BaseException}

\end{fulllineitems}

\index{renderDXF() (in module gtrace.draw.renderer)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.renderer.renderDXF}\pysiglinewithargsret{\code{gtrace.draw.renderer.}\bfcode{renderDXF}}{\emph{canvas}, \emph{filename}}{}
Render a canvas into a DXF file

\end{fulllineitems}



\paragraph{\texttt{tools} Module}
\label{api/gtrace.draw:module-gtrace.draw.tools}\label{api/gtrace.draw:tools-module}\index{gtrace.draw.tools (module)}\index{drawAllBeams() (in module gtrace.draw.tools)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.tools.drawAllBeams}\pysiglinewithargsret{\code{gtrace.draw.tools.}\bfcode{drawAllBeams}}{\emph{d}, \emph{beamList}, \emph{sigma=3.0}, \emph{drawWidth=True}, \emph{drawPower=False}, \emph{drawROC=False}, \emph{drawGouy=False}, \emph{drawOptDist=False}, \emph{layer=None}, \emph{mode='x'}, \emph{fontSize=0.01}}{}
\end{fulllineitems}

\index{drawAllOptics() (in module gtrace.draw.tools)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.tools.drawAllOptics}\pysiglinewithargsret{\code{gtrace.draw.tools.}\bfcode{drawAllOptics}}{\emph{d}, \emph{opticsList}, \emph{drawName=True}, \emph{layer=None}}{}
\end{fulllineitems}

\index{drawOptSys() (in module gtrace.draw.tools)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.tools.drawOptSys}\pysiglinewithargsret{\code{gtrace.draw.tools.}\bfcode{drawOptSys}}{\emph{optList}, \emph{beamList}, \emph{filename}, \emph{fontSize=False}}{}
\end{fulllineitems}

\index{rotateAll() (in module gtrace.draw.tools)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.tools.rotateAll}\pysiglinewithargsret{\code{gtrace.draw.tools.}\bfcode{rotateAll}}{\emph{objList}, \emph{angle}, \emph{center}}{}
\end{fulllineitems}

\index{transAll() (in module gtrace.draw.tools)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.draw:gtrace.draw.tools.transAll}\pysiglinewithargsret{\code{gtrace.draw.tools.}\bfcode{transAll}}{\emph{objList}, \emph{transVect}}{}
\end{fulllineitems}



\subsubsection{optics Package}
\label{api/gtrace.optics:optics-package}\label{api/gtrace.optics::doc}

\paragraph{\texttt{cavity} Module}
\label{api/gtrace.optics:module-gtrace.optics.cavity}\label{api/gtrace.optics:cavity-module}\index{gtrace.optics.cavity (module)}
cavity.py - A Cavity class and related functions for representing a Fabry-Perot cavity
\index{Cavity (class in gtrace.optics.cavity)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.cavity.Cavity}\pysiglinewithargsret{\strong{class }\code{gtrace.optics.cavity.}\bfcode{Cavity}}{\emph{r1=0.9}, \emph{r2=0.99}, \emph{L=1.0}, \emph{R1=-1.5}, \emph{R2=1.5}, \emph{wl=1.064e-06}, \emph{power=False}}{}
Bases: \code{traits.has\_traits.HasTraits}

A class to represent a Fabry-Perot cavity.

\emph{Attributes}

\textbf{r1:} Input mirror reflectivity (amplitude)

\textbf{r2:} End mirror reflectivity (amplitude)

\textbf{rp1:} Input mirror reflectivity (power)

\textbf{rp2:} End mirror reflectivity (power)

\textbf{L:} Length
\begin{description}
\item[{\textbf{R1:} ROC of the input mirror (positive when concave to incident light, i.e.}] \leavevmode
convex seen from inside the cavity)

\item[{\textbf{R2:} ROC of the end mirror (positive when concave to incident light, i.e.}] \leavevmode
concave seen from inside the cavity)

\end{description}

\textbf{wl:} Wavelength
\index{FSR() (gtrace.optics.cavity.Cavity method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.cavity.Cavity.FSR}\pysiglinewithargsret{\bfcode{FSR}}{}{}
Returns the free spectral range of the cavity.

\end{fulllineitems}

\index{Nbounce() (gtrace.optics.cavity.Cavity method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.cavity.Cavity.Nbounce}\pysiglinewithargsret{\bfcode{Nbounce}}{}{}
Bounce number

\end{fulllineitems}

\index{finesse() (gtrace.optics.cavity.Cavity method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.cavity.Cavity.finesse}\pysiglinewithargsret{\bfcode{finesse}}{}{}
Returns the finesse of the cavity.

\end{fulllineitems}

\index{intra() (gtrace.optics.cavity.Cavity method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.cavity.Cavity.intra}\pysiglinewithargsret{\bfcode{intra}}{\emph{f=0}, \emph{d=0}}{}
Returns the intra cavity field amplitude.
It assumes the cavity was locked to the incident light first. Then computes the
intra-cavity field amplitude for the light with a frequency shift f from the original light
with the cavity length changed by d from the initial state.

\emph{== Input arguments ==}

\textbf{f:} Frequency shift of the light in Hz.

\textbf{d:} Cavity length detuning in m.

\emph{== Returned parameter ==}

The intra-cavity field amplitude at the input mirror surface (a complex number).

\end{fulllineitems}

\index{modeSpacing() (gtrace.optics.cavity.Cavity method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.cavity.Cavity.modeSpacing}\pysiglinewithargsret{\bfcode{modeSpacing}}{}{}
Return the transverse mode spacing of the cavity (commonly called gamma).
It is a fractional number defined by gamma = (mode spacing frequency)/FSR.

\end{fulllineitems}

\index{pole() (gtrace.optics.cavity.Cavity method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.cavity.Cavity.pole}\pysiglinewithargsret{\bfcode{pole}}{}{}
Cavity pole frequency {[}Hz{]}

\end{fulllineitems}

\index{powerGain() (gtrace.optics.cavity.Cavity method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.cavity.Cavity.powerGain}\pysiglinewithargsret{\bfcode{powerGain}}{}{}
Ratio of the intra-cavity power to the input power.

\end{fulllineitems}

\index{refl() (gtrace.optics.cavity.Cavity method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.cavity.Cavity.refl}\pysiglinewithargsret{\bfcode{refl}}{\emph{f=0}, \emph{d=0}}{}
Returns the amplitude reflectivity of the cavity.
It assumes the cavity was locked to the incident light first. Then computes the
amplitude reflectivity for the light with a frequency shift f from the original light
with the cavity length changed by d from the initial state.

\emph{== Input arguments ==}

\textbf{f:} Frequency shift of the light in Hz.

\textbf{d:} Cavity length detuning in m.

\emph{== Returned parameter ==}

The amplitude reflectivity of the cavity (a complex number).

\end{fulllineitems}

\index{spotSize() (gtrace.optics.cavity.Cavity method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.cavity.Cavity.spotSize}\pysiglinewithargsret{\bfcode{spotSize}}{}{}
Returns the beam spot sizes on the input and end mirrors
as a tuple (w1,w2).

\end{fulllineitems}

\index{storageTime() (gtrace.optics.cavity.Cavity method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.cavity.Cavity.storageTime}\pysiglinewithargsret{\bfcode{storageTime}}{}{}
Storage time

\end{fulllineitems}

\index{trans() (gtrace.optics.cavity.Cavity method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.cavity.Cavity.trans}\pysiglinewithargsret{\bfcode{trans}}{\emph{f=0}, \emph{d=0}}{}
Returns the amplitude transmissivity of the cavity.
It assumes the cavity was locked to the incident light first. Then computes the
amplitude transmissivity for the light with a frequency shift f from the original light
with the cavity length changed by d from the initial state.

\emph{== Input arguments ==}

\textbf{f:} Frequency shift of the light in Hz.

\textbf{d:} Cavity length detuning in m.

\emph{== Returned parameter ==}

The amplitude transmissivity of the cavity (a complex number).

\end{fulllineitems}

\index{waist() (gtrace.optics.cavity.Cavity method)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.cavity.Cavity.waist}\pysiglinewithargsret{\bfcode{waist}}{\emph{size=False}}{}
Return the q-parameter or the radius of the beam at the cavity waist.

\emph{Input arguments}

\textbf{size:} (optional) if set to true, the first element of the returned tuple will be the waist size, rather than the q-parameter.

\emph{==Returned parameters ==}
\begin{description}
\item[{\textbf{(q0, d):}  This function returns a tuple with two elements.}] \leavevmode
The first element is the q-parameter of the cavity mode at
the cavity waist. If size=True is given, it becomes the waist
size (1/e\textasciicircum{}2 radius).
The second element is the distance of the cavity waist from
the input mirror.

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{finesse() (in module gtrace.optics.cavity)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.cavity.finesse}\pysiglinewithargsret{\code{gtrace.optics.cavity.}\bfcode{finesse}}{\emph{r1}, \emph{r2}, \emph{power=False}}{}
Returns the finesse of a cavity

\end{fulllineitems}



\paragraph{\texttt{consts} Module}
\label{api/gtrace.optics:consts-module}\label{api/gtrace.optics:module-gtrace.optics.consts}\index{gtrace.optics.consts (module)}\index{n\_fused\_silica() (in module gtrace.optics.consts)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.consts.n_fused_silica}\pysiglinewithargsret{\code{gtrace.optics.consts.}\bfcode{n\_fused\_silica}}{\emph{wl}}{}
Calculate the index of refraction of fused silica for a given wavelength.

\end{fulllineitems}

\index{n\_sapphire\_extraordinary() (in module gtrace.optics.consts)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.consts.n_sapphire_extraordinary}\pysiglinewithargsret{\code{gtrace.optics.consts.}\bfcode{n\_sapphire\_extraordinary}}{\emph{wl}}{}
Calculate the index of refraction of Sapphire extraordinary axis for a given wavelength.

\end{fulllineitems}

\index{n\_sapphire\_ordinary() (in module gtrace.optics.consts)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.consts.n_sapphire_ordinary}\pysiglinewithargsret{\code{gtrace.optics.consts.}\bfcode{n\_sapphire\_ordinary}}{\emph{wl}}{}
Calculate the index of refraction of Sapphire ordinary axis for a given wavelength.

\end{fulllineitems}

\index{sellmeier() (in module gtrace.optics.consts)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.consts.sellmeier}\pysiglinewithargsret{\code{gtrace.optics.consts.}\bfcode{sellmeier}}{\emph{wl}, \emph{B1}, \emph{B2}, \emph{B3}, \emph{C1}, \emph{C2}, \emph{C3}}{}
Calculate index of refraction using Sellmeiers equation

n\textasciicircum{}2 = 1+B1*wl\textasciicircum{}2/(wl\textasciicircum{}2 - C1) + B2*wl\textasciicircum{}2/(wl\textasciicircum{}2 - C2) + B3*wl\textasciicircum{}2/(wl\textasciicircum{}2 - C3)

See below for the coefficients for specific materials.
\href{http://www.cvimellesgriot.com/products/Documents/Catalog/Dispersion\_Equations.pdf}{http://www.cvimellesgriot.com/products/Documents/Catalog/Dispersion\_Equations.pdf}

\end{fulllineitems}



\paragraph{\texttt{gaussian} Module}
\label{api/gtrace.optics:module-gtrace.optics.gaussian}\label{api/gtrace.optics:gaussian-module}\index{gtrace.optics.gaussian (module)}
gaussian - Gaussian Optics Module

This module contains several utility functions for gaussian optics.
\index{ROCandWtoQ() (in module gtrace.optics.gaussian)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.gaussian.ROCandWtoQ}\pysiglinewithargsret{\code{gtrace.optics.gaussian.}\bfcode{ROCandWtoQ}}{\emph{ROC=1.0}, \emph{w=1.0}, \emph{wl=1.064e-06}}{}
\end{fulllineitems}

\index{Rw2q() (in module gtrace.optics.gaussian)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.gaussian.Rw2q}\pysiglinewithargsret{\code{gtrace.optics.gaussian.}\bfcode{Rw2q}}{\emph{ROC=1.0}, \emph{w=1.0}, \emph{wl=1.064e-06}}{}
Get the q-parameter from the ROC and w.

\end{fulllineitems}

\index{appertureCut() (in module gtrace.optics.gaussian)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.gaussian.appertureCut}\pysiglinewithargsret{\code{gtrace.optics.gaussian.}\bfcode{appertureCut}}{\emph{r=1.0}, \emph{w=3.0}}{}
\end{fulllineitems}

\index{beamClip() (in module gtrace.optics.gaussian)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.gaussian.beamClip}\pysiglinewithargsret{\code{gtrace.optics.gaussian.}\bfcode{beamClip}}{\emph{a=1.0}, \emph{w=3.0}}{}
\end{fulllineitems}

\index{modeMatching() (in module gtrace.optics.gaussian)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.gaussian.modeMatching}\pysiglinewithargsret{\code{gtrace.optics.gaussian.}\bfcode{modeMatching}}{\emph{q1}, \emph{q2x}, \emph{q2y=False}}{}
Mode matching between two beams with different q-parameters.
The axes of the two beams are assumed to be matched.

q1: q-parameter of the first beam. This beam is assumed to be circular.
\begin{description}
\item[{q2x: q-parameter of the second beam in x-direction. If the second beam}] \leavevmode
is also circular, omit the next argument.

\item[{q2y: q-parameter of the second beam in y-direction. Specify this parameter}] \leavevmode
if the second beam is eliptic.

\end{description}

\end{fulllineitems}

\index{modeSpacing() (in module gtrace.optics.gaussian)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.gaussian.modeSpacing}\pysiglinewithargsret{\code{gtrace.optics.gaussian.}\bfcode{modeSpacing}}{\emph{g1}, \emph{g2}}{}
\end{fulllineitems}

\index{optimalMatching() (in module gtrace.optics.gaussian)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.gaussian.optimalMatching}\pysiglinewithargsret{\code{gtrace.optics.gaussian.}\bfcode{optimalMatching}}{\emph{q1}, \emph{q2}}{}
Returns a mode (q-parameter) which best matches the given
two q-parameters, q1 and q2.

Returned values: (q, match)

q: The best matching q-parameter

match: Mode matching rate

\end{fulllineitems}

\index{q2R() (in module gtrace.optics.gaussian)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.gaussian.q2R}\pysiglinewithargsret{\code{gtrace.optics.gaussian.}\bfcode{q2R}}{\emph{q}}{}
Convert a q-parameter to the ROC

\end{fulllineitems}

\index{q2w() (in module gtrace.optics.gaussian)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.gaussian.q2w}\pysiglinewithargsret{\code{gtrace.optics.gaussian.}\bfcode{q2w}}{\emph{q}, \emph{wl=1.064e-06}}{}
Convert a q-parameter to the beam size

\end{fulllineitems}

\index{q2zr() (in module gtrace.optics.gaussian)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.gaussian.q2zr}\pysiglinewithargsret{\code{gtrace.optics.gaussian.}\bfcode{q2zr}}{\emph{q}}{}
Convert a q-parameter to Rayleigh range.

\end{fulllineitems}

\index{qToROC() (in module gtrace.optics.gaussian)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.gaussian.qToROC}\pysiglinewithargsret{\code{gtrace.optics.gaussian.}\bfcode{qToROC}}{\emph{q}}{}
\end{fulllineitems}

\index{qToRadius() (in module gtrace.optics.gaussian)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.gaussian.qToRadius}\pysiglinewithargsret{\code{gtrace.optics.gaussian.}\bfcode{qToRadius}}{\emph{q}, \emph{wl=1.064e-06}}{}
\end{fulllineitems}

\index{w02zr() (in module gtrace.optics.gaussian)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.gaussian.w02zr}\pysiglinewithargsret{\code{gtrace.optics.gaussian.}\bfcode{w02zr}}{\emph{w0}, \emph{wl=1.064e-06}}{}
Convert Rayleigh range to the waist size

\end{fulllineitems}

\index{zr2w0() (in module gtrace.optics.gaussian)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.gaussian.zr2w0}\pysiglinewithargsret{\code{gtrace.optics.gaussian.}\bfcode{zr2w0}}{\emph{zr}, \emph{wl=1.064e-06}}{}
Convert Rayleigh range to the waist size

\end{fulllineitems}



\paragraph{\texttt{geometric} Module}
\label{api/gtrace.optics:geometric-module}\label{api/gtrace.optics:module-gtrace.optics.geometric}\index{gtrace.optics.geometric (module)}\index{deflection\_angle() (in module gtrace.optics.geometric)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.geometric.deflection_angle}\pysiglinewithargsret{\code{gtrace.optics.geometric.}\bfcode{deflection\_angle}}{\emph{theta}, \emph{n1}, \emph{n2}, \emph{deg=True}}{}
\end{fulllineitems}

\index{line\_arc\_intersection() (in module gtrace.optics.geometric)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.geometric.line_arc_intersection}\pysiglinewithargsret{\code{gtrace.optics.geometric.}\bfcode{line\_arc\_intersection}}{\emph{pos}, \emph{dirVect}, \emph{chord\_center}, \emph{chordNormVect}, \emph{invROC}, \emph{diameter}, \emph{verbose=False}}{}
Compute the intersection point between a line
and an arc.

pos: Origin of the line
dirVect: Direction of the line
chord\_center: The center of the chord made by the arc.
chordNormVect: Normal vector of the chord.
invROC: Inverse of the ROC of the arc. Positive for concave surface.
diameter: Length of the chord.

\end{fulllineitems}

\index{line\_plane\_intersection() (in module gtrace.optics.geometric)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.geometric.line_plane_intersection}\pysiglinewithargsret{\code{gtrace.optics.geometric.}\bfcode{line\_plane\_intersection}}{\emph{pos}, \emph{dirVect}, \emph{plane\_center}, \emph{normalVector}, \emph{diameter}}{}
Compute the intersection point between a line
and a plane

A line is specified by its origin (pos) and the
direction vector (dirVect).
A plane is specfied by its center coordinates (plane\_center)
and the normal vector (normalVector).
The plane has its size (diameter).

The returned value is a dictionary of with the following keys:
``Intersection Point'': numpy array of the coordinates of the intersection point.
``isHit'': A boolean value of whether the line intersects with the plane or not.
``distance'': Distance between the origin of the line and the intersection point.
``distance from center'': Distance between the center of the plane and the intersection point.

\end{fulllineitems}

\index{normSpheric() (in module gtrace.optics.geometric)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.geometric.normSpheric}\pysiglinewithargsret{\code{gtrace.optics.geometric.}\bfcode{normSpheric}}{\emph{normAngle}, \emph{invROC}, \emph{dist\_from\_center}}{}
Returns the local normal angle of a spheric mirror
at a distance from the center.
\begin{description}
\item[{normAngle: The angle formed by the normal vector of the mirror}] \leavevmode
at the center and the x-axis.

\end{description}

invROC: 1/R, where R is the ROC of the mirror.
\begin{description}
\item[{dist\_from\_center: The distance from the center of the point where}] \leavevmode
the local normal is requested.
This is a signed value.
For a mirror facing +x (the normal vector points
towards positive x direction), this distance
is positive for points with positive y coordinate,
and negative for points with negative y coordinate.

\end{description}

\end{fulllineitems}

\index{refl\_defl\_angle() (in module gtrace.optics.geometric)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.geometric.refl_defl_angle}\pysiglinewithargsret{\code{gtrace.optics.geometric.}\bfcode{refl\_defl\_angle}}{\emph{beamAngle}, \emph{normAngle}, \emph{n1}, \emph{n2}, \emph{invROC=None}}{}
Returns a tuples of reflection and deflection angles.
\begin{description}
\item[{beamAngle: The angle formed by the propagation direction vector}] \leavevmode
of the incident beam and the x-axis.

\item[{normAngle: The angle formed by the normal vector of the surface}] \leavevmode
and the x-axis.

\end{description}

n1: Index of refraction of the incident side medium.

n2: Index of refraction of the transmission side medium.

\end{fulllineitems}

\index{vc\_deflect() (in module gtrace.optics.geometric)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.geometric.vc_deflect}\pysiglinewithargsret{\code{gtrace.optics.geometric.}\bfcode{vc\_deflect}}{\emph{theta}, \emph{theta1}, \emph{n1}, \emph{n2}}{}
Deflection angle helper function for VariCAD.
theta is the angle of the surface measured from right.
theta1 is the angle of the incident beam measured from right.
It returns an angle of the deflected beam measured from right.

\end{fulllineitems}

\index{vc\_reflect() (in module gtrace.optics.geometric)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.geometric.vc_reflect}\pysiglinewithargsret{\code{gtrace.optics.geometric.}\bfcode{vc\_reflect}}{\emph{theta}, \emph{theta1}}{}
\end{fulllineitems}

\index{vector\_rotation\_2D() (in module gtrace.optics.geometric)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.geometric.vector_rotation_2D}\pysiglinewithargsret{\code{gtrace.optics.geometric.}\bfcode{vector\_rotation\_2D}}{\emph{vect}, \emph{angle}}{}
\end{fulllineitems}



\paragraph{\texttt{unit} Module}
\label{api/gtrace.optics:unit-module}\label{api/gtrace.optics:module-gtrace.optics.unit}\index{gtrace.optics.unit (module)}\index{deg2rad() (in module gtrace.optics.unit)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.unit.deg2rad}\pysiglinewithargsret{\code{gtrace.optics.unit.}\bfcode{deg2rad}}{\emph{deg}}{}
\end{fulllineitems}

\index{rad2deg() (in module gtrace.optics.unit)}

\begin{fulllineitems}
\phantomsection\label{api/gtrace.optics:gtrace.optics.unit.rad2deg}\pysiglinewithargsret{\code{gtrace.optics.unit.}\bfcode{rad2deg}}{\emph{rad}}{}
\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{g}
\item {\texttt{gtrace.\_\_init\_\_}}, \pageref{api/gtrace:module-gtrace.__init__}
\item {\texttt{gtrace.beam}}, \pageref{api/gtrace:module-gtrace.beam}
\item {\texttt{gtrace.draw}}, \pageref{api/gtrace.draw:module-gtrace.draw}
\item {\texttt{gtrace.draw.draw}}, \pageref{api/gtrace.draw:module-gtrace.draw.draw}
\item {\texttt{gtrace.draw.dxf}}, \pageref{api/gtrace.draw:module-gtrace.draw.dxf}
\item {\texttt{gtrace.draw.renderer}}, \pageref{api/gtrace.draw:module-gtrace.draw.renderer}
\item {\texttt{gtrace.draw.tools}}, \pageref{api/gtrace.draw:module-gtrace.draw.tools}
\item {\texttt{gtrace.hello}}, \pageref{api/gtrace:module-gtrace.hello}
\item {\texttt{gtrace.nonsequential}}, \pageref{api/gtrace:module-gtrace.nonsequential}
\item {\texttt{gtrace.optcomp}}, \pageref{api/gtrace:module-gtrace.optcomp}
\item {\texttt{gtrace.optics.cavity}}, \pageref{api/gtrace.optics:module-gtrace.optics.cavity}
\item {\texttt{gtrace.optics.consts}}, \pageref{api/gtrace.optics:module-gtrace.optics.consts}
\item {\texttt{gtrace.optics.gaussian}}, \pageref{api/gtrace.optics:module-gtrace.optics.gaussian}
\item {\texttt{gtrace.optics.geometric}}, \pageref{api/gtrace.optics:module-gtrace.optics.geometric}
\item {\texttt{gtrace.optics.unit}}, \pageref{api/gtrace.optics:module-gtrace.optics.unit}
\item {\texttt{gtrace.unit}}, \pageref{api/gtrace:module-gtrace.unit}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
