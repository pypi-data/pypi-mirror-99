

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>gtrace.beam &mdash; gtrace 0.1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="gtrace 0.1.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">gtrace 0.1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for gtrace.beam</h1><div class="highlight"><pre>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">gtrace.beam</span>

<span class="sd">A module to define GaussianBeam class.</span>

<span class="sd">&#39;&#39;&#39;</span>

<span class="c">#{{{ Import modules</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span>
<span class="n">sqrt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">scimath</span><span class="o">.</span><span class="n">sqrt</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>

<span class="kn">from</span> <span class="nn">traits.api</span> <span class="kn">import</span> <span class="n">HasTraits</span><span class="p">,</span> <span class="n">Int</span><span class="p">,</span> <span class="n">Float</span><span class="p">,</span> <span class="n">CFloat</span><span class="p">,</span> <span class="n">CComplex</span><span class="p">,</span> <span class="n">CArray</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Str</span>

<span class="kn">from</span> <span class="nn">unit</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">gtrace.optics</span> <span class="kn">as</span> <span class="nn">optics</span>
<span class="kn">import</span> <span class="nn">gtrace.optics.geometric</span>
<span class="kn">from</span> <span class="nn">gtrace.optics.gaussian</span> <span class="kn">import</span> <span class="n">q2zr</span><span class="p">,</span> <span class="n">q2w</span><span class="p">,</span> <span class="n">q2R</span><span class="p">,</span> <span class="n">optimalMatching</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="c">#import gtrace.sdxf as sdxf</span>
<span class="kn">import</span> <span class="nn">gtrace.draw</span> <span class="kn">as</span> <span class="nn">draw</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="kn">as</span> <span class="nn">sopt</span>

<span class="c">#}}}</span>

<span class="c">#{{{ Author and License Infomation</span>

<span class="c">#Copyright (c) 2011-2012, Yoichi Aso</span>
<span class="c"># All rights reserved.</span>

<span class="c"># Redistribution and use in source and binary forms, with or without</span>
<span class="c"># modification, are permitted provided that the following conditions</span>
<span class="c"># are met:</span>
<span class="c">#</span>
<span class="c"># * Redistributions of source code must retain the above copyright</span>
<span class="c">#   notice, this list of conditions and the following disclaimer.</span>
<span class="c">#</span>
<span class="c"># * Redistributions in binary form must reproduce the above copyright</span>
<span class="c">#   notice, this list of conditions and the following disclaimer in the</span>
<span class="c">#   documentation and/or other materials provided with the distribution.</span>
<span class="c">#</span>
<span class="c"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="c"># &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="c"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</span>
<span class="c"># FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE</span>
<span class="c"># COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<span class="c"># INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,</span>
<span class="c"># BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="c"># LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<span class="c"># CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<span class="c"># LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN</span>
<span class="c"># ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="c"># POSSIBILITY OF SUCH DAMAGE.</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s">&quot;Yoichi Aso&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s">&quot;Copyright 2011-2012, Yoichi Aso&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Yoichi Aso&quot;</span><span class="p">]</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s">&quot;BSD&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s">&quot;0.2.0&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s">&quot;Yoichi Aso&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s">&quot;aso@granite.phys.s.u-tokyo.ac.jp&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s">&quot;Beta&quot;</span>

<span class="c">#}}}</span>

<span class="c">#{{{ GaussianBeam Class</span>

<div class="viewcode-block" id="GaussianBeam"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.GaussianBeam">[docs]</a><span class="k">class</span> <span class="nc">GaussianBeam</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        </span>
<span class="sd">    This is a class to represent a Gaussian beam.</span>
<span class="sd">    A GaussianBeam object has its origin (pos) and a propagation</span>
<span class="sd">    direction (dirVect or dirAngle).</span>
<span class="sd">    A GaussianBeam is characterized by q-parameter(s) at its origin.</span>
<span class="sd">    The beam can be either circular or elliptic. In order to deal with</span>
<span class="sd">    elliptic beams, some parameters are stored in pairs like (q0x, q0y).</span>
<span class="sd">    x and y denote the axes of the cross section of the beam. x-axis is</span>
<span class="sd">    parallel to the paper and the y-axis is perpendicular to the paper.</span>

<span class="sd">    A beam object can be propagated through a free space or made</span>
<span class="sd">    to interact with an optics.</span>

<span class="sd">    As a beam propagate through optical system, optical distance and</span>
<span class="sd">    Gouy phase are accumerated.</span>

<span class="sd">    *=== Attributes ===*</span>
<span class="sd">    </span>
<span class="sd">    **q:** q-parameter of the beam. If the beam is eliptic, q is the q-parameter</span>
<span class="sd">        of the best matching circular mode.</span>
<span class="sd">        </span>
<span class="sd">    **qx:** q-parameter of the beam in the x-direction. [complex float]</span>
<span class="sd">    </span>
<span class="sd">    **qy:** q-parameter of the beam in the y-direction. [complex float]</span>
<span class="sd">    </span>
<span class="sd">    **pos:** Position of the beam origin. [(2,) float array]</span>
<span class="sd">    </span>
<span class="sd">    **dirVect:** Propagation direction vector. [(2,) float array]</span>
<span class="sd">    </span>
<span class="sd">    **dirAngle:** Propagation direction angle measured from the positive x-axis. [float]</span>
<span class="sd">              </span>
<span class="sd">    **length:** Length of the beam (used for DXF export) [float]</span>
<span class="sd">    </span>
<span class="sd">    **layer:** Layer name of the beam when exported to a DXF file.</span>

<span class="sd">    **name:** Name of the beam</span>
<span class="sd">              </span>
<span class="sd">    **wl:** Wavelength in vacuum. Not the wavelength in the medium. [float]</span>

<span class="sd">    **n:** Index of refraction of the medium the beam is passing through. [float]</span>

<span class="sd">    **P:** Power [float]</span>
<span class="sd">    </span>
<span class="sd">    **wx:** Beamwidth in x-direction [float]</span>

<span class="sd">    **wy:** Beamwidth in y-direction [float]</span>

<span class="sd">    **optDist:** Accumulated optical distance.</span>

<span class="sd">    **Gouyx:** Accumulated Gouy phase in x-direction.</span>

<span class="sd">    **Gouyy:** Accumulated Gouy phase in y-direction.</span>

<span class="sd">    **Mx:** ABCD matrix in x-direction.</span>
<span class="sd">           This is a 2x2 matrix representing the product</span>
<span class="sd">           of ABCD transformations applied to this beam.</span>
<span class="sd">           It defaults to an identity matrix.</span>
<span class="sd">           Whenever a beam experience an ABCD matrix</span>
<span class="sd">           transformation, such as propagation in the space</span>
<span class="sd">           or reflection by a curved mirror, the applied ABCD</span>
<span class="sd">           matrix is multiplied to this matrix, so that we can</span>
<span class="sd">           keep track of what kind of transformations were</span>
<span class="sd">           made during beam propagation.</span>

<span class="sd">    **My:** ABCD matrix in y-direction. The meaning is the same as Mx.</span>

<span class="sd">    **departSurfAngle:** The angle formed by x-axis and the normal vector of</span>
<span class="sd">                                  the surface from which the beam is departing.</span>
<span class="sd">                                  Default is None. Used by the drawing routine.</span>

<span class="sd">    **departSurfInvROC:** Inverse of the ROC of the surface from which the beam is departing.</span>
<span class="sd">                                     The ROC is positive for a concave surface seen from</span>
<span class="sd">                                     the beam side.</span>
<span class="sd">                                     Default is None. Used by the drawing routine.                                    </span>
<span class="sd">    </span>
<span class="sd">    **incSurfAngle:** The angle formed by the x-arm and the normal vector of</span>
<span class="sd">                            the surface to which the beam is incident.</span>
<span class="sd">                            Default is None. Used by the drawing routine.    </span>

<span class="sd">    **incSurfInvROC:** Inverse of the ROC of the surface to which the beam is incident.</span>
<span class="sd">                               The ROC is positive for a concave surface seen from</span>
<span class="sd">                               the beam side.</span>
<span class="sd">                               Default is None. Used by the drawing routine.</span>

<span class="sd">    **stray_order:** An integer indicating if this beam is a stray light or not.</span>
<span class="sd">                        The default value is 0. Every time a beam is reflected by an AR surface</span>
<span class="sd">                        or transmits an HR surface, this couter is increased by 1.</span>

<span class="sd">    &#39;&#39;&#39;</span>

<span class="c">#{{{ Traits Definitions</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">Str</span><span class="p">()</span>
    <span class="n">wl</span> <span class="o">=</span> <span class="n">CFloat</span><span class="p">(</span><span class="mf">1064.0</span><span class="o">*</span><span class="n">nm</span><span class="p">)</span>  <span class="c">#Wavelength</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">CFloat</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="n">W</span><span class="p">)</span>  <span class="c">#Power</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">CComplex</span><span class="p">()</span>  <span class="c">#q-parameter at the origin (best matching circular mode)</span>
    <span class="n">qx</span> <span class="o">=</span> <span class="n">CComplex</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span>  <span class="c">#q-parameter at the origin (x-direction)</span>
    <span class="n">qy</span> <span class="o">=</span> <span class="n">CComplex</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span>  <span class="c">#q-parameter at the origin (y-direction)</span>
    <span class="n">qrx</span> <span class="o">=</span> <span class="n">CComplex</span><span class="p">()</span>  <span class="c">#Reduced q-parameter at the origin (x-direction)</span>
                                  <span class="c"># qrx = qx/n</span>
    <span class="n">qry</span> <span class="o">=</span> <span class="n">CComplex</span><span class="p">()</span>  <span class="c">#Reduced q-parameter at the origin (x-direction)</span>
                                  <span class="c"># qry = qy/n</span>
    <span class="n">Gouyx</span> <span class="o">=</span> <span class="n">CFloat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="c">#Accumurated Gouy phase</span>
    <span class="n">Gouyy</span> <span class="o">=</span> <span class="n">CFloat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="c">#Accumurated Gouy phase</span>
    <span class="n">wx</span> <span class="o">=</span> <span class="n">CFloat</span><span class="p">()</span>
    <span class="n">wy</span> <span class="o">=</span> <span class="n">CFloat</span><span class="p">()</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">CFloat</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="n">pos</span> <span class="o">=</span> <span class="n">CArray</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">CFloat</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">layer</span> <span class="o">=</span> <span class="n">Str</span><span class="p">()</span>
    <span class="n">dirVect</span> <span class="o">=</span> <span class="n">CArray</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
    <span class="n">dirAngle</span> <span class="o">=</span> <span class="n">CFloat</span><span class="p">()</span>
    <span class="n">optDist</span> <span class="o">=</span> <span class="n">CFloat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

    <span class="n">Mx</span> <span class="o">=</span> <span class="n">CArray</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">My</span> <span class="o">=</span> <span class="n">CArray</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    
<span class="c">#}}}</span>

<span class="c">#{{{ __init__</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q0</span><span class="o">=</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="mi">1064</span><span class="o">*</span><span class="n">nm</span><span class="p">)</span><span class="o">*</span><span class="mf">1e-6</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">q0x</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">q0y</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">pos</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">length</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">dirAngle</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">dirVect</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">wl</span><span class="o">=</span><span class="mi">1064</span><span class="o">*</span><span class="n">nm</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="mi">1</span><span class="o">*</span><span class="n">W</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Beam&quot;</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="s">&#39;main_beam&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        === Arguments ===</span>

<span class="sd">        q0: q-parameter. If q0x or q0y is not given, this parameter is used</span>
<span class="sd">            as both qx and qy. [complex float]</span>
<span class="sd">            </span>
<span class="sd">            q0x: q-parameter in x-direction [complex float]</span>
<span class="sd">            q0y: q-parameter in y-direction [complex float]</span>
<span class="sd">            </span>
<span class="sd">            pos: Position of the origin of the beam [(2,) float array]</span>
<span class="sd">            length: Length of the beam (used for DXF export) [float]</span>
<span class="sd">            dirAngle: Propagation direction angle measured from the positive x-axis.</span>
<span class="sd">                      [float]    </span>
<span class="sd">                      dirVect: Propagation direction vector. [(2,) float array]</span>
<span class="sd">                      wl: wavelength [float]</span>
<span class="sd">                      P: Power [float]</span>
<span class="sd">                      n: Index of refraction of the medium the beam is passing through. [float]</span>
<span class="sd">                      name: Name of the beam</span>
<span class="sd">                      layer: Layer name of the beam when exported to a DXF file.</span>
<span class="sd">        &#39;&#39;&#39;</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="n">P</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layer</span> <span class="o">=</span> <span class="n">layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        
        <span class="k">if</span> <span class="n">q0x</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qx</span> <span class="o">=</span> <span class="n">q0x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qx</span> <span class="o">=</span> <span class="n">q0</span>
            
        <span class="k">if</span> <span class="n">q0y</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qy</span> <span class="o">=</span> <span class="n">q0y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qy</span> <span class="o">=</span> <span class="n">q0</span>

        <span class="k">if</span> <span class="n">dirVect</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dirVect</span> <span class="o">=</span> <span class="n">dirVect</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dirAngle</span> <span class="o">=</span> <span class="n">dirAngle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dirAngle_changed</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">optDist</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">departSurfAngle</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">departSurfInvROC</span> <span class="o">=</span> <span class="bp">None</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">incSurfAngle</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">incSurfInvROC</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stray_order</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c">#}}}</span>

<span class="c">#{{{ copy</span>

<div class="viewcode-block" id="GaussianBeam.copy"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.GaussianBeam.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Make a deep copy.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">b</span><span class="o">.</span><span class="n">qrx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qrx</span>
        <span class="n">b</span><span class="o">.</span><span class="n">qry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qry</span>
        <span class="k">return</span> <span class="n">b</span>

<span class="c">#}}}</span>

<span class="c">#{{{ propagate</span>
</div>
<div class="viewcode-block" id="GaussianBeam.propagate"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.GaussianBeam.propagate">[docs]</a>    <span class="k">def</span> <span class="nf">propagate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Propagate the beam by a distance d from the current position.</span>
<span class="sd">        self.n is used as the index of refraction.</span>
<span class="sd">        During this process, the optical distance traveled is added</span>
<span class="sd">        to self.optDist.</span>
<span class="sd">        self.Goux and self.Gouyy are also updated to record the Gouy</span>
<span class="sd">        phase change.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">qx0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qx</span>
        <span class="n">qy0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qy</span>

        <span class="n">ABCD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">d</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])</span>
        <span class="c">#ABCD = np.array([[1.0, d/self.n**2],[0.0, 1.0]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ABCDTrans</span><span class="p">(</span><span class="n">ABCD</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirVect</span><span class="o">*</span><span class="n">d</span>

        <span class="c">#Increase the optical distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optDist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optDist</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="n">d</span>

        <span class="c">#Increase the Gouy phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gouyx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gouyx</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qx</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qx</span><span class="p">))</span>\
                     <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">qx0</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">qx0</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Gouyy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gouyy</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qy</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qy</span><span class="p">))</span>\
                     <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">qy0</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">qy0</span><span class="p">))</span>

<span class="c">#}}}</span>

<span class="c">#{{{ ABCD Trans</span></div>
<div class="viewcode-block" id="GaussianBeam.ABCDTrans"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.GaussianBeam.ABCDTrans">[docs]</a>    <span class="k">def</span> <span class="nf">ABCDTrans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCDx</span><span class="p">,</span> <span class="n">ABCDy</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Apply ABCD transformation to the beam.</span>

<span class="sd">        **ABCDx:** ABCD matrix for x-direction</span>

<span class="sd">        **ABCDy:** ABCD matrix for y-direction</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">ABCDy</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ABCDy</span> <span class="o">=</span> <span class="n">ABCDx</span>
            
        <span class="c">#Update q-parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qrx</span> <span class="o">=</span> <span class="p">(</span><span class="n">ABCDx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">qrx</span> <span class="o">+</span> <span class="n">ABCDx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">ABCDx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">qrx</span> <span class="o">+</span> <span class="n">ABCDx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qry</span> <span class="o">=</span> <span class="p">(</span><span class="n">ABCDy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">qry</span> <span class="o">+</span> <span class="n">ABCDy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">ABCDy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">qry</span> <span class="o">+</span> <span class="n">ABCDy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

        <span class="c">#Update Mx and My</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ABCDx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Mx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">My</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ABCDy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">My</span><span class="p">)</span>        
        
<span class="c">#}}}</span>

<span class="c">#{{{ rotate</span>
</div>
<div class="viewcode-block" id="GaussianBeam.rotate"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.GaussianBeam.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Rotate the beam around &#39;center&#39;.</span>
<span class="sd">        If center is not given, the beam is rotated</span>
<span class="sd">        around self.pos.</span>

<span class="sd">        *Arguments*</span>

<span class="sd">        **angle:** Rotation angle in radians.</span>

<span class="sd">        **center:** Center for rotation. [(2,) array of float]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">center</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="n">optics</span><span class="o">.</span><span class="n">geometric</span><span class="o">.</span><span class="n">vector_rotation_2D</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">center</span> <span class="o">+</span> <span class="n">pointer</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">dirAngle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirAngle</span> <span class="o">+</span> <span class="n">angle</span>

<span class="c">#}}}</span>

<span class="c">#{{{ Translate</span>
</div>
<div class="viewcode-block" id="GaussianBeam.translate"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.GaussianBeam.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trVect</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Translate the beam by the direction and the distance</span>
<span class="sd">        specified by a vector.</span>

<span class="sd">       *Arguments*</span>

<span class="sd">        **trVect:** A vector to specify the translation direction and</span>
<span class="sd">                distance. [(2,) float array]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="n">trVect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trVect</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="n">trVect</span>
        
<span class="c">#}}}</span>

<span class="c">#{{{ Flip</span></div>
<div class="viewcode-block" id="GaussianBeam.flip"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.GaussianBeam.flip">[docs]</a>    <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flipDirVect</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Change the propagation direction of the beam</span>
<span class="sd">        by 180 degrees.</span>
<span class="sd">        This is equivalent to the reflection of the beam</span>
<span class="sd">        by a spherical mirror with the same ROC as the beam.</span>

<span class="sd">        If optional argument flipDirVect is set to False,</span>
<span class="sd">        the propagation direction of the beam is not changed.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qx</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qx</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qy</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qy</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">flipDirVect</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dirVect</span> <span class="o">=</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirVect</span>

<span class="c">#}}}</span>

<span class="c">#{{{ width</span>
</div>
<div class="viewcode-block" id="GaussianBeam.width"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.GaussianBeam.width">[docs]</a>    <span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the beam width at a distance dist</span>
<span class="sd">        from the origin of the beam.</span>
<span class="sd">        The width is the readius where the light power becomes 1/e^2.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="n">qx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qx</span> <span class="o">+</span> <span class="n">dist</span>
        <span class="n">qy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qy</span> <span class="o">+</span> <span class="n">dist</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">qx</span><span class="p">))),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">qy</span><span class="p">))))</span>

<span class="c">#}}}</span>

<span class="c">#{{{ R</span>
</div>
<div class="viewcode-block" id="GaussianBeam.R"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.GaussianBeam.R">[docs]</a>    <span class="k">def</span> <span class="nf">R</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the beam ROC at a distance dist</span>
<span class="sd">        from the origin of the beam.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span>
        <span class="n">qx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qx</span> <span class="o">+</span> <span class="n">dist</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">qy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qy</span> <span class="o">+</span> <span class="n">dist</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">q2R</span><span class="p">(</span><span class="n">qx</span><span class="p">),</span> <span class="n">q2R</span><span class="p">(</span><span class="n">qy</span><span class="p">))</span>

<span class="c">#}}}</span>

<span class="c">#{{{ Waist</span>
</div>
<div class="viewcode-block" id="GaussianBeam.waist"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.GaussianBeam.waist">[docs]</a>    <span class="k">def</span> <span class="nf">waist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the tuples of waist size and distance</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c">#Waist positions</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qx</span><span class="p">)</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qy</span><span class="p">)</span>

        <span class="c">#Waist sizes</span>
        <span class="n">wx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">(</span><span class="n">dx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">wy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">(</span><span class="n">dy</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">{</span><span class="s">&quot;Waist Size&quot;</span><span class="p">:(</span><span class="n">wx</span><span class="p">,</span> <span class="n">wy</span><span class="p">),</span> <span class="s">&quot;Waist Position&quot;</span><span class="p">:(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">)}</span>
    
<span class="c">#}}}</span>

<span class="c">#{{{ draw</span>

<span class="c">#{{{ Main Function</span>
</div>
<div class="viewcode-block" id="GaussianBeam.draw"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.GaussianBeam.draw">[docs]</a>    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cv</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">3.</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">drawWidth</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
             <span class="n">fontSize</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">drawPower</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">drawROC</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">drawGouy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">drawOptDist</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">drawName</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Draw the beam into a DXF object.</span>

<span class="sd">        *Arguments*</span>

<span class="sd">        **cv:** draw.Canvas object.</span>
<span class="sd">        </span>
<span class="sd">        **sigma:** The width of the beam drawn is sigma * (1/e^2 radius of the beam).</span>
<span class="sd">               The default is sigma = 3. sigma = 2.7 gives 1ppm diffraction loss.</span>
<span class="sd">               [float]</span>
<span class="sd">               </span>
<span class="sd">        **mode:** &#39;avg&#39;, &#39;x&#39;, or &#39;y&#39;. A beam can have different widths for x- and y-</span>
<span class="sd">              directions. If &#39;avg&#39; is specified, the average of them are drawn.</span>
<span class="sd">              &#39;x&#39; and &#39;y&#39; specifies to show the width of the respective directions.</span>
<span class="sd">        </span>
<span class="sd">        **fontSize:** Size of the font used to show supplemental informations. [float]</span>

<span class="sd">        **drawWidth:** Whether to draw width or not. [Boolean]</span>

<span class="sd">        **drawPower:** Whether to show the beam power. [Boolean]</span>

<span class="sd">        **drawROC:** Whether to show the ROC or not. [Boolean]</span>

<span class="sd">        **drawGouy:** Whether to show the Gouy phase or not. [Boolean]</span>

<span class="sd">        **drawOptDist:** Whether to show the accumulated optical distance or not. [Boolean]</span>

<span class="sd">        **drawName:** Whether draw the name of the beam or not. [Boolean]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fontSize</span><span class="p">:</span>
            <span class="n">fontSize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="o">/</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sigma</span><span class="o">/</span><span class="mi">5</span>

        <span class="n">start</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirVect</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>

        <span class="c">#Location to put texts</span>
        <span class="c">#mid = self.pos + self.dirVect * self.length/2</span>
        <span class="c">#side = mid+fontSize*1.2*k        </span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">dirVect</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirVect</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">text_location</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">10</span><span class="o">*</span><span class="n">fontSize</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dirVect</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">fontSize</span><span class="o">*</span><span class="mi">1</span><span class="p">)</span>

        
        <span class="c">#Draw the center line</span>
        <span class="n">cv</span><span class="o">.</span><span class="n">add_shape</span><span class="p">(</span><span class="n">draw</span><span class="o">.</span><span class="n">Line</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">drawWidth</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">drawWidth</span><span class="p">(</span><span class="n">cv</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
            
        <span class="n">annotation</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">if</span> <span class="n">drawName</span><span class="p">:</span>
            <span class="n">annotation</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">+</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> &#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            
        <span class="k">if</span> <span class="n">drawPower</span><span class="p">:</span>
            <span class="n">annotation</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">+</span><span class="s">&#39;P=</span><span class="si">%.2E</span><span class="s"> &#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span>

        <span class="k">if</span> <span class="n">drawROC</span><span class="p">:</span>
            <span class="n">annotation</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">+</span><span class="s">&#39;ROCx=</span><span class="si">%.2E</span><span class="s"> &#39;</span><span class="o">%</span><span class="n">q2R</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qx</span><span class="p">)</span> 
            <span class="n">annotation</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">+</span><span class="s">&#39;ROCy=</span><span class="si">%.2E</span><span class="s"> &#39;</span><span class="o">%</span><span class="n">q2R</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qy</span><span class="p">)</span>             

        <span class="k">if</span> <span class="n">drawGouy</span><span class="p">:</span>
            <span class="n">annotation</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">+</span><span class="s">&#39;Gouyx=</span><span class="si">%.2E</span><span class="s"> &#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">Gouyx</span>
            <span class="n">annotation</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">+</span><span class="s">&#39;Gouyy=</span><span class="si">%.2E</span><span class="s"> &#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">Gouyy</span>

        <span class="k">if</span> <span class="n">drawOptDist</span><span class="p">:</span>
            <span class="n">annotation</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">+</span><span class="s">&#39;Optical distance=</span><span class="si">%.2E</span><span class="s"> &#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">optDist</span>

        <span class="n">cv</span><span class="o">.</span><span class="n">add_shape</span><span class="p">(</span><span class="n">draw</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">annotation</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="n">text_location</span><span class="p">,</span> 
                             <span class="n">height</span><span class="o">=</span><span class="n">fontSize</span><span class="p">),</span> <span class="n">layername</span><span class="o">=</span><span class="s">&#39;text&#39;</span><span class="p">)</span>

        <span class="c">#Indicate the beam direction</span>
        <span class="c"># text_location = tuple(self.pos + 10*fontSize*self.dirVect +k*fontSize*1)</span>
        <span class="c"># dxf.append(sdxf.Text(text=self.name+&#39;:origin P=%.2E&#39;%self.P, point=text_location,</span>
        <span class="c">#                      height=fontSize, layer=&#39;text&#39;))</span>

        <span class="c"># text_location = tuple(self.pos + (self.length - 10*fontSize)*self.dirVect + k*fontSize*1)</span>
        <span class="c"># dxf.append(sdxf.Text(text=self.name+&#39;:end P=%.2E&#39;%self.P, point=text_location,</span>
        <span class="c">#                      height=fontSize, layer=&#39;text&#39;))</span>
        
<span class="c">#}}}</span>

<span class="c">#{{{ drawWidth</span>
</div>
<div class="viewcode-block" id="GaussianBeam.drawWidth"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.GaussianBeam.drawWidth">[docs]</a>    <span class="k">def</span> <span class="nf">drawWidth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cv</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="c">#Draw the width</span>

        <span class="c">#Determine the number of line segments to draw</span>
        <span class="n">zr</span> <span class="o">=</span> <span class="n">q2zr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qx</span><span class="p">)</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">zr</span><span class="o">/</span><span class="mf">10.0</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="o">/</span><span class="mf">10.0</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="o">/</span><span class="mf">10.0</span>

        <span class="n">numSegments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="o">/</span><span class="n">resolution</span>

        <span class="k">if</span> <span class="n">numSegments</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">numSegments</span> <span class="o">=</span> <span class="mi">100</span>

        <span class="c">#q0 to be used</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">q0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qx</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&#39;y&#39;</span><span class="p">:</span>
            <span class="n">q0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">q0</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">qy</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>

        <span class="c">#Determine the start z coordinates</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">departSurfAngle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">departSurfAngle</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirAngle</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">departSurfInvROC</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">100</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">departSurfInvROC</span>
                <span class="p">(</span><span class="n">z1u</span><span class="p">,</span> <span class="n">z1d</span><span class="p">)</span> <span class="o">=</span> <span class="n">optimStartPointR</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span><span class="n">z1u</span><span class="p">,</span> <span class="n">z1d</span><span class="p">)</span> <span class="o">=</span> <span class="n">optimCrossPointFlat</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z1u</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">z1d</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c">#Determine the end z coordinates</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">incSurfAngle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incSurfAngle</span><span class="o">+</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirAngle</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>            
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incSurfInvROC</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">100</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">incSurfInvROC</span>
                <span class="p">(</span><span class="n">z2u</span><span class="p">,</span> <span class="n">z2d</span><span class="p">)</span> <span class="o">=</span> <span class="n">optimEndPointR</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">q0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span><span class="n">z2u</span><span class="p">,</span> <span class="n">z2d</span><span class="p">)</span> <span class="o">=</span> <span class="n">optimCrossPointFlat</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">q0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z2u</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">z2d</span> <span class="o">=</span> <span class="mf">0.0</span>
            

        <span class="n">du</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">z1u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="o">+</span><span class="n">z2u</span><span class="p">,</span> <span class="n">numSegments</span><span class="p">)</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">z1d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="o">+</span><span class="n">z2d</span><span class="p">,</span> <span class="n">numSegments</span><span class="p">)</span>        
        <span class="n">au</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">(</span><span class="n">du</span><span class="p">)</span>
        <span class="n">ad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">wu</span> <span class="o">=</span> <span class="n">au</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sigma</span>
            <span class="n">wd</span> <span class="o">=</span> <span class="n">ad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sigma</span>            
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&#39;y&#39;</span><span class="p">:</span>
            <span class="n">wu</span> <span class="o">=</span> <span class="n">au</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">sigma</span>
            <span class="n">wd</span> <span class="o">=</span> <span class="n">ad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">sigma</span>            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wu</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">*</span><span class="p">(</span><span class="n">au</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">au</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">wd</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">*</span><span class="p">(</span><span class="n">ad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">ad</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>            

        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">du</span><span class="p">,</span><span class="n">wu</span><span class="p">))</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">optics</span><span class="o">.</span><span class="n">geometric</span><span class="o">.</span><span class="n">vector_rotation_2D</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirAngle</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">cv</span><span class="o">.</span><span class="n">add_shape</span><span class="p">(</span><span class="n">draw</span><span class="o">.</span><span class="n">PolyLine</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">y</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]),</span> <span class="n">layername</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">+</span><span class="s">&quot;_width&quot;</span><span class="p">)</span>

        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dd</span><span class="p">,</span><span class="o">-</span><span class="n">wd</span><span class="p">))</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">optics</span><span class="o">.</span><span class="n">geometric</span><span class="o">.</span><span class="n">vector_rotation_2D</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirAngle</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">cv</span><span class="o">.</span><span class="n">add_shape</span><span class="p">(</span><span class="n">draw</span><span class="o">.</span><span class="n">PolyLine</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">y</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]),</span> <span class="n">layername</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">+</span><span class="s">&quot;_width&quot;</span><span class="p">)</span>        


<span class="c">#}}}        </span>

<span class="c">#{{{ drawWidthOld</span>
</div>
<div class="viewcode-block" id="GaussianBeam.drawWidthOld"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.GaussianBeam.drawWidthOld">[docs]</a>    <span class="k">def</span> <span class="nf">drawWidthOld</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dxf</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="c">#Draw the width</span>

        <span class="c">#Determine the number of line segments to draw</span>
        <span class="n">zr</span> <span class="o">=</span> <span class="n">q2zr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qx</span><span class="p">)</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">zr</span><span class="o">/</span><span class="mf">10.0</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="o">/</span><span class="mf">10.0</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="o">/</span><span class="mf">10.0</span>

        <span class="n">numSegments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="o">/</span><span class="n">resolution</span>

        <span class="k">if</span> <span class="n">numSegments</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">numSegments</span> <span class="o">=</span> <span class="mi">100</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">numSegments</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sigma</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&#39;y&#39;</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">sigma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>

        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">d</span><span class="p">,</span><span class="n">w</span><span class="p">))</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">optics</span><span class="o">.</span><span class="n">geometric</span><span class="o">.</span><span class="n">vector_rotation_2D</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirAngle</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">dxf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sdxf</span><span class="o">.</span><span class="n">LwPolyLine</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">layer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">+</span><span class="s">&quot;_width&quot;</span><span class="p">))</span>

        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">d</span><span class="p">,</span><span class="o">-</span><span class="n">w</span><span class="p">))</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">optics</span><span class="o">.</span><span class="n">geometric</span><span class="o">.</span><span class="n">vector_rotation_2D</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirAngle</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">dxf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sdxf</span><span class="o">.</span><span class="n">LwPolyLine</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">layer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">+</span><span class="s">&quot;_width&quot;</span><span class="p">))</span>


<span class="c">#}}}</span>

<span class="c">#}}}</span>

<span class="c">#{{{ Notification Handlers</span>
</div>
    <span class="k">def</span> <span class="nf">_dirAngle_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">trait_change_notify</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">dirVect</span><span class="o">=</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirAngle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirAngle</span><span class="p">)]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">trait_change_notify</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">dirAngle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirAngle</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span>
<span class="c">#        self.dirVect = array([np.cos(self.dirAngle), np.sin(self.dirAngle)])</span>
<span class="c">#        self.dirAngle = np.mod(self.dirAngle, 2*pi)</span>
            
    <span class="k">def</span> <span class="nf">_dirVect_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="c">#Normalize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">trait_change_notify</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">dirVect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirVect</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirVect</span><span class="p">)))</span>
        <span class="c">#Update dirAngle accordingly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">trait_change_notify</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">dirAngle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirVect</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">dirVect</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_qx_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wx</span> <span class="o">=</span> <span class="n">q2w</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qx</span><span class="p">,</span> <span class="n">wl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">trait_change_notify</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">qrx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qx</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">optimalMatching</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qy</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_qy_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wy</span> <span class="o">=</span> <span class="n">q2w</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qy</span><span class="p">,</span> <span class="n">wl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">trait_change_notify</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">qry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qy</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">optimalMatching</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qy</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">def</span> <span class="nf">_qrx_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qrx</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        
    <span class="k">def</span> <span class="nf">_qry_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qry</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span>

    <span class="k">def</span> <span class="nf">_n_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">trait_change_notify</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">qx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qrx</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">trait_change_notify</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">qy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qry</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

<span class="c">#}}}        </span>

<span class="c">#}}}</span>

<span class="c">#{{{ Functions to determine the cross points</span>
</div>
<div class="viewcode-block" id="optFunForStartPointR"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.optFunForStartPointR">[docs]</a><span class="k">def</span> <span class="nf">optFunForStartPointR</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">Mrot</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A function to return the distance between the point on</span>
<span class="sd">    the spherical surface at an angle phi and the beam width</span>
<span class="sd">    at the same z.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="o">-</span><span class="n">cp</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">sp</span><span class="p">]])</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Mrot</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">w1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">side</span>
    <span class="n">w2</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">q0</span><span class="o">+</span><span class="n">z</span><span class="p">))))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">w1</span><span class="o">-</span><span class="n">w2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="optimStartPointR"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.optimStartPointR">[docs]</a><span class="k">def</span> <span class="nf">optimStartPointR</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">Mrot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">ct</span><span class="p">,</span> <span class="o">-</span><span class="n">st</span><span class="p">],</span> <span class="p">[</span><span class="n">st</span><span class="p">,</span> <span class="n">ct</span><span class="p">]])</span>
    
    <span class="n">phi1</span> <span class="o">=</span> <span class="n">sopt</span><span class="o">.</span><span class="n">newton</span><span class="p">(</span><span class="n">optFunForStartPointR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">Mrot</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi1</span><span class="p">)</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="o">-</span><span class="n">cp</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">sp</span><span class="p">]])</span>
    <span class="n">z1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Mrot</span><span class="p">,</span> <span class="n">v</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">phi2</span> <span class="o">=</span> <span class="n">sopt</span><span class="o">.</span><span class="n">newton</span><span class="p">(</span><span class="n">optFunForStartPointR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">Mrot</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi2</span><span class="p">)</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi2</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="o">-</span><span class="n">cp</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">sp</span><span class="p">]])</span>
    <span class="n">z2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Mrot</span><span class="p">,</span> <span class="n">v</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="n">z1</span><span class="p">,</span><span class="n">z2</span><span class="p">)</span> 
</div>
<div class="viewcode-block" id="optFunForEndPointR"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.optFunForEndPointR">[docs]</a><span class="k">def</span> <span class="nf">optFunForEndPointR</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">Mrot</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A function to return the distance between the point on</span>
<span class="sd">    the spherical surface at an angle phi and the beam width</span>
<span class="sd">    at the same z.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="o">-</span><span class="n">R</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cp</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">sp</span><span class="p">]])</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Mrot</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">w1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">side</span>
    <span class="n">w2</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">q0</span><span class="o">+</span><span class="n">z</span><span class="p">))))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">w1</span><span class="o">-</span><span class="n">w2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="optimEndPointR"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.optimEndPointR">[docs]</a><span class="k">def</span> <span class="nf">optimEndPointR</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">Mrot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">ct</span><span class="p">,</span> <span class="o">-</span><span class="n">st</span><span class="p">],</span> <span class="p">[</span><span class="n">st</span><span class="p">,</span> <span class="n">ct</span><span class="p">]])</span>
    
    <span class="n">phi1</span> <span class="o">=</span> <span class="n">sopt</span><span class="o">.</span><span class="n">newton</span><span class="p">(</span><span class="n">optFunForEndPointR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">Mrot</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi1</span><span class="p">)</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">sp</span><span class="p">]])</span>
    <span class="n">z1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Mrot</span><span class="p">,</span> <span class="n">v</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">phi2</span> <span class="o">=</span> <span class="n">sopt</span><span class="o">.</span><span class="n">newton</span><span class="p">(</span><span class="n">optFunForEndPointR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">Mrot</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi2</span><span class="p">)</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi2</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">sp</span><span class="p">]])</span>
    <span class="n">z2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Mrot</span><span class="p">,</span> <span class="n">v</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="n">z1</span><span class="p">,</span><span class="n">z2</span><span class="p">)</span> 
</div>
<div class="viewcode-block" id="optFunForFlat"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.optFunForFlat">[docs]</a><span class="k">def</span> <span class="nf">optFunForFlat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Mrot</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A function to return the distance between the point on</span>
<span class="sd">    the spherical surface at an angle phi and the beam width</span>
<span class="sd">    at the same z.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],[</span><span class="n">a</span><span class="p">]])</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Mrot</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">w1</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">side</span>
    <span class="n">w2</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">q0</span><span class="o">+</span><span class="n">z</span><span class="p">))))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">w1</span><span class="o">-</span><span class="n">w2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="optimCrossPointFlat"><a class="viewcode-back" href="../../api/gtrace.html#gtrace.beam.optimCrossPointFlat">[docs]</a><span class="k">def</span> <span class="nf">optimCrossPointFlat</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">Mrot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">ct</span><span class="p">,</span> <span class="o">-</span><span class="n">st</span><span class="p">],</span> <span class="p">[</span><span class="n">st</span><span class="p">,</span> <span class="n">ct</span><span class="p">]])</span>
    
    <span class="n">a1</span> <span class="o">=</span> <span class="n">sopt</span><span class="o">.</span><span class="n">newton</span><span class="p">(</span><span class="n">optFunForFlat</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">Mrot</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],[</span><span class="n">a1</span><span class="p">]])</span>
    <span class="n">z1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Mrot</span><span class="p">,</span> <span class="n">v</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">a2</span> <span class="o">=</span> <span class="n">sopt</span><span class="o">.</span><span class="n">newton</span><span class="p">(</span><span class="n">optFunForFlat</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">Mrot</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],[</span><span class="n">a2</span><span class="p">]])</span>
    <span class="n">z2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Mrot</span><span class="p">,</span> <span class="n">v</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="n">z1</span><span class="p">,</span><span class="n">z2</span><span class="p">)</span> 

<span class="c">#}}}</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">gtrace 0.1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Yoichi Aso.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>