# coding: utf-8

"""
    Aron API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from openapi_client.api_client import ApiClient
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class APIV1Api(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def access_token_create_api(self, **kwargs):  # noqa: E501
        """access_token_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.access_token_create_api(async_req=True)
        >>> result = thread.get()

        :param access_token_create_api_payload:
        :type access_token_create_api_payload: AccessTokenCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AccountAccessTokenCreateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.access_token_create_api_with_http_info(**kwargs)  # noqa: E501

    def access_token_create_api_with_http_info(self, **kwargs):  # noqa: E501
        """access_token_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.access_token_create_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param access_token_create_api_payload:
        :type access_token_create_api_payload: AccessTokenCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AccountAccessTokenCreateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'access_token_create_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method access_token_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'access_token_create_api_payload' in local_var_params:
            body_params = local_var_params['access_token_create_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "AccountAccessTokenCreateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/access_tokens', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def access_token_verify_api(self, **kwargs):  # noqa: E501
        """access_token_verify_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.access_token_verify_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.access_token_verify_api_with_http_info(**kwargs)  # noqa: E501

    def access_token_verify_api_with_http_info(self, **kwargs):  # noqa: E501
        """access_token_verify_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.access_token_verify_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method access_token_verify_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/access_tokens/verify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def all_cluster_list_api(self, workspace_name, **kwargs):  # noqa: E501
        """all_cluster_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.all_cluster_list_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterAllClusterListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.all_cluster_list_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def all_cluster_list_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """all_cluster_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.all_cluster_list_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterAllClusterListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method all_cluster_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `all_cluster_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ClusterAllClusterListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/clusters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def change_password_api(self, **kwargs):  # noqa: E501
        """change_password_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.change_password_api(async_req=True)
        >>> result = thread.get()

        :param change_password_api_payload:
        :type change_password_api_payload: ChangePasswordAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseMyUser
        """
        kwargs['_return_http_data_only'] = True
        return self.change_password_api_with_http_info(**kwargs)  # noqa: E501

    def change_password_api_with_http_info(self, **kwargs):  # noqa: E501
        """change_password_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.change_password_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param change_password_api_payload:
        :type change_password_api_payload: ChangePasswordAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseMyUser, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'change_password_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_password_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'change_password_api_payload' in local_var_params:
            body_params = local_var_params['change_password_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseMyUser",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/change_password', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def change_username_api(self, **kwargs):  # noqa: E501
        """change_username_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.change_username_api(async_req=True)
        >>> result = thread.get()

        :param change_username_api_payload:
        :type change_username_api_payload: ChangeUsernameAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseMyUser
        """
        kwargs['_return_http_data_only'] = True
        return self.change_username_api_with_http_info(**kwargs)  # noqa: E501

    def change_username_api_with_http_info(self, **kwargs):  # noqa: E501
        """change_username_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.change_username_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param change_username_api_payload:
        :type change_username_api_payload: ChangeUsernameAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseMyUser, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'change_username_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_username_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'change_username_api_payload' in local_var_params:
            body_params = local_var_params['change_username_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseMyUser",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/change_username', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cli_experiment_metrics_update_api(self, experiment_id, **kwargs):  # noqa: E501
        """cli_experiment_metrics_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cli_experiment_metrics_update_api(experiment_id, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param cli_experiment_metrics_update_api_payload:
        :type cli_experiment_metrics_update_api_payload: CliExperimentMetricsUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.cli_experiment_metrics_update_api_with_http_info(experiment_id, **kwargs)  # noqa: E501

    def cli_experiment_metrics_update_api_with_http_info(self, experiment_id, **kwargs):  # noqa: E501
        """cli_experiment_metrics_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cli_experiment_metrics_update_api_with_http_info(experiment_id, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param cli_experiment_metrics_update_api_payload:
        :type cli_experiment_metrics_update_api_payload: CliExperimentMetricsUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_id',
            'cli_experiment_metrics_update_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cli_experiment_metrics_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_id' is set
        if self.api_client.client_side_validation and ('experiment_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['experiment_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_id` when calling `cli_experiment_metrics_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_id' in local_var_params:
            path_params['experimentID'] = local_var_params['experiment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cli_experiment_metrics_update_api_payload' in local_var_params:
            body_params = local_var_params['cli_experiment_metrics_update_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/experiments/{experimentID}/metrics', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_read_api(self, cluster_name, workspace_name, **kwargs):  # noqa: E501
        """cluster_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_read_api(cluster_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param cluster_name: (required)
        :type cluster_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseKernelClusterInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_read_api_with_http_info(cluster_name, workspace_name, **kwargs)  # noqa: E501

    def cluster_read_api_with_http_info(self, cluster_name, workspace_name, **kwargs):  # noqa: E501
        """cluster_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_read_api_with_http_info(cluster_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param cluster_name: (required)
        :type cluster_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseKernelClusterInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_name',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_name' is set
        if self.api_client.client_side_validation and ('cluster_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_name` when calling `cluster_read_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `cluster_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_name' in local_var_params:
            path_params['clusterName'] = local_var_params['cluster_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseKernelClusterInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/clusters/{clusterName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def custom_cluster_add_api(self, workspace_name, **kwargs):  # noqa: E501
        """custom_cluster_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_add_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param custom_cluster_add_api_payload:
        :type custom_cluster_add_api_payload: CustomClusterAddAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseKernelClusterInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.custom_cluster_add_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def custom_cluster_add_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """custom_cluster_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_add_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param custom_cluster_add_api_payload:
        :type custom_cluster_add_api_payload: CustomClusterAddAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseKernelClusterInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            'custom_cluster_add_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method custom_cluster_add_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `custom_cluster_add_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'custom_cluster_add_api_payload' in local_var_params:
            body_params = local_var_params['custom_cluster_add_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseKernelClusterInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/custom_clusters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def custom_cluster_delete_api(self, cluster_name, workspace_name, **kwargs):  # noqa: E501
        """custom_cluster_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_delete_api(cluster_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param cluster_name: (required)
        :type cluster_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.custom_cluster_delete_api_with_http_info(cluster_name, workspace_name, **kwargs)  # noqa: E501

    def custom_cluster_delete_api_with_http_info(self, cluster_name, workspace_name, **kwargs):  # noqa: E501
        """custom_cluster_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_delete_api_with_http_info(cluster_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param cluster_name: (required)
        :type cluster_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_name',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method custom_cluster_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_name' is set
        if self.api_client.client_side_validation and ('cluster_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_name` when calling `custom_cluster_delete_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `custom_cluster_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_name' in local_var_params:
            path_params['clusterName'] = local_var_params['cluster_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/custom_clusters/{clusterName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def custom_cluster_list_api(self, workspace_name, **kwargs):  # noqa: E501
        """custom_cluster_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_list_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterCustomClusterListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.custom_cluster_list_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def custom_cluster_list_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """custom_cluster_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_list_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterCustomClusterListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method custom_cluster_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `custom_cluster_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ClusterCustomClusterListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/custom_clusters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def custom_cluster_node_list_api(self, cluster_name, workspace_name, **kwargs):  # noqa: E501
        """custom_cluster_node_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_node_list_api(cluster_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param cluster_name: (required)
        :type cluster_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterCustomClusterNodeListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.custom_cluster_node_list_api_with_http_info(cluster_name, workspace_name, **kwargs)  # noqa: E501

    def custom_cluster_node_list_api_with_http_info(self, cluster_name, workspace_name, **kwargs):  # noqa: E501
        """custom_cluster_node_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_node_list_api_with_http_info(cluster_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param cluster_name: (required)
        :type cluster_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterCustomClusterNodeListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_name',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method custom_cluster_node_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_name' is set
        if self.api_client.client_side_validation and ('cluster_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_name` when calling `custom_cluster_node_list_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `custom_cluster_node_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_name' in local_var_params:
            path_params['clusterName'] = local_var_params['cluster_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ClusterCustomClusterNodeListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/custom_clusters/{clusterName}/nodes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def custom_cluster_system_metrics_api(self, cluster_name, workspace_name, **kwargs):  # noqa: E501
        """custom_cluster_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_system_metrics_api(cluster_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param cluster_name: (required)
        :type cluster_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseKernelClusterSystemMetrics
        """
        kwargs['_return_http_data_only'] = True
        return self.custom_cluster_system_metrics_api_with_http_info(cluster_name, workspace_name, **kwargs)  # noqa: E501

    def custom_cluster_system_metrics_api_with_http_info(self, cluster_name, workspace_name, **kwargs):  # noqa: E501
        """custom_cluster_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_system_metrics_api_with_http_info(cluster_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param cluster_name: (required)
        :type cluster_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseKernelClusterSystemMetrics, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_name',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method custom_cluster_system_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_name' is set
        if self.api_client.client_side_validation and ('cluster_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_name` when calling `custom_cluster_system_metrics_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `custom_cluster_system_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_name' in local_var_params:
            path_params['clusterName'] = local_var_params['cluster_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseKernelClusterSystemMetrics",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/custom_clusters/{clusterName}/system_metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def custom_cluster_update_api(self, cluster_name, workspace_name, **kwargs):  # noqa: E501
        """custom_cluster_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_update_api(cluster_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param cluster_name: (required)
        :type cluster_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param custom_cluster_update_api_payload:
        :type custom_cluster_update_api_payload: CustomClusterUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseKernelClusterInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.custom_cluster_update_api_with_http_info(cluster_name, workspace_name, **kwargs)  # noqa: E501

    def custom_cluster_update_api_with_http_info(self, cluster_name, workspace_name, **kwargs):  # noqa: E501
        """custom_cluster_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_update_api_with_http_info(cluster_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param cluster_name: (required)
        :type cluster_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param custom_cluster_update_api_payload:
        :type custom_cluster_update_api_payload: CustomClusterUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseKernelClusterInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_name',
            'workspace_name',
            'custom_cluster_update_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method custom_cluster_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_name' is set
        if self.api_client.client_side_validation and ('cluster_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_name` when calling `custom_cluster_update_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `custom_cluster_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_name' in local_var_params:
            path_params['clusterName'] = local_var_params['cluster_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'custom_cluster_update_api_payload' in local_var_params:
            body_params = local_var_params['custom_cluster_update_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseKernelClusterInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/custom_clusters/{clusterName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dataset_delete_api(self, dataset_name, workspace_name, **kwargs):  # noqa: E501
        """dataset_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_delete_api(dataset_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param dataset_name: (required)
        :type dataset_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.dataset_delete_api_with_http_info(dataset_name, workspace_name, **kwargs)  # noqa: E501

    def dataset_delete_api_with_http_info(self, dataset_name, workspace_name, **kwargs):  # noqa: E501
        """dataset_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_delete_api_with_http_info(dataset_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param dataset_name: (required)
        :type dataset_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dataset_name',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dataset_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dataset_name' is set
        if self.api_client.client_side_validation and ('dataset_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['dataset_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_name` when calling `dataset_delete_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `dataset_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dataset_name' in local_var_params:
            path_params['datasetName'] = local_var_params['dataset_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/datasets/{datasetName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dataset_list_api(self, workspace_name, **kwargs):  # noqa: E501
        """dataset_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_list_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfoList
        """
        kwargs['_return_http_data_only'] = True
        return self.dataset_list_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def dataset_list_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """dataset_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_list_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfoList, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dataset_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `dataset_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []
        if 'cursor_after_id' in local_var_params and local_var_params['cursor_after_id'] is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if 'cursor_after_value' in local_var_params and local_var_params['cursor_after_value'] is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if 'cursor_before_id' in local_var_params and local_var_params['cursor_before_id'] is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if 'cursor_before_value' in local_var_params and local_var_params['cursor_before_value'] is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if 'cursor_first' in local_var_params and local_var_params['cursor_first'] is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if 'cursor_last' in local_var_params and local_var_params['cursor_last'] is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'order_direction' in local_var_params and local_var_params['order_direction'] is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if 'order_field' in local_var_params and local_var_params['order_field'] is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if 'paginate_type' in local_var_params and local_var_params['paginate_type'] is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseDatasetInfoList",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/datasets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dataset_read_api(self, dataset_name, workspace_name, **kwargs):  # noqa: E501
        """dataset_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_read_api(dataset_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param dataset_name: (required)
        :type dataset_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.dataset_read_api_with_http_info(dataset_name, workspace_name, **kwargs)  # noqa: E501

    def dataset_read_api_with_http_info(self, dataset_name, workspace_name, **kwargs):  # noqa: E501
        """dataset_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_read_api_with_http_info(dataset_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param dataset_name: (required)
        :type dataset_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dataset_name',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dataset_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dataset_name' is set
        if self.api_client.client_side_validation and ('dataset_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['dataset_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_name` when calling `dataset_read_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `dataset_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dataset_name' in local_var_params:
            path_params['datasetName'] = local_var_params['dataset_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseDatasetInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/datasets/{datasetName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dataset_read_by_idapi(self, dataset_id, **kwargs):  # noqa: E501
        """dataset_read_by_idapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_read_by_idapi(dataset_id, async_req=True)
        >>> result = thread.get()

        :param dataset_id: (required)
        :type dataset_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.dataset_read_by_idapi_with_http_info(dataset_id, **kwargs)  # noqa: E501

    def dataset_read_by_idapi_with_http_info(self, dataset_id, **kwargs):  # noqa: E501
        """dataset_read_by_idapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_read_by_idapi_with_http_info(dataset_id, async_req=True)
        >>> result = thread.get()

        :param dataset_id: (required)
        :type dataset_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dataset_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dataset_read_by_idapi" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dataset_id' is set
        if self.api_client.client_side_validation and ('dataset_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dataset_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_id` when calling `dataset_read_by_idapi`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dataset_id' in local_var_params:
            path_params['datasetID'] = local_var_params['dataset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseDatasetInfo",
        }

        return self.api_client.call_api(
            '/api/v1/datasets/{datasetID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dataset_update_api(self, dataset_name, workspace_name, **kwargs):  # noqa: E501
        """dataset_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_update_api(dataset_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param dataset_name: (required)
        :type dataset_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param dataset_update_api_payload:
        :type dataset_update_api_payload: DatasetUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.dataset_update_api_with_http_info(dataset_name, workspace_name, **kwargs)  # noqa: E501

    def dataset_update_api_with_http_info(self, dataset_name, workspace_name, **kwargs):  # noqa: E501
        """dataset_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_update_api_with_http_info(dataset_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param dataset_name: (required)
        :type dataset_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param dataset_update_api_payload:
        :type dataset_update_api_payload: DatasetUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dataset_name',
            'workspace_name',
            'dataset_update_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dataset_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dataset_name' is set
        if self.api_client.client_side_validation and ('dataset_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['dataset_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_name` when calling `dataset_update_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `dataset_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dataset_name' in local_var_params:
            path_params['datasetName'] = local_var_params['dataset_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dataset_update_api_payload' in local_var_params:
            body_params = local_var_params['dataset_update_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseDatasetInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/datasets/{datasetName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def datasets_public_list_api(self, **kwargs):  # noqa: E501
        """datasets_public_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_public_list_api(async_req=True)
        >>> result = thread.get()

        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfoList
        """
        kwargs['_return_http_data_only'] = True
        return self.datasets_public_list_api_with_http_info(**kwargs)  # noqa: E501

    def datasets_public_list_api_with_http_info(self, **kwargs):  # noqa: E501
        """datasets_public_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_public_list_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfoList, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_public_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor_after_id' in local_var_params and local_var_params['cursor_after_id'] is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if 'cursor_after_value' in local_var_params and local_var_params['cursor_after_value'] is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if 'cursor_before_id' in local_var_params and local_var_params['cursor_before_id'] is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if 'cursor_before_value' in local_var_params and local_var_params['cursor_before_value'] is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if 'cursor_first' in local_var_params and local_var_params['cursor_first'] is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if 'cursor_last' in local_var_params and local_var_params['cursor_last'] is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'order_direction' in local_var_params and local_var_params['order_direction'] is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if 'order_field' in local_var_params and local_var_params['order_field'] is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if 'paginate_type' in local_var_params and local_var_params['paginate_type'] is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseDatasetInfoList",
        }

        return self.api_client.call_api(
            '/api/v1/datasets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_create_api(self, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_create_api(project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param experiment_create_api_payload:
        :type experiment_create_api_payload: ExperimentCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseExperimentInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_create_api_with_http_info(project_name, workspace_name, **kwargs)  # noqa: E501

    def experiment_create_api_with_http_info(self, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_create_api_with_http_info(project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param experiment_create_api_payload:
        :type experiment_create_api_payload: ExperimentCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseExperimentInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'project_name',
            'workspace_name',
            'experiment_create_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and ('project_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_create_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `experiment_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_create_api_payload' in local_var_params:
            body_params = local_var_params['experiment_create_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseExperimentInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects/{projectName}/experiments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_list_api(self, workspace_name, **kwargs):  # noqa: E501
        """experiment_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_list_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param cluster:
        :type cluster: int
        :param created_by:
        :type created_by: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param project_name:
        :type project_name: str
        :param status:
        :type status: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExperimentExperimentListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_list_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def experiment_list_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """experiment_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_list_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param cluster:
        :type cluster: int
        :param created_by:
        :type created_by: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param project_name:
        :type project_name: str
        :param status:
        :type status: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExperimentExperimentListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            'cluster',
            'created_by',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'project_name',
            'status'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `experiment_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
        if 'created_by' in local_var_params and local_var_params['created_by'] is not None:  # noqa: E501
            query_params.append(('created_by', local_var_params['created_by']))  # noqa: E501
        if 'cursor_after_id' in local_var_params and local_var_params['cursor_after_id'] is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if 'cursor_after_value' in local_var_params and local_var_params['cursor_after_value'] is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if 'cursor_before_id' in local_var_params and local_var_params['cursor_before_id'] is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if 'cursor_before_value' in local_var_params and local_var_params['cursor_before_value'] is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if 'cursor_first' in local_var_params and local_var_params['cursor_first'] is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if 'cursor_last' in local_var_params and local_var_params['cursor_last'] is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'order_direction' in local_var_params and local_var_params['order_direction'] is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if 'order_field' in local_var_params and local_var_params['order_field'] is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if 'paginate_type' in local_var_params and local_var_params['paginate_type'] is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if 'project_name' in local_var_params and local_var_params['project_name'] is not None:  # noqa: E501
            query_params.append(('projectName', local_var_params['project_name']))  # noqa: E501
        if 'status' in local_var_params and local_var_params['status'] is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501
        if 'workspace_name' in local_var_params and local_var_params['workspace_name'] is not None:  # noqa: E501
            query_params.append(('workspaceName', local_var_params['workspace_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ExperimentExperimentListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/experiments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_list_by_project_api(self, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_list_by_project_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_list_by_project_api(project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param cluster:
        :type cluster: int
        :param created_by:
        :type created_by: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param status:
        :type status: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExperimentExperimentListByProjectResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_list_by_project_api_with_http_info(project_name, workspace_name, **kwargs)  # noqa: E501

    def experiment_list_by_project_api_with_http_info(self, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_list_by_project_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_list_by_project_api_with_http_info(project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param cluster:
        :type cluster: int
        :param created_by:
        :type created_by: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param status:
        :type status: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExperimentExperimentListByProjectResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'project_name',
            'workspace_name',
            'cluster',
            'created_by',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'status'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_list_by_project_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and ('project_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_list_by_project_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `experiment_list_by_project_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
        if 'created_by' in local_var_params and local_var_params['created_by'] is not None:  # noqa: E501
            query_params.append(('created_by', local_var_params['created_by']))  # noqa: E501
        if 'cursor_after_id' in local_var_params and local_var_params['cursor_after_id'] is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if 'cursor_after_value' in local_var_params and local_var_params['cursor_after_value'] is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if 'cursor_before_id' in local_var_params and local_var_params['cursor_before_id'] is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if 'cursor_before_value' in local_var_params and local_var_params['cursor_before_value'] is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if 'cursor_first' in local_var_params and local_var_params['cursor_first'] is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if 'cursor_last' in local_var_params and local_var_params['cursor_last'] is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'order_direction' in local_var_params and local_var_params['order_direction'] is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if 'order_field' in local_var_params and local_var_params['order_field'] is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if 'paginate_type' in local_var_params and local_var_params['paginate_type'] is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if 'status' in local_var_params and local_var_params['status'] is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ExperimentExperimentListByProjectResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects/{projectName}/experiments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_log_api(self, experiment, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_log_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_log_api(experiment, project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param experiment: (required)
        :type experiment: str
        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param with_event_log:
        :type with_event_log: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExperimentExperimentLogResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_log_api_with_http_info(experiment, project_name, workspace_name, **kwargs)  # noqa: E501

    def experiment_log_api_with_http_info(self, experiment, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_log_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_log_api_with_http_info(experiment, project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param experiment: (required)
        :type experiment: str
        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param with_event_log:
        :type with_event_log: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExperimentExperimentLogResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment',
            'project_name',
            'workspace_name',
            'after',
            'before',
            'limit',
            'with_event_log'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_log_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment' is set
        if self.api_client.client_side_validation and ('experiment' not in local_var_params or  # noqa: E501
                                                        local_var_params['experiment'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment` when calling `experiment_log_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and ('project_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_log_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `experiment_log_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment' in local_var_params:
            path_params['experiment'] = local_var_params['experiment']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'before' in local_var_params and local_var_params['before'] is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'with_event_log' in local_var_params and local_var_params['with_event_log'] is not None:  # noqa: E501
            query_params.append(('withEventLog', local_var_params['with_event_log']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ExperimentExperimentLogResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects/{projectName}/experiments/{experiment}/log', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_metrics_api(self, experiment, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_metrics_api(experiment, project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param experiment: (required)
        :type experiment: str
        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExperimentExperimentMetricsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_metrics_api_with_http_info(experiment, project_name, workspace_name, **kwargs)  # noqa: E501

    def experiment_metrics_api_with_http_info(self, experiment, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_metrics_api_with_http_info(experiment, project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param experiment: (required)
        :type experiment: str
        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExperimentExperimentMetricsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment',
            'project_name',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment' is set
        if self.api_client.client_side_validation and ('experiment' not in local_var_params or  # noqa: E501
                                                        local_var_params['experiment'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment` when calling `experiment_metrics_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and ('project_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_metrics_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `experiment_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment' in local_var_params:
            path_params['experiment'] = local_var_params['experiment']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ExperimentExperimentMetricsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects/{projectName}/experiments/{experiment}/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_parameter_list_api(self, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_parameter_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_parameter_list_api(project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExperimentExperimentParameterListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_parameter_list_api_with_http_info(project_name, workspace_name, **kwargs)  # noqa: E501

    def experiment_parameter_list_api_with_http_info(self, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_parameter_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_parameter_list_api_with_http_info(project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExperimentExperimentParameterListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'project_name',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_parameter_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and ('project_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_parameter_list_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `experiment_parameter_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ExperimentExperimentParameterListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects/{projectName}/experiment_parameters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_read_api(self, experiment, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_read_api(experiment, project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param experiment: (required)
        :type experiment: str
        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseExperimentInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_read_api_with_http_info(experiment, project_name, workspace_name, **kwargs)  # noqa: E501

    def experiment_read_api_with_http_info(self, experiment, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_read_api_with_http_info(experiment, project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param experiment: (required)
        :type experiment: str
        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseExperimentInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment',
            'project_name',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment' is set
        if self.api_client.client_side_validation and ('experiment' not in local_var_params or  # noqa: E501
                                                        local_var_params['experiment'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment` when calling `experiment_read_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and ('project_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_read_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `experiment_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment' in local_var_params:
            path_params['experiment'] = local_var_params['experiment']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseExperimentInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects/{projectName}/experiments/{experiment}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_read_by_idapi(self, experiment_id, **kwargs):  # noqa: E501
        """experiment_read_by_idapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_read_by_idapi(experiment_id, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseExperimentInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_read_by_idapi_with_http_info(experiment_id, **kwargs)  # noqa: E501

    def experiment_read_by_idapi_with_http_info(self, experiment_id, **kwargs):  # noqa: E501
        """experiment_read_by_idapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_read_by_idapi_with_http_info(experiment_id, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseExperimentInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_read_by_idapi" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_id' is set
        if self.api_client.client_side_validation and ('experiment_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['experiment_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_id` when calling `experiment_read_by_idapi`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_id' in local_var_params:
            path_params['experimentID'] = local_var_params['experiment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseExperimentInfo",
        }

        return self.api_client.call_api(
            '/api/v1/experiments/{experimentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_stop_api(self, experiment, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_stop_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_stop_api(experiment, project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param experiment: (required)
        :type experiment: str
        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseExperiment
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_stop_api_with_http_info(experiment, project_name, workspace_name, **kwargs)  # noqa: E501

    def experiment_stop_api_with_http_info(self, experiment, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_stop_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_stop_api_with_http_info(experiment, project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param experiment: (required)
        :type experiment: str
        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseExperiment, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment',
            'project_name',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_stop_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment' is set
        if self.api_client.client_side_validation and ('experiment' not in local_var_params or  # noqa: E501
                                                        local_var_params['experiment'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment` when calling `experiment_stop_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and ('project_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_stop_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `experiment_stop_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment' in local_var_params:
            path_params['experiment'] = local_var_params['experiment']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseExperiment",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects/{projectName}/experiments/{experiment}/stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_system_metrics_api(self, experiment, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_system_metrics_api(experiment, project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param experiment: (required)
        :type experiment: str
        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param metrics:
        :type metrics: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExperimentExperimentSystemMetricsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_system_metrics_api_with_http_info(experiment, project_name, workspace_name, **kwargs)  # noqa: E501

    def experiment_system_metrics_api_with_http_info(self, experiment, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_system_metrics_api_with_http_info(experiment, project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param experiment: (required)
        :type experiment: str
        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param metrics:
        :type metrics: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExperimentExperimentSystemMetricsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment',
            'project_name',
            'workspace_name',
            'after',
            'before',
            'limit',
            'metrics'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_system_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment' is set
        if self.api_client.client_side_validation and ('experiment' not in local_var_params or  # noqa: E501
                                                        local_var_params['experiment'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment` when calling `experiment_system_metrics_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and ('project_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_system_metrics_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `experiment_system_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment' in local_var_params:
            path_params['experiment'] = local_var_params['experiment']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'before' in local_var_params and local_var_params['before'] is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'metrics' in local_var_params and local_var_params['metrics'] is not None:  # noqa: E501
            query_params.append(('metrics', local_var_params['metrics']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ExperimentExperimentSystemMetricsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects/{projectName}/experiments/{experiment}/system_metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_update_api(self, experiment, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_update_api(experiment, project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param experiment: (required)
        :type experiment: str
        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param experiment_update_api_payload:
        :type experiment_update_api_payload: ExperimentUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseExperiment
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_update_api_with_http_info(experiment, project_name, workspace_name, **kwargs)  # noqa: E501

    def experiment_update_api_with_http_info(self, experiment, project_name, workspace_name, **kwargs):  # noqa: E501
        """experiment_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_update_api_with_http_info(experiment, project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param experiment: (required)
        :type experiment: str
        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param experiment_update_api_payload:
        :type experiment_update_api_payload: ExperimentUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseExperiment, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment',
            'project_name',
            'workspace_name',
            'experiment_update_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment' is set
        if self.api_client.client_side_validation and ('experiment' not in local_var_params or  # noqa: E501
                                                        local_var_params['experiment'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment` when calling `experiment_update_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and ('project_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_update_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `experiment_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment' in local_var_params:
            path_params['experiment'] = local_var_params['experiment']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_update_api_payload' in local_var_params:
            body_params = local_var_params['experiment_update_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseExperiment",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects/{projectName}/experiments/{experiment}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def g_s_dataset_create_api(self, workspace_name, **kwargs):  # noqa: E501
        """g_s_dataset_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.g_s_dataset_create_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param gs_dataset_create_api_payload:
        :type gs_dataset_create_api_payload: GSDatasetCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.g_s_dataset_create_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def g_s_dataset_create_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """g_s_dataset_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.g_s_dataset_create_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param gs_dataset_create_api_payload:
        :type gs_dataset_create_api_payload: GSDatasetCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            'gs_dataset_create_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_s_dataset_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `g_s_dataset_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'gs_dataset_create_api_payload' in local_var_params:
            body_params = local_var_params['gs_dataset_create_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseDatasetInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/datasets_gs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_my_user_info_api(self, **kwargs):  # noqa: E501
        """get_my_user_info_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_my_user_info_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseMyUser
        """
        kwargs['_return_http_data_only'] = True
        return self.get_my_user_info_api_with_http_info(**kwargs)  # noqa: E501

    def get_my_user_info_api_with_http_info(self, **kwargs):  # noqa: E501
        """get_my_user_info_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_my_user_info_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseMyUser, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_my_user_info_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseMyUser",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/me', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def git_hub_authorize_api(self, **kwargs):  # noqa: E501
        """git_hub_authorize_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_hub_authorize_api(async_req=True)
        >>> result = thread.get()

        :param git_hub_authorize_api_payload:
        :type git_hub_authorize_api_payload: GitHubAuthorizeAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.git_hub_authorize_api_with_http_info(**kwargs)  # noqa: E501

    def git_hub_authorize_api_with_http_info(self, **kwargs):  # noqa: E501
        """git_hub_authorize_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_hub_authorize_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param git_hub_authorize_api_payload:
        :type git_hub_authorize_api_payload: GitHubAuthorizeAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'git_hub_authorize_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method git_hub_authorize_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'git_hub_authorize_api_payload' in local_var_params:
            body_params = local_var_params['git_hub_authorize_api_payload']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/github/authorize', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def git_hub_config_api(self, **kwargs):  # noqa: E501
        """git_hub_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_hub_config_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExternalGitHubConfigResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.git_hub_config_api_with_http_info(**kwargs)  # noqa: E501

    def git_hub_config_api_with_http_info(self, **kwargs):  # noqa: E501
        """git_hub_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_hub_config_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExternalGitHubConfigResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method git_hub_config_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ExternalGitHubConfigResponse",
        }

        return self.api_client.call_api(
            '/api/v1/github/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def git_hub_repository_list_api(self, **kwargs):  # noqa: E501
        """git_hub_repository_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_hub_repository_list_api(async_req=True)
        >>> result = thread.get()

        :param page:
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExternalGitHubRepositoryListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.git_hub_repository_list_api_with_http_info(**kwargs)  # noqa: E501

    def git_hub_repository_list_api_with_http_info(self, **kwargs):  # noqa: E501
        """git_hub_repository_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_hub_repository_list_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param page:
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExternalGitHubRepositoryListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'page'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method git_hub_repository_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in local_var_params and local_var_params['page'] is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ExternalGitHubRepositoryListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/github/repositories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def google_config_api(self, **kwargs):  # noqa: E501
        """google_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.google_config_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExternalGoogleConfigResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.google_config_api_with_http_info(**kwargs)  # noqa: E501

    def google_config_api_with_http_info(self, **kwargs):  # noqa: E501
        """google_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.google_config_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExternalGoogleConfigResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method google_config_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ExternalGoogleConfigResponse",
        }

        return self.api_client.call_api(
            '/api/v1/google/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def invitation_token_validate_api(self, **kwargs):  # noqa: E501
        """invitation_token_validate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.invitation_token_validate_api(async_req=True)
        >>> result = thread.get()

        :param invitation_token_validate_api_payload:
        :type invitation_token_validate_api_payload: InvitationTokenValidateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AccountInvitationTokenValidateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.invitation_token_validate_api_with_http_info(**kwargs)  # noqa: E501

    def invitation_token_validate_api_with_http_info(self, **kwargs):  # noqa: E501
        """invitation_token_validate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.invitation_token_validate_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param invitation_token_validate_api_payload:
        :type invitation_token_validate_api_payload: InvitationTokenValidateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AccountInvitationTokenValidateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'invitation_token_validate_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method invitation_token_validate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'invitation_token_validate_api_payload' in local_var_params:
            body_params = local_var_params['invitation_token_validate_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "AccountInvitationTokenValidateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/invitation_token/validate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def kernel_image_list_api(self, workspace_name, **kwargs):  # noqa: E501
        """kernel_image_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_image_list_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param execute_type:
        :type execute_type: str
        :param resource_id:
        :type resource_id: int
        :param savvihub_managed:
        :type savvihub_managed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: KernelKernelImageListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.kernel_image_list_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def kernel_image_list_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """kernel_image_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_image_list_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param execute_type:
        :type execute_type: str
        :param resource_id:
        :type resource_id: int
        :param savvihub_managed:
        :type savvihub_managed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(KernelKernelImageListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            'execute_type',
            'resource_id',
            'savvihub_managed'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method kernel_image_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `kernel_image_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []
        if 'execute_type' in local_var_params and local_var_params['execute_type'] is not None:  # noqa: E501
            query_params.append(('execute_type', local_var_params['execute_type']))  # noqa: E501
        if 'resource_id' in local_var_params and local_var_params['resource_id'] is not None:  # noqa: E501
            query_params.append(('resource_id', local_var_params['resource_id']))  # noqa: E501
        if 'savvihub_managed' in local_var_params and local_var_params['savvihub_managed'] is not None:  # noqa: E501
            query_params.append(('savvihub_managed', local_var_params['savvihub_managed']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "KernelKernelImageListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/kernels/images', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def kernel_image_read_api(self, image_id, **kwargs):  # noqa: E501
        """kernel_image_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_image_read_api(image_id, async_req=True)
        >>> result = thread.get()

        :param image_id: (required)
        :type image_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseKernelImage
        """
        kwargs['_return_http_data_only'] = True
        return self.kernel_image_read_api_with_http_info(image_id, **kwargs)  # noqa: E501

    def kernel_image_read_api_with_http_info(self, image_id, **kwargs):  # noqa: E501
        """kernel_image_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_image_read_api_with_http_info(image_id, async_req=True)
        >>> result = thread.get()

        :param image_id: (required)
        :type image_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseKernelImage, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'image_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method kernel_image_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'image_id' is set
        if self.api_client.client_side_validation and ('image_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['image_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `image_id` when calling `kernel_image_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'image_id' in local_var_params:
            path_params['imageID'] = local_var_params['image_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseKernelImage",
        }

        return self.api_client.call_api(
            '/api/v1/kernels_images/{imageID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def kernel_resource_spec_list_api(self, workspace_name, **kwargs):  # noqa: E501
        """kernel_resource_spec_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_resource_spec_list_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: KernelKernelResourceSpecListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.kernel_resource_spec_list_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def kernel_resource_spec_list_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """kernel_resource_spec_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_resource_spec_list_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(KernelKernelResourceSpecListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method kernel_resource_spec_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `kernel_resource_spec_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "KernelKernelResourceSpecListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/kernels/resource_specs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def ping_api(self, **kwargs):  # noqa: E501
        """ping_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.ping_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.ping_api_with_http_info(**kwargs)  # noqa: E501

    def ping_api_with_http_info(self, **kwargs):  # noqa: E501
        """ping_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.ping_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ping_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "str",
        }

        return self.api_client.call_api(
            '/api/v1/ping', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_branch_list_api(self, project_name, workspace_name, **kwargs):  # noqa: E501
        """project_branch_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_branch_list_api(project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param page:
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProjectProjectBranchListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.project_branch_list_api_with_http_info(project_name, workspace_name, **kwargs)  # noqa: E501

    def project_branch_list_api_with_http_info(self, project_name, workspace_name, **kwargs):  # noqa: E501
        """project_branch_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_branch_list_api_with_http_info(project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param page:
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProjectProjectBranchListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'project_name',
            'workspace_name',
            'page'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_branch_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and ('project_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_branch_list_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `project_branch_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []
        if 'page' in local_var_params and local_var_params['page'] is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ProjectProjectBranchListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects/{projectName}/branches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_commit_list_api(self, branch, project_name, workspace_name, **kwargs):  # noqa: E501
        """project_commit_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_commit_list_api(branch, project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param branch: (required)
        :type branch: str
        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param page:
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProjectProjectCommitListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.project_commit_list_api_with_http_info(branch, project_name, workspace_name, **kwargs)  # noqa: E501

    def project_commit_list_api_with_http_info(self, branch, project_name, workspace_name, **kwargs):  # noqa: E501
        """project_commit_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_commit_list_api_with_http_info(branch, project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param branch: (required)
        :type branch: str
        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param page:
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProjectProjectCommitListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'branch',
            'project_name',
            'workspace_name',
            'page'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_commit_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'branch' is set
        if self.api_client.client_side_validation and ('branch' not in local_var_params or  # noqa: E501
                                                        local_var_params['branch'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `branch` when calling `project_commit_list_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and ('project_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_commit_list_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `project_commit_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'branch' in local_var_params:
            path_params['branch'] = local_var_params['branch']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []
        if 'page' in local_var_params and local_var_params['page'] is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ProjectProjectCommitListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects/{projectName}/branches/{branch}/commits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_commit_read_api(self, project_name, sha, workspace_name, **kwargs):  # noqa: E501
        """project_commit_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_commit_read_api(project_name, sha, workspace_name, async_req=True)
        >>> result = thread.get()

        :param project_name: (required)
        :type project_name: str
        :param sha: (required)
        :type sha: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProtoCommit
        """
        kwargs['_return_http_data_only'] = True
        return self.project_commit_read_api_with_http_info(project_name, sha, workspace_name, **kwargs)  # noqa: E501

    def project_commit_read_api_with_http_info(self, project_name, sha, workspace_name, **kwargs):  # noqa: E501
        """project_commit_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_commit_read_api_with_http_info(project_name, sha, workspace_name, async_req=True)
        >>> result = thread.get()

        :param project_name: (required)
        :type project_name: str
        :param sha: (required)
        :type sha: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProtoCommit, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'project_name',
            'sha',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_commit_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and ('project_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_commit_read_api`")  # noqa: E501
        # verify the required parameter 'sha' is set
        if self.api_client.client_side_validation and ('sha' not in local_var_params or  # noqa: E501
                                                        local_var_params['sha'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sha` when calling `project_commit_read_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `project_commit_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'sha' in local_var_params:
            path_params['sha'] = local_var_params['sha']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ProtoCommit",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects/{projectName}/commits/{sha}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_create_api(self, workspace_name, **kwargs):  # noqa: E501
        """project_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_create_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param project_create_api_payload:
        :type project_create_api_payload: ProjectCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseProjectInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.project_create_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def project_create_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """project_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_create_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param project_create_api_payload:
        :type project_create_api_payload: ProjectCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseProjectInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            'project_create_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `project_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_create_api_payload' in local_var_params:
            body_params = local_var_params['project_create_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseProjectInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_git_hub_create_api(self, workspace_name, **kwargs):  # noqa: E501
        """project_git_hub_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_git_hub_create_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param project_git_hub_create_api_payload:
        :type project_git_hub_create_api_payload: ProjectGitHubCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseProjectInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.project_git_hub_create_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def project_git_hub_create_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """project_git_hub_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_git_hub_create_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param project_git_hub_create_api_payload:
        :type project_git_hub_create_api_payload: ProjectGitHubCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseProjectInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            'project_git_hub_create_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_git_hub_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `project_git_hub_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_git_hub_create_api_payload' in local_var_params:
            body_params = local_var_params['project_git_hub_create_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseProjectInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects_github', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_list_api(self, workspace_name, **kwargs):  # noqa: E501
        """project_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_list_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseProjectListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.project_list_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def project_list_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """project_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_list_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseProjectListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `project_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []
        if 'cursor_after_id' in local_var_params and local_var_params['cursor_after_id'] is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if 'cursor_after_value' in local_var_params and local_var_params['cursor_after_value'] is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if 'cursor_before_id' in local_var_params and local_var_params['cursor_before_id'] is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if 'cursor_before_value' in local_var_params and local_var_params['cursor_before_value'] is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if 'cursor_first' in local_var_params and local_var_params['cursor_first'] is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if 'cursor_last' in local_var_params and local_var_params['cursor_last'] is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'order_direction' in local_var_params and local_var_params['order_direction'] is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if 'order_field' in local_var_params and local_var_params['order_field'] is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if 'paginate_type' in local_var_params and local_var_params['paginate_type'] is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseProjectListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_read_api(self, project_name, workspace_name, **kwargs):  # noqa: E501
        """project_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_read_api(project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseProjectInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.project_read_api_with_http_info(project_name, workspace_name, **kwargs)  # noqa: E501

    def project_read_api_with_http_info(self, project_name, workspace_name, **kwargs):  # noqa: E501
        """project_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_read_api_with_http_info(project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseProjectInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'project_name',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and ('project_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_read_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `project_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseProjectInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects/{projectName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_read_by_idapi(self, project_id, **kwargs):  # noqa: E501
        """project_read_by_idapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_read_by_idapi(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseProjectInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.project_read_by_idapi_with_http_info(project_id, **kwargs)  # noqa: E501

    def project_read_by_idapi_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """project_read_by_idapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_read_by_idapi_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseProjectInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_read_by_idapi" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `project_read_by_idapi`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectID'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseProjectInfo",
        }

        return self.api_client.call_api(
            '/api/v1/projects/{projectID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_update_api(self, project_name, workspace_name, **kwargs):  # noqa: E501
        """project_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_update_api(project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param project_update_api_payload:
        :type project_update_api_payload: ProjectUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseProjectInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.project_update_api_with_http_info(project_name, workspace_name, **kwargs)  # noqa: E501

    def project_update_api_with_http_info(self, project_name, workspace_name, **kwargs):  # noqa: E501
        """project_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_update_api_with_http_info(project_name, workspace_name, async_req=True)
        >>> result = thread.get()

        :param project_name: (required)
        :type project_name: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param project_update_api_payload:
        :type project_update_api_payload: ProjectUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseProjectInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'project_name',
            'workspace_name',
            'project_update_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and ('project_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_update_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `project_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_update_api_payload' in local_var_params:
            body_params = local_var_params['project_update_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseProjectInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/projects/{projectName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def region_list_api(self, **kwargs):  # noqa: E501
        """region_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.region_list_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AccountRegionListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.region_list_api_with_http_info(**kwargs)  # noqa: E501

    def region_list_api_with_http_info(self, **kwargs):  # noqa: E501
        """region_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.region_list_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AccountRegionListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method region_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "AccountRegionListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/regions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def s3_dataset_create_api(self, workspace_name, **kwargs):  # noqa: E501
        """s3_dataset_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.s3_dataset_create_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param s3_dataset_create_api_payload:
        :type s3_dataset_create_api_payload: S3DatasetCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.s3_dataset_create_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def s3_dataset_create_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """s3_dataset_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.s3_dataset_create_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param s3_dataset_create_api_payload:
        :type s3_dataset_create_api_payload: S3DatasetCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            's3_dataset_create_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method s3_dataset_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `s3_dataset_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 's3_dataset_create_api_payload' in local_var_params:
            body_params = local_var_params['s3_dataset_create_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseDatasetInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/datasets_s3', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def savvi_hub_dataset_create_api(self, workspace_name, **kwargs):  # noqa: E501
        """savvi_hub_dataset_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.savvi_hub_dataset_create_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param savvi_hub_dataset_create_api_payload:
        :type savvi_hub_dataset_create_api_payload: SavviHubDatasetCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.savvi_hub_dataset_create_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def savvi_hub_dataset_create_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """savvi_hub_dataset_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.savvi_hub_dataset_create_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param savvi_hub_dataset_create_api_payload:
        :type savvi_hub_dataset_create_api_payload: SavviHubDatasetCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            'savvi_hub_dataset_create_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method savvi_hub_dataset_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `savvi_hub_dataset_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'savvi_hub_dataset_create_api_payload' in local_var_params:
            body_params = local_var_params['savvi_hub_dataset_create_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseDatasetInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/datasets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def send_verify_email_api(self, **kwargs):  # noqa: E501
        """send_verify_email_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.send_verify_email_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.send_verify_email_api_with_http_info(**kwargs)  # noqa: E501

    def send_verify_email_api_with_http_info(self, **kwargs):  # noqa: E501
        """send_verify_email_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.send_verify_email_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method send_verify_email_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/verify_email/send', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def service_access_update_api(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_access_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_access_update_api(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseServiceInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.service_access_update_api_with_http_info(service, workspace_name, **kwargs)  # noqa: E501

    def service_access_update_api_with_http_info(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_access_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_access_update_api_with_http_info(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseServiceInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'service',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_access_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service' is set
        if self.api_client.client_side_validation and ('service' not in local_var_params or  # noqa: E501
                                                        local_var_params['service'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service` when calling `service_access_update_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `service_access_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service' in local_var_params:
            path_params['service'] = local_var_params['service']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseServiceInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/services/{service}/access', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def service_config_update_api(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_config_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_config_update_api(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param service_config_update_api_payload:
        :type service_config_update_api_payload: ServiceConfigUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseServiceInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.service_config_update_api_with_http_info(service, workspace_name, **kwargs)  # noqa: E501

    def service_config_update_api_with_http_info(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_config_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_config_update_api_with_http_info(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param service_config_update_api_payload:
        :type service_config_update_api_payload: ServiceConfigUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseServiceInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'service',
            'workspace_name',
            'service_config_update_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_config_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service' is set
        if self.api_client.client_side_validation and ('service' not in local_var_params or  # noqa: E501
                                                        local_var_params['service'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service` when calling `service_config_update_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `service_config_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service' in local_var_params:
            path_params['service'] = local_var_params['service']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'service_config_update_api_payload' in local_var_params:
            body_params = local_var_params['service_config_update_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseServiceInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/services/{service}/config', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def service_create_api(self, workspace_name, **kwargs):  # noqa: E501
        """service_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_create_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param service_create_api_payload:
        :type service_create_api_payload: ServiceCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseServiceInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.service_create_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def service_create_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """service_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_create_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param service_create_api_payload:
        :type service_create_api_payload: ServiceCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseServiceInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            'service_create_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `service_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'service_create_api_payload' in local_var_params:
            body_params = local_var_params['service_create_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseServiceInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/services', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def service_list_api(self, workspace_name, **kwargs):  # noqa: E501
        """service_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_list_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param cluster:
        :type cluster: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param live_or_term_after:
        :type live_or_term_after: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param project_name:
        :type project_name: str
        :param service_type:
        :type service_type: str
        :param status:
        :type status: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ServiceServiceListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.service_list_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def service_list_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """service_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_list_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param cluster:
        :type cluster: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param live_or_term_after:
        :type live_or_term_after: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param project_name:
        :type project_name: str
        :param service_type:
        :type service_type: str
        :param status:
        :type status: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ServiceServiceListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            'cluster',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'live_or_term_after',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'project_name',
            'service_type',
            'status'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `service_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
        if 'cursor_after_id' in local_var_params and local_var_params['cursor_after_id'] is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if 'cursor_after_value' in local_var_params and local_var_params['cursor_after_value'] is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if 'cursor_before_id' in local_var_params and local_var_params['cursor_before_id'] is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if 'cursor_before_value' in local_var_params and local_var_params['cursor_before_value'] is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if 'cursor_first' in local_var_params and local_var_params['cursor_first'] is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if 'cursor_last' in local_var_params and local_var_params['cursor_last'] is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'live_or_term_after' in local_var_params and local_var_params['live_or_term_after'] is not None:  # noqa: E501
            query_params.append(('live_or_term_after', local_var_params['live_or_term_after']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'order_direction' in local_var_params and local_var_params['order_direction'] is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if 'order_field' in local_var_params and local_var_params['order_field'] is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if 'paginate_type' in local_var_params and local_var_params['paginate_type'] is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if 'project_name' in local_var_params and local_var_params['project_name'] is not None:  # noqa: E501
            query_params.append(('projectName', local_var_params['project_name']))  # noqa: E501
        if 'service_type' in local_var_params and local_var_params['service_type'] is not None:  # noqa: E501
            query_params.append(('serviceType', local_var_params['service_type']))  # noqa: E501
        if 'status' in local_var_params and local_var_params['status'] is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ServiceServiceListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def service_log_api(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_log_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_log_api(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ServiceServiceLogResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.service_log_api_with_http_info(service, workspace_name, **kwargs)  # noqa: E501

    def service_log_api_with_http_info(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_log_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_log_api_with_http_info(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ServiceServiceLogResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'service',
            'workspace_name',
            'after',
            'before',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_log_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service' is set
        if self.api_client.client_side_validation and ('service' not in local_var_params or  # noqa: E501
                                                        local_var_params['service'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service` when calling `service_log_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `service_log_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service' in local_var_params:
            path_params['service'] = local_var_params['service']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'before' in local_var_params and local_var_params['before'] is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ServiceServiceLogResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/services/{service}/log', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def service_name_update_api(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_name_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_name_update_api(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param service_name_update_api_payload:
        :type service_name_update_api_payload: ServiceNameUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseServiceInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.service_name_update_api_with_http_info(service, workspace_name, **kwargs)  # noqa: E501

    def service_name_update_api_with_http_info(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_name_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_name_update_api_with_http_info(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param service_name_update_api_payload:
        :type service_name_update_api_payload: ServiceNameUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseServiceInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'service',
            'workspace_name',
            'service_name_update_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_name_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service' is set
        if self.api_client.client_side_validation and ('service' not in local_var_params or  # noqa: E501
                                                        local_var_params['service'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service` when calling `service_name_update_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `service_name_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service' in local_var_params:
            path_params['service'] = local_var_params['service']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'service_name_update_api_payload' in local_var_params:
            body_params = local_var_params['service_name_update_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseServiceInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/services/{service}/name', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def service_read_api(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_read_api(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseServiceInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.service_read_api_with_http_info(service, workspace_name, **kwargs)  # noqa: E501

    def service_read_api_with_http_info(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_read_api_with_http_info(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseServiceInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'service',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service' is set
        if self.api_client.client_side_validation and ('service' not in local_var_params or  # noqa: E501
                                                        local_var_params['service'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service` when calling `service_read_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `service_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service' in local_var_params:
            path_params['service'] = local_var_params['service']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseServiceInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/services/{service}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def service_resource_spec_update_api(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_resource_spec_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_resource_spec_update_api(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param service_resource_spec_update_api_payload:
        :type service_resource_spec_update_api_payload: ServiceResourceSpecUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseServiceInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.service_resource_spec_update_api_with_http_info(service, workspace_name, **kwargs)  # noqa: E501

    def service_resource_spec_update_api_with_http_info(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_resource_spec_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_resource_spec_update_api_with_http_info(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param service_resource_spec_update_api_payload:
        :type service_resource_spec_update_api_payload: ServiceResourceSpecUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseServiceInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'service',
            'workspace_name',
            'service_resource_spec_update_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_resource_spec_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service' is set
        if self.api_client.client_side_validation and ('service' not in local_var_params or  # noqa: E501
                                                        local_var_params['service'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service` when calling `service_resource_spec_update_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `service_resource_spec_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service' in local_var_params:
            path_params['service'] = local_var_params['service']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'service_resource_spec_update_api_payload' in local_var_params:
            body_params = local_var_params['service_resource_spec_update_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseServiceInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/services/{service}/resource_spec', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def service_start_api(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_start_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_start_api(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseServiceInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.service_start_api_with_http_info(service, workspace_name, **kwargs)  # noqa: E501

    def service_start_api_with_http_info(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_start_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_start_api_with_http_info(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseServiceInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'service',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_start_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service' is set
        if self.api_client.client_side_validation and ('service' not in local_var_params or  # noqa: E501
                                                        local_var_params['service'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service` when calling `service_start_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `service_start_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service' in local_var_params:
            path_params['service'] = local_var_params['service']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseServiceInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/services/{service}/start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def service_stop_api(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_stop_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_stop_api(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseServiceInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.service_stop_api_with_http_info(service, workspace_name, **kwargs)  # noqa: E501

    def service_stop_api_with_http_info(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_stop_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_stop_api_with_http_info(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseServiceInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'service',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_stop_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service' is set
        if self.api_client.client_side_validation and ('service' not in local_var_params or  # noqa: E501
                                                        local_var_params['service'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service` when calling `service_stop_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `service_stop_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service' in local_var_params:
            path_params['service'] = local_var_params['service']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseServiceInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/services/{service}/stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def service_system_metrics_api(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_system_metrics_api(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param metrics:
        :type metrics: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ServiceServiceSystemMetricsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.service_system_metrics_api_with_http_info(service, workspace_name, **kwargs)  # noqa: E501

    def service_system_metrics_api_with_http_info(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_system_metrics_api_with_http_info(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param metrics:
        :type metrics: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ServiceServiceSystemMetricsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'service',
            'workspace_name',
            'after',
            'before',
            'limit',
            'metrics'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_system_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service' is set
        if self.api_client.client_side_validation and ('service' not in local_var_params or  # noqa: E501
                                                        local_var_params['service'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service` when calling `service_system_metrics_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `service_system_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service' in local_var_params:
            path_params['service'] = local_var_params['service']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'before' in local_var_params and local_var_params['before'] is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'metrics' in local_var_params and local_var_params['metrics'] is not None:  # noqa: E501
            query_params.append(('metrics', local_var_params['metrics']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ServiceServiceSystemMetricsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/services/{service}/system_metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def service_template_list_api(self, workspace_name, service_type, **kwargs):  # noqa: E501
        """service_template_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_template_list_api(workspace_name, service_type, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param service_type: (required)
        :type service_type: str
        :param savvihub_managed:
        :type savvihub_managed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ServiceServiceTemplateListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.service_template_list_api_with_http_info(workspace_name, service_type, **kwargs)  # noqa: E501

    def service_template_list_api_with_http_info(self, workspace_name, service_type, **kwargs):  # noqa: E501
        """service_template_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_template_list_api_with_http_info(workspace_name, service_type, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param service_type: (required)
        :type service_type: str
        :param savvihub_managed:
        :type savvihub_managed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ServiceServiceTemplateListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            'service_type',
            'savvihub_managed'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_template_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `service_template_list_api`")  # noqa: E501
        # verify the required parameter 'service_type' is set
        if self.api_client.client_side_validation and ('service_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_type` when calling `service_template_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []
        if 'savvihub_managed' in local_var_params and local_var_params['savvihub_managed'] is not None:  # noqa: E501
            query_params.append(('savvihub_managed', local_var_params['savvihub_managed']))  # noqa: E501
        if 'service_type' in local_var_params and local_var_params['service_type'] is not None:  # noqa: E501
            query_params.append(('service_type', local_var_params['service_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ServiceServiceTemplateListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/service_templates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def service_template_read_api(self, template_id, workspace_name, **kwargs):  # noqa: E501
        """service_template_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_template_read_api(template_id, workspace_name, async_req=True)
        >>> result = thread.get()

        :param template_id: (required)
        :type template_id: int
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseServiceTemplateInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.service_template_read_api_with_http_info(template_id, workspace_name, **kwargs)  # noqa: E501

    def service_template_read_api_with_http_info(self, template_id, workspace_name, **kwargs):  # noqa: E501
        """service_template_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_template_read_api_with_http_info(template_id, workspace_name, async_req=True)
        >>> result = thread.get()

        :param template_id: (required)
        :type template_id: int
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseServiceTemplateInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'template_id',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_template_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `service_template_read_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `service_template_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['templateID'] = local_var_params['template_id']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseServiceTemplateInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/service_templates/{templateID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def service_terminate_api(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_terminate_api(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseServiceInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.service_terminate_api_with_http_info(service, workspace_name, **kwargs)  # noqa: E501

    def service_terminate_api_with_http_info(self, service, workspace_name, **kwargs):  # noqa: E501
        """service_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_terminate_api_with_http_info(service, workspace_name, async_req=True)
        >>> result = thread.get()

        :param service: (required)
        :type service: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseServiceInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'service',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_terminate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service' is set
        if self.api_client.client_side_validation and ('service' not in local_var_params or  # noqa: E501
                                                        local_var_params['service'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service` when calling `service_terminate_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `service_terminate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service' in local_var_params:
            path_params['service'] = local_var_params['service']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseServiceInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/services/{service}/terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_in_api(self, **kwargs):  # noqa: E501
        """sign_in_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_api(async_req=True)
        >>> result = thread.get()

        :param sign_in_api_payload:
        :type sign_in_api_payload: SignInAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseUserWithTokenResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_in_api_with_http_info(**kwargs)  # noqa: E501

    def sign_in_api_with_http_info(self, **kwargs):  # noqa: E501
        """sign_in_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param sign_in_api_payload:
        :type sign_in_api_payload: SignInAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseUserWithTokenResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'sign_in_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_in_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign_in_api_payload' in local_var_params:
            body_params = local_var_params['sign_in_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseUserWithTokenResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/signin', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_in_cli_check_api(self, cli_token, **kwargs):  # noqa: E501
        """sign_in_cli_check_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_cli_check_api(cli_token, async_req=True)
        >>> result = thread.get()

        :param cli_token: (required)
        :type cli_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AccountSignInCliCheckResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_in_cli_check_api_with_http_info(cli_token, **kwargs)  # noqa: E501

    def sign_in_cli_check_api_with_http_info(self, cli_token, **kwargs):  # noqa: E501
        """sign_in_cli_check_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_cli_check_api_with_http_info(cli_token, async_req=True)
        >>> result = thread.get()

        :param cli_token: (required)
        :type cli_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AccountSignInCliCheckResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cli_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_in_cli_check_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cli_token' is set
        if self.api_client.client_side_validation and ('cli_token' not in local_var_params or  # noqa: E501
                                                        local_var_params['cli_token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cli_token` when calling `sign_in_cli_check_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cli_token' in local_var_params and local_var_params['cli_token'] is not None:  # noqa: E501
            query_params.append(('cli_token', local_var_params['cli_token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "AccountSignInCliCheckResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/signin/cli/check', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_in_cli_confirm_api(self, **kwargs):  # noqa: E501
        """sign_in_cli_confirm_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_cli_confirm_api(async_req=True)
        >>> result = thread.get()

        :param sign_in_cli_confirm_api_payload:
        :type sign_in_cli_confirm_api_payload: SignInCliConfirmAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_in_cli_confirm_api_with_http_info(**kwargs)  # noqa: E501

    def sign_in_cli_confirm_api_with_http_info(self, **kwargs):  # noqa: E501
        """sign_in_cli_confirm_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_cli_confirm_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param sign_in_cli_confirm_api_payload:
        :type sign_in_cli_confirm_api_payload: SignInCliConfirmAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'sign_in_cli_confirm_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_in_cli_confirm_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign_in_cli_confirm_api_payload' in local_var_params:
            body_params = local_var_params['sign_in_cli_confirm_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/signin/cli/confirm', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_in_cli_token_api(self, **kwargs):  # noqa: E501
        """sign_in_cli_token_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_cli_token_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AccountSignInCliTokenResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_in_cli_token_api_with_http_info(**kwargs)  # noqa: E501

    def sign_in_cli_token_api_with_http_info(self, **kwargs):  # noqa: E501
        """sign_in_cli_token_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_cli_token_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AccountSignInCliTokenResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_in_cli_token_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "AccountSignInCliTokenResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/signin/cli/token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_in_git_hub_api(self, **kwargs):  # noqa: E501
        """sign_in_git_hub_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_git_hub_api(async_req=True)
        >>> result = thread.get()

        :param sign_in_git_hub_api_payload:
        :type sign_in_git_hub_api_payload: SignInGitHubAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseUserWithTokenResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_in_git_hub_api_with_http_info(**kwargs)  # noqa: E501

    def sign_in_git_hub_api_with_http_info(self, **kwargs):  # noqa: E501
        """sign_in_git_hub_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_git_hub_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param sign_in_git_hub_api_payload:
        :type sign_in_git_hub_api_payload: SignInGitHubAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseUserWithTokenResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'sign_in_git_hub_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_in_git_hub_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign_in_git_hub_api_payload' in local_var_params:
            body_params = local_var_params['sign_in_git_hub_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseUserWithTokenResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/signin/github', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_in_google_api(self, **kwargs):  # noqa: E501
        """sign_in_google_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_google_api(async_req=True)
        >>> result = thread.get()

        :param sign_in_google_api_payload:
        :type sign_in_google_api_payload: SignInGoogleAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseUserWithTokenResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_in_google_api_with_http_info(**kwargs)  # noqa: E501

    def sign_in_google_api_with_http_info(self, **kwargs):  # noqa: E501
        """sign_in_google_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_google_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param sign_in_google_api_payload:
        :type sign_in_google_api_payload: SignInGoogleAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseUserWithTokenResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'sign_in_google_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_in_google_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign_in_google_api_payload' in local_var_params:
            body_params = local_var_params['sign_in_google_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseUserWithTokenResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/signin/google', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_up_api(self, **kwargs):  # noqa: E501
        """sign_up_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_up_api(async_req=True)
        >>> result = thread.get()

        :param sign_up_api_payload:
        :type sign_up_api_payload: SignUpAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseUserWithTokenResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_up_api_with_http_info(**kwargs)  # noqa: E501

    def sign_up_api_with_http_info(self, **kwargs):  # noqa: E501
        """sign_up_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_up_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param sign_up_api_payload:
        :type sign_up_api_payload: SignUpAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseUserWithTokenResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'sign_up_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_up_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign_up_api_payload' in local_var_params:
            body_params = local_var_params['sign_up_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseUserWithTokenResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/signup', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_up_validate_api(self, **kwargs):  # noqa: E501
        """sign_up_validate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_up_validate_api(async_req=True)
        >>> result = thread.get()

        :param sign_up_validate_api_payload:
        :type sign_up_validate_api_payload: SignUpValidateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_up_validate_api_with_http_info(**kwargs)  # noqa: E501

    def sign_up_validate_api_with_http_info(self, **kwargs):  # noqa: E501
        """sign_up_validate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_up_validate_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param sign_up_validate_api_payload:
        :type sign_up_validate_api_payload: SignUpValidateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'sign_up_validate_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_up_validate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign_up_validate_api_payload' in local_var_params:
            body_params = local_var_params['sign_up_validate_api_payload']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/accounts/signup/validate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def slack_authorize_api(self, **kwargs):  # noqa: E501
        """slack_authorize_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.slack_authorize_api(async_req=True)
        >>> result = thread.get()

        :param slack_authorize_api_payload:
        :type slack_authorize_api_payload: SlackAuthorizeAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.slack_authorize_api_with_http_info(**kwargs)  # noqa: E501

    def slack_authorize_api_with_http_info(self, **kwargs):  # noqa: E501
        """slack_authorize_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.slack_authorize_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param slack_authorize_api_payload:
        :type slack_authorize_api_payload: SlackAuthorizeAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'slack_authorize_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method slack_authorize_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'slack_authorize_api_payload' in local_var_params:
            body_params = local_var_params['slack_authorize_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/slack/authorize', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def slack_config_api(self, **kwargs):  # noqa: E501
        """slack_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.slack_config_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExternalSlackConfigResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.slack_config_api_with_http_info(**kwargs)  # noqa: E501

    def slack_config_api_with_http_info(self, **kwargs):  # noqa: E501
        """slack_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.slack_config_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExternalSlackConfigResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method slack_config_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ExternalSlackConfigResponse",
        }

        return self.api_client.call_api(
            '/api/v1/slack/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def snapshot_create_api(self, volume_id, **kwargs):  # noqa: E501
        """snapshot_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.snapshot_create_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param snapshot_create_api_payload:
        :type snapshot_create_api_payload: SnapshotCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSnapshotInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.snapshot_create_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def snapshot_create_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """snapshot_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.snapshot_create_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param snapshot_create_api_payload:
        :type snapshot_create_api_payload: SnapshotCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSnapshotInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id',
            'snapshot_create_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method snapshot_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and ('volume_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['volume_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `snapshot_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'snapshot_create_api_payload' in local_var_params:
            body_params = local_var_params['snapshot_create_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseSnapshotInfo",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/snapshots', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def snapshot_list_api(self, volume_id, **kwargs):  # noqa: E501
        """snapshot_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.snapshot_list_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SnapshotSnapshotListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.snapshot_list_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def snapshot_list_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """snapshot_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.snapshot_list_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SnapshotSnapshotListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method snapshot_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and ('volume_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['volume_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `snapshot_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []
        if 'cursor_after_id' in local_var_params and local_var_params['cursor_after_id'] is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if 'cursor_after_value' in local_var_params and local_var_params['cursor_after_value'] is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if 'cursor_before_id' in local_var_params and local_var_params['cursor_before_id'] is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if 'cursor_before_value' in local_var_params and local_var_params['cursor_before_value'] is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if 'cursor_first' in local_var_params and local_var_params['cursor_first'] is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if 'cursor_last' in local_var_params and local_var_params['cursor_last'] is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'order_direction' in local_var_params and local_var_params['order_direction'] is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if 'order_field' in local_var_params and local_var_params['order_field'] is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if 'paginate_type' in local_var_params and local_var_params['paginate_type'] is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "SnapshotSnapshotListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/snapshots', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def snapshot_read_api(self, snapshot_name, volume_id, **kwargs):  # noqa: E501
        """snapshot_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.snapshot_read_api(snapshot_name, volume_id, async_req=True)
        >>> result = thread.get()

        :param snapshot_name: (required)
        :type snapshot_name: str
        :param volume_id: (required)
        :type volume_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSnapshotInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.snapshot_read_api_with_http_info(snapshot_name, volume_id, **kwargs)  # noqa: E501

    def snapshot_read_api_with_http_info(self, snapshot_name, volume_id, **kwargs):  # noqa: E501
        """snapshot_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.snapshot_read_api_with_http_info(snapshot_name, volume_id, async_req=True)
        >>> result = thread.get()

        :param snapshot_name: (required)
        :type snapshot_name: str
        :param volume_id: (required)
        :type volume_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSnapshotInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'snapshot_name',
            'volume_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method snapshot_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'snapshot_name' is set
        if self.api_client.client_side_validation and ('snapshot_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['snapshot_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `snapshot_name` when calling `snapshot_read_api`")  # noqa: E501
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and ('volume_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['volume_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `snapshot_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'snapshot_name' in local_var_params:
            path_params['snapshotName'] = local_var_params['snapshot_name']  # noqa: E501
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseSnapshotInfo",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/snapshots/{snapshotName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def verify_email_api(self, **kwargs):  # noqa: E501
        """verify_email_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.verify_email_api(async_req=True)
        >>> result = thread.get()

        :param verify_email_api_payload:
        :type verify_email_api_payload: VerifyEmailAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.verify_email_api_with_http_info(**kwargs)  # noqa: E501

    def verify_email_api_with_http_info(self, **kwargs):  # noqa: E501
        """verify_email_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.verify_email_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param verify_email_api_payload:
        :type verify_email_api_payload: VerifyEmailAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'verify_email_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_email_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'verify_email_api_payload' in local_var_params:
            body_params = local_var_params['verify_email_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/verify_email', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_file_copy_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_copy_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_copy_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param volume_file_copy_api_payload:
        :type volume_file_copy_api_payload: VolumeFileCopyAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: VolumeVolumeFileCopyResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_file_copy_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_file_copy_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_copy_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_copy_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param volume_file_copy_api_payload:
        :type volume_file_copy_api_payload: VolumeFileCopyAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(VolumeVolumeFileCopyResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id',
            'volume_file_copy_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_file_copy_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and ('volume_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['volume_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_file_copy_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'volume_file_copy_api_payload' in local_var_params:
            body_params = local_var_params['volume_file_copy_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "VolumeVolumeFileCopyResponse",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/files/copy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_file_create_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_create_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param volume_file_create_api_payload:
        :type volume_file_create_api_payload: VolumeFileCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseFileMetadata
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_file_create_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_file_create_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_create_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param volume_file_create_api_payload:
        :type volume_file_create_api_payload: VolumeFileCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseFileMetadata, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id',
            'volume_file_create_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_file_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and ('volume_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['volume_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_file_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'volume_file_create_api_payload' in local_var_params:
            body_params = local_var_params['volume_file_create_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseFileMetadata",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_file_delete_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_delete_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param path:
        :type path: str
        :param recursive:
        :type recursive: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: VolumeVolumeFileDeleteResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_file_delete_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_file_delete_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_delete_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param path:
        :type path: str
        :param recursive:
        :type recursive: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(VolumeVolumeFileDeleteResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id',
            'path',
            'recursive'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_file_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and ('volume_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['volume_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_file_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []
        if 'path' in local_var_params and local_var_params['path'] is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501
        if 'recursive' in local_var_params and local_var_params['recursive'] is not None:  # noqa: E501
            query_params.append(('recursive', local_var_params['recursive']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "VolumeVolumeFileDeleteResponse",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/files/delete', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_file_list_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_list_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param last_updated:
        :type last_updated: int
        :param need_download_url:
        :type need_download_url: bool
        :param path:
        :type path: str
        :param recursive:
        :type recursive: bool
        :param snapshot:
        :type snapshot: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: VolumeVolumeFileListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_file_list_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_file_list_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_list_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param last_updated:
        :type last_updated: int
        :param need_download_url:
        :type need_download_url: bool
        :param path:
        :type path: str
        :param recursive:
        :type recursive: bool
        :param snapshot:
        :type snapshot: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(VolumeVolumeFileListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id',
            'last_updated',
            'need_download_url',
            'path',
            'recursive',
            'snapshot'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_file_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and ('volume_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['volume_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_file_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []
        if 'last_updated' in local_var_params and local_var_params['last_updated'] is not None:  # noqa: E501
            query_params.append(('last_updated', local_var_params['last_updated']))  # noqa: E501
        if 'need_download_url' in local_var_params and local_var_params['need_download_url'] is not None:  # noqa: E501
            query_params.append(('need_download_url', local_var_params['need_download_url']))  # noqa: E501
        if 'path' in local_var_params and local_var_params['path'] is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501
        if 'recursive' in local_var_params and local_var_params['recursive'] is not None:  # noqa: E501
            query_params.append(('recursive', local_var_params['recursive']))  # noqa: E501
        if 'snapshot' in local_var_params and local_var_params['snapshot'] is not None:  # noqa: E501
            query_params.append(('snapshot', local_var_params['snapshot']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "VolumeVolumeFileListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_file_read_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_read_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param path:
        :type path: str
        :param snapshot:
        :type snapshot: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseFileMetadata
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_file_read_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_file_read_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_read_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param path:
        :type path: str
        :param snapshot:
        :type snapshot: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseFileMetadata, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id',
            'path',
            'snapshot'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_file_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and ('volume_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['volume_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_file_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []
        if 'path' in local_var_params and local_var_params['path'] is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501
        if 'snapshot' in local_var_params and local_var_params['snapshot'] is not None:  # noqa: E501
            query_params.append(('snapshot', local_var_params['snapshot']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseFileMetadata",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/files/read', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_file_uploaded_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_uploaded_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_uploaded_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param path:
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseFileMetadata
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_file_uploaded_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_file_uploaded_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_uploaded_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_uploaded_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param path:
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseFileMetadata, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_file_uploaded_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and ('volume_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['volume_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_file_uploaded_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []
        if 'path' in local_var_params and local_var_params['path'] is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseFileMetadata",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/files/uploaded', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_read_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_read_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseVolume
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_read_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_read_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_read_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseVolume, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and ('volume_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['volume_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseVolume",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_sync_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_sync_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_sync_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseVolume
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_sync_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_sync_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_sync_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_sync_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseVolume, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_sync_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and ('volume_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['volume_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_sync_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseVolume",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/sync', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_create_api(self, **kwargs):  # noqa: E501
        """workspace_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_create_api(async_req=True)
        >>> result = thread.get()

        :param workspace_create_api_payload:
        :type workspace_create_api_payload: WorkspaceCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseWorkspaceInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_create_api_with_http_info(**kwargs)  # noqa: E501

    def workspace_create_api_with_http_info(self, **kwargs):  # noqa: E501
        """workspace_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_create_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param workspace_create_api_payload:
        :type workspace_create_api_payload: WorkspaceCreateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseWorkspaceInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_create_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'workspace_create_api_payload' in local_var_params:
            body_params = local_var_params['workspace_create_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseWorkspaceInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_list_api(self, **kwargs):  # noqa: E501
        """workspace_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_list_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkspaceWorkspaceListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_list_api_with_http_info(**kwargs)  # noqa: E501

    def workspace_list_api_with_http_info(self, **kwargs):  # noqa: E501
        """workspace_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_list_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkspaceWorkspaceListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "WorkspaceWorkspaceListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_member_add_api(self, workspace_name, **kwargs):  # noqa: E501
        """workspace_member_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_member_add_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param workspace_member_add_api_payload:
        :type workspace_member_add_api_payload: WorkspaceMemberAddAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseWorkspaceMember
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_member_add_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def workspace_member_add_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """workspace_member_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_member_add_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param workspace_member_add_api_payload:
        :type workspace_member_add_api_payload: WorkspaceMemberAddAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseWorkspaceMember, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            'workspace_member_add_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_member_add_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `workspace_member_add_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'workspace_member_add_api_payload' in local_var_params:
            body_params = local_var_params['workspace_member_add_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseWorkspaceMember",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/members', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_member_list_api(self, workspace_name, **kwargs):  # noqa: E501
        """workspace_member_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_member_list_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkspaceWorkspaceMemberListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_member_list_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def workspace_member_list_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """workspace_member_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_member_list_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkspaceWorkspaceMemberListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_member_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `workspace_member_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []
        if 'cursor_after_id' in local_var_params and local_var_params['cursor_after_id'] is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if 'cursor_after_value' in local_var_params and local_var_params['cursor_after_value'] is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if 'cursor_before_id' in local_var_params and local_var_params['cursor_before_id'] is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if 'cursor_before_value' in local_var_params and local_var_params['cursor_before_value'] is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if 'cursor_first' in local_var_params and local_var_params['cursor_first'] is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if 'cursor_last' in local_var_params and local_var_params['cursor_last'] is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'order_direction' in local_var_params and local_var_params['order_direction'] is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if 'order_field' in local_var_params and local_var_params['order_field'] is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if 'paginate_type' in local_var_params and local_var_params['paginate_type'] is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "WorkspaceWorkspaceMemberListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_member_remove_api(self, username, workspace_name, **kwargs):  # noqa: E501
        """workspace_member_remove_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_member_remove_api(username, workspace_name, async_req=True)
        >>> result = thread.get()

        :param username: (required)
        :type username: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_member_remove_api_with_http_info(username, workspace_name, **kwargs)  # noqa: E501

    def workspace_member_remove_api_with_http_info(self, username, workspace_name, **kwargs):  # noqa: E501
        """workspace_member_remove_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_member_remove_api_with_http_info(username, workspace_name, async_req=True)
        >>> result = thread.get()

        :param username: (required)
        :type username: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'username',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_member_remove_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `workspace_member_remove_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `workspace_member_remove_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/members/{username}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_notification_config_email_add_api(self, workspace_name, **kwargs):  # noqa: E501
        """workspace_notification_config_email_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_notification_config_email_add_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param workspace_notification_config_email_add_api_payload:
        :type workspace_notification_config_email_add_api_payload: WorkspaceNotificationConfigEmailAddAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseWorkspaceNotificationConfig
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_notification_config_email_add_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def workspace_notification_config_email_add_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """workspace_notification_config_email_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_notification_config_email_add_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param workspace_notification_config_email_add_api_payload:
        :type workspace_notification_config_email_add_api_payload: WorkspaceNotificationConfigEmailAddAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseWorkspaceNotificationConfig, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            'workspace_notification_config_email_add_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_notification_config_email_add_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `workspace_notification_config_email_add_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'workspace_notification_config_email_add_api_payload' in local_var_params:
            body_params = local_var_params['workspace_notification_config_email_add_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseWorkspaceNotificationConfig",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/notification_config_emails', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_notification_config_email_remove_api(self, email, workspace_name, **kwargs):  # noqa: E501
        """workspace_notification_config_email_remove_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_notification_config_email_remove_api(email, workspace_name, async_req=True)
        >>> result = thread.get()

        :param email: (required)
        :type email: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseWorkspaceNotificationConfig
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_notification_config_email_remove_api_with_http_info(email, workspace_name, **kwargs)  # noqa: E501

    def workspace_notification_config_email_remove_api_with_http_info(self, email, workspace_name, **kwargs):  # noqa: E501
        """workspace_notification_config_email_remove_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_notification_config_email_remove_api_with_http_info(email, workspace_name, async_req=True)
        >>> result = thread.get()

        :param email: (required)
        :type email: str
        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseWorkspaceNotificationConfig, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'email',
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_notification_config_email_remove_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email' is set
        if self.api_client.client_side_validation and ('email' not in local_var_params or  # noqa: E501
                                                        local_var_params['email'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `email` when calling `workspace_notification_config_email_remove_api`")  # noqa: E501
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `workspace_notification_config_email_remove_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in local_var_params:
            path_params['email'] = local_var_params['email']  # noqa: E501
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseWorkspaceNotificationConfig",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/notification_config_emails/{email}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_notification_config_read_api(self, workspace_name, **kwargs):  # noqa: E501
        """workspace_notification_config_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_notification_config_read_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseWorkspaceNotificationConfig
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_notification_config_read_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def workspace_notification_config_read_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """workspace_notification_config_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_notification_config_read_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseWorkspaceNotificationConfig, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_notification_config_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `workspace_notification_config_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseWorkspaceNotificationConfig",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}/notification_config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_read_api(self, workspace_name, **kwargs):  # noqa: E501
        """workspace_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_read_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseWorkspaceInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_read_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def workspace_read_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """workspace_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_read_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseWorkspaceInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `workspace_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseWorkspaceInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_update_api(self, workspace_name, **kwargs):  # noqa: E501
        """workspace_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_update_api(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param workspace_update_api_payload:
        :type workspace_update_api_payload: WorkspaceUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseWorkspaceInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_update_api_with_http_info(workspace_name, **kwargs)  # noqa: E501

    def workspace_update_api_with_http_info(self, workspace_name, **kwargs):  # noqa: E501
        """workspace_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_update_api_with_http_info(workspace_name, async_req=True)
        >>> result = thread.get()

        :param workspace_name: (required)
        :type workspace_name: str
        :param workspace_update_api_payload:
        :type workspace_update_api_payload: WorkspaceUpdateAPIPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseWorkspaceInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_name',
            'workspace_update_api_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_name' is set
        if self.api_client.client_side_validation and ('workspace_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_name` when calling `workspace_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_name' in local_var_params:
            path_params['workspaceName'] = local_var_params['workspace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'workspace_update_api_payload' in local_var_params:
            body_params = local_var_params['workspace_update_api_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "ResponseWorkspaceInfo",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
