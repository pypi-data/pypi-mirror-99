# ---------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# ---------------------------------------------------------

"""Contains functionality for managing submitted training runs in Azure Machine Learning."""

from __future__ import print_function
import os
import json
import uuid
import requests
import logging

from azureml.core.run import Run
from azureml.core.runconfig import RunConfiguration
from azureml.exceptions import AzureMLException, UserErrorException, ComputeTargetException
from azureml._restclient.constants import RequestHeaders
from azureml._base_sdk_common.user_agent import get_user_agent
from azureml._base_sdk_common import _ClientSessionId
from azureml._compute._util import get_requests_session
from azureml._restclient.clientbase import ClientBase

module_logger = logging.getLogger(__name__)


class AISCRun(Run):
    """Provides programmatic access for managing submitted training runs.

    A run submitted with :class:`azureml.core.script_run_config.ScriptRunConfig` represents a single trial in
    an experiment. Submitting the run to AISuperComputer returns a AISCRun object, which can be used to monitor
    the asynchronous execution of the run, log metrics and store output of the run, and analyze results and access
    artifacts generated by the run.

    :param experiment: The experiment object.
    :type experiment: azureml.core.experiment.Experiment
    :param run_id: The run ID.
    :type run_id: str
    :param directory: The source directory.
    :type directory: str
    :param _run_config: A run configuration.
    :type _run_config: azureml.core.runconfig.RunConfiguration
    :param kwargs: A dictionary of additional configuration parameters.
    :type kwargs: dict
    """

    RUN_TYPE = "azureml.aisc"

    def __init__(self, experiment, run_id, directory=None, _run_config=None, **kwargs):
        """Class AISCRun constructor."""
        from azureml._project.project import Project
        super(AISCRun, self).__init__(experiment, run_id, **kwargs)
        project_object = Project(experiment=experiment, directory=directory, _disable_service_check=True)
        if _run_config is not None:
            self._run_config_object = RunConfiguration._get_run_config_object(directory, _run_config)
        else:
            self._run_config_object = None
        self._project_object = project_object
        self._output_logs_pattern = "azureml-logs/[\d]{2}.+\.txt"

    @property
    def _run_config(self):
        if self._run_config_object is None:
            # Get it from experiment in the cloud.
            run_details = self.get_details()
            self._run_config_object = RunConfiguration._get_runconfig_using_run_details(run_details)
        return self._run_config_object

    def _download_working_directory(self, destination=None):
        """
        Download the run's working directory.

        :param destination: The destination path to store the diagnostics zip. If unspecified, the zip
            will be placed in the project directory.
        :type destination: str
        """
        if destination:
            if os.path.exists(destination) and not os.path.isdir(destination):
                raise UserErrorException("{} exists and is not a directory.".format(destination))
        else:
            destination = self._project_object.project_directory

        os.makedirs(destination, exist_ok=True)
        uri = self._run_dto.get('diagnostics_uri', None)
        if uri:
            response = self._client.diagnostics(uri=uri)
            target_file = os.path.join(destination, '{}-diagnostics.zip'.format(self.id))
            with open(target_file, 'wb') as local_file:
                for chunk in response.iter_content(chunk_size=1024):
                    local_file.write(chunk)
        else:
            raise AzureMLException("This run does not have a diagnostics Uri to download diagnostics.")

    def cancel(self):
        """Cancel the ongoing run."""
        super(AISCRun, self).cancel()

    @staticmethod
    def _from_run_dto(experiment, run_dto):
        """Return run from dto.

        :param experiment:
        :type experiment: azureml.core.experiment.Experiment
        :param run_dto:
        :type run_dto: object
        :return: Returns the run
        :rtype: ScriptRun
        """
        return AISCRun(experiment, run_dto.run_id, _run_dto=run_dto)

    @staticmethod
    def _get_job_endpoint(workspace, cluster_resource_id, run_id):
        """Return aisc endpoint for get job.

        :param workspace: The workspace object.
        :type workspace: azureml.core.Workspace
        :param cluster_resource_id: The cluster resource id for the aisc compute.
        :type cluster_resource_id: str
        :param run_id: The run id.
        :type run_id: str
        :return: The job endpoint.
        :rtype: str
        """
        job_fmt = '{}/jobs/{}'
        get_job = job_fmt.format(cluster_resource_id, run_id)

        resource_manager_endpoint = workspace._auth._get_cloud_type().endpoints.resource_manager
        return '{}{}'.format(resource_manager_endpoint, get_job)

    @staticmethod
    def __add_request_tracking_headers(headers):
        if RequestHeaders.CLIENT_REQUEST_ID not in headers:
            headers[RequestHeaders.CLIENT_REQUEST_ID] = str(uuid.uuid4())

        if RequestHeaders.CLIENT_SESSION_ID not in headers:
            headers[RequestHeaders.CLIENT_SESSION_ID] = _ClientSessionId

        if RequestHeaders.USER_AGENT not in headers:
            headers[RequestHeaders.USER_AGENT] = get_user_agent()

    def get_interactive_endpoints(self):
        """Retrieves the interactive endpoints for the run."""

        status = self.get_status()
        if status != "Running":
            module_logger.warning("get_interactive_endpoints() is only support while the run"
                                  " is in the 'Running' state. Current run state is " + status + ".")
            return {}

        from .compute import AISuperComputer
        ct = AISuperComputer(workspace=self.experiment._workspace)
        endpoint = AISCRun._get_job_endpoint(self.experiment._workspace, ct.cluster_resource_id, self.id)
        headers = self.experiment._workspace._auth.get_authentication_header()
        AISCRun.__add_request_tracking_headers(headers)
        params = {'api-version': '2020-12-01-preview'}
        # print(endpoint)
        resp = ClientBase._execute_func(get_requests_session().get, endpoint, params=params, headers=headers)

        try:
            resp.raise_for_status()
        except requests.exceptions.HTTPError:
            raise ComputeTargetException('Error occurred retrieving job:\n'
                                         'Response Code: {}\n'
                                         'Headers: {}\n'
                                         'Content: {}'.format(resp.status_code, resp.headers, resp.content))
        content = resp.content
        if isinstance(content, bytes):
            content = content.decode('utf-8')
        content = json.loads(content)
        grafana = content['properties']['grafanaEndpoint']
        notebook = content['properties']['notebookEndpoint']
        tensorboard = content['properties']['tensorBoardEndpoint']
        joblogs = content['properties']['jobLogsEndpoint']

        return {"grafana": grafana,
                "notebook": notebook,
                "tensorboard": tensorboard,
                "jobLogs": joblogs}


def _get_project_temporary_directory(run_id):
    import tempfile
    azureml_temp_dir = os.path.join(tempfile.gettempdir(), "azureml_runs")
    if not os.path.isdir(azureml_temp_dir):
        os.mkdir(azureml_temp_dir)

    project_temp_dir = os.path.join(azureml_temp_dir, run_id)
    return project_temp_dir
