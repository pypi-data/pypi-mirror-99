
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>jscatter.cloudscattering &#8212; Jscatter 1.3.0.5 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static//default.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    
    <link rel="shortcut icon" href="../../_static/Jscatter-32x-32.png"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Jscatter 1.3.0.5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">jscatter.cloudscattering</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for jscatter.cloudscattering</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># written by Ralf Biehl at the Forschungszentrum Jülich ,</span>
<span class="c1"># Jülich Center for Neutron Science 1 and Institute of Complex Systems 1</span>
<span class="c1">#    Jscatter is a program to read, analyse and plot data</span>
<span class="c1">#    Copyright (C) 2015-2019  Ralf Biehl</span>
<span class="c1">#</span>
<span class="c1">#    This program is free software: you can redistribute it and/or modify</span>
<span class="c1">#    it under the terms of the GNU General Public License as published by</span>
<span class="c1">#    the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1">#    (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1">#    This program is distributed in the hope that it will be useful,</span>
<span class="c1">#    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">#    GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU General Public License</span>
<span class="c1">#    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Cloud can represent any object described by a cloud of (different) scatterers with</span>
<span class="sd">scattering amplitudes as constant, sphere scattering amplitude,</span>
<span class="sd">Gaussian scattering amplitude or explicitly given ones.</span>

<span class="sd">The scattering of a cloud can represent the scattering of a **cluster of particles** with polydispersity</span>
<span class="sd">and position distortion according to root mean square displacements (rms).</span>
<span class="sd">Polydispersity and rms displacements are randomly changed within the explicit orientational average to represent</span>
<span class="sd">an ensemble average (opposite to the time average of a single cluster).</span>

<span class="sd">The cloud can represent a **particle lattice** in a nano particle to describe the Bragg peaks or be used as a kind</span>
<span class="sd">of volume integrations for **arbitrary shaped particles**.</span>
<span class="sd">Additional complex objects composed of different types of subparticles can be created.</span>
<span class="sd">E.g a hollow sphere decorated by Gaussian chains. See `cloudscattering examples` below.</span>

<span class="sd">The scattering is calculated by explicit calculation with a spherical average to allow inclusion of</span>
<span class="sd">polydispersity, position distortion and because its faster for large numbers of particles (&gt;1000).</span>
<span class="sd">For small number of particles the Debye equation can be used but without polydispersity and position distortion.</span>
<span class="sd">See :py:func:`~.cloudscattering.cloudScattering`</span>

<span class="sd">Note:</span>
<span class="sd">    Models that are build by positioning of differently shaped particles might depict</span>
<span class="sd">    approximations of the real scattering as overlaps are not considered or</span>
<span class="sd">    changes of specific configurations due to the presence of another particle might change.</span>
<span class="sd">    As an example we look at  :py:func:`~.formfactor.sphereGaussianCorona`. The Gaussian coils have overlap</span>
<span class="sd">    with the inner sphere and for high aggregation numbers the coil overlap is not described correctly.</span>

<span class="sd">    Nevertheless these approximations might be useful to describe general features of a scattering pattern.</span>
<span class="sd">    Additional one might consider that analytic models as a e.g. a sphere are approximations itself neglecting</span>
<span class="sd">    surface roughness, interfaces, deviations from symmetry or anisotropy and</span>
<span class="sd">    break down if a length scale of internal building blocks as e.g. atoms is reached.</span>

<span class="sd">**Cloudscattering examples**</span>

<span class="sd">Check the source</span>
<span class="sd"> - :py:func:`~.formfactor.decoratedCoreShell`</span>
<span class="sd"> - :py:func:`~.formfactor.linearPearls`</span>
<span class="sd"> - :py:func:`~.formfactor.superball`</span>
<span class="sd"> - :py:func:`~.structurefactor.latticeStructureFactor`</span>
<span class="sd"> - :ref:`A nano cube build of different lattices`</span>

<span class="sd">Cloudscattering results are normalized by :math:`I_0=(\sum b_i)^2` to equal one for q=0</span>
<span class="sd">(except for polydispersity).</span>

<span class="sd">===============</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">numbers</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.transform</span> <span class="kn">import</span> <span class="n">Rotation</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span> <span class="k">as</span> <span class="n">la</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">formel</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">parallel</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">formfactor</span>

<span class="kn">from</span> <span class="nn">.dataarray</span> <span class="kn">import</span> <span class="n">dataArray</span> <span class="k">as</span> <span class="n">dA</span>
<span class="kn">from</span> <span class="nn">.dataarray</span> <span class="kn">import</span> <span class="n">dataList</span> <span class="k">as</span> <span class="n">dL</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">fscatter</span>
    <span class="n">useFortran</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">fscatter</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">useFortran</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_fa_sphere</span><span class="p">(</span><span class="n">qr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    scattering amplitude sphere with catching the zero</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fa</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">qr</span><span class="p">)</span>
    <span class="n">qr1</span><span class="o">=</span><span class="n">qr</span><span class="p">[</span><span class="n">qr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">fa</span><span class="p">[</span><span class="n">qr</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">/</span> <span class="n">qr1</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">qr1</span><span class="p">)</span> <span class="o">-</span> <span class="n">qr1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">qr1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">fa</span>


<span class="k">def</span> <span class="nf">_fa_coil</span><span class="p">(</span><span class="n">qrg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    qrg is array dim 1</span>
<span class="sd">    fa_coil**2 is Debye function see [2]_ in  sphereCoreShellGaussianCorona</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">qrg</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">fa</span><span class="p">[</span><span class="n">qrg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">qrg</span><span class="p">[</span><span class="n">qrg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span><span class="n">qrg</span><span class="p">[</span><span class="n">qrg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">fa</span>


<div class="viewcode-block" id="fa_cuboid"><a class="viewcode-back" href="../../formfactor.html#jscatter.cloudscattering.fa_cuboid">[docs]</a><span class="k">def</span> <span class="nf">fa_cuboid</span><span class="p">(</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Formfactor amplitude cuboid dependent on 3D cartesian scattering vector qx,qy,qz.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    qx,qy,qz : array 1xN</span>
<span class="sd">        Wavevectors</span>
<span class="sd">    a,b,c : float</span>
<span class="sd">        Edge length  along x,y,z direction.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        array formfactor amplitude</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="c1"># numpy sinc is sinc(pi*x)/(pi*x)</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">qx</span> <span class="o">*</span> <span class="n">a</span> <span class="o">/</span> <span class="n">pi2</span><span class="p">)</span> <span class="o">*</span> \
         <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">qy</span> <span class="o">*</span> <span class="n">b</span> <span class="o">/</span> <span class="n">pi2</span><span class="p">)</span> <span class="o">*</span> \
         <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">qz</span> <span class="o">*</span> <span class="n">c</span> <span class="o">/</span> <span class="n">pi2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span><span class="p">,</span> <span class="n">fa</span><span class="p">])</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="fa_disc"><a class="viewcode-back" href="../../formfactor.html#jscatter.cloudscattering.fa_disc">[docs]</a><span class="k">def</span> <span class="nf">fa_disc</span><span class="p">(</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Formfactor amplitude of a disc dependent on 3D cartesian scattering vector qx,qy,qz.</span>

<span class="sd">    Disc axis along Z-axis</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    qx,qy,qz : array 1xN</span>
<span class="sd">        Wavevectors</span>
<span class="sd">    R : float</span>
<span class="sd">        Radius in x,y plane.</span>
<span class="sd">    D :float</span>
<span class="sd">        Thickness of the disc in Z direction.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        array formfactor amplitude</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">([</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">([</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">qz</span><span class="p">)</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">formfactor</span><span class="o">.</span><span class="n">_fa_disc</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">[</span><span class="n">R</span><span class="p">],</span> <span class="p">[</span><span class="n">D</span><span class="p">],</span> <span class="n">angle</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span><span class="p">,</span> <span class="n">fa</span><span class="p">])</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="fa_ellipsoid"><a class="viewcode-back" href="../../formfactor.html#jscatter.cloudscattering.fa_ellipsoid">[docs]</a><span class="k">def</span> <span class="nf">fa_ellipsoid</span><span class="p">(</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span><span class="p">,</span> <span class="n">Rp</span><span class="p">,</span> <span class="n">Re</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Formfactor amplitude of a ellipsoid of revolution dependent on 3D cartesian scattering vector qx,qy,qz.</span>

<span class="sd">    Pole axis is axis of revolution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    qx,qy,qz : array 1xN</span>
<span class="sd">        Wavevectors</span>
<span class="sd">    Rp, Re : float</span>
<span class="sd">        Half axes to pole Rp in z direction and to equator Re in x,y plane</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        array formfactor amplitude</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">([</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">([</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">qz</span><span class="p">)</span>
    <span class="n">axialratio</span> <span class="o">=</span> <span class="n">Rp</span> <span class="o">/</span> <span class="n">Re</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">q</span> <span class="o">*</span> <span class="n">Re</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">axialratio</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="n">z</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">z</span><span class="p">))</span> <span class="o">/</span> <span class="n">z</span> <span class="o">**</span> <span class="mi">3</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span><span class="p">,</span> <span class="n">fa</span><span class="p">])</span><span class="o">.</span><span class="n">T</span></div>


<span class="k">def</span> <span class="nf">_fa_prism</span><span class="p">(</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">H</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ! How to deal with complex fa,  incomplete !!!!!!!!!11</span>
<span class="sd">    Equal sided prism width edge length R of height H</span>

<span class="sd">    Center of mass is in the origin. The height is along Z-axis.</span>
<span class="sd">    The prism rectangular basis is parallel to XZ-plane, the triangular plane is parallel to XY-plane.</span>
<span class="sd">    See [1]_ SI *The form factor of a prism*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    qx,qy,qz : array 1xN</span>
<span class="sd">        Wavevectors</span>
<span class="sd">    R : float</span>
<span class="sd">        2R is edge length</span>
<span class="sd">    H : float</span>
<span class="sd">        Prism height in Z direction</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        array formfactor amplitude</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    With contrast :math:`\rho` and wavevector :math:`q=[q_x,q_y,q_z]` the scattering amplitude :math:`F_a(q)` is</span>

<span class="sd">    .. math:: F_a(q_x,q_y,q_z) = \rho \frac{2 \sqrt{3} e^{-iq_yR/ \sqrt{3}} H} {q_x (q_x^2-3q_y^2)} \</span>
<span class="sd">              (q_x e^{i q_yR\sqrt{3}} - q_xcos(q_xR) - i\sqrt{3} q_ysin(q_xR))  sinc(q_zH/2)</span>

<span class="sd">    and :math:`F(q)=&lt;F_a(q)F^*_a(q)&gt;=&lt;|F_a(q)|^2&gt;`</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] DNA-Nanoparticle Superlattices Formed From Anisotropic Building Blocks</span>
<span class="sd">          Jones et al</span>
<span class="sd">          Nature Materials 9, 913–917 (2010), doi: 10.1038/nmat2870</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># qx, qy, qz = points.T[:, :, None] * Q[None, None, :]</span>
    <span class="n">sq3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sq3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">qy</span><span class="o">*</span><span class="n">R</span><span class="o">/</span><span class="n">sq3</span><span class="p">)</span><span class="o">*</span><span class="n">H</span> <span class="o">/</span> <span class="p">(</span><span class="n">qx</span><span class="o">*</span><span class="p">(</span><span class="n">qx</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">qy</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span>
          <span class="p">(</span><span class="n">qx</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">qy</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">sq3</span><span class="p">)</span> <span class="o">-</span> <span class="n">qx</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">qx</span><span class="o">*</span><span class="n">R</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">sq3</span><span class="o">*</span><span class="n">qy</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">qx</span><span class="o">*</span><span class="n">R</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">qz</span><span class="o">*</span><span class="n">H</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span><span class="p">,</span> <span class="n">fa</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>


<span class="k">def</span> <span class="nf">_scattering</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ffpolydispersity</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coherent scattering of objects at positions r in direction point on sphere with length (radius) q</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    point : point on unit sphere 3 x 1</span>
<span class="sd">    q : float</span>
<span class="sd">        q vector length</span>
<span class="sd">    r : array  N x 3</span>
<span class="sd">        vector of objekt positions</span>
<span class="sd">    blength : array N</span>
<span class="sd">        scattering length of objects</span>
<span class="sd">    iff : Nxinteger</span>
<span class="sd">        indices of form factors</span>
<span class="sd">    formfactoramp ixN array</span>
<span class="sd">        formfactoramp of all objects</span>
<span class="sd">    rms: float</span>
<span class="sd">        position rms</span>
<span class="sd">    ffpolydispersity : float</span>
<span class="sd">        size rms by scaling of size</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    F(Q)*F(Q).conj() , F(Q).sum()</span>

<span class="sd">    pure numpy way as option</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">useFortran</span><span class="p">:</span>
        <span class="c1"># speedup 2.41 : 1.1  for  cloudScattering(q,insidegrid) on ncpu=1 comparing this fortran and below</span>
        <span class="c1"># speedup  38.5 : 4.75   for  ncpu=6 and 9261 points with rms&gt;0</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">fscatter</span><span class="o">.</span><span class="n">cloud</span><span class="o">.</span><span class="n">ffq</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="p">,</span> <span class="n">rms</span><span class="p">,</span> <span class="n">ffpolydispersity</span><span class="p">)</span>
        <span class="c1"># print(ret,point,r.shape)</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">ffpolydispersity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># normal distribution of size factor</span>
            <span class="n">sizerms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">ffpolydispersity</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># corresponding relative volume change</span>
            <span class="n">volrmsfactor</span> <span class="o">=</span> <span class="n">sizerms</span> <span class="o">**</span> <span class="mi">3</span>
            <span class="n">volrmsfactor</span><span class="p">[</span><span class="n">sizerms</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># interpolate with volume change weight</span>
            <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">blength</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">iff</span><span class="p">):</span>
                <span class="n">chose</span> <span class="o">=</span> <span class="n">iff</span> <span class="o">==</span> <span class="n">i</span>
                <span class="n">fa</span><span class="p">[</span><span class="n">chose</span><span class="p">]</span> <span class="o">=</span> <span class="n">volrmsfactor</span><span class="p">[</span><span class="n">chose</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">sizerms</span><span class="p">[</span><span class="n">chose</span><span class="p">],</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
                                                            <span class="n">formfactoramp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># interpolate the formfactoramp</span>
            <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">amp</span><span class="p">)</span> <span class="k">for</span> <span class="n">amp</span> <span class="ow">in</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
            <span class="n">fa</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[</span><span class="n">iff</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">qx</span> <span class="o">=</span> <span class="n">q</span> <span class="o">*</span> <span class="n">point</span>
        <span class="k">if</span> <span class="n">rms</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">rms</span>
        <span class="n">iqr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,ji&#39;</span><span class="p">,</span> <span class="n">qx</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span>  <span class="c1"># 454 µs        iqr.shape 26135</span>
        <span class="n">beiqrsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,i&#39;</span><span class="p">,</span> <span class="n">blength</span> <span class="o">*</span> <span class="n">fa</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">iqr</span><span class="p">))</span>
        <span class="n">Sq</span> <span class="o">=</span> <span class="n">beiqrsum</span> <span class="o">*</span> <span class="n">beiqrsum</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>  <span class="c1"># 2 µs</span>
        <span class="k">return</span> <span class="n">q</span><span class="p">,</span> <span class="n">Sq</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">beiqrsum</span><span class="o">.</span><span class="n">real</span>


<span class="k">def</span> <span class="nf">_sphaverage_scattering</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ffpolydispersity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">relError</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coherent scattering of objects at positions r in after oriental average.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q : float</span>
<span class="sd">        q vector length</span>
<span class="sd">    r : array  N x 3</span>
<span class="sd">        vector of objekt positions</span>
<span class="sd">    blength : array N</span>
<span class="sd">        scattering length of objects</span>
<span class="sd">    formfactoramp 2xN array</span>
<span class="sd">        formfactoramp of all objects</span>
<span class="sd">    rms: float</span>
<span class="sd">        position rms</span>
<span class="sd">    ffpolydispersity : float</span>
<span class="sd">        size rms by scaling of size</span>
<span class="sd">    relError : int</span>
<span class="sd">        determines number of points on Fibonacci lattice on sphere</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Q, &lt;F(Q)*F(Q).conj()&gt; , &lt;F(Q).sum()&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># call Fortran sphere average for ffq</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">fscatter</span><span class="o">.</span><span class="n">cloud</span><span class="o">.</span><span class="n">sphereaverage_ffq</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="p">,</span> <span class="n">rms</span><span class="p">,</span> <span class="n">ffpolydispersity</span><span class="p">,</span> <span class="n">relError</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_scattering_Debye</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Debye equation  definition as in _scattering</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iff1</span> <span class="o">=</span> <span class="n">iff</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">blength</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="c1"># interpolate the formfactoramp</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">amp</span><span class="p">)</span> <span class="k">for</span> <span class="n">amp</span> <span class="ow">in</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>

    <span class="c1"># ()**2.sum()**0.5 to get absolute value |ri-rj|</span>
    <span class="n">qrij</span> <span class="o">=</span> <span class="n">q</span> <span class="o">*</span> <span class="p">((</span><span class="n">r</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>  <span class="c1"># 137 ms r.shape (1856, 3)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">qrij</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 19 µs</span>
    <span class="n">sinoq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">qrij</span><span class="p">)</span> <span class="o">/</span> <span class="n">qrij</span>  <span class="c1"># 47.7 ms   still faster than np.sinc</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">sinoq</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 19.4 µs</span>
    <span class="n">Sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,j,ij-&gt;&#39;</span><span class="p">,</span> <span class="n">blength</span> <span class="o">*</span> <span class="n">fa</span><span class="p">[</span><span class="n">iff1</span><span class="p">],</span> <span class="n">blength</span> <span class="o">*</span> <span class="n">fa</span><span class="p">[</span><span class="n">iff1</span><span class="p">],</span> <span class="n">sinoq</span><span class="p">)</span>  <span class="c1"># 10.3 ms</span>
    <span class="k">return</span> <span class="n">Sq</span>


<div class="viewcode-block" id="cloudScattering"><a class="viewcode-back" href="../../formfactor.html#jscatter.cloudscattering.cloudScattering">[docs]</a><span class="k">def</span> <span class="nf">cloudScattering</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cloud</span><span class="p">,</span> <span class="n">relError</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ffpolydispersity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ncpu</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Orientational averaged scattering of a cloud of isotropic particles.</span>

<span class="sd">    Cloud can represent any object/lattice described by a cloud of scatterers with scattering amplitudes</span>
<span class="sd">    as constant, sphere scattering amplitude, Gaussian scattering amplitude or explicitly given one.</span>
<span class="sd">    The result is normalized by :math:`I_0=(\sum b_i)^2` to equal one for q=0 (except for polydispersity).</span>

<span class="sd">    - .I0 represents the forward scattering if :math:`b_i=b_vV_{unit cell}` with :math:`b_v` as</span>
<span class="sd">      scattering length density in the unit cell.</span>
<span class="sd">    - Remember that the atomic bond length are on the order 0.1-0.2 nm.</span>
<span class="sd">    - Methods to build clouds of scatterers e.g. a cube decorated with spheres at the corners can be</span>
<span class="sd">      found in :ref:`Lattice` with examples.</span>
<span class="sd">    - By default explicit spherical average is done. If rms and polydispersity are not needed the Debye-function</span>
<span class="sd">      can be used (for particle numbers&lt;1000 it is faster).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q : array, ndim= Nx1</span>
<span class="sd">         Radial wavevectors in 1/nm</span>
<span class="sd">    cloud : array Nx3 or Nx4 or Nx5</span>
<span class="sd">        - Center of mass positions cloud[:,:3] (in nm) of the N scatterers in the cloud.</span>
<span class="sd">        - If given cloud[:,3] is the scattering length :math:`b_i` at positions cloud[:,:3], otherwise :math:`b=1`.</span>
<span class="sd">        - Ff given cloud[:,4] is the column index in formfactor for a specific scatterer.</span>
<span class="sd">        - To compare with material scattering length density :math:`b_v` use :math:`b=b_vV_{unit cell}` with</span>
<span class="sd">          :math:`b_v` as scattering length density and :math:`V_{unit cell}` as cloud unit cell volume.</span>
<span class="sd">    relError : float</span>
<span class="sd">        Determines calculation method.</span>
<span class="sd">         - relError&gt;1   Explicit calculation of spherical average with Fibonacci lattice on sphere</span>
<span class="sd">                        of 2*relError+1 points. Already 150 gives good results (see Examples)</span>
<span class="sd">         - 0&lt;relError&lt;1 Monte Carlo integration on sphere until changes in successive iterations</span>
<span class="sd">                        become smaller than relError.</span>
<span class="sd">                        (Monte carlo integration with pseudo random numbers, see sphereAverage).</span>
<span class="sd">                        This might take long for too small error.</span>
<span class="sd">         - relError=0   The Debye equation is used (no asymmetry factor beta, no rms, no ffpolydispersity).</span>
<span class="sd">                        Computation is of order :math:`N^2` opposite to above which is order :math:`N`.</span>
<span class="sd">                        For about 1000 particles same computing time,for 500 Debye is 4 times faster than above.</span>
<span class="sd">                        If beta, rms or polydispersity is needed use above.</span>
<span class="sd">    rms : float, default=0</span>
<span class="sd">        Root mean square displacement :math:`\langle u^2 \rangle^{0.5}` of the positions in cloud as</span>
<span class="sd">        random (Gaussian) displacements in nm.</span>
<span class="sd">         - Displacement u is randomly changed for each orientation in orientational average.</span>
<span class="sd">         - rms results in a Debye-Waller factor e.g. for crystal lattices and in diffuse scattering at high q.</span>
<span class="sd">         - Using a low number of displacements introduces noise on the model function because of bad sampling.</span>
<span class="sd">           To reduce this noise during fitting relError should be high (&gt;2000 for linearPearls) and the result might be</span>
<span class="sd">           smoothed.</span>
<span class="sd">    formfactoramp : None,&#39;gauss&#39;,&#39;sphere&#39;, array</span>
<span class="sd">        Normalized scattering amplitudes of cloud points :math:`\hat{F_a^i}(q)`.</span>
<span class="sd">        :math:`F_a(q)=b_i \hat{F_a^i}(q)` with  bi from cloud[3].</span>
<span class="sd">         - None    : const scattering amplitude.</span>
<span class="sd">         - &#39;sphere&#39;: Sphere scattering amplitude according to [3]_ equal for all cloud points.</span>
<span class="sd">                     Parameter V is needed to determine :math:`R`.</span>
<span class="sd">                     The sphere radius is :math:`R=(\frac{3V}{4\pi})^{1/3}`</span>
<span class="sd">         - &#39;gauss&#39; : Gaussian function  :math:`\hat{F_a}(q) = exp(-\pi V^{2/3}q^2)` according to [2]_</span>
<span class="sd">                     Equal for all cloud points. The Gaussian shows no artificial minima compared to the sphere.</span>
<span class="sd">                     Use parameter V to determine :math:`b_i`.</span>
<span class="sd">         - &#39;coil&#39; :  Polymer coil (ideal Gaussian chain) showing scattering according to Debye function equal for all.</span>
<span class="sd">                     Parameter V needed to determine :math:`R_g = (\frac{3V}{4\pi})^{1/3}`.</span>
<span class="sd">                     The scattering length is :math:`b_i = Nb_{monomer}` with monomer number :math:`N`.</span>
<span class="sd">         - Explicit isotropic :math:`\hat{F_a}(q)` as array with [q,fa1(q),fa2(q),fa3(q),....].</span>
<span class="sd">            - If multiple fai are given the index i for a cloud point needs to be given in cloud[4]</span>
<span class="sd">            - The normalized scattering amplitude fa for each cloud point is calculated as fa=fai/fai[0].</span>
<span class="sd">              Missing values are linear interpolated, q values outside interval are mapped to qmin or qmax.</span>
<span class="sd">            - Explicit formfactors are assumed to be isotropic.</span>
<span class="sd">            - If the scattering amplitude is not known :math:`F_a(q) \approx F^{1/2}(q)`</span>
<span class="sd">              might be used as crude approximation for low Q.</span>
<span class="sd">    V : float, default=None</span>
<span class="sd">        Volume of the scatterers to determine scattering amplitude (see formfactoramp).</span>
<span class="sd">        Only needed for formfactoramp &#39;sphere&#39; and &#39;gauss&#39;.</span>
<span class="sd">    ffpolydispersity : float</span>
<span class="sd">        Polydispersity of the gridpoints in relative units for sphere, gauss, explicit.</span>
<span class="sd">        Assuming F(q*R) for each gridpoint F is scaled as F(q*f*R)  with f as normal distribution</span>
<span class="sd">        around 1 and standard deviation ffpolydispersity. The scattering length :math:`b` is scaled according</span>
<span class="sd">        to the respective volume change by f**3. (f&lt;0 is set to zero) assuming a volume scatterer.</span>
<span class="sd">        This results in a change of the forward scattering because of the stronger weight of larger objects.</span>
<span class="sd">    ncpu : int, default 0</span>
<span class="sd">        Number of cpus used in the pool for multiprocessing.</span>
<span class="sd">         - not given or 0 : all cpus are used</span>
<span class="sd">         - int&gt;0          : min(ncpu, mp.cpu_count)</span>
<span class="sd">         - int&lt;0          : ncpu not to use</span>
<span class="sd">         - 1              : single core usage for testing or comparing speed to Debye</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dataArray</span>
<span class="sd">        Columns [q, Pq, beta, fa]</span>
<span class="sd">         - Pq , formfactor , beta asymmetry factor, fa scattering amplitude</span>
<span class="sd">         - .I0 :          :math:`=I(q=0)=(\sum_N b_i)^2`</span>
<span class="sd">         - .sumblength :  :math:`=\sum_N b_i`</span>
<span class="sd">         - .formfactoramplitude   : formfactor amplitude of cloudpoints according to type for all q values.</span>
<span class="sd">         - .formfactoramplitude_q :  corresponding q values</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    We calculate the normalized formfactor :math:`\hat{F}(q)` for :math:`N` particles</span>
<span class="sd">    in a volume :math:`V` after explicit orientational average :math:`&lt;&gt;`</span>

<span class="sd">    .. math:: \hat{F}(q)=&lt; \hat{F_a}(q) \cdot \hat{F_a}^*(q) &gt;=&lt; |\hat{F_a}(q)|^2 &gt;</span>

<span class="sd">    with normalized scattering amplitude :math:`\hat{F_a}(q)` and scattering length density :math:`b(r)`</span>
<span class="sd">    (:math:`b_i(q)` is the particle formfactor)</span>

<span class="sd">    .. math:: \hat{F_a}(q)= \int_V b(r) e^{i\mathbf{qr}} \mathrm{d}r  / \int_V b(r) \mathrm{d}r  =</span>
<span class="sd">                    \sum_N b_i(q) e^{i\mathbf{qr}}  / \sum_N b_i(0)</span>

<span class="sd">    The scattering intensity of a single object represented by the cloud is</span>

<span class="sd">    .. math:: I(q)=\hat{F}(q) \cdot (\int_V b(r) \mathrm{d}r)^2 = \hat{F}(q) \cdot (\sum_i b_i )^2</span>

<span class="sd">    beta is the asymmetry factor [1]_ :math:`beta =|&lt; \hat{F_a}(q) &gt;|^2 / &lt; |\hat{F_a}(q)|^2 &gt;`</span>

<span class="sd">    One has to expect a peak at :math:`q \approx 2\pi/d_{NN}` with :math:`d_{NN}` as the next</span>
<span class="sd">    neighbour distance between particles.</span>

<span class="sd">    :math:`b_i(q)` is a particle formfactor amplitude of the particles as e.g. q dependent Xray</span>
<span class="sd">    scattering amplitude or the formfactors in a cloud of different particles,</span>
<span class="sd">    but may also be constant as for neutron scattering atomic formfactors.</span>

<span class="sd">    Random displacements :math:`u_i` lead to :math:`r_i=r_i+u_i` and to the Debye-Waller factor for Bragg peaks</span>
<span class="sd">    and diffusive scattering at higher q. See :ref:`A nano cube build of different lattices` .</span>

<span class="sd">    The explicit orientational average can be simplified using the **Debye scattering equation** [4]_</span>

<span class="sd">     .. math::  \hat{F}(Q)(\sum b_i)^2=\sum_i \sum_j b_i(q) b_j(q) \frac{\sin(qr_{ij})}{qr_{ij}}</span>
<span class="sd">                     =\sum_i b_i(q)^2 + 2\sum_i \sum_{j&gt;i} b_i(q) b_j(q) \frac{\sin(qr_{ij})}{qr_{ij}}</span>

<span class="sd">    Here no rms or ffpolydispersity are included. The calculation of :math:`beta` requires an additional calculation.</span>

<span class="sd">    The scattering of a cloud can represent the scattering of a *cluster of particles* with polydispersity</span>
<span class="sd">    and position distortion according to root mean square displacements (rms).</span>
<span class="sd">    Polydispersity and rms displacements are randomly changed within the orientational average to represent</span>
<span class="sd">    an ensemble average (opposite to the time average of a single cluster).</span>

<span class="sd">    **Examples**</span>
<span class="sd">     - See :py:func:`~.structurefactor.latticeStructureFactor` for nanocubes.</span>
<span class="sd">     - :ref:`A nano cube build of different lattices` .</span>
<span class="sd">     - The model :py:func:`~.formfactor.linearPearls` uses cloudscattering.</span>
<span class="sd">       Look into the source code as example how to create a complex model.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The example compares to the analytic solution for an ellipsoid, then for a cube.</span>
<span class="sd">    For other shapes the grid may be better rotated away from the object symmetry or a random grid should be used.</span>
<span class="sd">    The example shows a good approximation with NN=20. Because of the grid peak at :math:`q=2\pi/d_{NN}`</span>
<span class="sd">    the grid scatterer distance :math:`d_{NN}` should be :math:`d_{NN} &lt; \frac{1}{3} 2\pi/q_{max}` .</span>

<span class="sd">    Inspecting :ref:`A nano cube build of different lattices` shows other possibilities building a grid.</span>
<span class="sd">    Also a pseudo random grid can be used :py:func:`~.structurefactor.pseudoRandomLattice` .</span>

<span class="sd">    ::</span>

<span class="sd">     # ellipsoid with grid build by mgrid</span>
<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     import matplotlib.pyplot as plt</span>
<span class="sd">     from mpl_toolkits.mplot3d import Axes3D</span>
<span class="sd">     # cubic grid points</span>
<span class="sd">     R=3;NN=20;relError=50</span>
<span class="sd">     grid= np.mgrid[-R:R:1j*NN, -R:R:1j*NN,-2*R:2*R:2j*NN].reshape(3,-1).T</span>
<span class="sd">     # points inside of sphere with radius R</span>
<span class="sd">     p=1;p2=1*2 # p defines a superball with 1-&gt;sphere p=inf cuboid ....</span>
<span class="sd">     inside=lambda xyz,R1,R2,R3:(np.abs(xyz[:,0])/R1)**p2+(np.abs(xyz[:,1])/R2)**p2+(np.abs(xyz[:,2])/R3)**p2&lt;=1</span>
<span class="sd">     insidegrid=grid[inside(grid,R,R,2*R)]</span>
<span class="sd">     q=np.r_[0:5:0.1]</span>
<span class="sd">     p=js.grace()</span>
<span class="sd">     p.title(&#39;compare form factors of an ellipsoid&#39;)</span>
<span class="sd">     ffe=js.ff.cloudScattering(q,insidegrid,relError=relError)</span>
<span class="sd">     p.plot(ffe,legend=&#39;cloud ff explicit&#39;)</span>
<span class="sd">     ffa=js.ff.ellipsoid(q,2*R,R)</span>
<span class="sd">     p.plot(ffa.X,ffa.Y/ffa.I0,li=1,sy=0,legend=&#39;analytic formula&#39;)</span>
<span class="sd">     p.legend()</span>
<span class="sd">     # show only each 20th point</span>
<span class="sd">     js.mpl.scatter3d(insidegrid[::10,:])</span>

<span class="sd">    ::</span>

<span class="sd">     # cube</span>
<span class="sd">     # grid points generated by cubic grid</span>
<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     q=np.r_[0.1:5:0.1]</span>
<span class="sd">     p=js.grace()</span>
<span class="sd">     R=3;N=10;relError=0.01  # random points on sphere</span>
<span class="sd">     grid= js.sf.scLattice(R/N,N)</span>
<span class="sd">     ffe=js.ff.cloudScattering(q,grid,relError=relError)</span>
<span class="sd">     p.plot(ffe,legend=&#39;cloud ff explicit 10&#39;)</span>
<span class="sd">     # each point has a cube around it including the border</span>
<span class="sd">     ffa=js.ff.cuboid(q,2*R+R/N)</span>
<span class="sd">     p.plot(ffa.X,ffa.Y/ffa.I0,li=1,sy=0,legend=&#39;analytic formula&#39;)</span>
<span class="sd">     p.yaxis(scale=&#39;l&#39;)</span>
<span class="sd">     p.title(&#39;compare form factors of an cube&#39;)</span>
<span class="sd">     p.legend(x=2,y=0.1)</span>


<span class="sd">    An objekt with **explicit given formfactoramp** for each gridpoint.</span>
<span class="sd">    ::</span>

<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     q = js.loglist(0.01, 7, 100)</span>
<span class="sd">     # 5 coreshell particles in line with polydispersity</span>
<span class="sd">     rod0 = np.zeros([5, 3])</span>
<span class="sd">     rod0[:, 1] = np.r_[0, 1, 2, 3, 4] * 4</span>
<span class="sd">     cs = js.ff.sphereCoreShell(q=q, Rc=1, Rs=2, bc=0.1, bs=1, solventSLD=0)</span>
<span class="sd">     csa = np.c_[cs.X,cs[2]].T</span>
<span class="sd">     ffe = js.ff.cloudScattering(q, rod0, formfactoramp=csa,relError=100,ffpolydispersity=0.1)</span>
<span class="sd">     p=js.grace()</span>
<span class="sd">     p.plot(ffe)</span>

<span class="sd">    Using cloudScattering as **fit model**.</span>

<span class="sd">    We have to define a model that parametrizes the building of the cloud that we get fit parameters.</span>
<span class="sd">    As example we use two overlapping spheres. The model can be used to fit some data.</span>
<span class="sd">    The build of the model is important as it describes how the overlap is treated e.g. as average.</span>

<span class="sd">    We have to consider some points:</span>
<span class="sd">     - It is important that the model is continuous in its parameters to avoid steps as</span>
<span class="sd">       any fit algorithm cannot handle this.</span>
<span class="sd">     - We have to limit some parameters that make giant grids.</span>
<span class="sd">       Fit algorithm make first a small step then a large one to estimate a good step size for parameter changes.</span>
<span class="sd">       If in the dumbbell example the radii R1 or R2 is increased to &gt;1000 then the grid size burst the RAM</span>
<span class="sd">       and we get a Memory Error. Use hard limits for the radii to a reasonable value as shown below (see setlimit).</span>
<span class="sd">     - The argument &quot;factor&quot; limits the initial step size. Reduce it (default 100 -&gt; [0.1..100]).</span>
<span class="sd">     - In the below example the first fit is fast but bad as we find a local minimum.</span>
<span class="sd">       A global fit algorithm takes quite long but finds the correct solution.</span>

<span class="sd">    ::</span>

<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     #</span>
<span class="sd">     #: test if distance from point on X axis</span>
<span class="sd">     isInside=lambda x,A,R:((x-np.r_[A,0,0])**2).sum(axis=1)**0.5&lt;R</span>
<span class="sd">     #: model</span>
<span class="sd">     def dumbbell(q,A,R1,b1,bgr=0,dx=0.3,relError=50):</span>
<span class="sd">         # D sphere distance</span>
<span class="sd">         # R1, R2 radii</span>
<span class="sd">         # b1,b2  scattering length</span>
<span class="sd">         # bgr background</span>
<span class="sd">         # dx grid distance not a fit parameter!!</span>
<span class="sd">         R2=R1</span>
<span class="sd">         b2=b1</span>
<span class="sd">         mR=max(R1,R2)</span>
<span class="sd">         # xyz coordinates</span>
<span class="sd">         grid=np.mgrid[-A/2-mR:A/2+mR:dx,-mR:mR:dx,-mR:mR:dx].reshape(3,-1).T</span>
<span class="sd">         insidegrid=grid[isInside(grid,-A/2.,R1) | isInside(grid,A/2.,R2)]</span>
<span class="sd">         # add blength column</span>
<span class="sd">         insidegrid=np.c_[insidegrid,insidegrid[:,0]*0]</span>
<span class="sd">         # set the corresponding blength; the order is important as here b2 overwrites b1</span>
<span class="sd">         insidegrid[isInside(insidegrid[:,:3],-A/2.,R1),3]=b1</span>
<span class="sd">         insidegrid[isInside(insidegrid[:,:3],A/2.,R2),3]=b2</span>
<span class="sd">         # and maybe a mix ; this depends on your model</span>
<span class="sd">         insidegrid[isInside(insidegrid[:,:3],-A/2.,R1) &amp; isInside(insidegrid[:,:3],A/2.,R2),3]=(b2+b1)/2.</span>
<span class="sd">         # calc the scattering</span>
<span class="sd">         result=js.ff.cloudScattering(q,insidegrid,relError=relError)</span>
<span class="sd">         result.Y=result.Y*result.I0+bgr</span>
<span class="sd">         # add attributes for later usage</span>
<span class="sd">         result.A=A</span>
<span class="sd">         result.R1=R1</span>
<span class="sd">         result.b1=b1</span>
<span class="sd">         result.dx=dx</span>
<span class="sd">         result.insidegrid=insidegrid</span>
<span class="sd">         return result</span>
<span class="sd">     #</span>
<span class="sd">     # test it</span>
<span class="sd">     q=np.r_[0.01:5:0.02]</span>
<span class="sd">     data=dumbbell(q,3,2,1)</span>

<span class="sd">     # show result configuration</span>
<span class="sd">     js.mpl.scatter3d(data.insidegrid[:,0],data.insidegrid[:,1],data.insidegrid[:,2])</span>
<span class="sd">     #</span>
<span class="sd">     # Fit your data like this.</span>
<span class="sd">     # It may be a good idea to use not the highest resolution in the beginning because of speed.</span>
<span class="sd">     # If you have a good set of starting parameters you can decrease dx.</span>
<span class="sd">     data2=data.prune(number=100)</span>
<span class="sd">     data2.makeErrPlot(yscale=&#39;l&#39;)</span>

<span class="sd">     data2=data.prune(number=100)</span>
<span class="sd">     data2.makeErrPlot(yscale=&#39;l&#39;)</span>
<span class="sd">     data2.setLimit(R1=[None,None,1,4],A=[None,None,1,10])</span>

<span class="sd">     # this results in a fast but bad fit result</span>
<span class="sd">     # a local minima is found but the basics is working.</span>
<span class="sd">     data2.fit(model=dumbbell,</span>
<span class="sd">                freepar={&#39;A&#39;:3,&#39;R1&#39;:2.4,&#39;b1&#39;:1},</span>
<span class="sd">                fixpar={&#39;dx&#39;:0.3,&#39;bgr&#39;:0},</span>
<span class="sd">                mapNames={&#39;q&#39;:&#39;X&#39;},factor=1)</span>

<span class="sd">     # To get a good result we need to find the global minimum by a different algorithm (&#39;differential evolution&#39;)</span>
<span class="sd">     # The limits are used as border to search in an limited area.</span>
<span class="sd">     # The fit takes about 3500 iterations (1000s on Ryzen 1600X 6 cores)</span>
<span class="sd">     data2.fit(model=dumbbell,method=&#39;differential_evolution&#39;,</span>
<span class="sd">                freepar={&#39;A&#39;:3,&#39;R1&#39;:2.4,&#39;b1&#39;:1},</span>
<span class="sd">                fixpar={&#39;dx&#39;:0.3,&#39;bgr&#39;:0},</span>
<span class="sd">                mapNames={&#39;q&#39;:&#39;X&#39;})</span>

<span class="sd">    Fit a sphere formfactoramp.</span>

<span class="sd">    The quality of the grid approximation (number of gridpoints) may</span>
<span class="sd">    improve the correct description of higher order minima.</span>
<span class="sd">    ::</span>

<span class="sd">     import numpy as np</span>
<span class="sd">     import jscatter as js</span>

<span class="sd">     # a function to discriminate what is inside of the sphere</span>
<span class="sd">     # basically a superball p2=2 is a sphere</span>
<span class="sd">     inside=lambda xyz,R1,p2:(np.abs(xyz[:,0]))**p2+(np.abs(xyz[:,1]))**p2+(np.abs(xyz[:,2]))**p2&lt;=R1**2</span>

<span class="sd">     def test(q,R,b,p2=2,relError=20):</span>
<span class="sd">         # make cubic grid with right size (increase NN for better approximation)</span>
<span class="sd">         NN=20</span>
<span class="sd">         grid= np.mgrid[-R:R:1j*NN, -R:R:1j*NN,-R:R:1j*NN].reshape(3,-1).T</span>
<span class="sd">         # cut the edges to get a sphere</span>
<span class="sd">         insidegrid=grid[inside(grid,R,p2)]</span>
<span class="sd">         # add scattering length for points</span>
<span class="sd">         # the average scattering length density is sum(b)/sphereVolume</span>
<span class="sd">         insidegrid=np.c_[insidegrid,insidegrid[:,0]*0]</span>
<span class="sd">         insidegrid[:,3]=b</span>
<span class="sd">         # calc formfactor (normalised) for a single sphere</span>
<span class="sd">         ffs=js.ff.cloudScattering(q,insidegrid,relError=relError)</span>
<span class="sd">         # the total scattering is sumblength**2</span>
<span class="sd">         ffs.Y*=ffs.sumblength**2</span>
<span class="sd">         # save radius and the grid for later</span>
<span class="sd">         ffs.R=R</span>
<span class="sd">         ffs.insidegrid=insidegrid</span>
<span class="sd">         return ffs</span>

<span class="sd">     ####main</span>
<span class="sd">     q=np.r_[0:3:0.01]</span>
<span class="sd">     sp=js.formfactor.sphere(q,3,1)</span>

<span class="sd">     sp.makeErrPlot(yscale=&#39;l&#39;)   # show intermediate results</span>
<span class="sd">     sp.setlimit(R=[0.3,10])      # set some reasonable limits for R</span>
<span class="sd">     sp.fit(model=test,</span>
<span class="sd">         freepar={&#39;b&#39;:6,&#39;R&#39;:2.1},</span>
<span class="sd">         fixpar={},</span>
<span class="sd">         mapNames={&#39;q&#39;:&#39;X&#39;})</span>

<span class="sd">     # show the resulting sphere grid</span>
<span class="sd">     resultgrid=sp.lastfit.insidegrid</span>
<span class="sd">     js.mpl.scatter3d(resultgrid[:,0],resultgrid[:,1],resultgrid[:,2])</span>

<span class="sd">    Here we compare explicit calculation with the Debye equation as the later gets quite slow for larger numbers.</span>
<span class="sd">    ::</span>

<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     R=6;NN=20</span>
<span class="sd">     q=np.r_[0:5:0.1]</span>
<span class="sd">     grid=js.formel.randomPointsInCube(10000)*R-R/2</span>
<span class="sd">     ffe=js.ff.cloudScattering(q,grid,relError=150)    # takes about  1.3 s on six core</span>
<span class="sd">     ffd=js.ff.cloudScattering(q,grid,relError=0)      # takes about 11.4 s on six core</span>
<span class="sd">     grid=js.formel.randomPointsInCube(500)*R-R/2</span>
<span class="sd">     ffe=js.ff.cloudScattering(q,grid,relError=150)    # takes about 132 ms on six core</span>
<span class="sd">     ffd=js.ff.cloudScattering(q,grid,relError=0)      # takes about  33 ms on six core</span>

<span class="sd">     p=js.grace()</span>
<span class="sd">     p.plot(ffe)</span>
<span class="sd">     p.plot(ffd)</span>
<span class="sd">     p.yaxis(scale=&#39;l&#39;)</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M. Kotlarchyk and S.-H. Chen, J. Chem. Phys. 79, 2461 (1983).1</span>
<span class="sd">    .. [2] An improved method for calculating the contribution of solvent to</span>
<span class="sd">           the X-ray diffraction pattern of biological molecules</span>
<span class="sd">           Fraser R MacRae T Suzuki E IUCr Journal of Applied Crystallography 1978 vol: 11 (6) pp: 693-694</span>
<span class="sd">    .. [3] X-ray diffuse scattering by proteins in solution. Consideration of solvent influence</span>
<span class="sd">           B. A. Fedorov, O. B. Ptitsyn and L. A. Voronin</span>
<span class="sd">           J. Appl. Cryst. (1974). 7, 181-186 doi: 10.1107/S0021889874009137</span>
<span class="sd">    .. [4] Zerstreuung von Röntgenstrahlen</span>
<span class="sd">           Debye P. Annalen der Physik 1915 vol: 351 (6) pp: 809-823 DOI: 10.1002/andp.19153510606</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="c1"># last columns are scattering length and iff</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">iff</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># index in formfactoramp</span>
        <span class="n">cloud</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># last column is scattering length</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">cloud</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">sumblength</span> <span class="o">=</span> <span class="n">blength</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">relError</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">relError</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formfactoramp</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">formfactoramp</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">):</span>
            <span class="c1"># gaussian shape</span>
            <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">q</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">V</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">formfactoramp</span> <span class="o">=</span> <span class="s1">&#39;gaussian&#39;</span>
            <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">formfactoramp</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">):</span>
            <span class="c1"># sphere</span>
            <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.</span> <span class="o">*</span> <span class="n">V</span> <span class="o">/</span> <span class="mf">4.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span>
            <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">_fa_sphere</span><span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">R</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">formfactoramp</span> <span class="o">=</span> <span class="s1">&#39;sphere&#39;</span>
            <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">formfactoramp</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">):</span>
            <span class="c1"># polymer coil showing Debye scattering</span>
            <span class="n">Rg</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.</span> <span class="o">*</span> <span class="n">V</span> <span class="o">/</span> <span class="mf">4.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span>
            <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">_fa_coil</span><span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">Rg</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">formfactoramp</span> <span class="o">=</span> <span class="s1">&#39;polymer&#39;</span>
            <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formfactoramp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">formfactoramp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">fa</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="n">fa</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">formfactoramp</span> <span class="o">=</span> <span class="s1">&#39;explicit&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># const form factor as default</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">q</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">formfactoramp</span> <span class="o">=</span> <span class="s1">&#39;constant&#39;</span>
        <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">relError</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Debye equation</span>
        <span class="c1"># no asymmetry factor beta, no rms, no ffpolydispersity</span>
        <span class="k">if</span> <span class="n">useFortran</span><span class="p">:</span>
            <span class="c1"># about 4 timesfaster than below python version on single core</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">fscatter</span><span class="o">.</span><span class="n">cloud</span><span class="o">.</span><span class="n">scattering_debye</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cloud</span><span class="p">,</span> <span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="p">,</span> <span class="n">fa</span><span class="p">,</span> <span class="n">ncpu</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dA</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sumblength</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># res=[_scattering_Debye(qx, cloud, blength, iff, fa) for qx in q]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">parallel</span><span class="o">.</span><span class="n">doForList</span><span class="p">(</span><span class="n">_scattering_Debye</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span>
                                     <span class="n">r</span><span class="o">=</span><span class="n">cloud</span><span class="p">,</span> <span class="n">blength</span><span class="o">=</span><span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="o">=</span><span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="o">=</span><span class="n">fa</span><span class="p">,</span>
                                     <span class="n">ncpu</span><span class="o">=</span><span class="n">ncpu</span><span class="p">,</span> <span class="n">loopover</span><span class="o">=</span><span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">dA</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">res</span> <span class="o">/</span> <span class="n">sumblength</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">columnname</span> <span class="o">=</span> <span class="s1">&#39;q; Pq&#39;</span>
    <span class="k">elif</span> <span class="n">relError</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># explicit average</span>
        <span class="c1"># allows asymmetry factor beta, rms, ffpolydispersity</span>
        <span class="k">if</span> <span class="n">useFortran</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">parallel</span><span class="o">.</span><span class="n">doForList</span><span class="p">(</span><span class="n">_sphaverage_scattering</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span>
                                     <span class="n">r</span><span class="o">=</span><span class="n">cloud</span><span class="p">,</span> <span class="n">blength</span><span class="o">=</span><span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="o">=</span><span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="o">=</span><span class="n">fa</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="n">rms</span><span class="p">,</span>
                                     <span class="n">ffpolydispersity</span><span class="o">=</span><span class="n">ffpolydispersity</span><span class="p">,</span>
                                     <span class="n">ncpu</span><span class="o">=</span><span class="n">ncpu</span><span class="p">,</span> <span class="n">relError</span><span class="o">=</span><span class="n">relError</span><span class="p">,</span> <span class="n">loopover</span><span class="o">=</span><span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># in _scattering there is a choice to use pure python; the above instant fortran call is 20% faster</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">parallel</span><span class="o">.</span><span class="n">doForList</span><span class="p">(</span><span class="n">formel</span><span class="o">.</span><span class="n">sphereAverage</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">_scattering</span><span class="p">,</span>
                                     <span class="n">r</span><span class="o">=</span><span class="n">cloud</span><span class="p">,</span> <span class="n">blength</span><span class="o">=</span><span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="o">=</span><span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="o">=</span><span class="n">fa</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="n">rms</span><span class="p">,</span>
                                     <span class="n">ffpolydispersity</span><span class="o">=</span><span class="n">ffpolydispersity</span><span class="p">,</span>
                                     <span class="n">ncpu</span><span class="o">=</span><span class="n">ncpu</span><span class="p">,</span> <span class="n">relError</span><span class="o">=</span><span class="n">relError</span><span class="p">,</span> <span class="n">loopover</span><span class="o">=</span><span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># the third row is F(Q)</span>
        <span class="c1"># asymmetry factor beta according to Chen  beta=|&lt;F(Q)&gt;|²/&lt;|F(Q)|²&gt;</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span> <span class="o">/</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sumblength</span> <span class="o">**</span> <span class="mi">2</span>  <span class="c1"># normalisation</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">sumblength</span>       <span class="c1"># normalisation</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">dA</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">beta</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">columnname</span> <span class="o">=</span> <span class="s1">&#39;q; Pq; beta; fa&#39;</span>

    <span class="n">result</span><span class="o">.</span><span class="n">sumblength</span> <span class="o">=</span> <span class="n">sumblength</span>
    <span class="n">result</span><span class="o">.</span><span class="n">I0</span> <span class="o">=</span> <span class="n">sumblength</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">result</span><span class="o">.</span><span class="n">formfactoramplitude_q</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">result</span><span class="o">.</span><span class="n">formfactoramplitude</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">result</span><span class="o">.</span><span class="n">formfactor</span> <span class="o">=</span> <span class="n">formfactoramp</span>
    <span class="n">result</span><span class="o">.</span><span class="n">rms</span> <span class="o">=</span> <span class="n">rms</span>
    <span class="n">result</span><span class="o">.</span><span class="n">ffpolydispersity</span> <span class="o">=</span> <span class="n">ffpolydispersity</span>
    <span class="n">result</span><span class="o">.</span><span class="n">setColumnIndex</span><span class="p">(</span><span class="n">iey</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="n">result</span><span class="o">.</span><span class="n">modelname</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span>
    <span class="k">return</span> <span class="n">result</span></div>


<span class="k">def</span> <span class="nf">_getGaussMosaic</span><span class="p">(</span><span class="n">mosaicity</span><span class="p">,</span> <span class="n">nCone</span><span class="p">):</span>
    <span class="c1"># get mosaic rotations for integration with weight</span>
    <span class="c1"># mosaicity = [width , phi, theta] in rad; nCon number of points</span>
    <span class="c1"># returns a list of rotation vectors v[:3] and weights [4]</span>
    <span class="c1"># rotation vector is vector to rotate around and |vector| is angle to rotate</span>
    <span class="n">mo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mosaicity</span><span class="p">)</span>
    <span class="c1"># determine rotation from center to mosaic orientation with a weight for integrations</span>
    <span class="c1"># first get Fibonacci lattice points around [0,0,1] as mosaic pattern,</span>
    <span class="c1"># ([0,0,1] is not included in Fib lattice points)</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">mo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
        <span class="c1"># we use the angular deviation for Gaussian weight</span>
        <span class="c1"># adjust fib lattice to get in final area nCone points  () but not more than full sphere</span>
        <span class="c1"># factor 2.5 for later Gauss weight</span>
        <span class="n">qfib</span> <span class="o">=</span> <span class="n">formel</span><span class="o">.</span><span class="n">fibonacciLatticePointsOnSphere</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">nCone</span><span class="o">/</span><span class="nb">min</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">mo</span><span class="p">[</span><span class="mi">0</span><span class="p">])))))</span>
        <span class="n">qfib</span> <span class="o">=</span> <span class="n">qfib</span><span class="p">[</span><span class="n">qfib</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">2.5</span><span class="o">*</span><span class="n">mo</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">:]</span>  <span class="c1"># select upper sphere theta&lt;2*mo[0]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># equal weight</span>
        <span class="n">qfib</span> <span class="o">=</span> <span class="n">formel</span><span class="o">.</span><span class="n">fibonacciLatticePointsOnSphere</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">nCone</span> <span class="o">/</span><span class="nb">min</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">mo</span><span class="p">[</span><span class="mi">0</span><span class="p">]))))))</span>
        <span class="n">qfib</span> <span class="o">=</span> <span class="n">qfib</span><span class="p">[</span><span class="n">qfib</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">mo</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">:]</span>  <span class="c1"># select upper sphere theta&lt;abs(mo[0])</span>

    <span class="n">qfibxyz</span> <span class="o">=</span> <span class="n">formel</span><span class="o">.</span><span class="n">rphitheta2xyz</span><span class="p">(</span><span class="n">qfib</span><span class="p">)</span>
    <span class="c1"># rotate qfib to given orientation center</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;yz&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">mo</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">mo</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">rot</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]</span>
    <span class="n">rotfib</span> <span class="o">=</span> <span class="p">(</span><span class="n">rot</span> <span class="o">@</span> <span class="n">qfibxyz</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># @ is matrix multiplication</span>
    <span class="c1"># determine rotation from center to rotfib points</span>
    <span class="n">cr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">rotfib</span><span class="p">)</span>    <span class="c1"># rotation vector perp to both; is normalized as center and rotfib are</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">center</span> <span class="o">@</span> <span class="n">rotfib</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>    <span class="c1"># get rotation angle</span>

    <span class="c1"># cr multiply by angle in rad =rotvector; append integration weight</span>
    <span class="c1"># mosaic is rotation vector with norm as angle and last ist integration weight</span>
    <span class="c1"># rotation vectors x3 as normal vector with vector length =angle, weight is gaussian weight</span>
    <span class="k">if</span> <span class="n">mo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">formel</span><span class="o">.</span><span class="n">gauss</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mo</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">Y</span>  <span class="c1"># fib points represent equal area on sphere</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

    <span class="n">mosaic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">cr</span> <span class="o">*</span> <span class="n">angle</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">weight</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">/</span> <span class="n">weight</span><span class="o">.</span><span class="n">sum</span><span class="p">()])</span>
    <span class="k">return</span> <span class="n">mosaic</span>


<div class="viewcode-block" id="orientedCloudScattering"><a class="viewcode-back" href="../../formfactor.html#jscatter.cloudscattering.orientedCloudScattering">[docs]</a><span class="k">def</span> <span class="nf">orientedCloudScattering</span><span class="p">(</span><span class="n">qxzw</span><span class="p">,</span> <span class="n">cloud</span><span class="p">,</span> <span class="n">mosaicity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="n">V</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="n">nCone</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">ncpu</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Oriented 3D scattering of a cloud of isotropic particles.</span>

<span class="sd">    - Cloud can represent an object/lattice described by a cloud of isotropic scatterers</span>
<span class="sd">      to describe formfactors or structure factors.</span>
<span class="sd">    - Scattering amplitudes may be constant, sphere scattering amplitude,</span>
<span class="sd">      Gaussian scattering amplitude or explicitly given form factor.</span>
<span class="sd">    - For mean cloud particle distance *d* one expects Bragg peaks or structure factor peaks around 2π/d.</span>
<span class="sd">    - In a scattering geometry with the incoming beam along the cloud z-axis a flat small angle detector</span>
<span class="sd">      depicts the projection of the Ewald sphere onto the :math:`q_xq_y`-plane (see sas).</span>
<span class="sd">      Only for small angle scattering one might assume z=0.</span>
<span class="sd">    - Instead of rotating the cloud by rotation matrix :math:`R` we may rotate the reciprocal space by :math:`R^T`</span>
<span class="sd">      to result in a rotating crystal method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    qxzw : array, ndim= Nx3</span>
<span class="sd">         3D wavevectors in 1/nm.</span>
<span class="sd">         Wavevectors may represent a line, a plane or any other 3D distribution in reciprocal space</span>
<span class="sd">         (e.g. Ewald-sphere surface).</span>
<span class="sd">         If 2D (ndim=Nx2) the 3rd dim is set to zero.</span>
<span class="sd">    cloud : array Nx3, Nx4, Nx5</span>
<span class="sd">        Positions (center of mass) and type of particles.</span>

<span class="sd">        - cloud[:,3] Center of mass positions (in nm) of the N scatterers in the cloud.</span>
<span class="sd">        - cloud[:,3] scattering length :math:`b` at positions cloud[:,:3], optional, otherwise :math:`b=1`.</span>
<span class="sd">        - cloud[:,4] column index in formfactoramp for a specific scatterer, optional.</span>
<span class="sd">    rms : float, default=0</span>
<span class="sd">        Root mean square displacement :math:`\langleu^2\rangle^{0.5} of the positions in cloud as random</span>
<span class="sd">        displacements in nm. The displacement is randomly chosen for each orientation (nCone).</span>
<span class="sd">        rms can be used to simulate a Debye-Waller factor.</span>
<span class="sd">        **nCone&gt;&gt;50 with mosaicity&gt;0 or rms&gt;0 is advised to yield reasonable average and reduced noise**.</span>
<span class="sd">    mosaicity : list 3 float, default None</span>
<span class="sd">        Mosaicity describes a Gaussian distribution of crystallite orientations around a reference orientation [1]_.</span>
<span class="sd">        The mosaicity is commonly equated with the standard deviation of the Gaussian [2]_.</span>
<span class="sd">        Here mosaicity = [width, phi, theta] (units rad) with</span>
<span class="sd">          - width</span>
<span class="sd">             - &gt;0 : Gaussian distribution weight (cut at π) with width=sigma.</span>
<span class="sd">             - &lt;0 : equal weight within width.</span>
<span class="sd">          - phi as azimuthal angle of reference orientation in spherical coordinates (phi=0, theta=π/2 is x axis)</span>
<span class="sd">          - theta as altitude angle of reference  orientation in spherical coordinates (theta=0 is Z axis)</span>
<span class="sd">        - 3° around the X-axis [np.deg2rad(3),0,π/2]</span>
<span class="sd">        - 5° around the Y-axis [np.deg2rad(5),π/2,π/2]</span>
<span class="sd">        - 5° around the Z-axis [np.deg2rad(5),0,0]</span>
<span class="sd">        Integration is limited to 2.5*sigma in the Gaussian.</span>
<span class="sd">    nCone : int</span>
<span class="sd">        Number of points in mosaicity distribution as Fibonacci lattice points.</span>
<span class="sd">    formfactoramp : None,&#39;gauss&#39;,&#39;sphere&#39;,&#39;cube&#39;</span>
<span class="sd">        Normalized scattering amplitudes of cloud points :math:`\hat{F_a^i}(q)`.</span>
<span class="sd">        :math:`F_a(q)=b_i \hat{F_a^i}(q)` with  bi from cloud[3].</span>
<span class="sd">         - None    : const scattering amplitude.</span>
<span class="sd">         - &#39;sphere&#39;: Sphere scattering amplitude according to [3]_ equal for all cloud points.</span>
<span class="sd">                     Parameter V is needed to determine :math:`R`.</span>
<span class="sd">                     The sphere radius is :math:`R=(\frac{3V}{4\pi})^{1/3}`</span>
<span class="sd">         - &#39;gauss&#39; : Gaussian function  :math:`\hat{F_a}(q) = exp(-\pi V^{2/3}q^2)` according to [2]_</span>
<span class="sd">                     Equal for all cloud points. The Gaussian shows no artificial minima compared to the sphere.</span>
<span class="sd">                     Use parameter V to determine :math:`b_i`.</span>
<span class="sd">         - &#39;coil&#39; :  Polymer coil (ideal Gaussian chain) showing scattering according to Debye function equal for all.</span>
<span class="sd">                     Parameter V needed to determine :math:`R_g = (\frac{3V}{4\pi})^{1/3}`.</span>
<span class="sd">                     The scattering length is :math:`b_i = Nb_{monomer}` with monomer number :math:`N`.</span>
<span class="sd">         - Explicit isotropic :math:`\hat{F_a}(q)` as array with [q,fa1(q),fa2(q),fa3(q),....].</span>
<span class="sd">            - If multiple fai are given the index i for a cloud point needs to be given in cloud[4]</span>
<span class="sd">            - The normalized scattering amplitude fa for each cloud point is calculated as fa=fai/fai[0].</span>
<span class="sd">              Missing values are linear interpolated, q values outside interval are mapped to qmin or qmax.</span>
<span class="sd">            - Explicit formfactoramps are assumed to be isotropic.</span>
<span class="sd">            - If the scattering amplitude is not known :math:`F_a(q) \approx F^{1/2}(q)`</span>
<span class="sd">              might be used as approximation for low Q.</span>
<span class="sd">    V : float, default=None</span>
<span class="sd">        Volume of the scatterers to determine scattering amplitude (see formfactoramp).</span>
<span class="sd">        Only needed for formfactoramp &#39;sphere&#39; and &#39;gauss&#39;.</span>
<span class="sd">    ncpu : int, default 0</span>
<span class="sd">        Number of cpus used in the pool for multiprocessing.</span>
<span class="sd">         - not given or 0 : all cpus are used</span>
<span class="sd">         - int&gt;0          : min(ncpu, mp.cpu_count)</span>
<span class="sd">         - int&lt;0          : ncpu not to use</span>
<span class="sd">         - 1              : single core usage for testing or comparing speed to Debye</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dataArray</span>
<span class="sd">        Columns [qx, qz, qw, Pq]</span>
<span class="sd">         - The forward scattering is Pq(q=0)= sumblength**2</span>
<span class="sd">         - .sumblength : Sum of blength with sumblength**2</span>
<span class="sd">         - .formfactoramplitude : formfactoramplitude of cloudpoints according to type for all q values.</span>
<span class="sd">         - .formfactoramplitude_q :corresponding q values.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    How to use orientedCloudScattering for fitting see last Example in cloudScattering.</span>

<span class="sd">    Two point particles on y-axis result in pattern cos**2,</span>
<span class="sd">    Mosaicity creates incomplete 2d Debye-Scherer like rings. rms smears larger q. ::</span>

<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     from scipy.spatial.transform import Rotation</span>

<span class="sd">     # detector planes for z=0, y=0, x=0</span>
<span class="sd">     q = np.mgrid[-6:6:51j, -6:6:51j].reshape(2,-1).T</span>
<span class="sd">     qz =np.c_[q,np.zeros_like(q[:,0])]  # flat detector in experiment has z!=0</span>
<span class="sd">     qy = (Rotation.from_euler(&#39;x&#39;,np.pi/2).as_matrix() @ qz.T).T</span>
<span class="sd">     qx = (Rotation.from_euler(&#39;y&#39;,np.pi/2).as_matrix() @ qz.T).T</span>

<span class="sd">     # to show as cube surfaces</span>
<span class="sd">     fig = js.mpl.figure(figsize=[8, 3],dpi=200)</span>
<span class="sd">     ax1 = fig.add_subplot(1, 4, 1, projection=&#39;3d&#39;)</span>
<span class="sd">     ax2 = fig.add_subplot(1, 4, 2, projection=&#39;3d&#39;)</span>
<span class="sd">     ax3 = fig.add_subplot(1, 4, 3, projection=&#39;3d&#39;)</span>
<span class="sd">     ax4 = fig.add_subplot(1, 4, 4, projection=&#39;3d&#39;)</span>
<span class="sd">     fig.suptitle(&#39;Two points along Y&#39;)</span>

<span class="sd">     # two points (constant formfactor)</span>
<span class="sd">     rod2=np.zeros([2,3])</span>
<span class="sd">     rod2[:,1]=np.r_[0,np.pi]  # position on y axis</span>

<span class="sd">     mo = [np.deg2rad(5),0,0]</span>
<span class="sd">     ffz2 = js.ff.orientedCloudScattering(qz,rod2,rms=0,mosaicity=mo,nCone=50)</span>
<span class="sd">     ffy2 = js.ff.orientedCloudScattering(qy,rod2,rms=0,mosaicity=mo,nCone=50)</span>
<span class="sd">     ffx2 = js.ff.orientedCloudScattering(qx,rod2,rms=0,mosaicity=mo,nCone=50)</span>
<span class="sd">     ax = js.mpl.contourOnCube(ffz2[[0,1,3]].array,ffx2[[1,2,3]].array,ffy2[[0,2,3]].array,offset=[-6,-6,6], ax=ax1)</span>
<span class="sd">     ax.set_title(&#39;5° mosaicity \nalong z-axis&#39;,size=&#39;small&#39;)</span>

<span class="sd">     mo = [np.deg2rad(25),0,0]</span>
<span class="sd">     ffz2 = js.ff.orientedCloudScattering(qz,rod2,rms=0,mosaicity=mo,nCone=150)</span>
<span class="sd">     ffy2 = js.ff.orientedCloudScattering(qy,rod2,rms=0,mosaicity=mo,nCone=150)</span>
<span class="sd">     ffx2 = js.ff.orientedCloudScattering(qx,rod2,rms=0,mosaicity=mo,nCone=150)</span>
<span class="sd">     ax = js.mpl.contourOnCube(ffz2[[0,1,3]].array,ffx2[[1,2,3]].array,ffy2[[0,2,3]].array,offset=[-6,-6,6], ax=ax2)</span>
<span class="sd">     ax.set_title(&#39;25° mosaicity \n along z-axis&#39;,size=&#39;small&#39;)</span>

<span class="sd">     mo = np.deg2rad([45,0,90])</span>
<span class="sd">     ffz2 = js.ff.orientedCloudScattering(qz,rod2,rms=0,mosaicity=mo,nCone=150)</span>
<span class="sd">     ffy2 = js.ff.orientedCloudScattering(qy,rod2,rms=0,mosaicity=mo,nCone=150)</span>
<span class="sd">     ffx2 = js.ff.orientedCloudScattering(qx,rod2,rms=0,mosaicity=mo,nCone=150)</span>
<span class="sd">     ax = js.mpl.contourOnCube(ffz2[[0,1,3]].array,ffx2[[1,2,3]].array,ffy2[[0,2,3]].array,offset=[-6,-6,6], ax=ax3)</span>
<span class="sd">     ax.set_title(&#39;45° mosaicity \n along x-axis&#39;,size=&#39;small&#39;)</span>

<span class="sd">     mo = [np.deg2rad(25),0,0]</span>
<span class="sd">     ffz2 = js.ff.orientedCloudScattering(qz,rod2,rms=0.2,mosaicity=mo,nCone=150)</span>
<span class="sd">     ffy2 = js.ff.orientedCloudScattering(qy,rod2,rms=0.2,mosaicity=mo,nCone=150)</span>
<span class="sd">     ffx2 = js.ff.orientedCloudScattering(qx,rod2,rms=0.2,mosaicity=mo,nCone=150)</span>
<span class="sd">     ax = js.mpl.contourOnCube(ffz2[[0,1,3]].array,ffx2[[1,2,3]].array,ffy2[[0,2,3]].array,offset=[-6,-6,6], ax=ax4)</span>
<span class="sd">     ax.set_title(&#39;25°mosaicity +rms=0.2 \n along x-axis&#39;,size=&#39;small&#39;)</span>

<span class="sd">     #ax.figure.savefig(js.examples.imagepath+&#39;/cloudMosaicity.jpg&#39;)</span>

<span class="sd">    .. image:: ../../examples/images/cloudMosaicity.jpg</span>
<span class="sd">     :width: 90 %</span>
<span class="sd">     :align: center</span>
<span class="sd">     :alt: filledSphere</span>

<span class="sd">    Same as above for a **cubic grid** of 5x5x5 point particles using ::</span>

<span class="sd">     cube = js.lattice.scLattice(2,[2,2,2]).XYZ</span>

<span class="sd">    See example *example_orientedCloudCube.py*</span>

<span class="sd">    .. image:: ../../examples/images/cloudMosaicitycube.jpg</span>
<span class="sd">     :width: 90 %</span>
<span class="sd">     :align: center</span>
<span class="sd">     :alt: filledSphere</span>

<span class="sd">    **5 spheres in line** with small position distortion and mosaicity 20° around z-axis::</span>

<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     rod0 = np.zeros([5, 3])</span>
<span class="sd">     rod0[:, 1] = np.r_[0, 1, 2, 3, 4] * 3</span>
<span class="sd">     qxzw = np.mgrid[-6:6:50j, -6:6:50j].reshape(2, -1).T</span>
<span class="sd">     mo = [np.deg2rad(20),0,0]</span>
<span class="sd">     ffe = js.ff.orientedCloudScattering(qxzw,rod0,formfactoramp=&#39;sphere&#39;,V=4/3.*np.pi*2**3,mosaicity=mo,rms=0.02)</span>
<span class="sd">     fig4 = js.mpl.surface(ffe.X, ffe.Z, np.log10(ffe.Y), colorMap=&#39;gnuplot&#39;)</span>
<span class="sd">     fig4.axes[0].set_title(&#39;5 spheres with R=2 along Z with noise (rms=0.02)&#39;)</span>
<span class="sd">     fig4.show()</span>


<span class="sd">    **Solution of oriented particle-composite** of 3 touching core shell particles with small position distortion.</span>
<span class="sd">    Here we add a isotropic Percus-Yevick structure factor as effective composite interaction</span>
<span class="sd">    between particle composites.</span>

<span class="sd">    The particles are oriented along x-axis to a tumbling around x-axis is represented by x-axis mosaicity</span>
<span class="sd">    ::</span>

<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     N=6    # number of particles</span>
<span class="sd">     Rc=2   # core radius</span>
<span class="sd">     Rs=6   # outer shell radius</span>
<span class="sd">     d=Rs*2 # distance of particles</span>
<span class="sd">     volumefraction=0.10  # single particles</span>
<span class="sd">     rms=1.5</span>
<span class="sd">     # position composite particles along X axis</span>
<span class="sd">     rod0 = np.zeros([N, 3])</span>
<span class="sd">     rod0[:, 0] = np.r_[0:N] * d  # positions</span>
<span class="sd">     # q grid</span>
<span class="sd">     qxzw = np.mgrid[-2:2:150j, -2:2:150j].reshape(2, -1).T</span>
<span class="sd">     # core shell formfactoramp for particles and use interpolation</span>
<span class="sd">     q = js.loglist(0.01, 7, 100)</span>
<span class="sd">     cs = js.ff.sphereCoreShell(q=q, Rc=Rc, Rs=Rs, bc=-0.1, bs=1, solventSLD=0)</span>
<span class="sd">     csa = cs[[0,2]]</span>
<span class="sd">     # oriented composite scattering</span>
<span class="sd">     ffe = js.ff.orientedCloudScattering(qxzw, rod0, formfactoramp=csa, mosaicity=np.deg2rad([5,0,90]), rms=rms)</span>
<span class="sd">     fig4a = js.mpl.contourImage(ffe.X, ffe.Z, ffe.Y, colorMap=&#39;gnuplot&#39;,scale=&#39;log&#39;)</span>
<span class="sd">     fig4a.axes[0].set_title(&#39;3 core shell particles with R=2 along X with noise&#39;)</span>

<span class="sd">     # add structure factor according to radial q component</span>
<span class="sd">     sf=js.sf.PercusYevick(q, Rs*N/2, eta=volumefraction*N)  # approximate higher radius</span>
<span class="sd">     qradial=np.linalg.norm(ffe[:3],axis=0)</span>
<span class="sd">     ffe.Y=ffe.Y*sf.interp(qradial)</span>
<span class="sd">     fig4b = js.mpl.contourImage(ffe.X, ffe.Z, ffe.Y, colorMap=&#39;gnuplot&#39;,scale=&#39;log&#39;)</span>
<span class="sd">     fig4b.axes[0].set_title(&#39;3 core shell particles with noise and interparticle interaction &#39;)</span>
<span class="sd">     #fig4b.savefig(js.examples.imagepath+&#39;/orientedCloudScattering.jpg&#39;)</span>

<span class="sd">    .. image:: ../../examples/images/orientedCloudScattering.jpg</span>
<span class="sd">     :width: 70 %</span>
<span class="sd">     :align: center</span>
<span class="sd">     :alt: orientedCloudScattering</span>


<span class="sd">    Make a slice for an angular region but with higher resolution to see the additional peaks due to alignment</span>
<span class="sd">    ::</span>

<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     # rod0 will be position of 5 points in a row</span>
<span class="sd">     rod0 = np.zeros([5, 3])</span>
<span class="sd">     rod0[:, 1] = np.r_[0, 1, 2, 3, 4] * 3</span>

<span class="sd">     qxzw = np.mgrid[-4:4:150j, -4:4:150j].reshape(2, -1).T    # xz plane grid</span>
<span class="sd">     # only as demo : extract q from qxzw</span>
<span class="sd">     qxzw = np.c_[qxzw, np.zeros_like(qxzw[:, 0])]              # add y=0 component</span>
<span class="sd">     qrpt = js.formel.xyz2rphitheta(qxzw)                     # spherical coordinates</span>
<span class="sd">     q = np.unique(sorted(qrpt[:, 0]))</span>

<span class="sd">     # or use interpolation; cs will be our formfactoramp</span>
<span class="sd">     q = js.loglist(0.01, 7, 100)</span>
<span class="sd">     cs = js.ff.sphereCoreShell(q=q, Rc=1, Rs=2, bc=0.1, bs=1, solventSLD=0)</span>
<span class="sd">     csa = cs[[0,2]]</span>

<span class="sd">     # calc scattering in plane qxzw</span>
<span class="sd">     ffe = js.ff.orientedCloudScattering(qxzw, rod0, formfactoramp=csa, mosaicity=np.deg2rad([5,0,0]), nCone=100, rms=0.05)</span>

<span class="sd">     # show it in surface plot</span>
<span class="sd">     fig4 = js.mpl.surface(ffe.X, ffe.Z, np.log10(ffe.Y), colorMap=&#39;gnuplot&#39;)</span>
<span class="sd">     fig4.axes[0].set_title(&#39;5 core shell particles with R=2 along Z with noise (rms=0.05)&#39;)</span>
<span class="sd">     fig4.show()</span>

<span class="sd">     # We do an explicit radial average</span>
<span class="sd">     # transform X,Z to spherical coordinates</span>
<span class="sd">     qphi=js.formel.xyz2rphitheta([ffe.X,ffe.Z,np.zeros_like(ffe.X)],transpose=True )[:,:2]</span>
<span class="sd">     # add qphi or use later rp[1] for selection</span>
<span class="sd">     ffb=ffe.addColumn(2,qphi.T)</span>
<span class="sd">     # select a portion of the phi angles</span>
<span class="sd">     phi=np.pi/2</span>
<span class="sd">     dphi=0.2</span>
<span class="sd">     ffn=ffb[:,(ffb[-1]&lt;phi+dphi)&amp;(ffb[-1]&gt;phi-dphi)]</span>
<span class="sd">     ffn.isort(-2)    # sort along radial q</span>
<span class="sd">     p=js.grace()</span>
<span class="sd">     p.plot(ffn[-2],ffn.Y,le=&#39;oriented spheres form factor&#39;)</span>
<span class="sd">     # compare to coreshell formfactoramp scaled</span>
<span class="sd">     p.plot(cs.X,csa.Y**2/cs.Y[0]*25,li=1,le=&#39;coreshell form factor&#39;)</span>
<span class="sd">     p.yaxis(label=&#39;F(Q,phi=90°+-11°)&#39;, scale=&#39;log&#39;)</span>
<span class="sd">     p.title(&#39;5 aligned core shell particle with additional interferences&#39;,size=1.)</span>
<span class="sd">     p.subtitle(&#39; due to sphere alignment dependent on observation angle&#39;)</span>

<span class="sd">     # 2: direct way with 2D q in xz plane</span>
<span class="sd">     rod0 = np.zeros([5, 3])</span>
<span class="sd">     rod0[:, 1] = np.r_[0, 1, 2, 3, 4] * 3</span>
<span class="sd">     x=np.r_[0.0:6:0.05]</span>
<span class="sd">     qxzw = np.c_[x, x*0,x*0]</span>
<span class="sd">     for alpha in np.r_[0:91:30]:</span>
<span class="sd">         R=js.formel.rotationMatrix(np.r_[0,0,1],np.deg2rad(alpha)) # rotate around Z axis</span>
<span class="sd">         qa=np.dot(R,qxzw.T).T[:,:2]</span>
<span class="sd">         mo=np.deg2rad([5,0,0])</span>
<span class="sd">         ffe = js.ff.orientedCloudScattering(qa, rod0, formfactoramp=csa, mosaicity=mo, nCone=100, rms=0.05)</span>
<span class="sd">         p.plot(x,ffe.Y,li=[1,2,-1],sy=0,le=&#39;alpha=%g&#39; %alpha)</span>
<span class="sd">     p.xaxis(label=r&#39;Q / nm\S-1&#39;)</span>
<span class="sd">     p.legend()</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M. Kotlarchyk and S.-H. Chen, J. Chem. Phys. 79, 2461 (1983).1</span>
<span class="sd">    .. [2] An improved method for calculating the contribution of solvent to</span>
<span class="sd">           the X-ray diffraction pattern of biological molecules</span>
<span class="sd">           Fraser R MacRae T Suzuki E IUCr Journal of Applied Crystallography 1978 vol: 11 (6) pp: 693-694</span>
<span class="sd">    .. [3] X-ray diffuse scattering by proteins in solution. Consideration of solvent influence</span>
<span class="sd">           B. A. Fedorov, O. B. Ptitsyn and L. A. Voronin J. Appl. Cryst. (1974). 7, 181-186</span>
<span class="sd">           doi: 10.1107/S0021889874009137</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">qxzw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># make 3D q with qz=0</span>
        <span class="n">qxzw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">qxzw</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">qxzw</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])]</span>

    <span class="k">if</span> <span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="c1"># last columns are scattering length and iff</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">iff</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># index in formfactoramp</span>
        <span class="n">cloud</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># last column is scattering length</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">cloud</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">sumblength</span> <span class="o">=</span> <span class="n">blength</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">mosaicity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># determine mosaic points for integrations as Fibonacci points with equal area distribution</span>
        <span class="c1"># we use the angular deviation for Gaussian weight</span>
        <span class="n">mosaic</span> <span class="o">=</span> <span class="n">_getGaussMosaic</span><span class="p">(</span><span class="n">mosaicity</span><span class="p">,</span> <span class="n">nCone</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># zero vector (no rotation) with weight 1</span>
        <span class="k">if</span> <span class="n">rms</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># get some statistics for rms</span>
            <span class="n">mosaic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]]</span> <span class="o">*</span> <span class="n">nCone</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mosaic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>

    <span class="c1"># generate reduced q list for formfactoramps</span>
    <span class="c1"># transform to spherical coordinates and make selective qlist</span>
    <span class="n">qrpt</span> <span class="o">=</span> <span class="n">formel</span><span class="o">.</span><span class="n">xyz2rphitheta</span><span class="p">(</span><span class="n">qxzw</span><span class="p">)</span>
    <span class="n">qround</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">qrpt</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">qred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">qround</span><span class="p">)</span>  <span class="c1"># reduced q list list to 10**-3 precision</span>

    <span class="c1"># define formfactoramp fa for qround</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formfactoramp</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">formfactoramp</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">):</span>
            <span class="c1"># gaussian shape</span>
            <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">qred</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">qred</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">V</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">formfactoramp</span> <span class="o">=</span> <span class="s1">&#39;gaussian&#39;</span>
            <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">formfactoramp</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">):</span>
            <span class="c1"># sphere</span>
            <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.</span> <span class="o">*</span> <span class="n">V</span> <span class="o">/</span> <span class="mf">4.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span>
            <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">qred</span><span class="p">,</span> <span class="n">_fa_sphere</span><span class="p">(</span><span class="n">qred</span> <span class="o">*</span> <span class="n">R</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">formfactoramp</span> <span class="o">=</span> <span class="s1">&#39;sphere&#39;</span>
            <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">formfactoramp</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">):</span>
            <span class="c1"># polymer coil showing Debye scattering</span>
            <span class="n">Rg</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.</span> <span class="o">*</span> <span class="n">V</span> <span class="o">/</span> <span class="mf">4.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span>
            <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">qred</span><span class="p">,</span> <span class="n">_fa_coil</span><span class="p">(</span><span class="n">qred</span> <span class="o">*</span> <span class="n">Rg</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">formfactoramp</span> <span class="o">=</span> <span class="s1">&#39;polymer&#39;</span>
            <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formfactoramp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">formfactoramp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">fa</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">formfactoramp</span> <span class="o">=</span> <span class="s1">&#39;explicit&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># const form factor as default</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">qred</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">qred</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">formfactoramp</span> <span class="o">=</span> <span class="s1">&#39;constant&#39;</span>
        <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># do mosaicaverage in fortran</span>
    <span class="n">FqFa</span> <span class="o">=</span> <span class="n">fscatter</span><span class="o">.</span><span class="n">cloud</span><span class="o">.</span><span class="n">mosaicaverage</span><span class="p">(</span><span class="n">qxzw</span><span class="o">=</span><span class="n">qxzw</span><span class="p">,</span> <span class="n">mosaic</span><span class="o">=</span><span class="n">mosaic</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">cloud</span><span class="p">,</span> <span class="n">blength</span><span class="o">=</span><span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="o">=</span><span class="n">iff</span><span class="p">,</span>
                                      <span class="n">formfactoramp</span><span class="o">=</span><span class="n">fa</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="n">rms</span><span class="p">,</span> <span class="n">ncpu</span><span class="o">=</span><span class="n">ncpu</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">dA</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">qxzw</span><span class="p">,</span> <span class="n">FqFa</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">sumblength</span> <span class="o">=</span> <span class="n">sumblength</span>
    <span class="n">result</span><span class="o">.</span><span class="n">formfactoramplitude_q</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">result</span><span class="o">.</span><span class="n">formfactoramplitude</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">result</span><span class="o">.</span><span class="n">formfactortype</span> <span class="o">=</span> <span class="n">formfactoramp</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">Volume</span> <span class="o">=</span> <span class="n">V</span>
    <span class="n">result</span><span class="o">.</span><span class="n">setColumnIndex</span><span class="p">(</span><span class="n">ix</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">iy</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">iz</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">iw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">iey</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">columnname</span> <span class="o">=</span> <span class="s1">&#39;qx; qz; qw; Pq; fa&#39;</span>

    <span class="n">result</span><span class="o">.</span><span class="n">modelname</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="orientedCloudScattering3Dff"><a class="viewcode-back" href="../../formfactor.html#jscatter.cloudscattering.orientedCloudScattering3Dff">[docs]</a><span class="k">def</span> <span class="nf">orientedCloudScattering3Dff</span><span class="p">(</span><span class="n">qxzw</span><span class="p">,</span> <span class="n">cloud</span><span class="p">,</span> <span class="n">mosaicity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dorient</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="n">nCone</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ncpu</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Oriented 3D scattering of a cloud of non-isotropic particles.</span>

<span class="sd">    - Cloud can represent an object/lattice described by a cloud of equal non-isotropic scatterers</span>
<span class="sd">      as e.g. as a lattice of oriented cuboids or ellipsoids.</span>
<span class="sd">    - Anisotropic formfactor amplitudes are fa_cuboid, fa_ellipsoid, fa_disc or can be calculated using</span>
<span class="sd">      *orientedCloudScattering(...)[[0,1,2,4]]* e.g. for sphere twins, triples or any other shape.</span>
<span class="sd">    - For mean cloud particle distance *d* one expects Bragg peaks or structure factor peaks around 2π/d.</span>
<span class="sd">    - In a scattering geometry with the incoming beam along the cloud z-axis a flat small angle detector</span>
<span class="sd">      depicts the projection of the Ewald sphere onto the :math:`q_xq_y`-plane (see sas).</span>
<span class="sd">      Only for small angle scattering one might assume z=0.</span>
<span class="sd">    - Instead of rotating the cloud by rotation matrix :math:`R` we may rotate the reciprocal space by :math:`R^T`</span>
<span class="sd">      to result in a rotating crystal method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    qxzw : array, ndim= Nx3, Nx2</span>
<span class="sd">         3D wavevectors (unit 1/nm) may represent a plane (e.g detector plane)</span>
<span class="sd">         or any other 3D distribution in reciprocal space as a line or the surface of the Ewald sphere.</span>

<span class="sd">         If 2D the 3rd dim (w) is set to zero for convenience.</span>
<span class="sd">    cloud : array Nx3, Nx4, Nx5, Nx6, Nx7</span>
<span class="sd">        Positions (center of mass) and orientations of individual particles in the cloud.</span>
<span class="sd">        Orientation angles describe the rotation of the non-isotropic scatterer relative to the used 3D formfactoramp</span>
<span class="sd">        with `yaw, pitch and roll angle &lt;https://en.wikipedia.org/wiki/Euler_angles#Tait–Bryan_angles&gt;`_ as</span>
<span class="sd">        rotations  around (in order) z-y&#39;-x&quot; (intrinsic) or x-y-z axes (extrinsic)</span>
<span class="sd">        leading to :math:`R = R_z(\theta) R_y(\phi) R_x(\psi)`.</span>

<span class="sd">        - cloud[:,:3] center of mass positions</span>
<span class="sd">        - cloud[:,3] scattering length :math:`b_i`</span>
<span class="sd">        - cloud[:,4] roll angle Ψ [0..2π] around extrinsic x axis.</span>
<span class="sd">        - cloud[:,5] pitch angle φ [0..2π] around extrinsic y axis.</span>
<span class="sd">        - cloud[:,6] yaw angle θ [0..π] around extrinsic z axis.</span>
<span class="sd">    mosaicity : list 3 float, default None</span>
<span class="sd">        Mosaicity describes a Gaussian distribution of crystallite orientations around a reference orientation [1]_.</span>
<span class="sd">        The mosaicity is commonly equated with the standard deviation of the Gaussian [2]_.</span>
<span class="sd">        Here mosaicity = [width, phi, theta] (units rad) with</span>
<span class="sd">          - width</span>
<span class="sd">             - &gt;0 : Gaussian distribution weight (cut at π) with width=sigma.</span>
<span class="sd">             - &lt;0 : equal weight within width.</span>
<span class="sd">          - phi as azimuthal angle of reference orientation in spherical coordinates (phi=0, theta=π/2 is x axis)</span>
<span class="sd">          - theta as altitude angle of reference  orientation in spherical coordinates (theta=0 is Z axis)</span>
<span class="sd">        - 3° around the X-axis [np.deg2rad(3),0,π/2]</span>
<span class="sd">        - 5° around the Y-axis [np.deg2rad(5),π/2,π/2]</span>
<span class="sd">        - 5° around the Z-axis [np.deg2rad(5),0,0]</span>
<span class="sd">        Integration is limited to 2.5*sigma in the Gaussian.</span>
<span class="sd">    rms : float, default=0</span>
<span class="sd">        Root mean square displacement :math:`\langleu^2\rangle^{0.5} of the positions in cloud as random</span>
<span class="sd">        displacements in nm. The displacement is randomly chosen for each orientation (nCone).</span>
<span class="sd">        rms can be used to simulate a Debye-Waller factor.</span>
<span class="sd">        **nCone&gt;&gt;50 with mosaicity&gt;0 or rms&gt;0 is advised to yield reasonable average and reduced noise**.</span>
<span class="sd">    dorient : float, default=0</span>
<span class="sd">        Width of Gaussian distribution (units rad) of roll,pitch and yaw angles in cloud particle orientation.</span>
<span class="sd">        **nCone&gt;&gt;50 with mosaicity&gt;0, rms&gt;0 or dorient&gt;0  is advised to yield reasonable average and reduced noise**.</span>
<span class="sd">    nCone : int, None, default 50</span>
<span class="sd">        Number of points in mosaicity distribution as Fibonacci lattice points.</span>
<span class="sd">    formfactoramp :  array 4xN</span>
<span class="sd">         - Explicit isotropic formfactor amplitude as array with [qx,qz,qw, fa(qx,qz,qw,)] and q in units 1/nm.</span>
<span class="sd">         - formfactoramp fa(q) is normalized fa-&gt;fa/fa(0,0,0).</span>
<span class="sd">         - Missing values are linear interpolated, q values outside interval are mapped to border values.</span>
<span class="sd">         - if shape is (N,4) automatic transpose is used.</span>
<span class="sd">    ncpu : int, default 0</span>
<span class="sd">        Number of cpus used in the pool for multiprocessing.</span>
<span class="sd">         - not given or 0 : all cpus are used</span>
<span class="sd">         - int&gt;0          : min(ncpu, mp.cpu_count)</span>
<span class="sd">         - int&lt;0          : ncpu not to use</span>
<span class="sd">         - 1              : single core usage for testing or comparing speed to Debye</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dataArray</span>
<span class="sd">        Columns [qx, qz, qw, Pq]</span>
<span class="sd">         - .sumblength : sum of blength with sum(cloud[:,3])</span>
<span class="sd">         - The forward scattering is :math:`Sq(q=0)= (\sum b_i)^2 = cloud[:,3].sum()^2`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    **Cubes along line, simple cubic and distorted **</span>
<span class="sd">    We depict the respective q=0 plane at the surface of a cube to present all 3 orientations.  ::</span>

<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     from scipy.spatial.transform import Rotation</span>

<span class="sd">     # detector planes; a real flat detector has z&gt;0</span>
<span class="sd">     q = np.mgrid[-9:9:51j, -9:9:51j].reshape(2,-1).T</span>
<span class="sd">     qz =np.c_[q,np.zeros_like(q[:,0])]  # for z=0</span>
<span class="sd">     qy = (Rotation.from_euler(&#39;x&#39;,np.pi/2).as_matrix() @ qz.T).T</span>
<span class="sd">     qx = (Rotation.from_euler(&#39;y&#39;,np.pi/2).as_matrix() @ qz.T).T</span>

<span class="sd">     # degree of disorder</span>
<span class="sd">     dorient=0</span>

<span class="sd">     # a 3D scattering amplitude of an asymmetric cube</span>
<span class="sd">     N=20</span>
<span class="sd">     R=np.linalg.norm(qz,axis=1).max()</span>
<span class="sd">     grid= js.sf.scLattice(R/N,N).XYZ</span>
<span class="sd">     fa = js.ff.fa_cuboid(*grid[:,:3].T,0.2,0.4,2)</span>

<span class="sd">     # create a rod of 2 cubes as demo</span>
<span class="sd">     rod2=np.zeros([2,6]);</span>
<span class="sd">     rod2[:,1] = np.r_[0,3]      # set y positions</span>
<span class="sd">     rod2[:,3] = 1               # set b</span>
<span class="sd">     rod2[:,4] = 0 #np.pi/2      # set azimuth angle φ</span>
<span class="sd">     rod2[:,5] = 0               # set altitude angle θ</span>
<span class="sd">     # look only at one</span>
<span class="sd">     ffz1 = js.ff.orientedCloudScattering3Dff(qz,cloud=rod2[:1], formfactoramp=fa,dorient=dorient)</span>
<span class="sd">     ffy1 = js.ff.orientedCloudScattering3Dff(qy,cloud=rod2[:1], formfactoramp=fa,dorient=dorient)</span>
<span class="sd">     ffx1 = js.ff.orientedCloudScattering3Dff(qx,cloud=rod2[:1], formfactoramp=fa,dorient=dorient)</span>

<span class="sd">     # a rod of 4 cubes</span>
<span class="sd">     rod4 = np.repeat([np.r_[0,0,0,1,0,0]],4,axis=0)</span>
<span class="sd">     rod4[:,0] = np.r_[0:6:4j]  # set distance along x axis</span>
<span class="sd">     ffz4 = js.ff.orientedCloudScattering3Dff(qz,cloud=rod4, formfactoramp=fa,dorient=dorient)</span>
<span class="sd">     ffy4 = js.ff.orientedCloudScattering3Dff(qy,cloud=rod4, formfactoramp=fa,dorient=dorient)</span>
<span class="sd">     ffx4 = js.ff.orientedCloudScattering3Dff(qx,cloud=rod4, formfactoramp=fa,dorient=dorient)</span>

<span class="sd">     # a small lattice of 3x3x3 cubes</span>
<span class="sd">     square27 = js.lattice.scLattice(2,[1,1,1]).points</span>
<span class="sd">     square27 = np.hstack([square27,np.zeros([square27.shape[0],2])])</span>
<span class="sd">     ffz27 = js.ff.orientedCloudScattering3Dff(qz,cloud=square27, formfactoramp=fa,dorient=dorient)</span>
<span class="sd">     ffy27 = js.ff.orientedCloudScattering3Dff(qy,cloud=square27, formfactoramp=fa,dorient=dorient)</span>
<span class="sd">     ffx27 = js.ff.orientedCloudScattering3Dff(qx,cloud=square27, formfactoramp=fa,dorient=dorient)</span>

<span class="sd">     square27[:,4] = np.pi/8</span>
<span class="sd">     ffz27pi = js.ff.orientedCloudScattering3Dff(qz,cloud=square27, formfactoramp=fa,dorient=dorient)</span>
<span class="sd">     ffy27pi = js.ff.orientedCloudScattering3Dff(qy,cloud=square27, formfactoramp=fa,dorient=dorient)</span>
<span class="sd">     ffx27pi = js.ff.orientedCloudScattering3Dff(qx,cloud=square27, formfactoramp=fa,dorient=dorient)</span>


<span class="sd">     # show as cube surfaces</span>
<span class="sd">     fig = js.mpl.figure(figsize=[10, 3.5])</span>
<span class="sd">     ax1 = fig.add_subplot(1, 4, 1, projection=&#39;3d&#39;)</span>
<span class="sd">     ax2 = fig.add_subplot(1, 4, 2, projection=&#39;3d&#39;)</span>
<span class="sd">     ax3 = fig.add_subplot(1, 4, 3, projection=&#39;3d&#39;)</span>
<span class="sd">     ax4 = fig.add_subplot(1, 4, 4, projection=&#39;3d&#39;)</span>
<span class="sd">     js.mpl.contourOnCube(ffz1[[0,1,3]].array,ffx1[[1,2,3]].array,ffy1[[0,2,3]].array,offset=[-9,-9,9],ax=ax1)</span>
<span class="sd">     ax1.set_title(&#39;Single cube&#39;)</span>
<span class="sd">     js.mpl.contourOnCube(ffz4[[0,1,3]].array,ffx4[[1,2,3]].array,ffy4[[0,2,3]].array,offset=[-9,-9,9],ax=ax2)</span>
<span class="sd">     ax2.set_title(&#39;4 cubes along x-axis&#39;)</span>
<span class="sd">     js.mpl.contourOnCube(ffz27[[0,1,3]].array,ffx27[[1,2,3]].array,ffy27[[0,2,3]].array,offset=[-9,-9,9],ax=ax3)</span>
<span class="sd">     ax3.set_title(&#39;3x3x3 grid of cubes&#39;)</span>
<span class="sd">     js.mpl.contourOnCube(ffz27pi[[0,1,3]].array,ffx27pi[[1,2,3]].array,ffy27pi[[0,2,3]].array,offset=[-9,-9,9],ax=ax4)</span>
<span class="sd">     ax4.set_title(&#39;3x3x3 grid \n22° rotated cubes&#39;)</span>
<span class="sd">     fig.suptitle(&#39;Cubes with shape x,y,z = 0.2,0.4,2&#39;)</span>
<span class="sd">     fig.tight_layout()</span>
<span class="sd">     #fig.savefig(js.examples.imagepath+&#39;/cubeScattering3D.jpg&#39;)</span>

<span class="sd">    Dependent on the arrangement structure factor peaks but are limited to regions with intensity in the formfactor.</span>
<span class="sd">    Rotating the cubes (22°) changes the pattern as shown on the rightmost.</span>

<span class="sd">    .. image:: ../../examples/images/cubeScattering3D.jpg</span>
<span class="sd">     :width: 90 %</span>
<span class="sd">     :align: center</span>
<span class="sd">     :alt: cubeScattering3D</span>

<span class="sd">    The same as above with **20° average disorder in orientation** ```dorient=np.deg2rad(20)``` leading to smearing</span>
<span class="sd">    of high Q patterns.</span>

<span class="sd">    .. image:: ../../examples/images/cubeScattering3Ddoreint20.jpg</span>
<span class="sd">     :width: 90 %</span>
<span class="sd">     :align: center</span>
<span class="sd">     :alt: cubeScattering3Ddoreint20</span>


<span class="sd">    **Build tetraeders of spheres and position on simple grid 3x3x3**</span>
<span class="sd">    We depict the respective q=0 plane at the surface of a cube to present all 3 orientations.  ::</span>

<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     from scipy.spatial.transform import Rotation</span>

<span class="sd">     # detector planes; a real flat detector has z&gt;0</span>
<span class="sd">     q = np.mgrid[-9:9:51j, -9:9:51j].reshape(2,-1).T</span>
<span class="sd">     qz =np.c_[q,np.zeros_like(q[:,0])]  # for z=0</span>
<span class="sd">     qy = (Rotation.from_euler(&#39;x&#39;,np.pi/2).as_matrix() @ qz.T).T</span>
<span class="sd">     qx = (Rotation.from_euler(&#39;y&#39;,np.pi/2).as_matrix() @ qz.T).T</span>

<span class="sd">     # a 3D scattering amplitude of a tetraeder of</span>
<span class="sd">     N=20</span>
<span class="sd">     R=np.linalg.norm(qz,axis=1).max()</span>
<span class="sd">     grid= js.sf.scLattice(R/N,N).XYZ</span>

<span class="sd">     # Tetraeder: 4 points on a unit sphere, centroid at the origin, with lower face level, edge length = sqrt(8/3)</span>
<span class="sd">     tetraeder = np.zeros([4,3])</span>
<span class="sd">     tetraeder[0]=np.r_[(8/9)**0.5,0,-1/3]</span>
<span class="sd">     tetraeder[0]=np.r_[-(2/9)**0.5, (2/3)**0.5,-1/3]</span>
<span class="sd">     tetraeder[0]=np.r_[-(2/9)**0.5,-(2/3)**0.5,-1/3]</span>
<span class="sd">     tetraeder[0]=np.r_[0,0,1]</span>
<span class="sd">     V=4/3*np.pi*((8/3)**0.5 * 0.2)**3  # 0.2* edge length</span>
<span class="sd">     fa = js.ff.orientedCloudScattering(grid[:,:3],cloud=tetraeder,formfactoramp=&#39;sphere&#39;,V=V)[[0,1,2,4]].array.T</span>

<span class="sd">     # a small lattice of 3x3x3 cubes</span>
<span class="sd">     cub27 = js.lattice.scLattice(2,[1,1,1]).points</span>
<span class="sd">     cub27 = np.hstack([cub27,np.zeros([cub27.shape[0],2])])</span>
<span class="sd">     ffz27 = js.ff.orientedCloudScattering3Dff(qz,cloud=cub27, formfactoramp=fa)</span>
<span class="sd">     ffy27 = js.ff.orientedCloudScattering3Dff(qy,cloud=cub27, formfactoramp=fa)</span>
<span class="sd">     ffx27 = js.ff.orientedCloudScattering3Dff(qx,cloud=cub27, formfactoramp=fa)</span>


<span class="sd">     # show as cube surfaces</span>
<span class="sd">     ax = js.mpl.contourOnCube(ffz27[[0,1,3]].array,ffx27[[1,2,3]].array,ffy27[[0,2,3]].array,offset=[-9,-9,9])</span>
<span class="sd">     ax.figure.suptitle(&#39;Tetraders in 3x3x3 cubic lattice&#39;)</span>
<span class="sd">     ax.figure.tight_layout()</span>
<span class="sd">     #ax.figure.savefig(js.examples.imagepath+&#39;/cloudTetraders.jpg&#39;)</span>


<span class="sd">    .. image:: ../../examples/images/cloudTetraders.jpg</span>
<span class="sd">     :width: 50 %</span>
<span class="sd">     :align: center</span>
<span class="sd">     :alt: filledSphere</span>


<span class="sd">    Look at the calculated formfactor of a single particle ::</span>

<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     # detector plane (z=0 will be added automatically), for real flat detector z will be small but !=0)</span>
<span class="sd">     qxzw = np.mgrid[-5:5:51j, -7:7:71j].reshape(2,-1).T</span>

<span class="sd">     # create a grid for the formfactor amplitude fa larger than maximum detector q.</span>
<span class="sd">     N=20</span>
<span class="sd">     R=np.linalg.norm(qxzw,axis=1).max()</span>
<span class="sd">     grid= js.sf.scLattice(R/N,N).XYZ #</span>
<span class="sd">     # formfactor amplitude with edge length a,b,c in xyz direction</span>
<span class="sd">     fa = js.ff.fa_cuboid(*grid[:,:3].T,0.31,3.141,0.31)</span>

<span class="sd">     # look at formfactor amplitude</span>
<span class="sd">     x,y,z,Y = fa[fa[:,2]==0].T</span>
<span class="sd">     figfa = js.mpl.surface(x,y,Y)</span>
<span class="sd">     figfa.axes[0].set_title(r&#39;formfactor amplitude $F_a$ with negative values&#39;)</span>

<span class="sd">     # to look at a single particle</span>
<span class="sd">     rod0=np.array([[0,0,0,1,0,0]])</span>
<span class="sd">     ffe=js.ff.orientedCloudScattering3Dff(qxzw,cloud=rod0, formfactoramp=fa)</span>
<span class="sd">     fig=js.mpl.surface(ffe.X,ffe.Z,ffe.Y)</span>
<span class="sd">     fig.axes[0].set_title(r&#39;formfactor $F_a^2$&#39;)</span>
<span class="sd">     fig.show()</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Darwin CG, Phil. Mag. 43, 800-829 (1922). (DOI: 10.1080/14786442208633940)</span>
<span class="sd">    .. [2] https://en.wikipedia.org/wiki/Mosaicity</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">qxzw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># make 3D q with qz=0</span>
        <span class="n">qxzw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">qxzw</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">qxzw</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])]</span>

    <span class="c1"># look at cloud</span>
    <span class="k">if</span> <span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">cloud</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">cloud</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">5</span><span class="p">]</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">cloud</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">5</span><span class="p">]</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">]</span>
        <span class="n">cloud</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Used shape of cloud not implemented.&#39;</span><span class="p">)</span>
    <span class="n">sumblength</span> <span class="o">=</span> <span class="n">blength</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">nCone</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nCone</span> <span class="o">=</span> <span class="mi">50</span>  <span class="c1"># default</span>
    <span class="k">if</span> <span class="n">mosaicity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># determine mosaic points for integrations as Fibonacci points with equal area distribution</span>
        <span class="c1"># we use the angular deviation for Gaussian weight or equal weight</span>
        <span class="n">mosaic</span> <span class="o">=</span> <span class="n">_getGaussMosaic</span><span class="p">(</span><span class="n">mosaicity</span><span class="p">,</span> <span class="n">nCone</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># zero vector with weight 1</span>
        <span class="k">if</span> <span class="n">rms</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">dorient</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mosaic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]]</span> <span class="o">*</span> <span class="n">nCone</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mosaic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>

    <span class="c1"># change if wrong orientation</span>
    <span class="k">if</span> <span class="n">formfactoramp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">formfactoramp</span> <span class="o">=</span> <span class="n">formfactoramp</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># do it in Fortran</span>
    <span class="n">Sq</span> <span class="o">=</span> <span class="n">fscatter</span><span class="o">.</span><span class="n">cloud</span><span class="o">.</span><span class="n">mosaicaverage3d</span><span class="p">(</span><span class="n">qxzw</span><span class="o">=</span><span class="n">qxzw</span><span class="p">,</span> <span class="n">mosaic</span><span class="o">=</span><span class="n">mosaic</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">cloud</span><span class="p">,</span> <span class="n">blength</span><span class="o">=</span><span class="n">blength</span><span class="p">,</span> <span class="n">dorient</span><span class="o">=</span><span class="n">dorient</span><span class="p">,</span>
                                        <span class="n">psi</span><span class="o">=</span><span class="n">psi</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="o">=</span><span class="n">formfactoramp</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="n">rms</span><span class="p">,</span>
                                        <span class="n">nr</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="n">formfactoramp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">)),</span> <span class="n">ncpu</span><span class="o">=</span><span class="n">ncpu</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Sq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="c1"># on error Sq will have negative integer IER, error indicator</span>
        <span class="c1"># from fortran routine QSHEP3. 0, if no errors were encountered.</span>
        <span class="k">if</span> <span class="n">Sq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># this should never happen, jsut to document it</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;formfactoramp error: N, NQ, NW, or NR is out of range.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">Sq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;formfactoramp error: duplicate nodes were encountered.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">Sq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;formfactoramp error: if all nodes are coplanar.&#39;</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">dA</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">qxzw</span><span class="p">,</span> <span class="n">Sq</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">sumblength</span> <span class="o">=</span> <span class="n">sumblength</span>
    <span class="n">result</span><span class="o">.</span><span class="n">I0</span> <span class="o">=</span> <span class="n">sumblength</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">result</span><span class="o">.</span><span class="n">rms</span> <span class="o">=</span> <span class="n">rms</span>
    <span class="n">result</span><span class="o">.</span><span class="n">mosaicity</span> <span class="o">=</span> <span class="n">mosaicity</span>
    <span class="n">result</span><span class="o">.</span><span class="n">dorient</span> <span class="o">=</span> <span class="n">dorient</span>
    <span class="n">result</span><span class="o">.</span><span class="n">setColumnIndex</span><span class="p">(</span><span class="n">ix</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">iy</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">iz</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">iw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">iey</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">columnname</span> <span class="o">=</span> <span class="s1">&#39;qx; qz; qw; Pq&#39;</span>

    <span class="n">result</span><span class="o">.</span><span class="n">modelname</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span>
    <span class="k">return</span> <span class="n">result</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/Jscatter1.gif" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../BeginnersGuide.html">1. Beginners Guide / Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dataArray.html">2. dataArray</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dataList.html">3. dataList</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../formel.html">4. formel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sas.html">5. smallanglescattering (sas)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../formfactor.html">6. formfactor (ff)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../structurefactor.html">7. structurefactor (sf)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dynamic.html">8. dynamic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dls.html">9. dls</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parallel.html">10. parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../GracePlot.html">11. Plotting in XmGrace</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mpl.html">12. mpl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">13. Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Extending.html">14. Extending/Contributing/Fortran</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tips.html">15. Tips</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Remarks.html">16. Intention and Remarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Installation.html">17. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../citing.html">18. Citing Jscatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">19. Changelog</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Jscatter 1.3.0.5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">jscatter.cloudscattering</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015-19, Ralf Biehl.
      Last updated on Mar 18, 2021.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.2.
    </div>
  </body>
</html>