import inspect
from lumipy.navigation.provider_definition import ProviderDefinition
from lumipy.query.expression.table.base_source_table import BaseSourceTable
from lumipy.query.expression.column.source_column import SourceColumn
from abc import ABCMeta
from lumipy.common.string_utils import indent_str
from typing import Type


# noinspection PyArgumentList,PyMethodParameters,PyTypeChecker
class ProviderClassFactory(ABCMeta):
    """Metaclass of all provider SourceTables. Each provider source table class is an instance of this metaclass.
    This approach allows the __init__ method of these classes to be altered to show the parameters they take and to
    generate a docstring for them from a ProviderDefinition. This is so it shows up in help() and shift+tab tooltips in
    Jupyter.

    """

    def __new__(mcs, provider_description: ProviderDefinition) -> Type[BaseSourceTable]:

        """Build a new instance of the metaclass (a provider table class that inherits from BaseSourceTable)

        Args:
            provider_description:
                A provider description object defining the features of the provider we are building a
                source table class for.
        Returns:
            BaseSourceTable: the provider source table class.
        """

        mcs.class_name = provider_description.get_table_name().replace('.', '')
        params = provider_description.list_parameters()
        namespace = {
            '_table_name': provider_description.get_table_name(),
            'provider_description': provider_description,
            'params': {param.name: param for param in params},
            '__init__': mcs.make_ctor(mcs, provider_description=provider_description),
            '_client': provider_description.get_client()
        }

        return super().__new__(mcs, mcs.class_name, (BaseSourceTable,), namespace)

    def make_ctor(mcs, provider_description: ProviderDefinition):
        """Build a replacement __init__ method for the provider source table class.

        Args:
            provider_description:
                A provider description object defining the features of the provider we are building a
                source table class for.
        Returns:
            Function that acts as a replacement class constructor in the provider source table class
            being built by this metaclass.

        """
        # Build ctor that takes prov params and assigns inst attrs
        from lumipy.query.expression.table.table_parameter_assignment import ParameterAssignment

        ctor_params = provider_description.list_parameters()
        param_names = [p.name for p in ctor_params]

        # Define the constructor function. This will be modified to document the class
        # generated by this metaclass.
        def __init__(self, **ctor_kwargs):
            param_assignments = {}
            for k, v in ctor_kwargs.items():
                if k not in param_names:
                    msg = f"'{k}' is not a parameter of the {type(self).__name__} data provider class.\n"
                    if len(param_names) > 0:
                        msg += f"Valid parameters are {', '.join(param_names)}."
                    else:
                        msg += f"This provider class does not have any parameters: try doing {type(self).__name__}()."
                    raise ValueError(
                        msg
                    )
                p_description = self.params[k]
                param_assignments[k] = ParameterAssignment(p_description, v)

            lineage = list(param_assignments.values())
            lineage.append(provider_description)
            table_hash = hash(sum(hash(p) for p in lineage))

            columns = [
                SourceColumn(c, table_hash, with_brackets=True)
                for c in provider_description.list_columns()
            ]
            # Call constructor of the base class to actually build the instance of the provider source
            # table class.
            super(type(self), self).__init__(
                provider_description.get_table_name(),
                columns,
                provider_description.get_client(),
                'provider',
                param_assignments,
                *lineage
            )

        # Alter the constructor's signature to match input params. This will allow the user to use help() or
        # shift+tab in jupyter to inspect it.
        params = [inspect.Parameter(
            param,
            inspect.Parameter.POSITIONAL_OR_KEYWORD
        ) for param in ['self'] + param_names]
        __init__.__signature__ = inspect.Signature(params)

        # Generate docstring and add it to the ctor
        doc_top_line = f'{mcs.class_name} source table:'
        doc_parts = ['__init__ Parameters:']
        for p in ctor_params:
            if isinstance(p.description, str) and len(p.description) > 0:
                description = p.description
            else:
                description = '[Parameter description not available.]'
            param_doc = f"{p.name}:\n  DataType: {p.data_type.name}\n  Description: {description}"
            doc_parts.append(indent_str(param_doc, 2))
        doc_body = indent_str('\n'.join(doc_parts), 2)
        __init__.__doc__ = f"{doc_top_line}\n{doc_body}"

        return __init__
