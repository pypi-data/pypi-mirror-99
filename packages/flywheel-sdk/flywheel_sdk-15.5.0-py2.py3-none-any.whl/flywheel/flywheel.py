# coding: utf-8

# flake8: noqa

"""
    Flywheel

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 15.5.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import


import codecs
import os
import sys
import six
import platform
import logging

log = logging.getLogger('Flywheel')

from flywheel.configuration import Configuration
from flywheel.api_client import ApiClient
from flywheel.view_builder import ViewBuilder
from flywheel.finder import Finder
import flywheel.api

SDK_VERSION = "15.5.0"

def config_from_api_key(api_key):
    parts = api_key.split(':')
    if len(parts) < 2:
        raise Exception('Invalid API key')

    host = parts[0]
    if len(parts) == 2:
        key = parts[1]
        port = '443'
    else:
        port = parts[1]
        key = parts[-1]

    if '__force_insecure' in parts:
        scheme = 'http'
    else:
        scheme = 'https'

    config = Configuration()
    config.host = '{}://{}:{}/api'.format(scheme, host, port)
    config.api_key = {'Authorization': key}
    config.api_key_prefix = {'Authorization': 'scitran-user'}
    return config


class Flywheel:
    def __init__(self, api_key, minimum_supported_major_version=0, root=False,
                 skip_version_check=True, subjects_in_resolver=None):
        # Init logging
        logging.basicConfig()

        # Check that the client caller is expecting the minimum supported version
        if minimum_supported_major_version < 11:
            raise Exception('The Flywheel CLI is expecting a version before v11'
                ' of the Flywheel SDK. Please use flywheel.Client() instead of'
                ' flywheel.Flywheel() if your are not the Flywheel CLI.')

        # Parse API Key and configure api_client
        config = config_from_api_key(api_key)
        self.api_client = ApiClient(config, context=self)

        # Root mode (Deprecated)
        if root:
            log.warning('Root mode is deprecated')
            self.api_client.set_default_query_param('exhaustive', 'true')

        self.api_client.user_agent = 'Flywheel SDK/{} (Python {}; {})'.format(SDK_VERSION,
            platform.python_version(), platform.system())

        # Initialize Apis
        self.acquisitions_api = flywheel.api.AcquisitionsApi(self.api_client)
        self.analyses_api = flywheel.api.AnalysesApi(self.api_client)
        self.batch_api = flywheel.api.BatchApi(self.api_client)
        self.bulk_api = flywheel.api.BulkApi(self.api_client)
        self.callbacks_api = flywheel.api.CallbacksApi(self.api_client)
        self.collections_api = flywheel.api.CollectionsApi(self.api_client)
        self.containers_api = flywheel.api.ContainersApi(self.api_client)
        self.dataexplorer_api = flywheel.api.DataexplorerApi(self.api_client)
        self.default_api = flywheel.api.DefaultApi(self.api_client)
        self.devices_api = flywheel.api.DevicesApi(self.api_client)
        self.dimse_api = flywheel.api.DimseApi(self.api_client)
        self.files_api = flywheel.api.FilesApi(self.api_client)
        self.gears_api = flywheel.api.GearsApi(self.api_client)
        self.groups_api = flywheel.api.GroupsApi(self.api_client)
        self.jobs_api = flywheel.api.JobsApi(self.api_client)
        self.modalities_api = flywheel.api.ModalitiesApi(self.api_client)
        self.projects_api = flywheel.api.ProjectsApi(self.api_client)
        self.reports_api = flywheel.api.ReportsApi(self.api_client)
        self.roles_api = flywheel.api.RolesApi(self.api_client)
        self.rules_api = flywheel.api.RulesApi(self.api_client)
        self.sessions_api = flywheel.api.SessionsApi(self.api_client)
        self.site_api = flywheel.api.SiteApi(self.api_client)
        self.subjects_api = flywheel.api.SubjectsApi(self.api_client)
        self.users_api = flywheel.api.UsersApi(self.api_client)
        self.views_api = flywheel.api.ViewsApi(self.api_client)

        # Finder objects
        self.users = Finder(self, 'get_all_users')
        self.groups = Finder(self, 'get_all_groups')
        self.projects = Finder(self, 'get_all_projects')
        self.subjects = Finder(self, 'get_all_subjects')
        self.sessions = Finder(self, 'get_all_sessions')
        self.acquisitions = Finder(self, 'get_all_acquisitions')
        self.jobs = Finder(self, 'get_all_jobs')
        self.gears = Finder(self, 'get_all_gears')
        self.collections = Finder(self, 'get_all_collections')

        # Enable subjects in resolver by default
        if subjects_in_resolver is None:
            subjects_in_resolver = os.environ.get('FLYWHEEL_SDK_SUBJECTS_IN_RESOLVER', '').lower() not in ['0', 'false']

        if subjects_in_resolver:
            self.enable_feature('Subject-Container')
        self.enable_feature('Safe-Redirect')

        # Perform version check
        self.check_version = not skip_version_check
        if not self.check_version:
            self.check_version = os.environ.get('FLYWHEEL_SDK_SKIP_VERSION_CHECK', '').lower() in ['0', 'false']
        self.api_client.set_version_check_fn(self.perform_version_check)


    def add_acquisition(self, body, **kwargs):  # noqa: E501
        """Create a new acquisition


        :param Acquisition body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ContainerNewOutput
        """
        return self.acquisitions_api.add_acquisition(body, **kwargs)


    def add_acquisition_analysis(self, acquisition_id, body, **kwargs):  # noqa: E501
        """Create an analysis and upload files.

        When query param \"job\" is \"true\", send JSON to create an analysis and job.  Otherwise, multipart/form-data to upload files and create an analysis. 

        :param str acquisition_id: (required)
        :param AnalysisInput body: (required)
        :param bool job: Return job as an object instead of an id
        :param bool async_: Perform the request asynchronously
        :return: ContainerNewOutput
        """
        return self.acquisitions_api.add_acquisition_analysis(acquisition_id, body, **kwargs)


    def add_acquisition_analysis_note(self, acquisition_id, analysis_id, body, **kwargs):  # noqa: E501
        """Add a note to acquisition analysis.


        :param str acquisition_id: (required)
        :param str analysis_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.acquisitions_api.add_acquisition_analysis_note(acquisition_id, analysis_id, body, **kwargs)


    def add_acquisition_note(self, acquisition_id, body, **kwargs):  # noqa: E501
        """Add a note to acquisition.


        :param str acquisition_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.acquisitions_api.add_acquisition_note(acquisition_id, body, **kwargs)


    def add_acquisition_tag(self, acquisition_id, body, **kwargs):  # noqa: E501
        """Add a tag to acquisition.

        Progates changes to projects, sessions and acquisitions

        :param str acquisition_id: (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.acquisitions_api.add_acquisition_tag(acquisition_id, body, **kwargs)


    def delete_acquisition(self, acquisition_id, **kwargs):  # noqa: E501
        """Delete a acquisition

        Read-write project permissions are required to delete an acquisition. </br>Admin project permissions are required if the acquisition contains data uploaded by sources other than users and jobs.

        :param str acquisition_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        return self.acquisitions_api.delete_acquisition(acquisition_id, **kwargs)


    def delete_acquisition_analysis(self, acquisition_id, analysis_id, **kwargs):  # noqa: E501
        """Delete an anaylsis


        :param str acquisition_id: (required)
        :param str analysis_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        return self.acquisitions_api.delete_acquisition_analysis(acquisition_id, analysis_id, **kwargs)


    def delete_acquisition_analysis_note(self, acquisition_id, analysis_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from acquisition analysis.


        :param str acquisition_id: (required)
        :param str analysis_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.acquisitions_api.delete_acquisition_analysis_note(acquisition_id, analysis_id, note_id, **kwargs)


    def delete_acquisition_file(self, acquisition_id, file_name, **kwargs):  # noqa: E501
        """Delete a file

        A user with read-write or higher permissions on the container may delete files that were uploaded by users or were the output of jobs. (Specifically, files whose `origin.type` is either `job` or `user`.) <br/> A user with admin permissions on the container may delete any file. 

        :param str acquisition_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.acquisitions_api.delete_acquisition_file(acquisition_id, file_name, **kwargs)


    def delete_acquisition_note(self, acquisition_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from acquisition


        :param str acquisition_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.acquisitions_api.delete_acquisition_note(acquisition_id, note_id, **kwargs)


    def delete_acquisition_tag(self, acquisition_id, tag_value, **kwargs):  # noqa: E501
        """Delete a tag


        :param str acquisition_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.acquisitions_api.delete_acquisition_tag(acquisition_id, tag_value, **kwargs)


    def download_acquisition_analysis_inputs(self, acquisition_id, analysis_id, **kwargs):  # noqa: E501
        """Download analysis inputs.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for all inputs in the anlaysis If no \"ticket\" query param is included, server error 500 

        :param str acquisition_id: (required)
        :param str analysis_id: (required)
        :param str ticket: ticket id of the inputs to download
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.acquisitions_api.download_acquisition_analysis_inputs(acquisition_id, analysis_id, **kwargs)


    def download_acquisition_analysis_outputs(self, acquisition_id, analysis_id, **kwargs):  # noqa: E501
        """Download analysis outputs.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for all outputs in the anlaysis If no \"ticket\" query param is included, server error 500 

        :param str acquisition_id: (required)
        :param str analysis_id: (required)
        :param str ticket: ticket id of the outputs to download
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.acquisitions_api.download_acquisition_analysis_outputs(acquisition_id, analysis_id, **kwargs)


    def download_file_from_acquisition(self, acquisition_id, file_name, dest_file, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str acquisition_id: (required)
        :param str file_name: (required)
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: DownloadTicket
        """
        return self.acquisitions_api.download_file_from_acquisition(acquisition_id, file_name, dest_file, **kwargs)


    def get_acquisition_file_zip_info(self, acquisition_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str acquisition_id: (required)
        :param str file_name: (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.acquisitions_api.get_acquisition_file_zip_info(acquisition_id, file_name, **kwargs)


    def get_acquisition_download_url(self, acquisition_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str acquisition_id: (required)
        :param str file_name: (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async_: Perform the request asynchronously
        :return: DownloadTicket
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.acquisitions_api.get_acquisition_download_ticket(acquisition_id, file_name, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def download_input_from_acquisition_analysis(self, acquisition_id, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str acquisition_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.acquisitions_api.download_input_from_acquisition_analysis(acquisition_id, analysis_id, filename, dest_file, **kwargs)


    def get_acquisition_analysis_input_zip_info(self, acquisition_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str acquisition_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.acquisitions_api.get_acquisition_analysis_input_zip_info(acquisition_id, analysis_id, filename, **kwargs)


    def get_acquisition_analysis_input_download_url(self, acquisition_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str acquisition_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.acquisitions_api.get_acquisition_analysis_input_download_ticket(acquisition_id, analysis_id, filename, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def download_output_from_acquisition_analysis(self, acquisition_id, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str acquisition_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.acquisitions_api.download_output_from_acquisition_analysis(acquisition_id, analysis_id, filename, dest_file, **kwargs)


    def get_acquisition_analysis_output_zip_info(self, acquisition_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str acquisition_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.acquisitions_api.get_acquisition_analysis_output_zip_info(acquisition_id, analysis_id, filename, **kwargs)


    def get_acquisition_analysis_output_download_url(self, acquisition_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str acquisition_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.acquisitions_api.get_acquisition_analysis_output_download_ticket(acquisition_id, analysis_id, filename, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def get_acquisition(self, acquisition_id, **kwargs):  # noqa: E501
        """Get a single acquisition


        :param str acquisition_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Acquisition
        """
        return self.acquisitions_api.get_acquisition(acquisition_id, **kwargs)


    def get_acquisition_analyses(self, acquisition_id, **kwargs):  # noqa: E501
        """Get analyses for acquisition.

        Returns analyses that directly belong to this resource.

        :param str acquisition_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[AnalysisListEntry]
        """
        return self.acquisitions_api.get_acquisition_analyses(acquisition_id, **kwargs)


    def get_acquisition_analysis(self, acquisition_id, analysis_id, **kwargs):  # noqa: E501
        """Get an analysis.


        :param str acquisition_id: (required)
        :param str analysis_id: (required)
        :param bool inflate_job: Return job as an object instead of an id
        :param bool async_: Perform the request asynchronously
        :return: AnalysisOutput
        """
        return self.acquisitions_api.get_acquisition_analysis(acquisition_id, analysis_id, **kwargs)


    def get_acquisition_file_info(self, acquisition_id, file_name, **kwargs):  # noqa: E501
        """Get info for a particular file.


        :param str acquisition_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: FileEntry
        """
        return self.acquisitions_api.get_acquisition_file_info(acquisition_id, file_name, **kwargs)


    def get_acquisition_note(self, acquisition_id, note_id, **kwargs):  # noqa: E501
        """Get a note on acquisition.


        :param str acquisition_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Note
        """
        return self.acquisitions_api.get_acquisition_note(acquisition_id, note_id, **kwargs)


    def get_acquisition_tag(self, acquisition_id, tag_value, **kwargs):  # noqa: E501
        """Get the value of a tag, by name.


        :param str acquisition_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: Tag
        """
        return self.acquisitions_api.get_acquisition_tag(acquisition_id, tag_value, **kwargs)


    def get_all_acquisitions(self, **kwargs):  # noqa: E501
        """Get a list of acquisitions


        :param bool exhaustive: Set to return a complete list regardless of permissions
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[Acquisition]
        """
        return self.acquisitions_api.get_all_acquisitions(**kwargs)


    def modify_acquisition(self, acquisition_id, body, **kwargs):  # noqa: E501
        """Update a acquisition


        :param str acquisition_id: (required)
        :param Acquisition body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.acquisitions_api.modify_acquisition(acquisition_id, body, **kwargs)


    def modify_acquisition_analysis(self, acquisition_id, analysis_id, body, **kwargs):  # noqa: E501
        """Modify an analysis.


        :param str acquisition_id: (required)
        :param str analysis_id: (required)
        :param AnalysisUpdate body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.acquisitions_api.modify_acquisition_analysis(acquisition_id, analysis_id, body, **kwargs)


    def modify_acquisition_file(self, acquisition_id, file_name, body, **kwargs):  # noqa: E501
        """Modify a file&#39;s attributes

        Note: If modifying a file's modality, the current classification will be cleared (except for items in the \"Custom\" list) 

        :param str acquisition_id: (required)
        :param str file_name: (required)
        :param FileEntry body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2005
        """
        return self.acquisitions_api.modify_acquisition_file(acquisition_id, file_name, body, **kwargs)


    def modify_acquisition_file_classification(self, acquisition_id, file_name, body, **kwargs):  # noqa: E501
        """Update classification for a particular file.

        If replacing a file's classification, the modality can optionally be modified as well.

        :param str acquisition_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2005
        """
        return self.acquisitions_api.modify_acquisition_file_classification(acquisition_id, file_name, body, **kwargs)


    def modify_acquisition_file_info(self, acquisition_id, file_name, body, **kwargs):  # noqa: E501
        """Update info for a particular file.


        :param str acquisition_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.acquisitions_api.modify_acquisition_file_info(acquisition_id, file_name, body, **kwargs)


    def modify_acquisition_info(self, acquisition_id, body, **kwargs):  # noqa: E501
        """Update or replace info for a acquisition.


        :param str acquisition_id: (required)
        :param InfoUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.acquisitions_api.modify_acquisition_info(acquisition_id, body, **kwargs)


    def modify_acquisition_note(self, acquisition_id, note_id, body, **kwargs):  # noqa: E501
        """Update a note on acquisition.


        :param str acquisition_id: (required)
        :param str note_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.acquisitions_api.modify_acquisition_note(acquisition_id, note_id, body, **kwargs)


    def rename_acquisition_tag(self, acquisition_id, tag_value, body, **kwargs):  # noqa: E501
        """Rename a tag.


        :param str acquisition_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.acquisitions_api.rename_acquisition_tag(acquisition_id, tag_value, body, **kwargs)


    def replace_acquisition_file(self, acquisition_id, file_name, **kwargs):  # noqa: E501
        """Replace a file


        :param str acquisition_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.acquisitions_api.replace_acquisition_file(acquisition_id, file_name, **kwargs)


    def upload_file_to_acquisition(self, acquisition_id, file, **kwargs):  # noqa: E501
        """Upload a file to acquisition.


        :param str acquisition_id: (required)
        :param file file: The file to upload (required)
        :param str metadata: File metadata
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.acquisitions_api.upload_file_to_acquisition(acquisition_id, file, **kwargs)


    def upload_output_to_acquisition_analysis(self, acquisition_id, analysis_id, file, **kwargs):  # noqa: E501
        """Upload an output file to analysis.


        :param str acquisition_id: (required)
        :param str analysis_id: (required)
        :param file file: The file to upload (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.acquisitions_api.upload_output_to_acquisition_analysis(acquisition_id, analysis_id, file, **kwargs)


    def add_analysis_note(self, analysis_id, body, **kwargs):  # noqa: E501
        """Add a note to analysis.


        :param str analysis_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.analyses_api.add_analysis_note(analysis_id, body, **kwargs)


    def add_analysis_tag(self, analysis_id, body, **kwargs):  # noqa: E501
        """Add a tag to analysis.

        Progates changes to projects, sessions and acquisitions

        :param str analysis_id: (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.analyses_api.add_analysis_tag(analysis_id, body, **kwargs)


    def delete_analysis_note(self, analysis_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from analysis


        :param str analysis_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.analyses_api.delete_analysis_note(analysis_id, note_id, **kwargs)


    def delete_analysis_tag(self, analysis_id, tag_value, **kwargs):  # noqa: E501
        """Delete a tag


        :param str analysis_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.analyses_api.delete_analysis_tag(analysis_id, tag_value, **kwargs)


    def download_analysis_inputs(self, analysis_id, **kwargs):  # noqa: E501
        """Download analysis inputs.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for all inputs in the anlaysis If no \"ticket\" query param is included, server error 500 

        :param str analysis_id: (required)
        :param str ticket: ticket id of the inputs to download
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.analyses_api.download_analysis_inputs(analysis_id, **kwargs)


    def download_analysis_outputs(self, analysis_id, **kwargs):  # noqa: E501
        """Download analysis outputs.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for all outputs in the anlaysis If no \"ticket\" query param is included, server error 500 

        :param str analysis_id: (required)
        :param str ticket: ticket id of the outputs to download
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.analyses_api.download_analysis_outputs(analysis_id, **kwargs)


    def download_input_from_analysis(self, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.analyses_api.download_input_from_analysis(analysis_id, filename, dest_file, **kwargs)


    def get_analysis_input_zip_info(self, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.analyses_api.get_analysis_input_zip_info(analysis_id, filename, **kwargs)


    def get_analysis_input_download_url(self, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.analyses_api.get_analysis_input_download_ticket(analysis_id, filename, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def download_output_from_analysis(self, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.analyses_api.download_output_from_analysis(analysis_id, filename, dest_file, **kwargs)


    def get_analysis_output_zip_info(self, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.analyses_api.get_analysis_output_zip_info(analysis_id, filename, **kwargs)


    def get_analysis_output_download_url(self, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.analyses_api.get_analysis_output_download_ticket(analysis_id, filename, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def get_analyses(self, container_name, container_id, subcontainer_name, **kwargs):  # noqa: E501
        """Get nested analyses for a container

        Returns analyses that belong to containers of the specified type that belong to ContainerId.  For example: `projects/{ProjectId}/acquisitions/analyses` will return any analyses  that have an acquisition that is under that project as a parent. The `all` keyword is also supported, for example: projects/{ProjectId}/all/analyses  will return any analyses that have any session or acquisition or the project itself as a parent. 

        :param str container_name: The parent container type (required)
        :param str container_id: The parent container id (required)
        :param str subcontainer_name: The sub container type (required)
        :param bool async_: Perform the request asynchronously
        :return: list[AnalysisListEntry]
        """
        return self.analyses_api.get_analyses(container_name, container_id, subcontainer_name, **kwargs)


    def get_analysis(self, analysis_id, **kwargs):  # noqa: E501
        """Get an analysis.


        :param str analysis_id: (required)
        :param bool inflate_job: Return job as an object instead of an id
        :param bool async_: Perform the request asynchronously
        :return: AnalysisOutput
        """
        return self.analyses_api.get_analysis(analysis_id, **kwargs)


    def get_analysis_file_info(self, analysis_id, file_name, **kwargs):  # noqa: E501
        """Get info for a particular file.


        :param str analysis_id: The analysis id (required)
        :param str file_name: The name of the file (required)
        :param bool async_: Perform the request asynchronously
        :return: FileEntry
        """
        return self.analyses_api.get_analysis_file_info(analysis_id, file_name, **kwargs)


    def get_analysis_note(self, analysis_id, note_id, **kwargs):  # noqa: E501
        """Get a note on analysis.


        :param str analysis_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Note
        """
        return self.analyses_api.get_analysis_note(analysis_id, note_id, **kwargs)


    def get_analysis_tag(self, analysis_id, tag_value, **kwargs):  # noqa: E501
        """Get the value of a tag, by name.


        :param str analysis_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: Tag
        """
        return self.analyses_api.get_analysis_tag(analysis_id, tag_value, **kwargs)


    def modify_analysis(self, analysis_id, body, **kwargs):  # noqa: E501
        """Modify an analysis.


        :param str analysis_id: (required)
        :param AnalysisUpdate body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.analyses_api.modify_analysis(analysis_id, body, **kwargs)


    def modify_analysis_info(self, analysis_id, body, **kwargs):  # noqa: E501
        """Update or replace info for a analysis.


        :param str analysis_id: (required)
        :param InfoUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.analyses_api.modify_analysis_info(analysis_id, body, **kwargs)


    def modify_analysis_note(self, analysis_id, note_id, body, **kwargs):  # noqa: E501
        """Update a note on analysis.


        :param str analysis_id: (required)
        :param str note_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.analyses_api.modify_analysis_note(analysis_id, note_id, body, **kwargs)


    def rename_analysis_tag(self, analysis_id, tag_value, body, **kwargs):  # noqa: E501
        """Rename a tag.


        :param str analysis_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.analyses_api.rename_analysis_tag(analysis_id, tag_value, body, **kwargs)


    def upload_output_to_analysis(self, analysis_id, file, **kwargs):  # noqa: E501
        """Upload an output file to analysis.


        :param str analysis_id: (required)
        :param file file: The file to upload (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.analyses_api.upload_output_to_analysis(analysis_id, file, **kwargs)


    def cancel_batch(self, batch_id, **kwargs):  # noqa: E501
        """Cancel a Job

        Cancels jobs that are still pending, returns number of jobs cancelled. Moves a 'running' batch job to 'cancelled'. 

        :param str batch_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: BatchCancelOutput
        """
        return self.batch_api.cancel_batch(batch_id, **kwargs)


    def create_batch_job_from_jobs(self, body, **kwargs):  # noqa: E501
        """Create a batch job proposal from preconstructed jobs and insert it as &#39;pending&#39;.


        :param BatchJobsProposalInput body: Set of jobs to be run as a batch (required)
        :param bool async_: Perform the request asynchronously
        :return: BatchProposal
        """
        return self.batch_api.create_batch_job_from_jobs(body, **kwargs)


    def get_all_batches(self, **kwargs):  # noqa: E501
        """Get a list of batch jobs the user has created.

        Requires login.

        :param bool async_: Perform the request asynchronously
        :return: list[Batch]
        """
        return self.batch_api.get_all_batches(**kwargs)


    def get_batch(self, batch_id, **kwargs):  # noqa: E501
        """Get batch job details.


        :param str batch_id: (required)
        :param bool jobs: If true, return job objects instead of job ids
        :param bool async_: Perform the request asynchronously
        :return: Batch
        """
        return self.batch_api.get_batch(batch_id, **kwargs)


    def propose_batch(self, body, **kwargs):  # noqa: E501
        """Create a batch job proposal and insert it as &#39;pending&#39;.


        :param BatchProposalInput body: The batch proposal (required)
        :param bool async_: Perform the request asynchronously
        :return: BatchProposal
        """
        return self.batch_api.propose_batch(body, **kwargs)


    def start_batch(self, batch_id, **kwargs):  # noqa: E501
        """Launch a job.

        Creates jobs from proposed inputs, returns jobs enqueued. Moves 'pending' batch job to 'running'. 

        :param str batch_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: list[Job]
        """
        return self.batch_api.start_batch(batch_id, **kwargs)


    def bulk_copy(self, body, **kwargs):  # noqa: E501
        """Perform a bulk copy operation


        :param BulkMoveSessions body: (required)
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.bulk_api.bulk_copy(body, **kwargs)


    def bulk_delete(self, body, **kwargs):  # noqa: E501
        """Perform a bulk delete operation


        :param BulkMoveSessions body: (required)
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.bulk_api.bulk_delete(body, **kwargs)


    def bulk_move(self, body, **kwargs):  # noqa: E501
        """Perform a bulk move operation


        :param BulkMoveSessions body: (required)
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.bulk_api.bulk_move(body, **kwargs)


    def bulk_move_sessions(self, body, **kwargs):  # noqa: E501
        """Perform a bulk move of sessions to either a subject or project


        :param BulkMoveSessions body: (required)
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.bulk_api.bulk_move_sessions(body, **kwargs)


    def callback_virus_scan(self, container_type, container_id, file_name, body, **kwargs):  # noqa: E501
        """Callback url to send the virus scan result of a file.

        This endpoint accepts the result from the anti-virus service.  NOTE: this endpoint only can be used via a signed url. 

        :param str container_type: (required)
        :param str container_id: (required)
        :param str file_name: (required)
        :param CallbacksVirusScanInput body: (required)
        :param str signature: Url's signature (signed callback url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.callbacks_api.callback_virus_scan(container_type, container_id, file_name, body, **kwargs)


    def add_collection(self, body, **kwargs):  # noqa: E501
        """Create a collection


        :param Collection body: (required)
        :param bool async_: Perform the request asynchronously
        :return: CollectionNewOutput
        """
        return self.collections_api.add_collection(body, **kwargs)


    def add_collection_analysis(self, collection_id, body, **kwargs):  # noqa: E501
        """Create an analysis and upload files.

        When query param \"job\" is \"true\", send JSON to create an analysis and job.  Otherwise, multipart/form-data to upload files and create an analysis. 

        :param str collection_id: (required)
        :param AnalysisInput body: (required)
        :param bool job: Return job as an object instead of an id
        :param bool async_: Perform the request asynchronously
        :return: ContainerNewOutput
        """
        return self.collections_api.add_collection_analysis(collection_id, body, **kwargs)


    def add_collection_analysis_note(self, collection_id, analysis_id, body, **kwargs):  # noqa: E501
        """Add a note to collection analysis.


        :param str collection_id: (required)
        :param str analysis_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.collections_api.add_collection_analysis_note(collection_id, analysis_id, body, **kwargs)


    def add_collection_note(self, collection_id, body, **kwargs):  # noqa: E501
        """Add a note to collection.


        :param str collection_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.collections_api.add_collection_note(collection_id, body, **kwargs)


    def add_collection_permission(self, collection_id, body, **kwargs):  # noqa: E501
        """Add a permission


        :param str collection_id: (required)
        :param PermissionAccessPermission body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.collections_api.add_collection_permission(collection_id, body, **kwargs)


    def add_collection_tag(self, collection_id, body, **kwargs):  # noqa: E501
        """Add a tag to collection.

        Progates changes to projects, sessions and acquisitions

        :param str collection_id: (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.collections_api.add_collection_tag(collection_id, body, **kwargs)


    def delete_collection(self, collection_id, **kwargs):  # noqa: E501
        """Delete a collection


        :param str collection_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.collections_api.delete_collection(collection_id, **kwargs)


    def delete_collection_analysis(self, collection_id, analysis_id, **kwargs):  # noqa: E501
        """Delete an anaylsis


        :param str collection_id: (required)
        :param str analysis_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        return self.collections_api.delete_collection_analysis(collection_id, analysis_id, **kwargs)


    def delete_collection_analysis_note(self, collection_id, analysis_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from collection analysis.


        :param str collection_id: (required)
        :param str analysis_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.collections_api.delete_collection_analysis_note(collection_id, analysis_id, note_id, **kwargs)


    def delete_collection_file(self, collection_id, file_name, **kwargs):  # noqa: E501
        """Delete a file

        A user with read-write or higher permissions on the container may delete files that were uploaded by users or were the output of jobs. (Specifically, files whose `origin.type` is either `job` or `user`.) <br/> A user with admin permissions on the container may delete any file. 

        :param str collection_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.collections_api.delete_collection_file(collection_id, file_name, **kwargs)


    def delete_collection_note(self, collection_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from collection


        :param str collection_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.collections_api.delete_collection_note(collection_id, note_id, **kwargs)


    def delete_collection_tag(self, collection_id, tag_value, **kwargs):  # noqa: E501
        """Delete a tag


        :param str collection_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.collections_api.delete_collection_tag(collection_id, tag_value, **kwargs)


    def delete_collection_user_permission(self, collection_id, user_id, **kwargs):  # noqa: E501
        """Delete a permission


        :param str collection_id: (required)
        :param str user_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.collections_api.delete_collection_user_permission(collection_id, user_id, **kwargs)


    def download_collection_analysis_inputs(self, collection_id, analysis_id, **kwargs):  # noqa: E501
        """Download analysis inputs.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for all inputs in the anlaysis If no \"ticket\" query param is included, server error 500 

        :param str collection_id: (required)
        :param str analysis_id: (required)
        :param str ticket: ticket id of the inputs to download
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.collections_api.download_collection_analysis_inputs(collection_id, analysis_id, **kwargs)


    def download_collection_analysis_outputs(self, collection_id, analysis_id, **kwargs):  # noqa: E501
        """Download analysis outputs.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for all outputs in the anlaysis If no \"ticket\" query param is included, server error 500 

        :param str collection_id: (required)
        :param str analysis_id: (required)
        :param str ticket: ticket id of the outputs to download
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.collections_api.download_collection_analysis_outputs(collection_id, analysis_id, **kwargs)


    def download_file_from_collection(self, collection_id, file_name, dest_file, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str collection_id: (required)
        :param str file_name: (required)
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: DownloadTicket
        """
        return self.collections_api.download_file_from_collection(collection_id, file_name, dest_file, **kwargs)


    def get_collection_file_zip_info(self, collection_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str collection_id: (required)
        :param str file_name: (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.collections_api.get_collection_file_zip_info(collection_id, file_name, **kwargs)


    def get_collection_download_url(self, collection_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str collection_id: (required)
        :param str file_name: (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async_: Perform the request asynchronously
        :return: DownloadTicket
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.collections_api.get_collection_download_ticket(collection_id, file_name, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def download_input_from_collection_analysis(self, collection_id, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str collection_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.collections_api.download_input_from_collection_analysis(collection_id, analysis_id, filename, dest_file, **kwargs)


    def get_collection_analysis_input_zip_info(self, collection_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str collection_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.collections_api.get_collection_analysis_input_zip_info(collection_id, analysis_id, filename, **kwargs)


    def get_collection_analysis_input_download_url(self, collection_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str collection_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.collections_api.get_collection_analysis_input_download_ticket(collection_id, analysis_id, filename, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def download_output_from_collection_analysis(self, collection_id, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str collection_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.collections_api.download_output_from_collection_analysis(collection_id, analysis_id, filename, dest_file, **kwargs)


    def get_collection_analysis_output_zip_info(self, collection_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str collection_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.collections_api.get_collection_analysis_output_zip_info(collection_id, analysis_id, filename, **kwargs)


    def get_collection_analysis_output_download_url(self, collection_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str collection_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.collections_api.get_collection_analysis_output_download_ticket(collection_id, analysis_id, filename, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def get_all_collections(self, **kwargs):  # noqa: E501
        """List all collections.


        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[Collection]
        """
        return self.collections_api.get_all_collections(**kwargs)


    def get_all_collections_curators(self, **kwargs):  # noqa: E501
        """List all curators of collections


        :param bool async_: Perform the request asynchronously
        :return: list[object]
        """
        return self.collections_api.get_all_collections_curators(**kwargs)


    def get_collection(self, collection_id, **kwargs):  # noqa: E501
        """Retrieve a single collection


        :param str collection_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Collection
        """
        return self.collections_api.get_collection(collection_id, **kwargs)


    def get_collection_acquisitions(self, collection_id, **kwargs):  # noqa: E501
        """List acquisitions in a collection


        :param str collection_id: (required)
        :param str session: The id of a session, to which the acquisitions returned will be restricted
        :param bool async_: Perform the request asynchronously
        :return: list[Acquisition]
        """
        return self.collections_api.get_collection_acquisitions(collection_id, **kwargs)


    def get_collection_analyses(self, collection_id, **kwargs):  # noqa: E501
        """Get analyses for collection.

        Returns analyses that directly belong to this resource.

        :param str collection_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[AnalysisListEntry]
        """
        return self.collections_api.get_collection_analyses(collection_id, **kwargs)


    def get_collection_analysis(self, collection_id, analysis_id, **kwargs):  # noqa: E501
        """Get an analysis.


        :param str collection_id: (required)
        :param str analysis_id: (required)
        :param bool inflate_job: Return job as an object instead of an id
        :param bool async_: Perform the request asynchronously
        :return: AnalysisOutput
        """
        return self.collections_api.get_collection_analysis(collection_id, analysis_id, **kwargs)


    def get_collection_file_info(self, collection_id, file_name, **kwargs):  # noqa: E501
        """Get info for a particular file.


        :param str collection_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: FileEntry
        """
        return self.collections_api.get_collection_file_info(collection_id, file_name, **kwargs)


    def get_collection_note(self, collection_id, note_id, **kwargs):  # noqa: E501
        """Get a note on collection.


        :param str collection_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Note
        """
        return self.collections_api.get_collection_note(collection_id, note_id, **kwargs)


    def get_collection_sessions(self, collection_id, **kwargs):  # noqa: E501
        """List sessions in a collection


        :param str collection_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[Session]
        """
        return self.collections_api.get_collection_sessions(collection_id, **kwargs)


    def get_collection_tag(self, collection_id, tag_value, **kwargs):  # noqa: E501
        """Get the value of a tag, by name.


        :param str collection_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: Tag
        """
        return self.collections_api.get_collection_tag(collection_id, tag_value, **kwargs)


    def get_collection_user_permission(self, collection_id, user_id, **kwargs):  # noqa: E501
        """List a user&#39;s permissions for this group.


        :param str collection_id: (required)
        :param str user_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: PermissionAccessPermission
        """
        return self.collections_api.get_collection_user_permission(collection_id, user_id, **kwargs)


    def modify_collection(self, collection_id, body, **kwargs):  # noqa: E501
        """Update a collection and its contents


        :param str collection_id: (required)
        :param Collection body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.collections_api.modify_collection(collection_id, body, **kwargs)


    def modify_collection_analysis(self, collection_id, analysis_id, body, **kwargs):  # noqa: E501
        """Modify an analysis.


        :param str collection_id: (required)
        :param str analysis_id: (required)
        :param AnalysisUpdate body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.collections_api.modify_collection_analysis(collection_id, analysis_id, body, **kwargs)


    def modify_collection_file(self, collection_id, file_name, body, **kwargs):  # noqa: E501
        """Modify a file&#39;s attributes

        Note: If modifying a file's modality, the current classification will be cleared (except for items in the \"Custom\" list) 

        :param str collection_id: (required)
        :param str file_name: (required)
        :param FileEntry body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2005
        """
        return self.collections_api.modify_collection_file(collection_id, file_name, body, **kwargs)


    def modify_collection_file_classification(self, collection_id, file_name, body, **kwargs):  # noqa: E501
        """Update classification for a particular file.

        If replacing a file's classification, the modality can optionally be modified as well.

        :param str collection_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2005
        """
        return self.collections_api.modify_collection_file_classification(collection_id, file_name, body, **kwargs)


    def modify_collection_file_info(self, collection_id, file_name, body, **kwargs):  # noqa: E501
        """Update info for a particular file.


        :param str collection_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.collections_api.modify_collection_file_info(collection_id, file_name, body, **kwargs)


    def modify_collection_info(self, collection_id, body, **kwargs):  # noqa: E501
        """Update or replace info for a collection.


        :param str collection_id: (required)
        :param InfoUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.collections_api.modify_collection_info(collection_id, body, **kwargs)


    def modify_collection_note(self, collection_id, note_id, body, **kwargs):  # noqa: E501
        """Update a note on collection.


        :param str collection_id: (required)
        :param str note_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.collections_api.modify_collection_note(collection_id, note_id, body, **kwargs)


    def modify_collection_user_permission(self, collection_id, user_id, body, **kwargs):  # noqa: E501
        """Update a user&#39;s permission for this group.


        :param str collection_id: (required)
        :param str user_id: (required)
        :param PermissionAccessPermission body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.collections_api.modify_collection_user_permission(collection_id, user_id, body, **kwargs)


    def rename_collection_tag(self, collection_id, tag_value, body, **kwargs):  # noqa: E501
        """Rename a tag.


        :param str collection_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.collections_api.rename_collection_tag(collection_id, tag_value, body, **kwargs)


    def replace_collection_file(self, collection_id, file_name, **kwargs):  # noqa: E501
        """Replace a file


        :param str collection_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.collections_api.replace_collection_file(collection_id, file_name, **kwargs)


    def upload_file_to_collection(self, collection_id, file, **kwargs):  # noqa: E501
        """Upload a file to collection.


        :param str collection_id: (required)
        :param file file: The file to upload (required)
        :param str metadata: File metadata
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.collections_api.upload_file_to_collection(collection_id, file, **kwargs)


    def upload_output_to_collection_analysis(self, collection_id, analysis_id, file, **kwargs):  # noqa: E501
        """Upload an output file to analysis.


        :param str collection_id: (required)
        :param str analysis_id: (required)
        :param file file: The file to upload (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.collections_api.upload_output_to_collection_analysis(collection_id, analysis_id, file, **kwargs)


    def add_container_analysis(self, container_id, body, **kwargs):  # noqa: E501
        """Create an analysis and upload files.

        When query param \"job\" is \"true\", send JSON to create an analysis and job.  Otherwise, multipart/form-data to upload files and create an analysis. 

        :param str container_id: (required)
        :param AnalysisInput body: (required)
        :param bool job: Return job as an object instead of an id
        :param bool async_: Perform the request asynchronously
        :return: ContainerNewOutput
        """
        return self.containers_api.add_container_analysis(container_id, body, **kwargs)


    def add_container_analysis_note(self, container_id, analysis_id, body, **kwargs):  # noqa: E501
        """Add a note to container analysis.


        :param str container_id: (required)
        :param str analysis_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.containers_api.add_container_analysis_note(container_id, analysis_id, body, **kwargs)


    def add_container_note(self, container_id, body, **kwargs):  # noqa: E501
        """Add a note to container.


        :param str container_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.containers_api.add_container_note(container_id, body, **kwargs)


    def add_container_tag(self, container_id, body, **kwargs):  # noqa: E501
        """Add a tag to container.

        Progates changes to projects, sessions and acquisitions

        :param str container_id: (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.containers_api.add_container_tag(container_id, body, **kwargs)


    def check_uids_exist(self, body, **kwargs):  # noqa: E501
        """Check for existence of UIDs system-wide


        :param ContainerUidcheck body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ContainerUidcheck
        """
        return self.containers_api.check_uids_exist(body, **kwargs)


    def delete_container(self, container_id, **kwargs):  # noqa: E501
        """Delete a container


        :param str container_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.containers_api.delete_container(container_id, **kwargs)


    def delete_container_analysis(self, container_id, analysis_id, **kwargs):  # noqa: E501
        """Delete an anaylsis


        :param str container_id: (required)
        :param str analysis_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        return self.containers_api.delete_container_analysis(container_id, analysis_id, **kwargs)


    def delete_container_analysis_note(self, container_id, analysis_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from container analysis.


        :param str container_id: (required)
        :param str analysis_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.containers_api.delete_container_analysis_note(container_id, analysis_id, note_id, **kwargs)


    def delete_container_file(self, container_id, file_name, **kwargs):  # noqa: E501
        """Delete a file

        A user with read-write or higher permissions on the container may delete files that were uploaded by users or were the output of jobs. (Specifically, files whose `origin.type` is either `job` or `user`.) <br/> A user with admin permissions on the container may delete any file. 

        :param str container_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.containers_api.delete_container_file(container_id, file_name, **kwargs)


    def delete_container_note(self, container_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from container


        :param str container_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.containers_api.delete_container_note(container_id, note_id, **kwargs)


    def delete_container_tag(self, container_id, tag_value, **kwargs):  # noqa: E501
        """Delete a tag


        :param str container_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.containers_api.delete_container_tag(container_id, tag_value, **kwargs)


    def download_container_analysis_inputs(self, container_id, analysis_id, **kwargs):  # noqa: E501
        """Download analysis inputs.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for all inputs in the anlaysis If no \"ticket\" query param is included, server error 500 

        :param str container_id: (required)
        :param str analysis_id: (required)
        :param str ticket: ticket id of the inputs to download
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.containers_api.download_container_analysis_inputs(container_id, analysis_id, **kwargs)


    def download_container_analysis_outputs(self, container_id, analysis_id, **kwargs):  # noqa: E501
        """Download analysis outputs.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for all outputs in the anlaysis If no \"ticket\" query param is included, server error 500 

        :param str container_id: (required)
        :param str analysis_id: (required)
        :param str ticket: ticket id of the outputs to download
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.containers_api.download_container_analysis_outputs(container_id, analysis_id, **kwargs)


    def download_file_from_container(self, container_id, file_name, dest_file, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str container_id: (required)
        :param str file_name: (required)
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: DownloadTicket
        """
        return self.containers_api.download_file_from_container(container_id, file_name, dest_file, **kwargs)


    def get_container_file_zip_info(self, container_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str container_id: (required)
        :param str file_name: (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.containers_api.get_container_file_zip_info(container_id, file_name, **kwargs)


    def get_container_download_url(self, container_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str container_id: (required)
        :param str file_name: (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async_: Perform the request asynchronously
        :return: DownloadTicket
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.containers_api.get_container_download_ticket(container_id, file_name, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def download_input_from_container_analysis(self, container_id, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str container_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.containers_api.download_input_from_container_analysis(container_id, analysis_id, filename, dest_file, **kwargs)


    def get_container_analysis_input_zip_info(self, container_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str container_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.containers_api.get_container_analysis_input_zip_info(container_id, analysis_id, filename, **kwargs)


    def get_container_analysis_input_download_url(self, container_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str container_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.containers_api.get_container_analysis_input_download_ticket(container_id, analysis_id, filename, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def download_output_from_container_analysis(self, container_id, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str container_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.containers_api.download_output_from_container_analysis(container_id, analysis_id, filename, dest_file, **kwargs)


    def get_container_analysis_output_zip_info(self, container_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str container_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.containers_api.get_container_analysis_output_zip_info(container_id, analysis_id, filename, **kwargs)


    def get_container_analysis_output_download_url(self, container_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str container_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.containers_api.get_container_analysis_output_download_ticket(container_id, analysis_id, filename, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def get_container(self, container_id, **kwargs):  # noqa: E501
        """Retrieve a single container


        :param str container_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: ContainerOutput
        """
        return self.containers_api.get_container(container_id, **kwargs)


    def get_container_analyses(self, container_id, **kwargs):  # noqa: E501
        """Get analyses for container.

        Returns analyses that directly belong to this resource.

        :param str container_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[AnalysisListEntry]
        """
        return self.containers_api.get_container_analyses(container_id, **kwargs)


    def get_container_analysis(self, container_id, analysis_id, **kwargs):  # noqa: E501
        """Get an analysis.


        :param str container_id: (required)
        :param str analysis_id: (required)
        :param bool inflate_job: Return job as an object instead of an id
        :param bool async_: Perform the request asynchronously
        :return: AnalysisOutput
        """
        return self.containers_api.get_container_analysis(container_id, analysis_id, **kwargs)


    def get_container_file_info(self, container_id, file_name, **kwargs):  # noqa: E501
        """Get info for a particular file.


        :param str container_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: FileEntry
        """
        return self.containers_api.get_container_file_info(container_id, file_name, **kwargs)


    def get_container_note(self, container_id, note_id, **kwargs):  # noqa: E501
        """Get a note on container.


        :param str container_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Note
        """
        return self.containers_api.get_container_note(container_id, note_id, **kwargs)


    def get_container_tag(self, container_id, tag_value, **kwargs):  # noqa: E501
        """Get the value of a tag, by name.


        :param str container_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: Tag
        """
        return self.containers_api.get_container_tag(container_id, tag_value, **kwargs)


    def modify_container(self, container_id, body, **kwargs):  # noqa: E501
        """Update a container and its contents


        :param str container_id: (required)
        :param ContainerUpdate body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.containers_api.modify_container(container_id, body, **kwargs)


    def modify_container_analysis(self, container_id, analysis_id, body, **kwargs):  # noqa: E501
        """Modify an analysis.


        :param str container_id: (required)
        :param str analysis_id: (required)
        :param AnalysisUpdate body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.containers_api.modify_container_analysis(container_id, analysis_id, body, **kwargs)


    def modify_container_file(self, container_id, file_name, body, **kwargs):  # noqa: E501
        """Modify a file&#39;s attributes

        Note: If modifying a file's modality, the current classification will be cleared (except for items in the \"Custom\" list) 

        :param str container_id: (required)
        :param str file_name: (required)
        :param FileEntry body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2005
        """
        return self.containers_api.modify_container_file(container_id, file_name, body, **kwargs)


    def modify_container_file_classification(self, container_id, file_name, body, **kwargs):  # noqa: E501
        """Update classification for a particular file.

        If replacing a file's classification, the modality can optionally be modified as well.

        :param str container_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2005
        """
        return self.containers_api.modify_container_file_classification(container_id, file_name, body, **kwargs)


    def modify_container_file_info(self, container_id, file_name, body, **kwargs):  # noqa: E501
        """Update info for a particular file.


        :param str container_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.containers_api.modify_container_file_info(container_id, file_name, body, **kwargs)


    def modify_container_info(self, container_id, body, **kwargs):  # noqa: E501
        """Update or replace info for a container.


        :param str container_id: (required)
        :param InfoUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.containers_api.modify_container_info(container_id, body, **kwargs)


    def modify_container_note(self, container_id, note_id, body, **kwargs):  # noqa: E501
        """Update a note on container.


        :param str container_id: (required)
        :param str note_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.containers_api.modify_container_note(container_id, note_id, body, **kwargs)


    def rename_container_tag(self, container_id, tag_value, body, **kwargs):  # noqa: E501
        """Rename a tag.


        :param str container_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.containers_api.rename_container_tag(container_id, tag_value, body, **kwargs)


    def replace_container_file(self, container_id, file_name, **kwargs):  # noqa: E501
        """Replace a file


        :param str container_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.containers_api.replace_container_file(container_id, file_name, **kwargs)


    def upload_file_to_container(self, container_id, file, **kwargs):  # noqa: E501
        """Upload a file to container.


        :param str container_id: (required)
        :param file file: The file to upload (required)
        :param str metadata: File metadata
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.containers_api.upload_file_to_container(container_id, file, **kwargs)


    def upload_output_to_container_analysis(self, container_id, analysis_id, file, **kwargs):  # noqa: E501
        """Upload an output file to analysis.


        :param str container_id: (required)
        :param str analysis_id: (required)
        :param file file: The file to upload (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.containers_api.upload_output_to_container_analysis(container_id, analysis_id, file, **kwargs)


    def get_search_query_suggestions(self, body, **kwargs):  # noqa: E501
        """Get suggestions for a structured search query

        Send the search query from the start of the string, and get a set of suggested replacements back. When utilizing a suggestion, the caller should replace the contents from the \"from\" field to the end of the string with the provided \"value\". 

        :param SearchStructuredSearchQuery body: (required)
        :param bool async_: Perform the request asynchronously
        :return: SearchQuerySuggestions
        """
        return self.dataexplorer_api.get_search_query_suggestions(body, **kwargs)


    def get_search_status(self, **kwargs):  # noqa: E501
        """Get the status of search (Mongo Connector)


        :param bool async_: Perform the request asynchronously
        :return: SearchStatus
        """
        return self.dataexplorer_api.get_search_status(**kwargs)


    def parse_search_query(self, body, **kwargs):  # noqa: E501
        """Parse a structured search query

        Validates a search query, returning any parse errors that were encountered. In the future, this endpoint may return the abstract syntax tree or evaluated query. 

        :param SearchStructuredSearchQuery body: (required)
        :param bool async_: Perform the request asynchronously
        :return: SearchParseSearchQueryResult
        """
        return self.dataexplorer_api.parse_search_query(body, **kwargs)


    def search(self, body, **kwargs):  # noqa: E501
        """Perform a search query


        :param SearchQuery body: (required)
        :param bool simple:
        :param int size:
        :param bool async_: Perform the request asynchronously
        :return: list[SearchResponse]
        """
        return self.dataexplorer_api.search(body, **kwargs)


    def clean_packfiles(self, **kwargs):  # noqa: E501
        """Clean up expired upload tokens and invalid token directories.


        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.default_api.clean_packfiles(**kwargs)


    def engine_upload(self, level, id, job, **kwargs):  # noqa: E501
        """Upload a list of file fields.

        ### Default behavior: > Uploads a list of file fields sent as file1, file2, etc to an existing   container and updates fields of the files, the container and it's   parents as specified in the metadata fileformfield using the   engine placer class  > A non-file form field called \"metadata\" is also required, which must be   a string containing JSON.  > See ``api/schemas/input/enginemetadata.json`` for the format of this metadata.  ### When ``level`` is ``analysis``: > Uploads a list of files to an existing analysis object, marking   all files as ``output=true`` using the job-based analyses placer   class.  > A non-file form field called \"metadata\" is also required, which must be   a string containing JSON.  > See ``api/schemas/input/analysis.json`` for the format of this metadata.  ### Signed URL upload with ``upload_ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?upload_ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request. 

        :param str level: Which level to store files in (required)
        :param str id: The ID of the container to place files in (required)
        :param str job: Required if ``level`` is ``analysis`` (required)
        :param str body: Object encoded as a JSON string. It is **required** and used **only** when the ``upload_ticket`` parameter is used. See ``schemas/input/signedurlmetadata.json`` for the format of the json payload. 
        :param str form_data:
        :param str upload_ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.default_api.engine_upload(level, id, job, **kwargs)


    def fetch_tree(self, body, **kwargs):  # noqa: E501
        """Query a portion of the flywheel hierarchy, returning only the requested fields.

        This is a build-your-own request endpoint that can fetch from anywhere in the hierarchy, returning just the fields that you care about.  # Fields Each fetch-level described must include a list of fields to return. These fields can be anything on the container (except info), and will be included in the response if they are present in the container.  # Joins Children or parents can be joined as part of this request, by specifying an additional subdocument of the given name. Check /tree/graph for a list of containers and their connections.  # Filter Joined documents can be further filtered (with the exception of inputs & files) by passing a filter in the subdocument. Filtering follows the same convention as top-level pagination.  # Sort Joined documents can be sorted as well, following the convention as top-level pagination.  # Limit Joins can be limited to a the first N documents by specifying a limit in the subdocument.  # Join-origin Passing `true` for the `join-origin` flag in the files subdocument will populates the `join-origin` map for each container with files. 

        :param TreeRequest body: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[TreeResponseItem]
        """
        return self.default_api.fetch_tree(body, **kwargs)


    def get_auth_status(self, **kwargs):  # noqa: E501
        """Get Login status

        Get the current login status of the requestor

        :param bool async_: Perform the request asynchronously
        :return: AuthLoginStatus
        """
        return self.default_api.get_auth_status(**kwargs)


    def get_config(self, **kwargs):  # noqa: E501
        """Return public Scitran configuration information


        :param bool async_: Perform the request asynchronously
        :return: ConfigOutput
        """
        return self.default_api.get_config(**kwargs)


    def get_config_js(self, **kwargs):  # noqa: E501
        """Return public Scitran configuration information in javascript format.


        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.default_api.get_config_js(**kwargs)


    def get_tree_graph(self, **kwargs):  # noqa: E501
        """Get a description of the flywheel hiearchy


        :param bool async_: Perform the request asynchronously
        :return: TreeGraph
        """
        return self.default_api.get_tree_graph(**kwargs)


    def get_version(self, **kwargs):  # noqa: E501
        """Get server and database schema version info


        :param bool async_: Perform the request asynchronously
        :return: VersionOutput
        """
        return self.default_api.get_version(**kwargs)


    def login(self, **kwargs):  # noqa: E501
        """Login

        Scitran Authentication

        :param bool async_: Perform the request asynchronously
        :return: AuthLoginOutput
        """
        return self.default_api.login(**kwargs)


    def logout(self, **kwargs):  # noqa: E501
        """Log Out

        Remove authtokens for user

        :param bool async_: Perform the request asynchronously
        :return: AuthLogoutOutput
        """
        return self.default_api.logout(**kwargs)


    def lookup_path(self, body, **kwargs):  # noqa: E501
        """Perform path based lookup of a single node in the Flywheel hierarchy

        This will perform a deep lookup of a node. See /resolve for more details. 

        :param ResolverInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ResolverNode
        """
        return self.default_api.lookup_path(body, **kwargs)


    def resolve_path(self, body, **kwargs):  # noqa: E501
        """Perform path based lookup of nodes in the Flywheel hierarchy

        This will perform a deep lookup of a node (i.e. group/project/session/acquisition) and its children, including any files. The query path is an array of strings in the following order (by default):    * group id   * project label   * session label   * acquisition label  Additionally, analyses for project/session/acquisition nodes can be resolved by inserting the literal string `\"analyses\"`. e.g. `['scitran', 'MyProject', 'analyses']`.  Files for projects, sessions, acquisitions and analyses can be resolved by inserting the literal string `\"files\"`. e.g. `['scitran', 'MyProject', 'files']`.  An ID can be used instead of a label by formatting the string as `<id:project_id>`. The full path to the node, and the node's children will be included in the response. 

        :param ResolverInput body: (required)
        :param bool exhaustive: Set to return a complete list regardless of permissions
        :param bool full_tree: Parse full download style paths (e.g. group/PROJECTS/project_label/SUBJECTS/...)
        :param bool minattr: Return only minimal attributes
        :param bool async_: Perform the request asynchronously
        :return: ResolverOutput
        """
        return self.default_api.resolve_path(body, **kwargs)


    def create_device(self, body, **kwargs):  # noqa: E501
        """Create a new device.

        Will create a new device record together with an api key. Request must be an admin request. 

        :param Device body: (required)
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.devices_api.create_device(body, **kwargs)


    def get_all_devices(self, **kwargs):  # noqa: E501
        """List all devices.

        Requires login.

        :param bool async_: Perform the request asynchronously
        :return: list[Device]
        """
        return self.devices_api.get_all_devices(**kwargs)


    def get_all_devices_status(self, **kwargs):  # noqa: E501
        """Get status for all known devices.

        ok - missing - error - unknown

        :param bool async_: Perform the request asynchronously
        :return: DeviceStatus
        """
        return self.devices_api.get_all_devices_status(**kwargs)


    def get_device(self, device_id, **kwargs):  # noqa: E501
        """Get device details


        :param str device_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Device
        """
        return self.devices_api.get_device(device_id, **kwargs)


    def modify_device(self, device_id, body, **kwargs):  # noqa: E501
        """Update a device


        :param str device_id: (required)
        :param Device body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.devices_api.modify_device(device_id, body, **kwargs)


    def regenerate_key(self, device_id, **kwargs):  # noqa: E501
        """Regenerate device API key


        :param str device_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2001
        """
        return self.devices_api.regenerate_key(device_id, **kwargs)


    def update_device(self, body, **kwargs):  # noqa: E501
        """Modify a device&#39;s type, name, interval, info or set errors.

        Will modify the device record of the device making the request. Type may only be set once if not already specified at creation. Request must be a drone request. 

        :param Device body: (required)
        :param bool async_: Perform the request asynchronously
        :return: Device
        """
        return self.devices_api.update_device(body, **kwargs)


    def create_project_aet(self, body, **kwargs):  # noqa: E501
        """Create a new DIMSE project AET

        Will create a new DIMSE AET that refers to a Flywheel project. AETs can only be created by admins and use drone access via DIMSE. 

        :param DimseProjectInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.dimse_api.create_project_aet(body, **kwargs)


    def create_service_aet(self, body, **kwargs):  # noqa: E501
        """Create a new DIMSE service AET

        Will create a new DIMSE AET that refers to an external DICOM node. Service AETs can be used to issue C-MOVEs to from project AETs. Requires login. AETs can only be created by admins. 

        :param DimseServiceInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.dimse_api.create_service_aet(body, **kwargs)


    def delete_project_aet(self, project_aet, **kwargs):  # noqa: E501
        """Delete a DIMSE project AET

        Delete DIMSE project by AET. AETs can only be deleted by admins. 

        :param str project_aet: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.dimse_api.delete_project_aet(project_aet, **kwargs)


    def delete_service_aet(self, service_aet, **kwargs):  # noqa: E501
        """Delete a DIMSE service AET

        Delete DIMSE service by AET. AETs can only be deleted by admins. 

        :param str service_aet: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.dimse_api.delete_service_aet(service_aet, **kwargs)


    def get_all_project_aets(self, **kwargs):  # noqa: E501
        """List all DIMSE project AETs

        Will list all DIMSE AETs referring to a Flywheel project. Project AETs can be used to issue C-FIND and C-MOVE on Flywheel projects. Requires login and admin privilege. 

        :param bool async_: Perform the request asynchronously
        :return: list[DimseProjectOutput]
        """
        return self.dimse_api.get_all_project_aets(**kwargs)


    def get_all_service_aets(self, **kwargs):  # noqa: E501
        """List all DIMSE services AETs

        Will list all DIMSE AETs referring to external DICOM nodes. Requires login and admin privilege. 

        :param bool async_: Perform the request asynchronously
        :return: list[DimseServiceOutput]
        """
        return self.dimse_api.get_all_service_aets(**kwargs)


    def get_project_aet(self, project_aet, **kwargs):  # noqa: E501
        """Get DIMSE project AET

        Get DIMSE project by AET, id or project id. Requires admin privilege. 

        :param str project_aet: (required)
        :param bool async_: Perform the request asynchronously
        :return: DimseProjectOutput
        """
        return self.dimse_api.get_project_aet(project_aet, **kwargs)


    def get_service_aet(self, service_aet, **kwargs):  # noqa: E501
        """Get DIMSE service by AET or id

        Get a DIMSE service. Requires login and admin privilege. 

        :param str service_aet: (required)
        :param bool async_: Perform the request asynchronously
        :return: DimseServiceOutput
        """
        return self.dimse_api.get_service_aet(service_aet, **kwargs)


    def create_download_ticket(self, body, **kwargs):  # noqa: E501
        """Create a download ticket

        Use filters in the payload to exclude/include files. To pass a single filter, each of its conditions should be satisfied. If a file pass at least one filter, it is included in the targets. 

        :param Download body: Download files with tag 'incomplete' OR type 'dicom' (required)
        :param str type: The download type, one of: bulk, classic or full. Default is classic.
        :param bool analyses: For \"full\" download, whether or not to include analyses. Default is false.
        :param bool metadata: For \"full\" download, whether or not to include metadata sidecars. Default is false.
        :param str prefix: A string to customize the name of the download in the format <prefix>_<timestamp>.tar. Defaults to \"scitran\". 
        :param bool async_: Perform the request asynchronously
        :return: DownloadTicketWithSummary
        """
        return self.files_api.create_download_ticket(body, **kwargs)


    def delete_file(self, file_id, **kwargs):  # noqa: E501
        """Delete a File

        A user with read-write or higher permissions on the container may delete files that were uploaded by users or were the output of jobs. (Specifically, files whose `origin.type` is either `job` or `user`.) <br/> A user with admin permissions on the container may delete any file. 

        :param str file_id: (required)
        :param int version:
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        return self.files_api.delete_file(file_id, **kwargs)


    def download_ticket(self, ticket, dest_file, **kwargs):  # noqa: E501
        """Download files listed in the given ticket.

        You can use POST to create a download ticket The files listed in the ticket are put into a tar archive 

        :param str ticket: ID of the download ticket (required)
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.files_api.download_ticket(ticket, dest_file, **kwargs)


    def get_file(self, file_id, **kwargs):  # noqa: E501
        """Get File

        Get file details

        :param str file_id: (required)
        :param int version:
        :param bool async_: Perform the request asynchronously
        :return: FileEntry
        """
        return self.files_api.get_file(file_id, **kwargs)


    def get_file_versions(self, file_id, **kwargs):  # noqa: E501
        """Get Versions

        Get file version details

        :param str file_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: list[FileVersionOutput]
        """
        return self.files_api.get_file_versions(file_id, **kwargs)


    def restore_file(self, file_id, version, evaluate_gear_rules, **kwargs):  # noqa: E501
        """Restore a File

        Restore a specific version of a file as the active version. This will create a new version which will be identical to the restored version. 

        :param str file_id: (required)
        :param int version: (required)
        :param bool evaluate_gear_rules: Specify if gear rules should be reevaluated on the newly created file version (required)
        :param bool async_: Perform the request asynchronously
        :return: FileEntry
        """
        return self.files_api.restore_file(file_id, version, evaluate_gear_rules, **kwargs)


    def upload_by_label(self, **kwargs):  # noqa: E501
        """Multipart form upload with N file fields, each with their desired filename.

        ### Default behavior: > For technical reasons, no form field names can be repeated. Instead, use   (file1, file2) and so forth.  > A non-file form field called \"metadata\" is also required, which must be   a string containing JSON.  > See ``api/schemas/input/labelupload.json`` for the format of this metadata.  ### Signed URL upload with ``ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request. 

        :param str body: Object encoded as a JSON string. It is **required** and used **only** when the ``ticket`` parameter is used. See ``schemas/input/signedurlmetadata.json`` for the format of the json payload. 
        :param str form_data:
        :param str ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.files_api.upload_by_label(**kwargs)


    def upload_by_reaper(self, **kwargs):  # noqa: E501
        """Bottom-up UID matching of Multipart form upload with N file fields, each with their desired filename.

        ### Default behavior:  > Upload data, allowing users to move sessions during scans without causing new data to be   created in referenced project/group.  ### Evaluation Order:  * If a matching acquisition UID is found anywhere on the system, the related files will be placed under that acquisition. * **OR** If a matching session UID is found, a new acquistion is created with the specified UID under that Session UID. * **OR** If a matching group ID and project label are found, a new session and acquisition will be created within that project * **OR** If a matching group ID is found, a new project and session and acquisition will be created within that group. * **OR** A new session and acquisition will be created within a special \"Unknown\" group and project, which is only visible to system administrators.  ### Signed URL upload with ``ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request. 

        :param str body: Object encoded as a JSON string. It is **required** and used **only** when the ``ticket`` parameter is used. See ``schemas/input/signedurlmetadata.json`` for the format of the json payload. 
        :param str form_data:
        :param str ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param bool async_: Perform the request asynchronously
        :return: list[FileEntry]
        """
        return self.files_api.upload_by_reaper(**kwargs)


    def upload_by_uid(self, **kwargs):  # noqa: E501
        """Multipart form upload with N file fields, each with their desired filename.

        ### Default behavior: > Same behavior as /api/upload/label,   except the metadata field must be uid format   See ``api/schemas/input/uidupload.json`` for the format of this metadata.  ### Signed URL upload with ``ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request. 

        :param str body: Object encoded as a JSON string. It is **required** and used **only** when the ``ticket`` parameter is used. See ``schemas/input/signedurlmetadata.json`` for the format of the json payload. 
        :param str form_data:
        :param str ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.files_api.upload_by_uid(**kwargs)


    def upload_match_uid(self, **kwargs):  # noqa: E501
        """Multipart form upload with N file fields, each with their desired filename.

        ### Default behavior: > Accepts uploads to an existing data hierarchy, matched via Session and Acquisition UID   See ``api/schemas/input/uidmatchupload.json`` for the format of this metadata.  ### Signed URL upload with ``ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request. 

        :param str body: Object encoded as a JSON string. It is **required** and used **only** when the ``ticket`` parameter is used. See ``schemas/input/signedurlmetadata.json`` for the format of the json payload. 
        :param str form_data:
        :param str ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.files_api.upload_match_uid(**kwargs)


    def add_gear(self, gear_id_or_name, body, **kwargs):  # noqa: E501
        """Create or update a gear.

        If no existing gear is found, one will be created Otherwise, the specified gear will be updated 

        :param str gear_id_or_name: Name of the gear to interact with (required)
        :param GearDoc body: (required)
        :param bool async_: Perform the request asynchronously
        :return: CollectionNewOutput
        """
        return self.gears_api.add_gear(gear_id_or_name, body, **kwargs)


    def delete_gear(self, gear_id_or_name, **kwargs):  # noqa: E501
        """Delete a gear (not recommended)


        :param str gear_id_or_name: Id of the gear to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.gears_api.delete_gear(gear_id_or_name, **kwargs)


    def get_all_gears(self, **kwargs):  # noqa: E501
        """List all gears


        :param bool all_versions: return all versions of each gear
        :param bool include_invalid: return gears with the 'invalid' flag set
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[GearDoc]
        """
        return self.gears_api.get_all_gears(**kwargs)


    def get_gear(self, gear_id_or_name, **kwargs):  # noqa: E501
        """Retrieve details about a specific gear


        :param str gear_id_or_name: Id of the gear to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: GearDoc
        """
        return self.gears_api.get_gear(gear_id_or_name, **kwargs)


    def get_gear_context(self, gear_id, container_type, container_id, **kwargs):  # noqa: E501
        """Get context values for the given gear and container.

        Ref: https://github.com/flywheel-io/gears/tree/master/spec#contextual-values 

        :param str gear_id: Id of the gear to interact with (required)
        :param str container_type: Type of the container to interact with (required)
        :param str container_id: Id of the container to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: GearContextLookup
        """
        return self.gears_api.get_gear_context(gear_id, container_type, container_id, **kwargs)


    def get_gear_invocation(self, gear_id, **kwargs):  # noqa: E501
        """Get a schema for invoking a gear.


        :param str gear_id: Id of the gear to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.gears_api.get_gear_invocation(gear_id, **kwargs)


    def get_gear_suggest(self, gear_id, container_type, container_id, **kwargs):  # noqa: E501
        """Get files with input suggestions, parent containers, and child containers for the given container.


        :param str gear_id: Id of the gear to interact with (required)
        :param str container_type: Type of the container to interact with (required)
        :param str container_id: Id of the container to interact with (required)
        :param str collection_id: Get suggestions for a collection
        :param str include: Include only \"children\" or \"files\"
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.gears_api.get_gear_suggest(gear_id, container_type, container_id, **kwargs)


    def get_gear_ticket(self, gear_ticket_id, **kwargs):  # noqa: E501
        """Retrieve a specific gear ticket


        :param str gear_ticket_id: The ID of the the gear ticket to retrieve (required)
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.gears_api.get_gear_ticket(gear_ticket_id, **kwargs)


    def get_my_gear_tickets(self, **kwargs):  # noqa: E501
        """Retrieve all gear tickets for the current user


        :param bool gear_names_only: If set, returns a string array of ticket IDs instead of the tickets themselves.
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.gears_api.get_my_gear_tickets(**kwargs)


    def prepare_add_gear(self, **kwargs):  # noqa: E501
        """Prepare a gear upload


        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.gears_api.prepare_add_gear(**kwargs)


    def save_gear(self, ticket, **kwargs):  # noqa: E501
        """Report the result of a gear upload and save the ticket


        :param bool ticket: The ticket ID to save (required)
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.gears_api.save_gear(ticket, **kwargs)


    def add_group(self, body, **kwargs):  # noqa: E501
        """Add a group


        :param Group body: (required)
        :param bool async_: Perform the request asynchronously
        :return: GroupNewOutput
        """
        return self.groups_api.add_group(body, **kwargs)


    def add_group_permission(self, group_id, body, **kwargs):  # noqa: E501
        """Add a permission


        :param str group_id: (required)
        :param PermissionAccessPermission body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.groups_api.add_group_permission(group_id, body, **kwargs)


    def add_group_permission_template(self, group_id, body, **kwargs):  # noqa: E501
        """Add a permission template


        :param str group_id: (required)
        :param RolesRoleAssignment body: (required)
        :param bool propagate:
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.groups_api.add_group_permission_template(group_id, body, **kwargs)


    def add_group_tag(self, group_id, body, **kwargs):  # noqa: E501
        """Add a tag to group.

        Progates changes to projects, sessions and acquisitions

        :param str group_id: (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.groups_api.add_group_tag(group_id, body, **kwargs)


    def add_role_to_group(self, group_id, body, **kwargs):  # noqa: E501
        """Add a role to the pool of roles in a group


        :param str group_id: (required)
        :param RolesGroupRolePoolInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.groups_api.add_role_to_group(group_id, body, **kwargs)


    def delete_group(self, group_id, **kwargs):  # noqa: E501
        """Delete a group


        :param str group_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        return self.groups_api.delete_group(group_id, **kwargs)


    def delete_group_tag(self, group_id, tag_value, **kwargs):  # noqa: E501
        """Delete a tag


        :param str group_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.groups_api.delete_group_tag(group_id, tag_value, **kwargs)


    def delete_group_user_permission(self, group_id, user_id, **kwargs):  # noqa: E501
        """Delete a permission


        :param str group_id: (required)
        :param str user_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.groups_api.delete_group_user_permission(group_id, user_id, **kwargs)


    def delete_group_user_permission_template(self, group_id, user_id, **kwargs):  # noqa: E501
        """Delete a permission


        :param str group_id: (required)
        :param str user_id: (required)
        :param bool propagate:
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.groups_api.delete_group_user_permission_template(group_id, user_id, **kwargs)


    def get_all_group_roles(self, group_id, **kwargs):  # noqa: E501
        """Get list of group roles


        :param str group_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: list[RolesRole]
        """
        return self.groups_api.get_all_group_roles(group_id, **kwargs)


    def get_all_groups(self, **kwargs):  # noqa: E501
        """List all groups


        :param bool exhaustive: Set to return a complete list regardless of permissions
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[Group]
        """
        return self.groups_api.get_all_groups(**kwargs)


    def get_group(self, group_id, **kwargs):  # noqa: E501
        """Get group info


        :param str group_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Group
        """
        return self.groups_api.get_group(group_id, **kwargs)


    def get_group_projects(self, group_id, **kwargs):  # noqa: E501
        """Get all projects in a group


        :param str group_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[Project]
        """
        return self.groups_api.get_group_projects(group_id, **kwargs)


    def get_group_role(self, group_id, role_id, **kwargs):  # noqa: E501
        """Return the role identified by the RoleId


        :param str group_id: (required)
        :param str role_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: RolesRole
        """
        return self.groups_api.get_group_role(group_id, role_id, **kwargs)


    def get_group_tag(self, group_id, tag_value, **kwargs):  # noqa: E501
        """Get the value of a tag, by name.


        :param str group_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: Tag
        """
        return self.groups_api.get_group_tag(group_id, tag_value, **kwargs)


    def get_group_user_permission(self, group_id, user_id, **kwargs):  # noqa: E501
        """List a user&#39;s permissions for this group.


        :param str group_id: (required)
        :param str user_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: PermissionAccessPermission
        """
        return self.groups_api.get_group_user_permission(group_id, user_id, **kwargs)


    def get_group_user_permission_template(self, group_id, user_id, **kwargs):  # noqa: E501
        """List a user&#39;s permissions for this {{resource}}.


        :param str group_id: (required)
        :param str user_id: (required)
        :param bool propagate:
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2003
        """
        return self.groups_api.get_group_user_permission_template(group_id, user_id, **kwargs)


    def modify_group(self, group_id, body, **kwargs):  # noqa: E501
        """Update group


        :param str group_id: (required)
        :param Group body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.groups_api.modify_group(group_id, body, **kwargs)


    def modify_group_user_permission(self, group_id, user_id, body, **kwargs):  # noqa: E501
        """Update a user&#39;s permission for this group.


        :param str group_id: (required)
        :param str user_id: (required)
        :param PermissionAccessPermission body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.groups_api.modify_group_user_permission(group_id, user_id, body, **kwargs)


    def modify_group_user_permission_template(self, group_id, user_id, body, **kwargs):  # noqa: E501
        """Update a user&#39;s permission for this {{resource}}.


        :param str group_id: (required)
        :param str user_id: (required)
        :param RolesRoleAssignment body: (required)
        :param bool propagate:
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.groups_api.modify_group_user_permission_template(group_id, user_id, body, **kwargs)


    def remove_role_from_group(self, group_id, role_id, **kwargs):  # noqa: E501
        """Remove the role from the group


        :param str group_id: (required)
        :param str role_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.groups_api.remove_role_from_group(group_id, role_id, **kwargs)


    def rename_group_tag(self, group_id, tag_value, body, **kwargs):  # noqa: E501
        """Rename a tag.


        :param str group_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.groups_api.rename_group_tag(group_id, tag_value, body, **kwargs)


    def accept_failed_output(self, job_id, **kwargs):  # noqa: E501
        """Accept failed job output.

        Remove the 'from_failed_job' flag from the files. Create any automatic jobs for the accepted files. 

        :param str job_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.jobs_api.accept_failed_output(job_id, **kwargs)


    def add_job(self, body, **kwargs):  # noqa: E501
        """Add a job


        :param Job body: (required)
        :param bool async_: Perform the request asynchronously
        :return: CommonObjectCreated
        """
        return self.jobs_api.add_job(body, **kwargs)


    def add_job_logs(self, job_id, body, **kwargs):  # noqa: E501
        """Add logs to a job.


        :param str job_id: (required)
        :param list[JobLogStatement] body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.jobs_api.add_job_logs(job_id, body, **kwargs)


    def ask_jobs(self, body, **kwargs):  # noqa: E501
        """Ask the queue a question

        Ask the queue a question, recieving work or statistics in return.

        :param JobAsk body: (required)
        :param bool async_: Perform the request asynchronously
        :return: JobAskResponse
        """
        return self.jobs_api.ask_jobs(body, **kwargs)


    def ask_jobs_state(self, job_state, body, **kwargs):  # noqa: E501
        """Ask job count by state

        Ask the queue for the number of jobs for a given state and query.

        :param str job_state: (required)
        :param JobAskState body: (required)
        :param bool async_: Perform the request asynchronously
        :return: JobAskStateResponse
        """
        return self.jobs_api.ask_jobs_state(job_state, body, **kwargs)


    def complete_job(self, job_id, body, **kwargs):  # noqa: E501
        """Complete a job, with information


        :param str job_id: (required)
        :param JobCompletionInput body: (required)
        :param str job_ticket_id:
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.jobs_api.complete_job(job_id, body, **kwargs)


    def determine_provider_for_job(self, body, **kwargs):  # noqa: E501
        """Determine the effective compute provider for a proposed job.


        :param Job body: (required)
        :param bool async_: Perform the request asynchronously
        :return: Provider
        """
        return self.jobs_api.determine_provider_for_job(body, **kwargs)


    def get_all_jobs(self, **kwargs):  # noqa: E501
        """Return all jobs


        :param str states: filter results by job state
        :param str tags: filter results by job tags
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[JobListEntry]
        """
        return self.jobs_api.get_all_jobs(**kwargs)


    def get_job(self, job_id, **kwargs):  # noqa: E501
        """Get job details


        :param str job_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Job
        """
        return self.jobs_api.get_job(job_id, **kwargs)


    def get_job_config(self, job_id, **kwargs):  # noqa: E501
        """Get a job&#39;s config


        :param str job_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: JobConfigOutput
        """
        return self.jobs_api.get_job_config(job_id, **kwargs)


    def get_job_detail(self, job_id, **kwargs):  # noqa: E501
        """Get job container details


        :param str job_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: JobDetail
        """
        return self.jobs_api.get_job_detail(job_id, **kwargs)


    def get_job_logs(self, job_id, **kwargs):  # noqa: E501
        """Get job logs


        :param str job_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: JobLog
        """
        return self.jobs_api.get_job_logs(job_id, **kwargs)


    def get_jobs_stats(self, **kwargs):  # noqa: E501
        """Get stats about all current jobs


        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.jobs_api.get_jobs_stats(**kwargs)


    def get_next_job(self, **kwargs):  # noqa: E501
        """Get the next job in the queue

        Used by the engine.

        :param list[str] tags:
        :param bool async_: Perform the request asynchronously
        :return: Job
        """
        return self.jobs_api.get_next_job(**kwargs)


    def modify_job(self, job_id, body, **kwargs):  # noqa: E501
        """Update a job.

        Updates timestamp. Enforces a valid state machine transition, if any. Rejects any change to a job that is not currently in 'pending' or 'running' state. Accepts the same body as /api/jobs/add , except all fields are optional. 

        :param str job_id: (required)
        :param Job body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.jobs_api.modify_job(job_id, body, **kwargs)


    def prepare_complete_job(self, job_id, **kwargs):  # noqa: E501
        """Create a ticket for completing a job, with id and status.


        :param str job_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: JobCompletionTicket
        """
        return self.jobs_api.prepare_complete_job(job_id, **kwargs)


    def reap_jobs(self, **kwargs):  # noqa: E501
        """Reap stale jobs


        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.jobs_api.reap_jobs(**kwargs)


    def retry_job(self, job_id, **kwargs):  # noqa: E501
        """Retry a job.

        The job must have a state of 'failed', and must not have already been retried. The failed jobs config is copied to a new job. The ID of the new job is returned 

        :param str job_id: (required)
        :param str compute_provider_id:
        :param bool ignore_state:
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.jobs_api.retry_job(job_id, **kwargs)


    def update_job_profile(self, job_id, body, **kwargs):  # noqa: E501
        """Update profile information on a job. (e.g. machine type, etc)


        :param str job_id: (required)
        :param JobProfileInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.jobs_api.update_job_profile(job_id, body, **kwargs)


    def add_modality(self, body, **kwargs):  # noqa: E501
        """Create a new modality.


        :param Modality body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ContainerNewOutput
        """
        return self.modalities_api.add_modality(body, **kwargs)


    def delete_modality(self, modality_id, **kwargs):  # noqa: E501
        """Delete a modality


        :param str modality_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.modalities_api.delete_modality(modality_id, **kwargs)


    def get_all_modalities(self, **kwargs):  # noqa: E501
        """List all modalities.

        Requires login.

        :param bool async_: Perform the request asynchronously
        :return: list[Modality]
        """
        return self.modalities_api.get_all_modalities(**kwargs)


    def get_modality(self, modality_id, **kwargs):  # noqa: E501
        """Get a modality&#39;s classification specification


        :param str modality_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Modality
        """
        return self.modalities_api.get_modality(modality_id, **kwargs)


    def replace_modality(self, modality_id, body, **kwargs):  # noqa: E501
        """Replace modality


        :param str modality_id: (required)
        :param Modality body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.modalities_api.replace_modality(modality_id, body, **kwargs)


    def add_project(self, body, **kwargs):  # noqa: E501
        """Create a new project


        :param Project body: (required)
        :param bool inherit:
        :param bool async_: Perform the request asynchronously
        :return: ContainerNewOutput
        """
        return self.projects_api.add_project(body, **kwargs)


    def add_project_analysis(self, project_id, body, **kwargs):  # noqa: E501
        """Create an analysis and upload files.

        When query param \"job\" is \"true\", send JSON to create an analysis and job.  Otherwise, multipart/form-data to upload files and create an analysis. 

        :param str project_id: (required)
        :param AnalysisInput body: (required)
        :param bool job: Return job as an object instead of an id
        :param bool async_: Perform the request asynchronously
        :return: ContainerNewOutput
        """
        return self.projects_api.add_project_analysis(project_id, body, **kwargs)


    def add_project_analysis_note(self, project_id, analysis_id, body, **kwargs):  # noqa: E501
        """Add a note to project analysis.


        :param str project_id: (required)
        :param str analysis_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.projects_api.add_project_analysis_note(project_id, analysis_id, body, **kwargs)


    def add_project_note(self, project_id, body, **kwargs):  # noqa: E501
        """Add a note to project.


        :param str project_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.projects_api.add_project_note(project_id, body, **kwargs)


    def add_project_permission(self, project_id, body, **kwargs):  # noqa: E501
        """Add a permission


        :param str project_id: (required)
        :param RolesRoleAssignment body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.projects_api.add_project_permission(project_id, body, **kwargs)


    def add_project_rule(self, project_id, body, **kwargs):  # noqa: E501
        """Create a new rule for a project.


        :param str project_id: (required)
        :param Rule body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.projects_api.add_project_rule(project_id, body, **kwargs)


    def add_project_tag(self, project_id, body, **kwargs):  # noqa: E501
        """Add a tag to project.

        Progates changes to projects, sessions and acquisitions

        :param str project_id: (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.projects_api.add_project_tag(project_id, body, **kwargs)


    def delete_project(self, project_id, **kwargs):  # noqa: E501
        """Delete a project

        Only site admins and users with \"admin\" project permissions may delete a project

        :param str project_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        return self.projects_api.delete_project(project_id, **kwargs)


    def delete_project_analysis(self, project_id, analysis_id, **kwargs):  # noqa: E501
        """Delete an anaylsis


        :param str project_id: (required)
        :param str analysis_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        return self.projects_api.delete_project_analysis(project_id, analysis_id, **kwargs)


    def delete_project_analysis_note(self, project_id, analysis_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from project analysis.


        :param str project_id: (required)
        :param str analysis_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.projects_api.delete_project_analysis_note(project_id, analysis_id, note_id, **kwargs)


    def delete_project_file(self, project_id, file_name, **kwargs):  # noqa: E501
        """Delete a file

        A user with read-write or higher permissions on the container may delete files that were uploaded by users or were the output of jobs. (Specifically, files whose `origin.type` is either `job` or `user`.) <br/> A user with admin permissions on the container may delete any file. 

        :param str project_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.projects_api.delete_project_file(project_id, file_name, **kwargs)


    def delete_project_note(self, project_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from project


        :param str project_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.projects_api.delete_project_note(project_id, note_id, **kwargs)


    def delete_project_tag(self, project_id, tag_value, **kwargs):  # noqa: E501
        """Delete a tag


        :param str project_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.projects_api.delete_project_tag(project_id, tag_value, **kwargs)


    def delete_project_user_permission(self, project_id, user_id, **kwargs):  # noqa: E501
        """Delete a permission


        :param str project_id: (required)
        :param str user_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.projects_api.delete_project_user_permission(project_id, user_id, **kwargs)


    def download_file_from_project(self, project_id, file_name, dest_file, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str project_id: (required)
        :param str file_name: (required)
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: DownloadTicket
        """
        return self.projects_api.download_file_from_project(project_id, file_name, dest_file, **kwargs)


    def get_project_file_zip_info(self, project_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str project_id: (required)
        :param str file_name: (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.projects_api.get_project_file_zip_info(project_id, file_name, **kwargs)


    def get_project_download_url(self, project_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str project_id: (required)
        :param str file_name: (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async_: Perform the request asynchronously
        :return: DownloadTicket
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.projects_api.get_project_download_ticket(project_id, file_name, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def download_input_from_project_analysis(self, project_id, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str project_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.projects_api.download_input_from_project_analysis(project_id, analysis_id, filename, dest_file, **kwargs)


    def get_project_analysis_input_zip_info(self, project_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str project_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.projects_api.get_project_analysis_input_zip_info(project_id, analysis_id, filename, **kwargs)


    def get_project_analysis_input_download_url(self, project_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str project_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.projects_api.get_project_analysis_input_download_ticket(project_id, analysis_id, filename, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def download_output_from_project_analysis(self, project_id, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str project_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.projects_api.download_output_from_project_analysis(project_id, analysis_id, filename, dest_file, **kwargs)


    def get_project_analysis_output_zip_info(self, project_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str project_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.projects_api.get_project_analysis_output_zip_info(project_id, analysis_id, filename, **kwargs)


    def get_project_analysis_output_download_url(self, project_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str project_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.projects_api.get_project_analysis_output_download_ticket(project_id, analysis_id, filename, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def download_project_analysis_inputs(self, project_id, analysis_id, **kwargs):  # noqa: E501
        """Download analysis inputs.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for all inputs in the anlaysis If no \"ticket\" query param is included, server error 500 

        :param str project_id: (required)
        :param str analysis_id: (required)
        :param str ticket: ticket id of the inputs to download
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.projects_api.download_project_analysis_inputs(project_id, analysis_id, **kwargs)


    def download_project_analysis_outputs(self, project_id, analysis_id, **kwargs):  # noqa: E501
        """Download analysis outputs.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for all outputs in the anlaysis If no \"ticket\" query param is included, server error 500 

        :param str project_id: (required)
        :param str analysis_id: (required)
        :param str ticket: ticket id of the outputs to download
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.projects_api.download_project_analysis_outputs(project_id, analysis_id, **kwargs)


    def end_project_packfile_upload(self, project_id, token, metadata, file_count, **kwargs):  # noqa: E501
        """End a packfile upload


        :param str project_id: (required)
        :param str token: (required)
        :param str metadata: string-encoded metadata json object. (required)
        :param str file_count: Number of files uploaded into this packfile. (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.projects_api.end_project_packfile_upload(project_id, token, metadata, file_count, **kwargs)


    def get_all_projects(self, **kwargs):  # noqa: E501
        """Get a list of projects


        :param bool exhaustive: Set to return a complete list regardless of permissions
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[Project]
        """
        return self.projects_api.get_all_projects(**kwargs)


    def get_all_projects_groups(self, **kwargs):  # noqa: E501
        """List all groups which have a project in them


        :param bool async_: Perform the request asynchronously
        :return: list[Group]
        """
        return self.projects_api.get_all_projects_groups(**kwargs)


    def get_project(self, project_id, **kwargs):  # noqa: E501
        """Get a single project


        :param str project_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Project
        """
        return self.projects_api.get_project(project_id, **kwargs)


    def get_project_acquisitions(self, project_id, **kwargs):  # noqa: E501
        """List all acquisitions for the given project.


        :param str project_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[Acquisition]
        """
        return self.projects_api.get_project_acquisitions(project_id, **kwargs)


    def get_project_analyses(self, project_id, **kwargs):  # noqa: E501
        """Get analyses for project.

        Returns analyses that directly belong to this resource.

        :param str project_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[AnalysisListEntry]
        """
        return self.projects_api.get_project_analyses(project_id, **kwargs)


    def get_project_analysis(self, project_id, analysis_id, **kwargs):  # noqa: E501
        """Get an analysis.


        :param str project_id: (required)
        :param str analysis_id: (required)
        :param bool inflate_job: Return job as an object instead of an id
        :param bool async_: Perform the request asynchronously
        :return: AnalysisOutput
        """
        return self.projects_api.get_project_analysis(project_id, analysis_id, **kwargs)


    def get_project_file_info(self, project_id, file_name, **kwargs):  # noqa: E501
        """Get info for a particular file.


        :param str project_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: FileEntry
        """
        return self.projects_api.get_project_file_info(project_id, file_name, **kwargs)


    def get_project_note(self, project_id, note_id, **kwargs):  # noqa: E501
        """Get a note on project.


        :param str project_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Note
        """
        return self.projects_api.get_project_note(project_id, note_id, **kwargs)


    def get_project_rule(self, project_id, rule_id, **kwargs):  # noqa: E501
        """Get a project rule.


        :param str project_id: (required)
        :param str rule_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Rule
        """
        return self.projects_api.get_project_rule(project_id, rule_id, **kwargs)


    def get_project_rules(self, project_id, **kwargs):  # noqa: E501
        """List all rules for a project.


        :param str project_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: list[Rule]
        """
        return self.projects_api.get_project_rules(project_id, **kwargs)


    def get_project_sessions(self, project_id, **kwargs):  # noqa: E501
        """List all sessions for the given project.


        :param str project_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[Session]
        """
        return self.projects_api.get_project_sessions(project_id, **kwargs)


    def get_project_subjects(self, project_id, **kwargs):  # noqa: E501
        """List all subjects for the given project.


        :param str project_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[Subject]
        """
        return self.projects_api.get_project_subjects(project_id, **kwargs)


    def get_project_tag(self, project_id, tag_value, **kwargs):  # noqa: E501
        """Get the value of a tag, by name.


        :param str project_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: Tag
        """
        return self.projects_api.get_project_tag(project_id, tag_value, **kwargs)


    def get_project_user_permission(self, project_id, user_id, **kwargs):  # noqa: E501
        """List a user&#39;s permissions for this project.


        :param str project_id: (required)
        :param str user_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2003
        """
        return self.projects_api.get_project_user_permission(project_id, user_id, **kwargs)


    def modify_project(self, project_id, body, **kwargs):  # noqa: E501
        """Update a project


        :param str project_id: (required)
        :param Project body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.projects_api.modify_project(project_id, body, **kwargs)


    def modify_project_analysis(self, project_id, analysis_id, body, **kwargs):  # noqa: E501
        """Modify an analysis.


        :param str project_id: (required)
        :param str analysis_id: (required)
        :param AnalysisUpdate body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.projects_api.modify_project_analysis(project_id, analysis_id, body, **kwargs)


    def modify_project_file(self, project_id, file_name, body, **kwargs):  # noqa: E501
        """Modify a file&#39;s attributes

        Note: If modifying a file's modality, the current classification will be cleared (except for items in the \"Custom\" list) 

        :param str project_id: (required)
        :param str file_name: (required)
        :param FileEntry body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2005
        """
        return self.projects_api.modify_project_file(project_id, file_name, body, **kwargs)


    def modify_project_file_classification(self, project_id, file_name, body, **kwargs):  # noqa: E501
        """Update classification for a particular file.

        If replacing a file's classification, the modality can optionally be modified as well.

        :param str project_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2005
        """
        return self.projects_api.modify_project_file_classification(project_id, file_name, body, **kwargs)


    def modify_project_file_info(self, project_id, file_name, body, **kwargs):  # noqa: E501
        """Update info for a particular file.


        :param str project_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.projects_api.modify_project_file_info(project_id, file_name, body, **kwargs)


    def modify_project_info(self, project_id, body, **kwargs):  # noqa: E501
        """Update or replace info for a project.


        :param str project_id: (required)
        :param InfoUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.projects_api.modify_project_info(project_id, body, **kwargs)


    def modify_project_note(self, project_id, note_id, body, **kwargs):  # noqa: E501
        """Update a note on project.


        :param str project_id: (required)
        :param str note_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.projects_api.modify_project_note(project_id, note_id, body, **kwargs)


    def modify_project_rule(self, project_id, rule_id, body, **kwargs):  # noqa: E501
        """Update a rule on a project.


        :param str project_id: (required)
        :param str rule_id: (required)
        :param Rule body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.projects_api.modify_project_rule(project_id, rule_id, body, **kwargs)


    def modify_project_user_permission(self, project_id, user_id, body, **kwargs):  # noqa: E501
        """Update a user&#39;s permission for this project.


        :param str project_id: (required)
        :param str user_id: (required)
        :param RolesRoleAssignment body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.projects_api.modify_project_user_permission(project_id, user_id, body, **kwargs)


    def project_packfile_upload(self, project_id, token, file, **kwargs):  # noqa: E501
        """Add files to an in-progress packfile


        :param str project_id: (required)
        :param str token: (required)
        :param file file: (required)
        :param bool async_: Perform the request asynchronously
        :return: list[FileEntry]
        """
        return self.projects_api.project_packfile_upload(project_id, token, file, **kwargs)


    def recalc_all_projects(self, **kwargs):  # noqa: E501
        """Recalculate all sessions against their project templates.

        Iterates all projects that have a session template. Recalculate if projects' sessions satisfy the template. Returns list of modified session ids. 

        :param bool async_: Perform the request asynchronously
        :return: SessionTemplateRecalcOutput
        """
        return self.projects_api.recalc_all_projects(**kwargs)


    def recalc_project(self, project_id, **kwargs):  # noqa: E501
        """Recalculate if sessions in the project satisfy the template.

        Returns list of modified session ids.

        :param str project_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: SessionTemplateRecalcOutput
        """
        return self.projects_api.recalc_project(project_id, **kwargs)


    def remove_project_rule(self, project_id, rule_id, **kwargs):  # noqa: E501
        """Remove a project rule.


        :param str project_id: (required)
        :param str rule_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        return self.projects_api.remove_project_rule(project_id, rule_id, **kwargs)


    def remove_project_template(self, project_id, **kwargs):  # noqa: E501
        """Remove the session template for a project.


        :param str project_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        return self.projects_api.remove_project_template(project_id, **kwargs)


    def rename_project_tag(self, project_id, tag_value, body, **kwargs):  # noqa: E501
        """Rename a tag.


        :param str project_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.projects_api.rename_project_tag(project_id, tag_value, body, **kwargs)


    def replace_project_file(self, project_id, file_name, **kwargs):  # noqa: E501
        """Replace a file


        :param str project_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.projects_api.replace_project_file(project_id, file_name, **kwargs)


    def set_project_template(self, project_id, body, **kwargs):  # noqa: E501
        """Set the session template for a project.


        :param str project_id: (required)
        :param list[ProjectTemplateSessionTemplate] body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.projects_api.set_project_template(project_id, body, **kwargs)


    def start_project_packfile_upload(self, project_id, **kwargs):  # noqa: E501
        """Start a packfile upload to project


        :param str project_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: PackfileStart
        """
        return self.projects_api.start_project_packfile_upload(project_id, **kwargs)


    def upload_file_to_project(self, project_id, file, **kwargs):  # noqa: E501
        """Upload a file to project.


        :param str project_id: (required)
        :param file file: The file to upload (required)
        :param str metadata: File metadata
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.projects_api.upload_file_to_project(project_id, file, **kwargs)


    def upload_output_to_project_analysis(self, project_id, analysis_id, file, **kwargs):  # noqa: E501
        """Upload an output file to analysis.


        :param str project_id: (required)
        :param str analysis_id: (required)
        :param file file: The file to upload (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.projects_api.upload_output_to_project_analysis(project_id, analysis_id, file, **kwargs)


    def collect_usage(self, **kwargs):  # noqa: E501
        """Collect daily usage statistics.

        Collects usage statistics for the selected day (or yesterday if no day is given)

        :param int year: The year portion of the date
        :param int month: The month portion of the date
        :param int day: The day portion of the date
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.reports_api.collect_usage(**kwargs)


    def get_access_log_report(self, **kwargs):  # noqa: E501
        """Get a report of access log entries for the given parameters


        :param str start_date: An ISO formatted timestamp for the start time of the report
        :param str end_date: An ISO formatted timestamp for the end time of the report
        :param str uid: User id of the target user
        :param int limit: Maximum number of records to return
        :param str subject: Limit the report to the subject code of subject accessed
        :param str project: Limit the report to the project id
        :param list[str] access_type: The list of access_types to filter logs
        :param bool csv: Set to download a csv file instead of json
        :param bool async_: Perform the request asynchronously
        :return: list[ReportAccessLogEntry]
        """
        return self.reports_api.get_access_log_report(**kwargs)


    def get_access_log_types(self, **kwargs):  # noqa: E501
        """Get the list of types of access log entries


        :param bool async_: Perform the request asynchronously
        :return: list[str]
        """
        return self.reports_api.get_access_log_types(**kwargs)


    def get_daily_usage_report(self, **kwargs):  # noqa: E501
        """Get a daily usage report for the given month.

        If no year/month pair is given, the current month will be used.

        :param int year: The year portion of the date
        :param int month: The month portion of the date
        :param str group: Limit the report to the given group id
        :param str project: Limit the report to the given project id
        :param bool csv: Download the report as a CSV file
        :param bool async_: Perform the request asynchronously
        :return: list[ReportDailyUsageEntry]
        """
        return self.reports_api.get_daily_usage_report(**kwargs)


    def get_legacy_usage_report(self, type, **kwargs):  # noqa: E501
        """Get a usage report for the site grouped by month or project

        This report is DEPRECATED and will be removed in a future release

        :param str type: The type of usage report to generate (required)
        :param str start_date: An ISO formatted timestamp for the start time of the report
        :param str end_date: An ISO formatted timestamp for the end time of the report
        :param bool async_: Perform the request asynchronously
        :return: list[ReportLegacyUsageEntry]
        """
        return self.reports_api.get_legacy_usage_report(type, **kwargs)


    def get_project_report(self, **kwargs):  # noqa: E501
        """get_project_report


        :param str projects: Specify multiple times to include projects in the report
        :param str start_date: Report start date
        :param str end_date: Report end date
        :param bool async_: Perform the request asynchronously
        :return: ReportProject
        """
        return self.reports_api.get_project_report(**kwargs)


    def get_site_report(self, **kwargs):  # noqa: E501
        """get_site_report


        :param bool async_: Perform the request asynchronously
        :return: ReportSite
        """
        return self.reports_api.get_site_report(**kwargs)


    def get_usage_availability(self, **kwargs):  # noqa: E501
        """Get year/month combinations where report data is available.


        :param bool async_: Perform the request asynchronously
        :return: list[ReportTimePeriod]
        """
        return self.reports_api.get_usage_availability(**kwargs)


    def get_usage_report(self, **kwargs):  # noqa: E501
        """Get a usage report for the given month.

        If no year/month pair is given, the current month will be used.

        :param int year: The year portion of the date
        :param int month: The month portion of the date
        :param bool csv: Download the report as a CSV file
        :param bool async_: Perform the request asynchronously
        :return: list[ReportUsageEntry]
        """
        return self.reports_api.get_usage_report(**kwargs)


    def add_role(self, body, **kwargs):  # noqa: E501
        """Add a new role


        :param RolesRoleInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: RolesRole
        """
        return self.roles_api.add_role(body, **kwargs)


    def delete_role(self, role_id, **kwargs):  # noqa: E501
        """Delete the role


        :param str role_id: The ID of the role (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.roles_api.delete_role(role_id, **kwargs)


    def get_all_roles(self, **kwargs):  # noqa: E501
        """Get list of all roles


        :param bool async_: Perform the request asynchronously
        :return: list[RolesRole]
        """
        return self.roles_api.get_all_roles(**kwargs)


    def get_role(self, role_id, **kwargs):  # noqa: E501
        """Return the role identified by the RoleId


        :param str role_id: The ID of the role (required)
        :param bool async_: Perform the request asynchronously
        :return: RolesRole
        """
        return self.roles_api.get_role(role_id, **kwargs)


    def modify_role(self, role_id, body, **kwargs):  # noqa: E501
        """Update the role identified by RoleId


        :param str role_id: The ID of the role (required)
        :param RolesRoleInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.roles_api.modify_role(role_id, body, **kwargs)


    def add_site_rule(self, body, **kwargs):  # noqa: E501
        """Create a new site rule.


        :param Rule body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.rules_api.add_site_rule(body, **kwargs)


    def get_site_rule(self, rule_id, **kwargs):  # noqa: E501
        """Get a site rule.


        :param str rule_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Rule
        """
        return self.rules_api.get_site_rule(rule_id, **kwargs)


    def get_site_rules(self, **kwargs):  # noqa: E501
        """List all site rules.


        :param bool async_: Perform the request asynchronously
        :return: list[Rule]
        """
        return self.rules_api.get_site_rules(**kwargs)


    def modify_site_rule(self, rule_id, body, **kwargs):  # noqa: E501
        """Update a site rule.


        :param str rule_id: (required)
        :param Rule body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.rules_api.modify_site_rule(rule_id, body, **kwargs)


    def remove_site_rule(self, rule_id, **kwargs):  # noqa: E501
        """Remove a site rule.


        :param str rule_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        return self.rules_api.remove_site_rule(rule_id, **kwargs)


    def add_session(self, body, **kwargs):  # noqa: E501
        """Create a new session


        :param Session body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ContainerNewOutput
        """
        return self.sessions_api.add_session(body, **kwargs)


    def add_session_analysis(self, session_id, body, **kwargs):  # noqa: E501
        """Create an analysis and upload files.

        When query param \"job\" is \"true\", send JSON to create an analysis and job.  Otherwise, multipart/form-data to upload files and create an analysis. 

        :param str session_id: (required)
        :param AnalysisInput body: (required)
        :param bool job: Return job as an object instead of an id
        :param bool async_: Perform the request asynchronously
        :return: ContainerNewOutput
        """
        return self.sessions_api.add_session_analysis(session_id, body, **kwargs)


    def add_session_analysis_note(self, session_id, analysis_id, body, **kwargs):  # noqa: E501
        """Add a note to session analysis.


        :param str session_id: (required)
        :param str analysis_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.sessions_api.add_session_analysis_note(session_id, analysis_id, body, **kwargs)


    def add_session_note(self, session_id, body, **kwargs):  # noqa: E501
        """Add a note to session.


        :param str session_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.sessions_api.add_session_note(session_id, body, **kwargs)


    def add_session_tag(self, session_id, body, **kwargs):  # noqa: E501
        """Add a tag to session.

        Progates changes to projects, sessions and acquisitions

        :param str session_id: (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.sessions_api.add_session_tag(session_id, body, **kwargs)


    def delete_session(self, session_id, **kwargs):  # noqa: E501
        """Delete a session

        Read-write project permissions are required to delete a session. </br>Admin project permissions are required if the session or it's acquisitions contain data uploaded by sources other than users and jobs.

        :param str session_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        return self.sessions_api.delete_session(session_id, **kwargs)


    def delete_session_analysis(self, session_id, analysis_id, **kwargs):  # noqa: E501
        """Delete an anaylsis


        :param str session_id: (required)
        :param str analysis_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        return self.sessions_api.delete_session_analysis(session_id, analysis_id, **kwargs)


    def delete_session_analysis_note(self, session_id, analysis_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from session analysis.


        :param str session_id: (required)
        :param str analysis_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.sessions_api.delete_session_analysis_note(session_id, analysis_id, note_id, **kwargs)


    def delete_session_file(self, session_id, file_name, **kwargs):  # noqa: E501
        """Delete a file

        A user with read-write or higher permissions on the container may delete files that were uploaded by users or were the output of jobs. (Specifically, files whose `origin.type` is either `job` or `user`.) <br/> A user with admin permissions on the container may delete any file. 

        :param str session_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.sessions_api.delete_session_file(session_id, file_name, **kwargs)


    def delete_session_note(self, session_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from session


        :param str session_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.sessions_api.delete_session_note(session_id, note_id, **kwargs)


    def delete_session_tag(self, session_id, tag_value, **kwargs):  # noqa: E501
        """Delete a tag


        :param str session_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.sessions_api.delete_session_tag(session_id, tag_value, **kwargs)


    def download_file_from_session(self, session_id, file_name, dest_file, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str session_id: (required)
        :param str file_name: (required)
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: DownloadTicket
        """
        return self.sessions_api.download_file_from_session(session_id, file_name, dest_file, **kwargs)


    def get_session_file_zip_info(self, session_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str session_id: (required)
        :param str file_name: (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.sessions_api.get_session_file_zip_info(session_id, file_name, **kwargs)


    def get_session_download_url(self, session_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str session_id: (required)
        :param str file_name: (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async_: Perform the request asynchronously
        :return: DownloadTicket
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.sessions_api.get_session_download_ticket(session_id, file_name, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def download_input_from_session_analysis(self, session_id, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str session_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.sessions_api.download_input_from_session_analysis(session_id, analysis_id, filename, dest_file, **kwargs)


    def get_session_analysis_input_zip_info(self, session_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str session_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.sessions_api.get_session_analysis_input_zip_info(session_id, analysis_id, filename, **kwargs)


    def get_session_analysis_input_download_url(self, session_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str session_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.sessions_api.get_session_analysis_input_download_ticket(session_id, analysis_id, filename, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def download_output_from_session_analysis(self, session_id, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str session_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.sessions_api.download_output_from_session_analysis(session_id, analysis_id, filename, dest_file, **kwargs)


    def get_session_analysis_output_zip_info(self, session_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str session_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.sessions_api.get_session_analysis_output_zip_info(session_id, analysis_id, filename, **kwargs)


    def get_session_analysis_output_download_url(self, session_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str session_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.sessions_api.get_session_analysis_output_download_ticket(session_id, analysis_id, filename, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def download_session_analysis_inputs(self, session_id, analysis_id, **kwargs):  # noqa: E501
        """Download analysis inputs.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for all inputs in the anlaysis If no \"ticket\" query param is included, server error 500 

        :param str session_id: (required)
        :param str analysis_id: (required)
        :param str ticket: ticket id of the inputs to download
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.sessions_api.download_session_analysis_inputs(session_id, analysis_id, **kwargs)


    def download_session_analysis_outputs(self, session_id, analysis_id, **kwargs):  # noqa: E501
        """Download analysis outputs.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for all outputs in the anlaysis If no \"ticket\" query param is included, server error 500 

        :param str session_id: (required)
        :param str analysis_id: (required)
        :param str ticket: ticket id of the outputs to download
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.sessions_api.download_session_analysis_outputs(session_id, analysis_id, **kwargs)


    def get_all_sessions(self, **kwargs):  # noqa: E501
        """Get a list of sessions


        :param bool exhaustive: Set to return a complete list regardless of permissions
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[Session]
        """
        return self.sessions_api.get_all_sessions(**kwargs)


    def get_session(self, session_id, **kwargs):  # noqa: E501
        """Get a single session


        :param str session_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Session
        """
        return self.sessions_api.get_session(session_id, **kwargs)


    def get_session_acquisitions(self, session_id, **kwargs):  # noqa: E501
        """List acquisitions in a session


        :param str session_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[Acquisition]
        """
        return self.sessions_api.get_session_acquisitions(session_id, **kwargs)


    def get_session_analyses(self, session_id, **kwargs):  # noqa: E501
        """Get analyses for session.

        Returns analyses that directly belong to this resource.

        :param str session_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[AnalysisListEntry]
        """
        return self.sessions_api.get_session_analyses(session_id, **kwargs)


    def get_session_analysis(self, session_id, analysis_id, **kwargs):  # noqa: E501
        """Get an analysis.


        :param str session_id: (required)
        :param str analysis_id: (required)
        :param bool inflate_job: Return job as an object instead of an id
        :param bool async_: Perform the request asynchronously
        :return: AnalysisOutput
        """
        return self.sessions_api.get_session_analysis(session_id, analysis_id, **kwargs)


    def get_session_file_info(self, session_id, file_name, **kwargs):  # noqa: E501
        """Get info for a particular file.


        :param str session_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: FileEntry
        """
        return self.sessions_api.get_session_file_info(session_id, file_name, **kwargs)


    def get_session_jobs(self, session_id, **kwargs):  # noqa: E501
        """Return any jobs that use inputs from this session


        :param str session_id: (required)
        :param str states: filter results by job state
        :param str tags: filter results by job tags
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: SessionJobsOutput
        """
        return self.sessions_api.get_session_jobs(session_id, **kwargs)


    def get_session_note(self, session_id, note_id, **kwargs):  # noqa: E501
        """Get a note on session.


        :param str session_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Note
        """
        return self.sessions_api.get_session_note(session_id, note_id, **kwargs)


    def get_session_tag(self, session_id, tag_value, **kwargs):  # noqa: E501
        """Get the value of a tag, by name.


        :param str session_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: Tag
        """
        return self.sessions_api.get_session_tag(session_id, tag_value, **kwargs)


    def modify_session(self, session_id, body, **kwargs):  # noqa: E501
        """Update a session


        :param str session_id: (required)
        :param Session body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.sessions_api.modify_session(session_id, body, **kwargs)


    def modify_session_analysis(self, session_id, analysis_id, body, **kwargs):  # noqa: E501
        """Modify an analysis.


        :param str session_id: (required)
        :param str analysis_id: (required)
        :param AnalysisUpdate body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.sessions_api.modify_session_analysis(session_id, analysis_id, body, **kwargs)


    def modify_session_file(self, session_id, file_name, body, **kwargs):  # noqa: E501
        """Modify a file&#39;s attributes

        Note: If modifying a file's modality, the current classification will be cleared (except for items in the \"Custom\" list) 

        :param str session_id: (required)
        :param str file_name: (required)
        :param FileEntry body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2005
        """
        return self.sessions_api.modify_session_file(session_id, file_name, body, **kwargs)


    def modify_session_file_classification(self, session_id, file_name, body, **kwargs):  # noqa: E501
        """Update classification for a particular file.

        If replacing a file's classification, the modality can optionally be modified as well.

        :param str session_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2005
        """
        return self.sessions_api.modify_session_file_classification(session_id, file_name, body, **kwargs)


    def modify_session_file_info(self, session_id, file_name, body, **kwargs):  # noqa: E501
        """Update info for a particular file.


        :param str session_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.sessions_api.modify_session_file_info(session_id, file_name, body, **kwargs)


    def modify_session_info(self, session_id, body, **kwargs):  # noqa: E501
        """Update or replace info for a session.


        :param str session_id: (required)
        :param InfoUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.sessions_api.modify_session_info(session_id, body, **kwargs)


    def modify_session_note(self, session_id, note_id, body, **kwargs):  # noqa: E501
        """Update a note on session.


        :param str session_id: (required)
        :param str note_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.sessions_api.modify_session_note(session_id, note_id, body, **kwargs)


    def rename_session_tag(self, session_id, tag_value, body, **kwargs):  # noqa: E501
        """Rename a tag.


        :param str session_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.sessions_api.rename_session_tag(session_id, tag_value, body, **kwargs)


    def replace_session_file(self, session_id, file_name, **kwargs):  # noqa: E501
        """Replace a file


        :param str session_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.sessions_api.replace_session_file(session_id, file_name, **kwargs)


    def upload_file_to_session(self, session_id, file, **kwargs):  # noqa: E501
        """Upload a file to session.


        :param str session_id: (required)
        :param file file: The file to upload (required)
        :param str metadata: File metadata
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.sessions_api.upload_file_to_session(session_id, file, **kwargs)


    def upload_output_to_session_analysis(self, session_id, analysis_id, file, **kwargs):  # noqa: E501
        """Upload an output file to analysis.


        :param str session_id: (required)
        :param str analysis_id: (required)
        :param file file: The file to upload (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.sessions_api.upload_output_to_session_analysis(session_id, analysis_id, file, **kwargs)


    def add_provider(self, body, **kwargs):  # noqa: E501
        """Add a new provider


        :param ProviderInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: CollectionNewOutput
        """
        return self.site_api.add_provider(body, **kwargs)


    def get_provider(self, provider_id, **kwargs):  # noqa: E501
        """Return the provider identified by ProviderId


        :param str provider_id: The ID of the provider (required)
        :param bool async_: Perform the request asynchronously
        :return: Provider
        """
        return self.site_api.get_provider(provider_id, **kwargs)


    def get_provider_config(self, provider_id, **kwargs):  # noqa: E501
        """Return the configuration for provider identified by ProviderId

        The returned configuration will be redacted, with any privileged values replaced with null.

        :param str provider_id: The ID of the provider (required)
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        return self.site_api.get_provider_config(provider_id, **kwargs)


    def get_providers(self, **kwargs):  # noqa: E501
        """Return a list of all providers on the site


        :param str _class: Limit the response to the given provider class
        :param bool async_: Perform the request asynchronously
        :return: list[Provider]
        """
        return self.site_api.get_providers(**kwargs)


    def get_site_settings(self, **kwargs):  # noqa: E501
        """Return administrative site settings

        Returns the site settings, which includes center-pays gear list. If the site settings have never been created, then center_gears will be null, rather than an empty list. 

        :param bool async_: Perform the request asynchronously
        :return: ConfigSiteSettings
        """
        return self.site_api.get_site_settings(**kwargs)


    def modify_provider(self, provider_id, body, **kwargs):  # noqa: E501
        """Update the provider identified by ProviderId


        :param str provider_id: The ID of the provider (required)
        :param ProviderInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.site_api.modify_provider(provider_id, body, **kwargs)


    def modify_site_settings(self, body, **kwargs):  # noqa: E501
        """Update administrative site settings


        :param ConfigSiteSettingsInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.site_api.modify_site_settings(body, **kwargs)


    def add_subject(self, body, **kwargs):  # noqa: E501
        """Create a new subject


        :param Subject body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ContainerNewOutput
        """
        return self.subjects_api.add_subject(body, **kwargs)


    def add_subject_analysis(self, subject_id, body, **kwargs):  # noqa: E501
        """Create an analysis and upload files.

        When query param \"job\" is \"true\", send JSON to create an analysis and job.  Otherwise, multipart/form-data to upload files and create an analysis. 

        :param str subject_id: (required)
        :param AnalysisInput body: (required)
        :param bool job: Return job as an object instead of an id
        :param bool async_: Perform the request asynchronously
        :return: ContainerNewOutput
        """
        return self.subjects_api.add_subject_analysis(subject_id, body, **kwargs)


    def add_subject_analysis_note(self, subject_id, analysis_id, body, **kwargs):  # noqa: E501
        """Add a note to subject analysis.


        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.subjects_api.add_subject_analysis_note(subject_id, analysis_id, body, **kwargs)


    def add_subject_note(self, subject_id, body, **kwargs):  # noqa: E501
        """Add a note to subject.


        :param str subject_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.subjects_api.add_subject_note(subject_id, body, **kwargs)


    def add_subject_tag(self, subject_id, body, **kwargs):  # noqa: E501
        """Add a tag to subject.

        Progates changes to projects, sessions and acquisitions

        :param str subject_id: (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.subjects_api.add_subject_tag(subject_id, body, **kwargs)


    def create_master_subject_code(self, body, **kwargs):  # noqa: E501
        """Request a master subject code for the given patient

        The workflow is the following.   - send `patient_id` (e.g., MRN) and/or `first_name`, `last_name`, `date_of_birth`   - indicate whether to use `patient_id` for identification or `first_name`, `last_name`, `date_of_birth`     by the `use_patient_id` field   - the response will contain a master subject code   - if you send the same identifying information again, you will receive the same code  Note that if you received a MSC code for example by just providing the `patient_id`, you can save more information for that MSC in a second request (`first_name`, `last_name`, `date_of_birth`). Only the missing fields will be set, so you can't update any existing field (e.g. changing the name). Since you can create multiple MSC codes with the same name and date of birth using different patient ids, you will get HTTP 400 error if you request an MSC code by name and date of birth and there are multiple matches. In this case you need to use patient id. 

        :param Body body: (required)
        :param bool async_: Perform the request asynchronously
        :return: MasterSubjectCodeCodeOutput
        """
        return self.subjects_api.create_master_subject_code(body, **kwargs)


    def delete_subject(self, subject_id, **kwargs):  # noqa: E501
        """Delete a subject

        Read-write project permissions are required to delete a subject. </br>Admin project permissions are required if the subject or it's acquisitions contain data uploaded by sources other than users and jobs.

        :param str subject_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        return self.subjects_api.delete_subject(subject_id, **kwargs)


    def delete_subject_analysis(self, subject_id, analysis_id, **kwargs):  # noqa: E501
        """Delete an anaylsis


        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        return self.subjects_api.delete_subject_analysis(subject_id, analysis_id, **kwargs)


    def delete_subject_analysis_note(self, subject_id, analysis_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from subject analysis.


        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.subjects_api.delete_subject_analysis_note(subject_id, analysis_id, note_id, **kwargs)


    def delete_subject_file(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Delete a file

        A user with read-write or higher permissions on the container may delete files that were uploaded by users or were the output of jobs. (Specifically, files whose `origin.type` is either `job` or `user`.) <br/> A user with admin permissions on the container may delete any file. 

        :param str subject_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.subjects_api.delete_subject_file(subject_id, file_name, **kwargs)


    def delete_subject_note(self, subject_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from subject


        :param str subject_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.subjects_api.delete_subject_note(subject_id, note_id, **kwargs)


    def delete_subject_tag(self, subject_id, tag_value, **kwargs):  # noqa: E501
        """Delete a tag


        :param str subject_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.subjects_api.delete_subject_tag(subject_id, tag_value, **kwargs)


    def download_file_from_subject(self, subject_id, file_name, dest_file, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str subject_id: (required)
        :param str file_name: (required)
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: DownloadTicket
        """
        return self.subjects_api.download_file_from_subject(subject_id, file_name, dest_file, **kwargs)


    def get_subject_file_zip_info(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str subject_id: (required)
        :param str file_name: (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.subjects_api.get_subject_file_zip_info(subject_id, file_name, **kwargs)


    def get_subject_download_url(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str subject_id: (required)
        :param str file_name: (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async_: Perform the request asynchronously
        :return: DownloadTicket
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.subjects_api.get_subject_download_ticket(subject_id, file_name, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def download_input_from_subject_analysis(self, subject_id, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.subjects_api.download_input_from_subject_analysis(subject_id, analysis_id, filename, dest_file, **kwargs)


    def get_subject_analysis_input_zip_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.subjects_api.get_subject_analysis_input_zip_info(subject_id, analysis_id, filename, **kwargs)


    def get_subject_analysis_input_download_url(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.subjects_api.get_subject_analysis_input_download_ticket(subject_id, analysis_id, filename, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def download_output_from_subject_analysis(self, subject_id, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.subjects_api.download_output_from_subject_analysis(subject_id, analysis_id, filename, dest_file, **kwargs)


    def get_subject_analysis_output_zip_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        return self.subjects_api.get_subject_analysis_output_zip_info(subject_id, analysis_id, filename, **kwargs)


    def get_subject_analysis_output_download_url(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.subjects_api.get_subject_analysis_output_download_ticket(subject_id, analysis_id, filename, **kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data

    def download_subject_analysis_inputs(self, subject_id, analysis_id, **kwargs):  # noqa: E501
        """Download analysis inputs.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for all inputs in the anlaysis If no \"ticket\" query param is included, server error 500 

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str ticket: ticket id of the inputs to download
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.subjects_api.download_subject_analysis_inputs(subject_id, analysis_id, **kwargs)


    def download_subject_analysis_outputs(self, subject_id, analysis_id, **kwargs):  # noqa: E501
        """Download analysis outputs.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for all outputs in the anlaysis If no \"ticket\" query param is included, server error 500 

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str ticket: ticket id of the outputs to download
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        return self.subjects_api.download_subject_analysis_outputs(subject_id, analysis_id, **kwargs)


    def get_all_subjects(self, **kwargs):  # noqa: E501
        """Get a list of subjects


        :param bool exhaustive: Set to return a complete list regardless of permissions
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[Subject]
        """
        return self.subjects_api.get_all_subjects(**kwargs)


    def get_subject(self, subject_id, **kwargs):  # noqa: E501
        """Get a single subject


        :param str subject_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Subject
        """
        return self.subjects_api.get_subject(subject_id, **kwargs)


    def get_subject_analyses(self, subject_id, **kwargs):  # noqa: E501
        """Get analyses for subject.

        Returns analyses that directly belong to this resource.

        :param str subject_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[AnalysisListEntry]
        """
        return self.subjects_api.get_subject_analyses(subject_id, **kwargs)


    def get_subject_analysis(self, subject_id, analysis_id, **kwargs):  # noqa: E501
        """Get an analysis.


        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param bool inflate_job: Return job as an object instead of an id
        :param bool async_: Perform the request asynchronously
        :return: AnalysisOutput
        """
        return self.subjects_api.get_subject_analysis(subject_id, analysis_id, **kwargs)


    def get_subject_file_info(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Get info for a particular file.


        :param str subject_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: FileEntry
        """
        return self.subjects_api.get_subject_file_info(subject_id, file_name, **kwargs)


    def get_subject_note(self, subject_id, note_id, **kwargs):  # noqa: E501
        """Get a note on subject.


        :param str subject_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Note
        """
        return self.subjects_api.get_subject_note(subject_id, note_id, **kwargs)


    def get_subject_sessions(self, subject_id, **kwargs):  # noqa: E501
        """List sessions of a subject


        :param str subject_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[Session]
        """
        return self.subjects_api.get_subject_sessions(subject_id, **kwargs)


    def get_subject_tag(self, subject_id, tag_value, **kwargs):  # noqa: E501
        """Get the value of a tag, by name.


        :param str subject_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: Tag
        """
        return self.subjects_api.get_subject_tag(subject_id, tag_value, **kwargs)


    def modify_subject(self, subject_id, body, **kwargs):  # noqa: E501
        """Update a subject


        :param str subject_id: (required)
        :param Subject body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.subjects_api.modify_subject(subject_id, body, **kwargs)


    def modify_subject_analysis(self, subject_id, analysis_id, body, **kwargs):  # noqa: E501
        """Modify an analysis.


        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param AnalysisUpdate body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.subjects_api.modify_subject_analysis(subject_id, analysis_id, body, **kwargs)


    def modify_subject_file(self, subject_id, file_name, body, **kwargs):  # noqa: E501
        """Modify a file&#39;s attributes

        Note: If modifying a file's modality, the current classification will be cleared (except for items in the \"Custom\" list) 

        :param str subject_id: (required)
        :param str file_name: (required)
        :param FileEntry body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2005
        """
        return self.subjects_api.modify_subject_file(subject_id, file_name, body, **kwargs)


    def modify_subject_file_classification(self, subject_id, file_name, body, **kwargs):  # noqa: E501
        """Update classification for a particular file.

        If replacing a file's classification, the modality can optionally be modified as well.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2005
        """
        return self.subjects_api.modify_subject_file_classification(subject_id, file_name, body, **kwargs)


    def modify_subject_file_info(self, subject_id, file_name, body, **kwargs):  # noqa: E501
        """Update info for a particular file.


        :param str subject_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.subjects_api.modify_subject_file_info(subject_id, file_name, body, **kwargs)


    def modify_subject_info(self, subject_id, body, **kwargs):  # noqa: E501
        """Update or replace info for a subject.


        :param str subject_id: (required)
        :param InfoUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.subjects_api.modify_subject_info(subject_id, body, **kwargs)


    def modify_subject_note(self, subject_id, note_id, body, **kwargs):  # noqa: E501
        """Update a note on subject.


        :param str subject_id: (required)
        :param str note_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.subjects_api.modify_subject_note(subject_id, note_id, body, **kwargs)


    def rename_subject_tag(self, subject_id, tag_value, body, **kwargs):  # noqa: E501
        """Rename a tag.


        :param str subject_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.subjects_api.rename_subject_tag(subject_id, tag_value, body, **kwargs)


    def replace_subject_file(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Replace a file


        :param str subject_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.subjects_api.replace_subject_file(subject_id, file_name, **kwargs)


    def upload_file_to_subject(self, subject_id, file, **kwargs):  # noqa: E501
        """Upload a file to subject.


        :param str subject_id: (required)
        :param file file: The file to upload (required)
        :param str metadata: File metadata
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.subjects_api.upload_file_to_subject(subject_id, file, **kwargs)


    def upload_output_to_subject_analysis(self, subject_id, analysis_id, file, **kwargs):  # noqa: E501
        """Upload an output file to analysis.


        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param file file: The file to upload (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.subjects_api.upload_output_to_subject_analysis(subject_id, analysis_id, file, **kwargs)


    def verify_master_subject_code(self, code, **kwargs):  # noqa: E501
        """Verify that the given master subject code exists or not


        :param str code: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.subjects_api.verify_master_subject_code(code, **kwargs)


    def add_user(self, body, **kwargs):  # noqa: E501
        """Add a new user


        :param User body: (required)
        :param bool async_: Perform the request asynchronously
        :return: CommonObjectCreated
        """
        return self.users_api.add_user(body, **kwargs)


    def delete_user(self, user_id, **kwargs):  # noqa: E501
        """Delete a user


        :param str user_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: CommonDeletedCount
        """
        return self.users_api.delete_user(user_id, **kwargs)


    def get_all_users(self, **kwargs):  # noqa: E501
        """Return a list of all users


        :param bool async_: Perform the request asynchronously
        :return: list[User]
        """
        return self.users_api.get_all_users(**kwargs)


    def get_current_user(self, **kwargs):  # noqa: E501
        """Get information about the current user


        :param bool async_: Perform the request asynchronously
        :return: User
        """
        return self.users_api.get_current_user(**kwargs)


    def get_current_user_avatar(self, **kwargs):  # noqa: E501
        """Get the avatar of the current user


        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.users_api.get_current_user_avatar(**kwargs)


    def get_current_user_info(self, **kwargs):  # noqa: E501
        """Get info of the current user


        :param str fields: Get only the specified fields from user's info. Accept multiple fields separated by comma. 
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.users_api.get_current_user_info(**kwargs)


    def get_current_user_jobs(self, **kwargs):  # noqa: E501
        """Return list of jobs created by the current user


        :param str gear: Gear name. Get only the jobs which are related to a specific gear. 
        :param bool async_: Perform the request asynchronously
        :return: UserJobsOutput
        """
        return self.users_api.get_current_user_jobs(**kwargs)


    def get_user(self, user_id, **kwargs):  # noqa: E501
        """Get information about the specified user


        :param str user_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: User
        """
        return self.users_api.get_user(user_id, **kwargs)


    def get_user_acquisitions(self, user_id, **kwargs):  # noqa: E501
        """Get all acquisitions that belong to the given user.


        :param str user_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: list[Acquisition]
        """
        return self.users_api.get_user_acquisitions(user_id, **kwargs)


    def get_user_avatar(self, user_id, **kwargs):  # noqa: E501
        """Get the avatar of the specified user


        :param str user_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.users_api.get_user_avatar(user_id, **kwargs)


    def get_user_collections(self, user_id, **kwargs):  # noqa: E501
        """Get all collections that belong to the given user.


        :param str user_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: list[Collection]
        """
        return self.users_api.get_user_collections(user_id, **kwargs)


    def get_user_groups(self, user_id, **kwargs):  # noqa: E501
        """List all groups the specified user is a member of


        :param str user_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: list[Group]
        """
        return self.users_api.get_user_groups(user_id, **kwargs)


    def get_user_projects(self, user_id, **kwargs):  # noqa: E501
        """Get all projects that belong to the given user.


        :param str user_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: list[Project]
        """
        return self.users_api.get_user_projects(user_id, **kwargs)


    def get_user_sessions(self, user_id, **kwargs):  # noqa: E501
        """Get all sessions that belong to the given user.


        :param str user_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: list[Session]
        """
        return self.users_api.get_user_sessions(user_id, **kwargs)


    def modify_current_user_info(self, body, **kwargs):  # noqa: E501
        """Update or replace info for the current user.


        :param InfoUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.users_api.modify_current_user_info(body, **kwargs)


    def modify_user(self, user_id, body, **kwargs):  # noqa: E501
        """Update the specified user


        :param str user_id: (required)
        :param User body: Accepts an object matching the User type except all fields are optional  (required)
        :param bool async_: Perform the request asynchronously
        :return: CommonModifiedCount
        """
        return self.users_api.modify_user(user_id, body, **kwargs)


    def add_view(self, container_id, body, **kwargs):  # noqa: E501
        """Add a new data view


        :param str container_id: The ID of the container, one of user, group or project. Use \"site\" as containerId to save or get a site data view. (required)
        :param DataView body: (required)
        :param bool async_: Perform the request asynchronously
        :return: CollectionNewOutput
        """
        return self.views_api.add_view(container_id, body, **kwargs)


    def delete_view(self, view_id, **kwargs):  # noqa: E501
        """Delete a data view


        :param str view_id: The ID of the view (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        return self.views_api.delete_view(view_id, **kwargs)


    def evaluate_view(self, view_id, container_id, **kwargs):  # noqa: E501
        """Execute a view, returning data in the preferred format.


        :param str view_id: The ID of the view (required)
        :param str container_id: The target container for view execution (required)
        :param str format:
        :param str filter: An optional filter expression
        :param int skip: The optional number of rows to skip
        :param int limit: The optional max number of rows to return
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.views_api.evaluate_view(view_id, container_id, **kwargs)


    def evaluate_view_adhoc(self, container_id, body, **kwargs):  # noqa: E501
        """Execute an ad-hoc view, returning data in the preferred format.


        :param str container_id: The target container for view execution (required)
        :param DataView body: (required)
        :param str format:
        :param str filter: An optional filter expression
        :param int skip: The optional number of rows to skip
        :param int limit: The optional max number of rows to return
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.views_api.evaluate_view_adhoc(container_id, body, **kwargs)


    def get_view(self, view_id, **kwargs):  # noqa: E501
        """Return the view identified by ViewId


        :param str view_id: The ID of the view (required)
        :param bool async_: Perform the request asynchronously
        :return: DataView
        """
        return self.views_api.get_view(view_id, **kwargs)


    def get_view_columns(self, **kwargs):  # noqa: E501
        """Return a list of all known column aliases for use in data views


        :param bool async_: Perform the request asynchronously
        :return: list[DataViewColumnAlias]
        """
        return self.views_api.get_view_columns(**kwargs)


    def get_views(self, container_id, **kwargs):  # noqa: E501
        """Return a list of all views belonging to container


        :param str container_id: The ID of the container, one of user, group or project. Use \"site\" as containerId to save or get a site data view. (required)
        :param bool async_: Perform the request asynchronously
        :return: list[DataView]
        """
        return self.views_api.get_views(container_id, **kwargs)


    def modify_view(self, view_id, body, **kwargs):  # noqa: E501
        """Update the view identified by ViewId


        :param str view_id: The ID of the view (required)
        :param DataView body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        return self.views_api.modify_view(view_id, body, **kwargs)


    def save_view_data_to_container(self, container_id, body, **kwargs):  # noqa: E501
        """Execute a view, saving data to the target container / file


        :param str container_id: The target container for view execution (required)
        :param DataViewSaveDataViewInput body: (required)
        :param str format:
        :param str filter: An optional filter expression
        :param int skip: The optional number of rows to skip
        :param int limit: The optional max number of rows to return
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        return self.views_api.save_view_data_to_container(container_id, body, **kwargs)


    def enable_feature(self, value):
        """Enable feature named value, via the X-Accept-Feature header"""
        features = self.api_client.default_headers.get('X-Accept-Feature')
        features = features + ',' + value if features else value
        self.api_client.set_default_header('X-Accept-Feature', features)

    def perform_version_check(self):
        import re
        import warnings

        VERSION_RE = re.compile(r'^(?P<semver>(?P<major>\d+)\.(?P<minor>\d+)(\.(?P<patch>\d+)))+.*')
        release_version = '' # Older core only version
        flywheel_version = None # Newer umbrella version for entire application
        try:
            version_info = self.default_api.get_version()
            release_version = version_info.release
            flywheel_version = getattr(version_info, 'flywheel_release', None)
        except:
            pass

        # If not sdk version
        # Prefer the newer flywheel version but fallback to the older release version
        sdk_version_match = VERSION_RE.match(SDK_VERSION)
        if flywheel_version:
            release_version_match = VERSION_RE.match(flywheel_version)
        elif release_version:
            release_version_match = VERSION_RE.match(release_version)
        else:
            release_version_match = None

        # Log conditionals:
        # 1. Client or server version not set
        # 2. Major version mismatch
        # 3. SDK Minor version > Server Minor version (client features not available on server)
        # 4. SDK Minor version < Server Minor version (new features on server)

        show_pip_message = False
        if sdk_version_match and release_version_match:
            # Compare major/minor version
            sdk_major = int(sdk_version_match.group('major'))
            sdk_minor = int(sdk_version_match.group('minor'))

            release_major = int(release_version_match.group('major'))
            release_minor = int(release_version_match.group('minor'))

            if sdk_major != release_major:
                if SDK_VERSION.find('dev') == -1:
                    # Always print version mismatch
                    warnings.warn('Client version {} does not match server version {}. Please update your client version!'.format(SDK_VERSION, release_version))
                    show_pip_message = True

            elif self.check_version:
                if sdk_minor > release_minor:
                    log.warning('Client version {} is ahead of server version {}. '.format(SDK_VERSION, release_version) +
                        'Not all client functionality will be supported by the server.')
                    show_pip_message = True
                elif sdk_minor < release_minor:
                    log.warning('Client version {} is behind server version {}. '.format(SDK_VERSION, release_version) +
                        'Please consider upgrading your client to access all available functionality.')
                    show_pip_message = True
        elif self.check_version:
            warnings.warn('Client or server version not available! This is an unsupported configuration!')

        if show_pip_message:
            log.warning('Use "pip install flywheel-sdk~={}" '.format(release_version_match.group('semver')) +
                'to install a compatible version for this server')

    def add_nodes_to_collection(self, collection_id, level, node_ids, **kwargs):
        """Generic method to add a list of nodes to a collection.

        :param str collection_id: (required) The id of the collection to update
        :param str level: (required) The level of nodes to add (e.g. session or acquisition)
        :param list[str] node_ids: (required) The list of node ids of type level to add
        :return: None
        """
        update = {
            'contents': {
                'operation': 'add',
                'nodes': [ {'_id': id, 'level': level} for id in node_ids ]
            }
        }
        return self.collections_api.modify_collection(collection_id, update, **kwargs)

    def add_sessions_to_collection(self, collection_id, session_ids, **kwargs):
        """Add a list of sessions to a collection.

        :param str collection_id: (required) The id of the collection to update
        :param list[str] session_ids: (required) The list of session ids to add
        :return: None
        """
        return self.add_nodes_to_collection(collection_id, 'session', session_ids, **kwargs)

    def add_acquisitions_to_collection(self, collection_id, acquisition_ids, **kwargs):
        """Add a list of acquisitions to a collection.

        :param str collection_id: (required) The id of the collection to update
        :param list[str] acquisition_ids: (required) The list of acquisition ids to add
        :return: None
        """
        return self.add_nodes_to_collection(collection_id, 'acquisition', acquisition_ids, **kwargs)

    def change_job_state(self, job_id, state):
        """Change a job state.

        :param str job_id: (required) The id of the job to modify
        :param str state: (required) The new job state
        :return: None
        """
        return self.modify_job(job_id, { 'state': state })

    def get(self, id, **kwargs):
        """Retrieve the specified object by id.

        Objects that can be retrieved in this way are:
            group, project, session, subject, acquisition, analysis and collection

        :param str id: The id of the object to retrieve
        :return: ContainerOutput
        """
        return self.get_container(id, **kwargs)

    def resolve(self, path, **kwargs):
        """Perform a path based lookup of nodes in the Flywheel hierarchy.

        :param str path: (required) The path to resolve
        :return: ResolverOutput
        """
        if not isinstance(path, list):
            path = path.split('/')

        return self.resolve_path(flywheel.ResolverInput(path=path), **kwargs)

    def lookup(self, path):
        """Perform a path based lookup of a single node in the Flywheel hierarchy.

        :param str path: (required) The path to resolve
        :return: ResolverOutput
        """
        if not isinstance(path, list):
            path = path.split('/')

        return self.lookup_path(flywheel.ResolverInput(path=path))

    def file_url(self, path):
        """Perform a path based lookup of a file in the Flywheel hierarchy, and return a single-use download URL.

        :param str path: (required) The path to resolve
        :return: The file URL if found, otherwise raises an error
        """
        result = self.resolve(path)
        if getattr(result.path[-1], 'container_type', None) != 'file':
            raise ValueError('Resolved path is not a file!')

        return result.path[-1].url()

    def download_tar(self, containers, dest_file, include_types=None, exclude_types=None):
        """Download the given set of containers as a tarball to dest_file.

        Supports downloading Projects, Sessions, Acquisitions and/or Analyses.

        :param containers: (required) The container, or list of containers to download.
        :param str dest_file: (required) The destination file on disk
        :param list include_types: The optional list of types to include in the download (e.g. ['nifti'])
        :param list exclude_types: The optional list of types to exclude from the download (e.g. ['dicom'])
        :return: A summary of the download
        """
        if not isinstance(containers, list):
            containers = [containers]

        # Extract the list of nodes
        nodes = []
        for container in containers:
            container_type = getattr(container, 'container_type', None)
            if container_type is None:
                raise ValueError('Unknown container specified!')

            nodes.append(flywheel.DownloadNode(level=container_type, id=container.id))

        # Setup filters
        type_filter = None
        if include_types or exclude_types:
            type_filter = flywheel.DownloadFilterDefinition(plus=include_types, minus=exclude_types)

        download_filters = None
        if type_filter:
            download_filters = [flywheel.DownloadFilter(types=type_filter)]

        # Create download request
        request = flywheel.Download(nodes=nodes, filters=download_filters, optional=True)
        summary = self.create_download_ticket(request)

        # Perform download
        self.download_ticket(summary.ticket, dest_file)
        return summary

    def download_file_from_acquisition_as_data(self, acquisition_id, file_name, **kwargs):
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str acquisition_id: (required)
        :param str file_name: (required)
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.acquisitions_api.download_file_from_acquisition_with_http_info(acquisition_id, file_name, **kwargs)
        if resp:
            return resp.content
        return None

    def download_input_from_acquisition_analysis_as_data(self, acquisition_id, analysis_id, filename, **kwargs):
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str acquisition_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.acquisitions_api.download_input_from_acquisition_analysis_with_http_info(acquisition_id, analysis_id, filename, **kwargs)
        if resp:
            return resp.content
        return None

    def download_output_from_acquisition_analysis_as_data(self, acquisition_id, analysis_id, filename, **kwargs):
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str acquisition_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.acquisitions_api.download_output_from_acquisition_analysis_with_http_info(acquisition_id, analysis_id, filename, **kwargs)
        if resp:
            return resp.content
        return None

    def set_acquisition_file_classification(self, acquisition_id, file_name, body, **kwargs):
        """Update classification with the provided fields.

        :param str acquisition_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'add': body }
        return self.acquisitions_api.modify_acquisition_file_classification(acquisition_id, file_name, body, **kwargs)

    def replace_acquisition_file_classification(self, acquisition_id, file_name, body, **kwargs):
        """Entirely replace classification with the provided fields.

        :param str acquisition_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'replace': body }
        return self.acquisitions_api.modify_acquisition_file_classification(acquisition_id, file_name, body, **kwargs)

    def delete_acquisition_file_classification_fields(self, acquisition_id, file_name, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str acquisition_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'delete': body }
        return self.acquisitions_api.modify_acquisition_file_classification(acquisition_id, file_name, body, **kwargs)

    def set_acquisition_file_info(self, acquisition_id, file_name, body, **kwargs):
        """Update info with the provided fields.

        :param str acquisition_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'set': body }
        return self.acquisitions_api.modify_acquisition_file_info(acquisition_id, file_name, body, **kwargs)

    def replace_acquisition_file_info(self, acquisition_id, file_name, body, **kwargs):
        """Entirely replace info with the provided fields.

        :param str acquisition_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'replace': body }
        return self.acquisitions_api.modify_acquisition_file_info(acquisition_id, file_name, body, **kwargs)

    def delete_acquisition_file_info_fields(self, acquisition_id, file_name, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str acquisition_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'delete': body }
        return self.acquisitions_api.modify_acquisition_file_info(acquisition_id, file_name, body, **kwargs)

    def set_acquisition_info(self, acquisition_id, body, **kwargs):
        """Update info with the provided fields.

        :param str acquisition_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'set': body }
        return self.acquisitions_api.modify_acquisition_info(acquisition_id, body, **kwargs)

    def replace_acquisition_info(self, acquisition_id, body, **kwargs):
        """Entirely replace info with the provided fields.

        :param str acquisition_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'replace': body }
        return self.acquisitions_api.modify_acquisition_info(acquisition_id, body, **kwargs)

    def delete_acquisition_info_fields(self, acquisition_id, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str acquisition_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'delete': body }
        return self.acquisitions_api.modify_acquisition_info(acquisition_id, body, **kwargs)

    def download_input_from_analysis_as_data(self, analysis_id, filename, **kwargs):
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.analyses_api.download_input_from_analysis_with_http_info(analysis_id, filename, **kwargs)
        if resp:
            return resp.content
        return None

    def download_output_from_analysis_as_data(self, analysis_id, filename, **kwargs):
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.analyses_api.download_output_from_analysis_with_http_info(analysis_id, filename, **kwargs)
        if resp:
            return resp.content
        return None

    def set_analysis_info(self, analysis_id, body, **kwargs):
        """Update info with the provided fields.

        :param str analysis_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'set': body }
        return self.analyses_api.modify_analysis_info(analysis_id, body, **kwargs)

    def replace_analysis_info(self, analysis_id, body, **kwargs):
        """Entirely replace info with the provided fields.

        :param str analysis_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'replace': body }
        return self.analyses_api.modify_analysis_info(analysis_id, body, **kwargs)

    def delete_analysis_info_fields(self, analysis_id, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str analysis_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'delete': body }
        return self.analyses_api.modify_analysis_info(analysis_id, body, **kwargs)

    def download_file_from_collection_as_data(self, collection_id, file_name, **kwargs):
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str collection_id: (required)
        :param str file_name: (required)
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.collections_api.download_file_from_collection_with_http_info(collection_id, file_name, **kwargs)
        if resp:
            return resp.content
        return None

    def download_input_from_collection_analysis_as_data(self, collection_id, analysis_id, filename, **kwargs):
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str collection_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.collections_api.download_input_from_collection_analysis_with_http_info(collection_id, analysis_id, filename, **kwargs)
        if resp:
            return resp.content
        return None

    def download_output_from_collection_analysis_as_data(self, collection_id, analysis_id, filename, **kwargs):
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str collection_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.collections_api.download_output_from_collection_analysis_with_http_info(collection_id, analysis_id, filename, **kwargs)
        if resp:
            return resp.content
        return None

    def set_collection_file_classification(self, collection_id, file_name, body, **kwargs):
        """Update classification with the provided fields.

        :param str collection_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'add': body }
        return self.collections_api.modify_collection_file_classification(collection_id, file_name, body, **kwargs)

    def replace_collection_file_classification(self, collection_id, file_name, body, **kwargs):
        """Entirely replace classification with the provided fields.

        :param str collection_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'replace': body }
        return self.collections_api.modify_collection_file_classification(collection_id, file_name, body, **kwargs)

    def delete_collection_file_classification_fields(self, collection_id, file_name, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str collection_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'delete': body }
        return self.collections_api.modify_collection_file_classification(collection_id, file_name, body, **kwargs)

    def set_collection_file_info(self, collection_id, file_name, body, **kwargs):
        """Update info with the provided fields.

        :param str collection_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'set': body }
        return self.collections_api.modify_collection_file_info(collection_id, file_name, body, **kwargs)

    def replace_collection_file_info(self, collection_id, file_name, body, **kwargs):
        """Entirely replace info with the provided fields.

        :param str collection_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'replace': body }
        return self.collections_api.modify_collection_file_info(collection_id, file_name, body, **kwargs)

    def delete_collection_file_info_fields(self, collection_id, file_name, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str collection_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'delete': body }
        return self.collections_api.modify_collection_file_info(collection_id, file_name, body, **kwargs)

    def set_collection_info(self, collection_id, body, **kwargs):
        """Update info with the provided fields.

        :param str collection_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'set': body }
        return self.collections_api.modify_collection_info(collection_id, body, **kwargs)

    def replace_collection_info(self, collection_id, body, **kwargs):
        """Entirely replace info with the provided fields.

        :param str collection_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'replace': body }
        return self.collections_api.modify_collection_info(collection_id, body, **kwargs)

    def delete_collection_info_fields(self, collection_id, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str collection_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'delete': body }
        return self.collections_api.modify_collection_info(collection_id, body, **kwargs)

    def download_file_from_container_as_data(self, container_id, file_name, **kwargs):
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str container_id: (required)
        :param str file_name: (required)
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.containers_api.download_file_from_container_with_http_info(container_id, file_name, **kwargs)
        if resp:
            return resp.content
        return None

    def download_input_from_container_analysis_as_data(self, container_id, analysis_id, filename, **kwargs):
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str container_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.containers_api.download_input_from_container_analysis_with_http_info(container_id, analysis_id, filename, **kwargs)
        if resp:
            return resp.content
        return None

    def download_output_from_container_analysis_as_data(self, container_id, analysis_id, filename, **kwargs):
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str container_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.containers_api.download_output_from_container_analysis_with_http_info(container_id, analysis_id, filename, **kwargs)
        if resp:
            return resp.content
        return None

    def set_container_file_classification(self, container_id, file_name, body, **kwargs):
        """Update classification with the provided fields.

        :param str container_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'add': body }
        return self.containers_api.modify_container_file_classification(container_id, file_name, body, **kwargs)

    def replace_container_file_classification(self, container_id, file_name, body, **kwargs):
        """Entirely replace classification with the provided fields.

        :param str container_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'replace': body }
        return self.containers_api.modify_container_file_classification(container_id, file_name, body, **kwargs)

    def delete_container_file_classification_fields(self, container_id, file_name, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str container_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'delete': body }
        return self.containers_api.modify_container_file_classification(container_id, file_name, body, **kwargs)

    def set_container_file_info(self, container_id, file_name, body, **kwargs):
        """Update info with the provided fields.

        :param str container_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'set': body }
        return self.containers_api.modify_container_file_info(container_id, file_name, body, **kwargs)

    def replace_container_file_info(self, container_id, file_name, body, **kwargs):
        """Entirely replace info with the provided fields.

        :param str container_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'replace': body }
        return self.containers_api.modify_container_file_info(container_id, file_name, body, **kwargs)

    def delete_container_file_info_fields(self, container_id, file_name, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str container_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'delete': body }
        return self.containers_api.modify_container_file_info(container_id, file_name, body, **kwargs)

    def set_container_info(self, container_id, body, **kwargs):
        """Update info with the provided fields.

        :param str container_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'set': body }
        return self.containers_api.modify_container_info(container_id, body, **kwargs)

    def replace_container_info(self, container_id, body, **kwargs):
        """Entirely replace info with the provided fields.

        :param str container_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'replace': body }
        return self.containers_api.modify_container_info(container_id, body, **kwargs)

    def delete_container_info_fields(self, container_id, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str container_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'delete': body }
        return self.containers_api.modify_container_info(container_id, body, **kwargs)

    def download_ticket_as_data(self, ticket, **kwargs):
        """Download files listed in the given ticket.

        You can use POST to create a download ticket The files listed in the ticket are put into a tar archive 

        :param str ticket: ID of the download ticket (required)
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.files_api.download_ticket_with_http_info(ticket, **kwargs)
        if resp:
            return resp.content
        return None

    def download_file_from_project_as_data(self, project_id, file_name, **kwargs):
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str project_id: (required)
        :param str file_name: (required)
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.projects_api.download_file_from_project_with_http_info(project_id, file_name, **kwargs)
        if resp:
            return resp.content
        return None

    def download_input_from_project_analysis_as_data(self, project_id, analysis_id, filename, **kwargs):
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str project_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.projects_api.download_input_from_project_analysis_with_http_info(project_id, analysis_id, filename, **kwargs)
        if resp:
            return resp.content
        return None

    def download_output_from_project_analysis_as_data(self, project_id, analysis_id, filename, **kwargs):
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str project_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.projects_api.download_output_from_project_analysis_with_http_info(project_id, analysis_id, filename, **kwargs)
        if resp:
            return resp.content
        return None

    def set_project_file_classification(self, project_id, file_name, body, **kwargs):
        """Update classification with the provided fields.

        :param str project_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'add': body }
        return self.projects_api.modify_project_file_classification(project_id, file_name, body, **kwargs)

    def replace_project_file_classification(self, project_id, file_name, body, **kwargs):
        """Entirely replace classification with the provided fields.

        :param str project_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'replace': body }
        return self.projects_api.modify_project_file_classification(project_id, file_name, body, **kwargs)

    def delete_project_file_classification_fields(self, project_id, file_name, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str project_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'delete': body }
        return self.projects_api.modify_project_file_classification(project_id, file_name, body, **kwargs)

    def set_project_file_info(self, project_id, file_name, body, **kwargs):
        """Update info with the provided fields.

        :param str project_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'set': body }
        return self.projects_api.modify_project_file_info(project_id, file_name, body, **kwargs)

    def replace_project_file_info(self, project_id, file_name, body, **kwargs):
        """Entirely replace info with the provided fields.

        :param str project_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'replace': body }
        return self.projects_api.modify_project_file_info(project_id, file_name, body, **kwargs)

    def delete_project_file_info_fields(self, project_id, file_name, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str project_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'delete': body }
        return self.projects_api.modify_project_file_info(project_id, file_name, body, **kwargs)

    def set_project_info(self, project_id, body, **kwargs):
        """Update info with the provided fields.

        :param str project_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'set': body }
        return self.projects_api.modify_project_info(project_id, body, **kwargs)

    def replace_project_info(self, project_id, body, **kwargs):
        """Entirely replace info with the provided fields.

        :param str project_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'replace': body }
        return self.projects_api.modify_project_info(project_id, body, **kwargs)

    def delete_project_info_fields(self, project_id, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str project_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'delete': body }
        return self.projects_api.modify_project_info(project_id, body, **kwargs)

    def download_file_from_session_as_data(self, session_id, file_name, **kwargs):
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str session_id: (required)
        :param str file_name: (required)
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.sessions_api.download_file_from_session_with_http_info(session_id, file_name, **kwargs)
        if resp:
            return resp.content
        return None

    def download_input_from_session_analysis_as_data(self, session_id, analysis_id, filename, **kwargs):
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str session_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.sessions_api.download_input_from_session_analysis_with_http_info(session_id, analysis_id, filename, **kwargs)
        if resp:
            return resp.content
        return None

    def download_output_from_session_analysis_as_data(self, session_id, analysis_id, filename, **kwargs):
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str session_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.sessions_api.download_output_from_session_analysis_with_http_info(session_id, analysis_id, filename, **kwargs)
        if resp:
            return resp.content
        return None

    def set_session_file_classification(self, session_id, file_name, body, **kwargs):
        """Update classification with the provided fields.

        :param str session_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'add': body }
        return self.sessions_api.modify_session_file_classification(session_id, file_name, body, **kwargs)

    def replace_session_file_classification(self, session_id, file_name, body, **kwargs):
        """Entirely replace classification with the provided fields.

        :param str session_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'replace': body }
        return self.sessions_api.modify_session_file_classification(session_id, file_name, body, **kwargs)

    def delete_session_file_classification_fields(self, session_id, file_name, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str session_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'delete': body }
        return self.sessions_api.modify_session_file_classification(session_id, file_name, body, **kwargs)

    def set_session_file_info(self, session_id, file_name, body, **kwargs):
        """Update info with the provided fields.

        :param str session_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'set': body }
        return self.sessions_api.modify_session_file_info(session_id, file_name, body, **kwargs)

    def replace_session_file_info(self, session_id, file_name, body, **kwargs):
        """Entirely replace info with the provided fields.

        :param str session_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'replace': body }
        return self.sessions_api.modify_session_file_info(session_id, file_name, body, **kwargs)

    def delete_session_file_info_fields(self, session_id, file_name, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str session_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'delete': body }
        return self.sessions_api.modify_session_file_info(session_id, file_name, body, **kwargs)

    def set_session_info(self, session_id, body, **kwargs):
        """Update info with the provided fields.

        :param str session_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'set': body }
        return self.sessions_api.modify_session_info(session_id, body, **kwargs)

    def replace_session_info(self, session_id, body, **kwargs):
        """Entirely replace info with the provided fields.

        :param str session_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'replace': body }
        return self.sessions_api.modify_session_info(session_id, body, **kwargs)

    def delete_session_info_fields(self, session_id, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str session_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'delete': body }
        return self.sessions_api.modify_session_info(session_id, body, **kwargs)

    def download_file_from_subject_as_data(self, subject_id, file_name, **kwargs):
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 

        :param str subject_id: (required)
        :param str file_name: (required)
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.subjects_api.download_file_from_subject_with_http_info(subject_id, file_name, **kwargs)
        if resp:
            return resp.content
        return None

    def download_input_from_subject_analysis_as_data(self, subject_id, analysis_id, filename, **kwargs):
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.subjects_api.download_input_from_subject_analysis_with_http_info(subject_id, analysis_id, filename, **kwargs)
        if resp:
            return resp.content
        return None

    def download_output_from_subject_analysis_as_data(self, subject_id, analysis_id, filename, **kwargs):
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :return: The binary file data
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        (resp) = self.subjects_api.download_output_from_subject_analysis_with_http_info(subject_id, analysis_id, filename, **kwargs)
        if resp:
            return resp.content
        return None

    def set_subject_file_classification(self, subject_id, file_name, body, **kwargs):
        """Update classification with the provided fields.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'add': body }
        return self.subjects_api.modify_subject_file_classification(subject_id, file_name, body, **kwargs)

    def replace_subject_file_classification(self, subject_id, file_name, body, **kwargs):
        """Entirely replace classification with the provided fields.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'replace': body }
        return self.subjects_api.modify_subject_file_classification(subject_id, file_name, body, **kwargs)

    def delete_subject_file_classification_fields(self, subject_id, file_name, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str subject_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :return: InlineResponse2005
        """
        body = { 'delete': body }
        return self.subjects_api.modify_subject_file_classification(subject_id, file_name, body, **kwargs)

    def set_subject_file_info(self, subject_id, file_name, body, **kwargs):
        """Update info with the provided fields.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'set': body }
        return self.subjects_api.modify_subject_file_info(subject_id, file_name, body, **kwargs)

    def replace_subject_file_info(self, subject_id, file_name, body, **kwargs):
        """Entirely replace info with the provided fields.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'replace': body }
        return self.subjects_api.modify_subject_file_info(subject_id, file_name, body, **kwargs)

    def delete_subject_file_info_fields(self, subject_id, file_name, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str subject_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :return: InlineResponse200
        """
        body = { 'delete': body }
        return self.subjects_api.modify_subject_file_info(subject_id, file_name, body, **kwargs)

    def set_subject_info(self, subject_id, body, **kwargs):
        """Update info with the provided fields.

        :param str subject_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'set': body }
        return self.subjects_api.modify_subject_info(subject_id, body, **kwargs)

    def replace_subject_info(self, subject_id, body, **kwargs):
        """Entirely replace info with the provided fields.

        :param str subject_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'replace': body }
        return self.subjects_api.modify_subject_info(subject_id, body, **kwargs)

    def delete_subject_info_fields(self, subject_id, body, **kwargs):
        """Delete the specified fields from  + name + .

        :param str subject_id: (required)
        :param InfoUpdateInput body: (required)
        :return: None
        """
        body = { 'delete': body }
        return self.subjects_api.modify_subject_info(subject_id, body, **kwargs)


    def View(self, **kwargs):
        """Short-hand for flywheel.ViewBuilder(\*\*kwargs).build()

        :param kwargs: The arguments to pass directly to ViewBuilder
        :return: The built data view
        """
        return ViewBuilder(**kwargs).build()

    def print_view_columns(self, file=sys.stdout):
        """Print a list of column aliases that can be used in data views.

        :param file-like file: The file to print to
        """
        for column in self.views_api.get_view_columns():
            if column.group:
                coltype = 'group'
            else:
                coltype = column.type
            six.print_('{} ({}): {}'.format(column.name, coltype, column.description), file=file)

    def read_view_data(self, view, container_id, decode=True, **kwargs):
        """Execute a data view against container, and return a file-like object that can be streamed.

        :param view: The view id or DataView object to execute.
        :type view: str or DataView
        :param str container_id: The id of the container to execute the view against
        :param bool decode: Whether or not to decode the stream to utf-8 (default is true)
        :param kwargs: Additional arguments to pass to the evaluate_view call. (e.g. format='csv')
        :return: A file-like object where the contents can be read
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        if isinstance(view, six.string_types):
            resp = self.views_api.evaluate_view_with_http_info(view, container_id, **kwargs)
        else:
            resp = self.views_api.evaluate_view_adhoc_with_http_info(container_id, view, **kwargs)
        resp.raw.decode_content = True
        if decode:
            return codecs.getreader(resp.encoding)(resp.raw)
        return resp.raw

    def read_view_dataframe(self, view, container_id, opts=None, **kwargs):
        """Execute a data view against container, and return a DataFrame.

        NOTE: This requires that the pandas module be installed on the system.

        :param view: The view id or DataView object to execute.
        :type view: str or DataView
        :param str container_id: The id of the container to execute the view against
        :param object opts: Additional options to pass to the pandas read_json function
        :param kwargs: Additional arguments to pass to the evaluate_view call.
        :return: A pandas DataFrame
        """
        import pandas

        if opts is None:
            opts = {}

        kwargs['format'] = 'json-flat'
        resp = self.read_view_data(view, container_id, decode=False, **kwargs)
        if resp:
            try:
                df = pandas.read_json(resp, 'records', **opts)
                return df
            finally:
                resp.close()
        return None


    def save_view_data(self, view, container_id, dest_file, **kwargs):
        """Execute a data view against container, and save the results to disk.

        :param view: The view id or DataView object to execute.
        :type view: str or DataView
        :param str container_id: The id of the container to execute the view against
        :param str dest_file: The destination file path
        :param kwargs: Additional arguments to pass to the evaluate_view call. (e.g. format='csv')
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        # Stream response to file
        with open(dest_file, 'wb') as out_file:
            if isinstance(view, six.string_types):
                resp = self.views_api.evaluate_view_with_http_info(view, container_id, **kwargs)
            else:
                resp = self.views_api.evaluate_view_adhoc_with_http_info(container_id, view, **kwargs)

            if resp:
                try:
                    for chunk in resp.iter_content(chunk_size=65536):
                        out_file.write(chunk)
                finally:
                    resp.close()

    def shutdown(self):
        """Release any outstanding resources"""
        self.api_client.shutdown()




