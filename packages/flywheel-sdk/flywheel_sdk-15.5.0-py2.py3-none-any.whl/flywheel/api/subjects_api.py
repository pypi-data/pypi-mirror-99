# coding: utf-8

"""
    Flywheel

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 15.5.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from flywheel.api_client import ApiClient
import flywheel.models

# NOTE: This file is auto generated by the swagger code generator program.
# Do not edit the class manually.

class SubjectsApi(object):
    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_subject(self, body, **kwargs):  # noqa: E501
        """Create a new subject

        This method makes a synchronous HTTP request by default.

        :param Subject body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ContainerNewOutput
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.add_subject_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_subject_with_http_info(body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def add_subject_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a new subject

        This method makes a synchronous HTTP request by default.

        :param Subject body: (required)
        :param bool async: Perform the request asynchronously
        :return: ContainerNewOutput
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_subject" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_subject`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.Subject.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContainerNewOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def add_subject_analysis(self, subject_id, body, **kwargs):  # noqa: E501
        """Create an analysis and upload files.

        When query param \"job\" is \"true\", send JSON to create an analysis and job.  Otherwise, multipart/form-data to upload files and create an analysis. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param AnalysisInput body: (required)
        :param bool job: Return job as an object instead of an id
        :param bool async_: Perform the request asynchronously
        :return: ContainerNewOutput
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.add_subject_analysis_with_http_info(subject_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_subject_analysis_with_http_info(subject_id, body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def add_subject_analysis_with_http_info(self, subject_id, body, **kwargs):  # noqa: E501
        """Create an analysis and upload files.

        When query param \"job\" is \"true\", send JSON to create an analysis and job.  Otherwise, multipart/form-data to upload files and create an analysis. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param AnalysisInput body: (required)
        :param bool job: Return job as an object instead of an id
        :param bool async: Perform the request asynchronously
        :return: ContainerNewOutput
        """

        all_params = ['subject_id', 'body', 'job']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_subject_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `add_subject_analysis`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_subject_analysis`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501

        query_params = []
        if 'job' in params:
            query_params.append(('job', params['job']))  # noqa: E501
        else:
            query_params.append(('job', 'true'))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.AnalysisInput.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/analyses', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContainerNewOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def add_subject_analysis_note(self, subject_id, analysis_id, body, **kwargs):  # noqa: E501
        """Add a note to subject analysis.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.add_subject_analysis_note_with_http_info(subject_id, analysis_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_subject_analysis_note_with_http_info(subject_id, analysis_id, body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def add_subject_analysis_note_with_http_info(self, subject_id, analysis_id, body, **kwargs):  # noqa: E501
        """Add a note to subject analysis.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param Note body: (required)
        :param bool async: Perform the request asynchronously
        :return: InlineResponse200
        """

        all_params = ['subject_id', 'analysis_id', 'body']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_subject_analysis_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `add_subject_analysis_note`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `add_subject_analysis_note`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_subject_analysis_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['AnalysisId'] = params['analysis_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.Note.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/analyses/{AnalysisId}/notes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def add_subject_note(self, subject_id, body, **kwargs):  # noqa: E501
        """Add a note to subject.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.add_subject_note_with_http_info(subject_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_subject_note_with_http_info(subject_id, body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def add_subject_note_with_http_info(self, subject_id, body, **kwargs):  # noqa: E501
        """Add a note to subject.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param Note body: (required)
        :param bool async: Perform the request asynchronously
        :return: InlineResponse200
        """

        all_params = ['subject_id', 'body']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_subject_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `add_subject_note`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_subject_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.Note.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/notes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def add_subject_tag(self, subject_id, body, **kwargs):  # noqa: E501
        """Add a tag to subject.

        Progates changes to projects, sessions and acquisitions
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.add_subject_tag_with_http_info(subject_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_subject_tag_with_http_info(subject_id, body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def add_subject_tag_with_http_info(self, subject_id, body, **kwargs):  # noqa: E501
        """Add a tag to subject.

        Progates changes to projects, sessions and acquisitions
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param Tag body: (required)
        :param bool async: Perform the request asynchronously
        :return: InlineResponse200
        """

        all_params = ['subject_id', 'body']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_subject_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `add_subject_tag`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_subject_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.Tag.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def create_master_subject_code(self, body, **kwargs):  # noqa: E501
        """Request a master subject code for the given patient

        The workflow is the following.   - send `patient_id` (e.g., MRN) and/or `first_name`, `last_name`, `date_of_birth`   - indicate whether to use `patient_id` for identification or `first_name`, `last_name`, `date_of_birth`     by the `use_patient_id` field   - the response will contain a master subject code   - if you send the same identifying information again, you will receive the same code  Note that if you received a MSC code for example by just providing the `patient_id`, you can save more information for that MSC in a second request (`first_name`, `last_name`, `date_of_birth`). Only the missing fields will be set, so you can't update any existing field (e.g. changing the name). Since you can create multiple MSC codes with the same name and date of birth using different patient ids, you will get HTTP 400 error if you request an MSC code by name and date of birth and there are multiple matches. In this case you need to use patient id. 
        This method makes a synchronous HTTP request by default.

        :param Body body: (required)
        :param bool async_: Perform the request asynchronously
        :return: MasterSubjectCodeCodeOutput
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.create_master_subject_code_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_master_subject_code_with_http_info(body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def create_master_subject_code_with_http_info(self, body, **kwargs):  # noqa: E501
        """Request a master subject code for the given patient

        The workflow is the following.   - send `patient_id` (e.g., MRN) and/or `first_name`, `last_name`, `date_of_birth`   - indicate whether to use `patient_id` for identification or `first_name`, `last_name`, `date_of_birth`     by the `use_patient_id` field   - the response will contain a master subject code   - if you send the same identifying information again, you will receive the same code  Note that if you received a MSC code for example by just providing the `patient_id`, you can save more information for that MSC in a second request (`first_name`, `last_name`, `date_of_birth`). Only the missing fields will be set, so you can't update any existing field (e.g. changing the name). Since you can create multiple MSC codes with the same name and date of birth using different patient ids, you will get HTTP 400 error if you request an MSC code by name and date of birth and there are multiple matches. In this case you need to use patient id. 
        This method makes a synchronous HTTP request by default.

        :param Body body: (required)
        :param bool async: Perform the request asynchronously
        :return: MasterSubjectCodeCodeOutput
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_master_subject_code" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_master_subject_code`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.Body.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/master-code', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MasterSubjectCodeCodeOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def delete_subject(self, subject_id, **kwargs):  # noqa: E501
        """Delete a subject

        Read-write project permissions are required to delete a subject. </br>Admin project permissions are required if the subject or it's acquisitions contain data uploaded by sources other than users and jobs.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.delete_subject_with_http_info(subject_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_subject_with_http_info(subject_id, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def delete_subject_with_http_info(self, subject_id, **kwargs):  # noqa: E501
        """Delete a subject

        Read-write project permissions are required to delete a subject. </br>Admin project permissions are required if the subject or it's acquisitions contain data uploaded by sources other than users and jobs.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param bool async: Perform the request asynchronously
        :return: InlineResponse2002
        """

        all_params = ['subject_id']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_subject" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `delete_subject`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def delete_subject_analysis(self, subject_id, analysis_id, **kwargs):  # noqa: E501
        """Delete an anaylsis

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2002
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.delete_subject_analysis_with_http_info(subject_id, analysis_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_subject_analysis_with_http_info(subject_id, analysis_id, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def delete_subject_analysis_with_http_info(self, subject_id, analysis_id, **kwargs):  # noqa: E501
        """Delete an anaylsis

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param bool async: Perform the request asynchronously
        :return: InlineResponse2002
        """

        all_params = ['subject_id', 'analysis_id']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_subject_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `delete_subject_analysis`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `delete_subject_analysis`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['AnalysisId'] = params['analysis_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/analyses/{AnalysisId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def delete_subject_analysis_note(self, subject_id, analysis_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from subject analysis.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.delete_subject_analysis_note_with_http_info(subject_id, analysis_id, note_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_subject_analysis_note_with_http_info(subject_id, analysis_id, note_id, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def delete_subject_analysis_note_with_http_info(self, subject_id, analysis_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from subject analysis.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str note_id: (required)
        :param bool async: Perform the request asynchronously
        :return: InlineResponse200
        """

        all_params = ['subject_id', 'analysis_id', 'note_id']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_subject_analysis_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `delete_subject_analysis_note`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `delete_subject_analysis_note`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `delete_subject_analysis_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['AnalysisId'] = params['analysis_id']  # noqa: E501
        if 'note_id' in params:
            path_params['NoteId'] = params['note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/analyses/{AnalysisId}/notes/{NoteId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def delete_subject_file(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Delete a file

        A user with read-write or higher permissions on the container may delete files that were uploaded by users or were the output of jobs. (Specifically, files whose `origin.type` is either `job` or `user`.) <br/> A user with admin permissions on the container may delete any file. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.delete_subject_file_with_http_info(subject_id, file_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_subject_file_with_http_info(subject_id, file_name, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def delete_subject_file_with_http_info(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Delete a file

        A user with read-write or higher permissions on the container may delete files that were uploaded by users or were the output of jobs. (Specifically, files whose `origin.type` is either `job` or `user`.) <br/> A user with admin permissions on the container may delete any file. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param bool async: Perform the request asynchronously
        :return: InlineResponse200
        """

        all_params = ['subject_id', 'file_name']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_subject_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `delete_subject_file`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `delete_subject_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'file_name' in params:
            path_params['FileName'] = params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/files/{FileName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def delete_subject_note(self, subject_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from subject

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.delete_subject_note_with_http_info(subject_id, note_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_subject_note_with_http_info(subject_id, note_id, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def delete_subject_note_with_http_info(self, subject_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from subject

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str note_id: (required)
        :param bool async: Perform the request asynchronously
        :return: InlineResponse200
        """

        all_params = ['subject_id', 'note_id']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_subject_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `delete_subject_note`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `delete_subject_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'note_id' in params:
            path_params['NoteId'] = params['note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/notes/{NoteId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def delete_subject_tag(self, subject_id, tag_value, **kwargs):  # noqa: E501
        """Delete a tag

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.delete_subject_tag_with_http_info(subject_id, tag_value, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_subject_tag_with_http_info(subject_id, tag_value, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def delete_subject_tag_with_http_info(self, subject_id, tag_value, **kwargs):  # noqa: E501
        """Delete a tag

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async: Perform the request asynchronously
        :return: InlineResponse200
        """

        all_params = ['subject_id', 'tag_value']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_subject_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `delete_subject_tag`")  # noqa: E501
        # verify the required parameter 'tag_value' is set
        if ('tag_value' not in params or
                params['tag_value'] is None):
            raise ValueError("Missing the required parameter `tag_value` when calling `delete_subject_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'tag_value' in params:
            path_params['TagValue'] = params['tag_value']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/tags/{TagValue}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def download_file_from_subject(self, subject_id, file_name, dest_file, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: DownloadTicket
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        # Stream response to file
        with open(dest_file, 'wb') as out_file:
            (resp) = self.download_file_from_subject_with_http_info(subject_id, file_name, **kwargs)  # noqa: E501
            if resp:
                try:
                    for chunk in resp.iter_content(chunk_size=65536):
                        out_file.write(chunk)
                finally:
                    resp.close()


    def download_file_from_subject_with_http_info(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async: Perform the request asynchronously
        :return: DownloadTicket
        """

        all_params = ['subject_id', 'file_name', 'view', 'info', 'member', 'signature', 'expires']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_file_from_subject" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `download_file_from_subject`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `download_file_from_subject`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'file_name' in params:
            path_params['FileName'] = params['file_name']  # noqa: E501

        query_params = []
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501
        if 'expires' in params:
            query_params.append(('expires', params['expires']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/files/{FileName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DownloadTicket',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_file_zip_info(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_subject_file_zip_info_with_http_info(subject_id, file_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_file_zip_info_with_http_info(subject_id, file_name, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_subject_file_zip_info_with_http_info(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async: Perform the request asynchronously
        :return: FileZipInfo
        """

        all_params = ['subject_id', 'file_name', 'ticket', 'view', 'info', 'member', 'signature', 'expires']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_file_zip_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_file_zip_info`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `get_subject_file_zip_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'file_name' in params:
            path_params['FileName'] = params['file_name']  # noqa: E501

        query_params = []
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        else:
            query_params.append(('info', 'true'))
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501
        if 'expires' in params:
            query_params.append(('expires', params['expires']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/files/{FileName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileZipInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_download_ticket(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async_: Perform the request asynchronously
        :return: DownloadTicket
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_subject_download_ticket_with_http_info(subject_id, file_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_download_ticket_with_http_info(subject_id, file_name, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_subject_download_ticket_with_http_info(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str signature: Url's signature (signed download url)
        :param str expires: Signed url expiration time (epoch time)
        :param bool async: Perform the request asynchronously
        :return: DownloadTicket
        """

        all_params = ['subject_id', 'file_name', 'ticket', 'view', 'info', 'member', 'signature', 'expires']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_download_ticket" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_download_ticket`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `get_subject_download_ticket`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'file_name' in params:
            path_params['FileName'] = params['file_name']  # noqa: E501

        query_params = []
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501
        if 'expires' in params:
            query_params.append(('expires', params['expires']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/files/{FileName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DownloadTicket',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def download_input_from_subject_analysis(self, subject_id, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        # Stream response to file
        with open(dest_file, 'wb') as out_file:
            (resp) = self.download_input_from_subject_analysis_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
            if resp:
                try:
                    for chunk in resp.iter_content(chunk_size=65536):
                        out_file.write(chunk)
                finally:
                    resp.close()


    def download_input_from_subject_analysis_with_http_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """

        all_params = ['subject_id', 'analysis_id', 'filename', 'info', 'member']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_input_from_subject_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `download_input_from_subject_analysis`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `download_input_from_subject_analysis`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `download_input_from_subject_analysis`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['AnalysisId'] = params['analysis_id']  # noqa: E501
        if 'filename' in params:
            path_params['Filename'] = params['filename']  # noqa: E501

        query_params = []
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/analyses/{AnalysisId}/inputs/{Filename}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnalysisFilesCreateTicketOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_analysis_input_zip_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_subject_analysis_input_zip_info_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_analysis_input_zip_info_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_subject_analysis_input_zip_info_with_http_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async: Perform the request asynchronously
        :return: FileZipInfo
        """

        all_params = ['subject_id', 'analysis_id', 'filename', 'ticket', 'info', 'member']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_analysis_input_zip_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_analysis_input_zip_info`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `get_subject_analysis_input_zip_info`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `get_subject_analysis_input_zip_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['AnalysisId'] = params['analysis_id']  # noqa: E501
        if 'filename' in params:
            path_params['Filename'] = params['filename']  # noqa: E501

        query_params = []
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        else:
            query_params.append(('info', 'true'))
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/analyses/{AnalysisId}/inputs/{Filename}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileZipInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_analysis_input_download_ticket(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_subject_analysis_input_download_ticket_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_analysis_input_download_ticket_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_subject_analysis_input_download_ticket_with_http_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the inputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """

        all_params = ['subject_id', 'analysis_id', 'filename', 'ticket', 'info', 'member']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_analysis_input_download_ticket" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_analysis_input_download_ticket`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `get_subject_analysis_input_download_ticket`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `get_subject_analysis_input_download_ticket`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['AnalysisId'] = params['analysis_id']  # noqa: E501
        if 'filename' in params:
            path_params['Filename'] = params['filename']  # noqa: E501

        query_params = []
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/analyses/{AnalysisId}/inputs/{Filename}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnalysisFilesCreateTicketOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def download_output_from_subject_analysis(self, subject_id, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        kwargs['_return_http_data_only'] = True
        kwargs['_preload_content'] = False
        # Stream response to file
        with open(dest_file, 'wb') as out_file:
            (resp) = self.download_output_from_subject_analysis_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
            if resp:
                try:
                    for chunk in resp.iter_content(chunk_size=65536):
                        out_file.write(chunk)
                finally:
                    resp.close()


    def download_output_from_subject_analysis_with_http_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """

        all_params = ['subject_id', 'analysis_id', 'filename', 'info', 'member']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_output_from_subject_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `download_output_from_subject_analysis`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `download_output_from_subject_analysis`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `download_output_from_subject_analysis`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['AnalysisId'] = params['analysis_id']  # noqa: E501
        if 'filename' in params:
            path_params['Filename'] = params['filename']  # noqa: E501

        query_params = []
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/analyses/{AnalysisId}/files/{Filename}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnalysisFilesCreateTicketOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_analysis_output_zip_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_subject_analysis_output_zip_info_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_analysis_output_zip_info_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_subject_analysis_output_zip_info_with_http_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async: Perform the request asynchronously
        :return: FileZipInfo
        """

        all_params = ['subject_id', 'analysis_id', 'filename', 'ticket', 'info', 'member']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_analysis_output_zip_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_analysis_output_zip_info`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `get_subject_analysis_output_zip_info`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `get_subject_analysis_output_zip_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['AnalysisId'] = params['analysis_id']  # noqa: E501
        if 'filename' in params:
            path_params['Filename'] = params['filename']  # noqa: E501

        query_params = []
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        else:
            query_params.append(('info', 'true'))
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/analyses/{AnalysisId}/files/{Filename}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileZipInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_analysis_output_download_ticket(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_subject_analysis_output_download_ticket_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_analysis_output_download_ticket_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_subject_analysis_output_download_ticket_with_http_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly. 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool async: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """

        all_params = ['subject_id', 'analysis_id', 'filename', 'ticket', 'info', 'member']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_analysis_output_download_ticket" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_analysis_output_download_ticket`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `get_subject_analysis_output_download_ticket`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `get_subject_analysis_output_download_ticket`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['AnalysisId'] = params['analysis_id']  # noqa: E501
        if 'filename' in params:
            path_params['Filename'] = params['filename']  # noqa: E501

        query_params = []
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/analyses/{AnalysisId}/files/{Filename}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnalysisFilesCreateTicketOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def download_subject_analysis_inputs(self, subject_id, analysis_id, **kwargs):  # noqa: E501
        """Download analysis inputs.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for all inputs in the anlaysis If no \"ticket\" query param is included, server error 500 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str ticket: ticket id of the inputs to download
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.download_subject_analysis_inputs_with_http_info(subject_id, analysis_id, **kwargs)  # noqa: E501
        else:
            (data) = self.download_subject_analysis_inputs_with_http_info(subject_id, analysis_id, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def download_subject_analysis_inputs_with_http_info(self, subject_id, analysis_id, **kwargs):  # noqa: E501
        """Download analysis inputs.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for all inputs in the anlaysis If no \"ticket\" query param is included, server error 500 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str ticket: ticket id of the inputs to download
        :param bool async: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """

        all_params = ['subject_id', 'analysis_id', 'ticket']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_subject_analysis_inputs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `download_subject_analysis_inputs`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `download_subject_analysis_inputs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['AnalysisId'] = params['analysis_id']  # noqa: E501

        query_params = []
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/analyses/{AnalysisId}/inputs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnalysisFilesCreateTicketOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def download_subject_analysis_outputs(self, subject_id, analysis_id, **kwargs):  # noqa: E501
        """Download analysis outputs.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for all outputs in the anlaysis If no \"ticket\" query param is included, server error 500 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str ticket: ticket id of the outputs to download
        :param bool async_: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.download_subject_analysis_outputs_with_http_info(subject_id, analysis_id, **kwargs)  # noqa: E501
        else:
            (data) = self.download_subject_analysis_outputs_with_http_info(subject_id, analysis_id, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def download_subject_analysis_outputs_with_http_info(self, subject_id, analysis_id, **kwargs):  # noqa: E501
        """Download analysis outputs.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for all outputs in the anlaysis If no \"ticket\" query param is included, server error 500 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param str ticket: ticket id of the outputs to download
        :param bool async: Perform the request asynchronously
        :return: AnalysisFilesCreateTicketOutput
        """

        all_params = ['subject_id', 'analysis_id', 'ticket']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_subject_analysis_outputs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `download_subject_analysis_outputs`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `download_subject_analysis_outputs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['AnalysisId'] = params['analysis_id']  # noqa: E501

        query_params = []
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/analyses/{AnalysisId}/files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnalysisFilesCreateTicketOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_all_subjects(self, **kwargs):  # noqa: E501
        """Get a list of subjects

        This method makes a synchronous HTTP request by default.

        :param bool exhaustive: Set to return a complete list regardless of permissions
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[Subject]
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_all_subjects_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_subjects_with_http_info(**kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_all_subjects_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of subjects

        This method makes a synchronous HTTP request by default.

        :param bool exhaustive: Set to return a complete list regardless of permissions
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async: Perform the request asynchronously
        :return: list[Subject]
        """

        all_params = ['exhaustive', 'filter', 'sort', 'limit', 'skip', 'page', 'after_id']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_subjects" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'exhaustive' in params:
            query_params.append(('exhaustive', params['exhaustive']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        else:
            query_params.append(('limit', '1000'))
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'after_id' in params:
            query_params.append(('after_id', params['after_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Subject]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject(self, subject_id, **kwargs):  # noqa: E501
        """Get a single subject

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Subject
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_subject_with_http_info(subject_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_with_http_info(subject_id, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_subject_with_http_info(self, subject_id, **kwargs):  # noqa: E501
        """Get a single subject

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param bool async: Perform the request asynchronously
        :return: Subject
        """

        all_params = ['subject_id']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Subject',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_analyses(self, subject_id, **kwargs):  # noqa: E501
        """Get analyses for subject.

        Returns analyses that directly belong to this resource.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[AnalysisListEntry]
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_subject_analyses_with_http_info(subject_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_analyses_with_http_info(subject_id, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_subject_analyses_with_http_info(self, subject_id, **kwargs):  # noqa: E501
        """Get analyses for subject.

        Returns analyses that directly belong to this resource.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async: Perform the request asynchronously
        :return: list[AnalysisListEntry]
        """

        all_params = ['subject_id', 'filter', 'sort', 'limit', 'skip', 'page', 'after_id']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_analyses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_analyses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'after_id' in params:
            query_params.append(('after_id', params['after_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/analyses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AnalysisListEntry]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_analysis(self, subject_id, analysis_id, **kwargs):  # noqa: E501
        """Get an analysis.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param bool inflate_job: Return job as an object instead of an id
        :param bool async_: Perform the request asynchronously
        :return: AnalysisOutput
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_subject_analysis_with_http_info(subject_id, analysis_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_analysis_with_http_info(subject_id, analysis_id, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_subject_analysis_with_http_info(self, subject_id, analysis_id, **kwargs):  # noqa: E501
        """Get an analysis.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param bool inflate_job: Return job as an object instead of an id
        :param bool async: Perform the request asynchronously
        :return: AnalysisOutput
        """

        all_params = ['subject_id', 'analysis_id', 'inflate_job']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_analysis`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `get_subject_analysis`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['AnalysisId'] = params['analysis_id']  # noqa: E501

        query_params = []
        if 'inflate_job' in params:
            query_params.append(('inflate_job', params['inflate_job']))  # noqa: E501
        else:
            query_params.append(('inflate_job', 'true'))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/analyses/{AnalysisId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnalysisOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_file_info(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Get info for a particular file.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: FileEntry
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_subject_file_info_with_http_info(subject_id, file_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_file_info_with_http_info(subject_id, file_name, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_subject_file_info_with_http_info(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Get info for a particular file.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param bool async: Perform the request asynchronously
        :return: FileEntry
        """

        all_params = ['subject_id', 'file_name']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_file_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_file_info`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `get_subject_file_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'file_name' in params:
            path_params['FileName'] = params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/files/{FileName}/info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_note(self, subject_id, note_id, **kwargs):  # noqa: E501
        """Get a note on subject.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Note
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_subject_note_with_http_info(subject_id, note_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_note_with_http_info(subject_id, note_id, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_subject_note_with_http_info(self, subject_id, note_id, **kwargs):  # noqa: E501
        """Get a note on subject.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str note_id: (required)
        :param bool async: Perform the request asynchronously
        :return: Note
        """

        all_params = ['subject_id', 'note_id']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_note`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `get_subject_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'note_id' in params:
            path_params['NoteId'] = params['note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/notes/{NoteId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Note',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_sessions(self, subject_id, **kwargs):  # noqa: E501
        """List sessions of a subject

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[Session]
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_subject_sessions_with_http_info(subject_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_sessions_with_http_info(subject_id, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_subject_sessions_with_http_info(self, subject_id, **kwargs):  # noqa: E501
        """List sessions of a subject

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async: Perform the request asynchronously
        :return: list[Session]
        """

        all_params = ['subject_id', 'filter', 'sort', 'limit', 'skip', 'page', 'after_id']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_sessions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_sessions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'after_id' in params:
            query_params.append(('after_id', params['after_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/sessions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Session]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_tag(self, subject_id, tag_value, **kwargs):  # noqa: E501
        """Get the value of a tag, by name.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: Tag
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_subject_tag_with_http_info(subject_id, tag_value, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_tag_with_http_info(subject_id, tag_value, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_subject_tag_with_http_info(self, subject_id, tag_value, **kwargs):  # noqa: E501
        """Get the value of a tag, by name.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param bool async: Perform the request asynchronously
        :return: Tag
        """

        all_params = ['subject_id', 'tag_value']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_tag`")  # noqa: E501
        # verify the required parameter 'tag_value' is set
        if ('tag_value' not in params or
                params['tag_value'] is None):
            raise ValueError("Missing the required parameter `tag_value` when calling `get_subject_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'tag_value' in params:
            path_params['TagValue'] = params['tag_value']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/tags/{TagValue}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tag',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def modify_subject(self, subject_id, body, **kwargs):  # noqa: E501
        """Update a subject

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param Subject body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.modify_subject_with_http_info(subject_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_subject_with_http_info(subject_id, body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def modify_subject_with_http_info(self, subject_id, body, **kwargs):  # noqa: E501
        """Update a subject

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param Subject body: (required)
        :param bool async: Perform the request asynchronously
        :return: InlineResponse200
        """

        all_params = ['subject_id', 'body']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_subject" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `modify_subject`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_subject`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.Subject.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def modify_subject_analysis(self, subject_id, analysis_id, body, **kwargs):  # noqa: E501
        """Modify an analysis.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param AnalysisUpdate body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.modify_subject_analysis_with_http_info(subject_id, analysis_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_subject_analysis_with_http_info(subject_id, analysis_id, body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def modify_subject_analysis_with_http_info(self, subject_id, analysis_id, body, **kwargs):  # noqa: E501
        """Modify an analysis.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param AnalysisUpdate body: (required)
        :param bool async: Perform the request asynchronously
        :return: InlineResponse200
        """

        all_params = ['subject_id', 'analysis_id', 'body']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_subject_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `modify_subject_analysis`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `modify_subject_analysis`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_subject_analysis`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['AnalysisId'] = params['analysis_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.AnalysisUpdate.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/analyses/{AnalysisId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def modify_subject_file(self, subject_id, file_name, body, **kwargs):  # noqa: E501
        """Modify a file&#39;s attributes

        Note: If modifying a file's modality, the current classification will be cleared (except for items in the \"Custom\" list) 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param FileEntry body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2005
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.modify_subject_file_with_http_info(subject_id, file_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_subject_file_with_http_info(subject_id, file_name, body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def modify_subject_file_with_http_info(self, subject_id, file_name, body, **kwargs):  # noqa: E501
        """Modify a file&#39;s attributes

        Note: If modifying a file's modality, the current classification will be cleared (except for items in the \"Custom\" list) 
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param FileEntry body: (required)
        :param bool async: Perform the request asynchronously
        :return: InlineResponse2005
        """

        all_params = ['subject_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_subject_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `modify_subject_file`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `modify_subject_file`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_subject_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'file_name' in params:
            path_params['FileName'] = params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.FileEntry.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/files/{FileName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def modify_subject_file_classification(self, subject_id, file_name, body, **kwargs):  # noqa: E501
        """Update classification for a particular file.

        If replacing a file's classification, the modality can optionally be modified as well.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse2005
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.modify_subject_file_classification_with_http_info(subject_id, file_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_subject_file_classification_with_http_info(subject_id, file_name, body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def modify_subject_file_classification_with_http_info(self, subject_id, file_name, body, **kwargs):  # noqa: E501
        """Update classification for a particular file.

        If replacing a file's classification, the modality can optionally be modified as well.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param ClassificationUpdateInput body: (required)
        :param bool async: Perform the request asynchronously
        :return: InlineResponse2005
        """

        all_params = ['subject_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_subject_file_classification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `modify_subject_file_classification`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `modify_subject_file_classification`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_subject_file_classification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'file_name' in params:
            path_params['FileName'] = params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.ClassificationUpdateInput.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/files/{FileName}/classification', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def modify_subject_file_info(self, subject_id, file_name, body, **kwargs):  # noqa: E501
        """Update info for a particular file.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.modify_subject_file_info_with_http_info(subject_id, file_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_subject_file_info_with_http_info(subject_id, file_name, body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def modify_subject_file_info_with_http_info(self, subject_id, file_name, body, **kwargs):  # noqa: E501
        """Update info for a particular file.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param InfoUpdateInput body: (required)
        :param bool async: Perform the request asynchronously
        :return: InlineResponse200
        """

        all_params = ['subject_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_subject_file_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `modify_subject_file_info`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `modify_subject_file_info`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_subject_file_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'file_name' in params:
            path_params['FileName'] = params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.InfoUpdateInput.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/files/{FileName}/info', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def modify_subject_info(self, subject_id, body, **kwargs):  # noqa: E501
        """Update or replace info for a subject.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param InfoUpdateInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.modify_subject_info_with_http_info(subject_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_subject_info_with_http_info(subject_id, body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def modify_subject_info_with_http_info(self, subject_id, body, **kwargs):  # noqa: E501
        """Update or replace info for a subject.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param InfoUpdateInput body: (required)
        :param bool async: Perform the request asynchronously
        :return: None
        """

        all_params = ['subject_id', 'body']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_subject_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `modify_subject_info`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_subject_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.InfoUpdateInput.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/info', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def modify_subject_note(self, subject_id, note_id, body, **kwargs):  # noqa: E501
        """Update a note on subject.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str note_id: (required)
        :param Note body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.modify_subject_note_with_http_info(subject_id, note_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_subject_note_with_http_info(subject_id, note_id, body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def modify_subject_note_with_http_info(self, subject_id, note_id, body, **kwargs):  # noqa: E501
        """Update a note on subject.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str note_id: (required)
        :param Note body: (required)
        :param bool async: Perform the request asynchronously
        :return: InlineResponse200
        """

        all_params = ['subject_id', 'note_id', 'body']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_subject_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `modify_subject_note`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `modify_subject_note`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_subject_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'note_id' in params:
            path_params['NoteId'] = params['note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.Note.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/notes/{NoteId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def rename_subject_tag(self, subject_id, tag_value, body, **kwargs):  # noqa: E501
        """Rename a tag.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: InlineResponse200
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.rename_subject_tag_with_http_info(subject_id, tag_value, body, **kwargs)  # noqa: E501
        else:
            (data) = self.rename_subject_tag_with_http_info(subject_id, tag_value, body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def rename_subject_tag_with_http_info(self, subject_id, tag_value, body, **kwargs):  # noqa: E501
        """Rename a tag.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str tag_value: The tag to interact with (required)
        :param Tag body: (required)
        :param bool async: Perform the request asynchronously
        :return: InlineResponse200
        """

        all_params = ['subject_id', 'tag_value', 'body']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rename_subject_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `rename_subject_tag`")  # noqa: E501
        # verify the required parameter 'tag_value' is set
        if ('tag_value' not in params or
                params['tag_value'] is None):
            raise ValueError("Missing the required parameter `tag_value` when calling `rename_subject_tag`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `rename_subject_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'tag_value' in params:
            path_params['TagValue'] = params['tag_value']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.Tag.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/tags/{TagValue}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def replace_subject_file(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Replace a file

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.replace_subject_file_with_http_info(subject_id, file_name, **kwargs)  # noqa: E501
        else:
            (data) = self.replace_subject_file_with_http_info(subject_id, file_name, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def replace_subject_file_with_http_info(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Replace a file

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str file_name: (required)
        :param bool async: Perform the request asynchronously
        :return: None
        """

        all_params = ['subject_id', 'file_name']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_subject_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `replace_subject_file`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `replace_subject_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'file_name' in params:
            path_params['FileName'] = params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/files/{FileName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def upload_file_to_subject(self, subject_id, file, **kwargs):  # noqa: E501
        """Upload a file to subject.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param file file: The file to upload (required)
        :param str metadata: File metadata
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.upload_file_to_subject_with_http_info(subject_id, file, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_file_to_subject_with_http_info(subject_id, file, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def upload_file_to_subject_with_http_info(self, subject_id, file, **kwargs):  # noqa: E501
        """Upload a file to subject.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param file file: The file to upload (required)
        :param str metadata: File metadata
        :param bool async: Perform the request asynchronously
        :return: None
        """

        all_params = ['subject_id', 'file', 'metadata']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_file_to_subject" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `upload_file_to_subject`")  # noqa: E501
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `upload_file_to_subject`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def upload_output_to_subject_analysis(self, subject_id, analysis_id, file, **kwargs):  # noqa: E501
        """Upload an output file to analysis.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param file file: The file to upload (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.upload_output_to_subject_analysis_with_http_info(subject_id, analysis_id, file, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_output_to_subject_analysis_with_http_info(subject_id, analysis_id, file, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def upload_output_to_subject_analysis_with_http_info(self, subject_id, analysis_id, file, **kwargs):  # noqa: E501
        """Upload an output file to analysis.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param str analysis_id: (required)
        :param file file: The file to upload (required)
        :param bool async: Perform the request asynchronously
        :return: None
        """

        all_params = ['subject_id', 'analysis_id', 'file']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_output_to_subject_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `upload_output_to_subject_analysis`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `upload_output_to_subject_analysis`")  # noqa: E501
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `upload_output_to_subject_analysis`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['SubjectId'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['AnalysisId'] = params['analysis_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{SubjectId}/analyses/{AnalysisId}/files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def verify_master_subject_code(self, code, **kwargs):  # noqa: E501
        """Verify that the given master subject code exists or not

        This method makes a synchronous HTTP request by default.

        :param str code: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.verify_master_subject_code_with_http_info(code, **kwargs)  # noqa: E501
        else:
            (data) = self.verify_master_subject_code_with_http_info(code, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def verify_master_subject_code_with_http_info(self, code, **kwargs):  # noqa: E501
        """Verify that the given master subject code exists or not

        This method makes a synchronous HTTP request by default.

        :param str code: (required)
        :param bool async: Perform the request asynchronously
        :return: None
        """

        all_params = ['code']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_master_subject_code" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'code' is set
        if ('code' not in params or
                params['code'] is None):
            raise ValueError("Missing the required parameter `code` when calling `verify_master_subject_code`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'code' in params:
            path_params['code'] = params['code']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/master-code/{code}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)
