# coding: utf-8

"""
    Flywheel

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 15.5.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from flywheel.api_client import ApiClient
import flywheel.models

# NOTE: This file is auto generated by the swagger code generator program.
# Do not edit the class manually.

class DefaultApi(object):
    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def clean_packfiles(self, **kwargs):  # noqa: E501
        """Clean up expired upload tokens and invalid token directories.

        This method makes a synchronous HTTP request by default.

        :param bool async_: Perform the request asynchronously
        :return: object
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.clean_packfiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.clean_packfiles_with_http_info(**kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def clean_packfiles_with_http_info(self, **kwargs):  # noqa: E501
        """Clean up expired upload tokens and invalid token directories.

        This method makes a synchronous HTTP request by default.

        :param bool async: Perform the request asynchronously
        :return: object
        """

        all_params = []  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clean_packfiles" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/clean-packfiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def engine_upload(self, level, id, job, **kwargs):  # noqa: E501
        """Upload a list of file fields.

        ### Default behavior: > Uploads a list of file fields sent as file1, file2, etc to an existing   container and updates fields of the files, the container and it's   parents as specified in the metadata fileformfield using the   engine placer class  > A non-file form field called \"metadata\" is also required, which must be   a string containing JSON.  > See ``api/schemas/input/enginemetadata.json`` for the format of this metadata.  ### When ``level`` is ``analysis``: > Uploads a list of files to an existing analysis object, marking   all files as ``output=true`` using the job-based analyses placer   class.  > A non-file form field called \"metadata\" is also required, which must be   a string containing JSON.  > See ``api/schemas/input/analysis.json`` for the format of this metadata.  ### Signed URL upload with ``upload_ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?upload_ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request. 
        This method makes a synchronous HTTP request by default.

        :param str level: Which level to store files in (required)
        :param str id: The ID of the container to place files in (required)
        :param str job: Required if ``level`` is ``analysis`` (required)
        :param str body: Object encoded as a JSON string. It is **required** and used **only** when the ``upload_ticket`` parameter is used. See ``schemas/input/signedurlmetadata.json`` for the format of the json payload. 
        :param str form_data:
        :param str upload_ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param bool async_: Perform the request asynchronously
        :return: object
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.engine_upload_with_http_info(level, id, job, **kwargs)  # noqa: E501
        else:
            (data) = self.engine_upload_with_http_info(level, id, job, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def engine_upload_with_http_info(self, level, id, job, **kwargs):  # noqa: E501
        """Upload a list of file fields.

        ### Default behavior: > Uploads a list of file fields sent as file1, file2, etc to an existing   container and updates fields of the files, the container and it's   parents as specified in the metadata fileformfield using the   engine placer class  > A non-file form field called \"metadata\" is also required, which must be   a string containing JSON.  > See ``api/schemas/input/enginemetadata.json`` for the format of this metadata.  ### When ``level`` is ``analysis``: > Uploads a list of files to an existing analysis object, marking   all files as ``output=true`` using the job-based analyses placer   class.  > A non-file form field called \"metadata\" is also required, which must be   a string containing JSON.  > See ``api/schemas/input/analysis.json`` for the format of this metadata.  ### Signed URL upload with ``upload_ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?upload_ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request. 
        This method makes a synchronous HTTP request by default.

        :param str level: Which level to store files in (required)
        :param str id: The ID of the container to place files in (required)
        :param str job: Required if ``level`` is ``analysis`` (required)
        :param str body: Object encoded as a JSON string. It is **required** and used **only** when the ``upload_ticket`` parameter is used. See ``schemas/input/signedurlmetadata.json`` for the format of the json payload. 
        :param str form_data:
        :param str upload_ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param bool async: Perform the request asynchronously
        :return: object
        """

        all_params = ['level', 'id', 'job', 'body', 'form_data', 'upload_ticket']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method engine_upload" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'level' is set
        if ('level' not in params or
                params['level'] is None):
            raise ValueError("Missing the required parameter `level` when calling `engine_upload`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `engine_upload`")  # noqa: E501
        # verify the required parameter 'job' is set
        if ('job' not in params or
                params['job'] is None):
            raise ValueError("Missing the required parameter `job` when calling `engine_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'job' in params:
            query_params.append(('job', params['job']))  # noqa: E501
        if 'upload_ticket' in params:
            query_params.append(('upload_ticket', params['upload_ticket']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'body' in params:
            form_params.append(('body', params['body']))  # noqa: E501
        if 'form_data' in params:
            form_params.append(('formData', params['form_data']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/engine', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def fetch_tree(self, body, **kwargs):  # noqa: E501
        """Query a portion of the flywheel hierarchy, returning only the requested fields.

        This is a build-your-own request endpoint that can fetch from anywhere in the hierarchy, returning just the fields that you care about.  # Fields Each fetch-level described must include a list of fields to return. These fields can be anything on the container (except info), and will be included in the response if they are present in the container.  # Joins Children or parents can be joined as part of this request, by specifying an additional subdocument of the given name. Check /tree/graph for a list of containers and their connections.  # Filter Joined documents can be further filtered (with the exception of inputs & files) by passing a filter in the subdocument. Filtering follows the same convention as top-level pagination.  # Sort Joined documents can be sorted as well, following the convention as top-level pagination.  # Limit Joins can be limited to a the first N documents by specifying a limit in the subdocument.  # Join-origin Passing `true` for the `join-origin` flag in the files subdocument will populates the `join-origin` map for each container with files. 
        This method makes a synchronous HTTP request by default.

        :param TreeRequest body: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async_: Perform the request asynchronously
        :return: list[TreeResponseItem]
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.fetch_tree_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.fetch_tree_with_http_info(body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def fetch_tree_with_http_info(self, body, **kwargs):  # noqa: E501
        """Query a portion of the flywheel hierarchy, returning only the requested fields.

        This is a build-your-own request endpoint that can fetch from anywhere in the hierarchy, returning just the fields that you care about.  # Fields Each fetch-level described must include a list of fields to return. These fields can be anything on the container (except info), and will be included in the response if they are present in the container.  # Joins Children or parents can be joined as part of this request, by specifying an additional subdocument of the given name. Check /tree/graph for a list of containers and their connections.  # Filter Joined documents can be further filtered (with the exception of inputs & files) by passing a filter in the subdocument. Filtering follows the same convention as top-level pagination.  # Sort Joined documents can be sorted as well, following the convention as top-level pagination.  # Limit Joins can be limited to a the first N documents by specifying a limit in the subdocument.  # Join-origin Passing `true` for the `join-origin` flag in the files subdocument will populates the `join-origin` map for each container with files. 
        This method makes a synchronous HTTP request by default.

        :param TreeRequest body: (required)
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param bool async: Perform the request asynchronously
        :return: list[TreeResponseItem]
        """

        all_params = ['body', 'filter', 'sort', 'limit', 'skip', 'page', 'after_id']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_tree" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `fetch_tree`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'after_id' in params:
            query_params.append(('after_id', params['after_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.TreeRequest.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/tree', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TreeResponseItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_auth_status(self, **kwargs):  # noqa: E501
        """Get Login status

        Get the current login status of the requestor
        This method makes a synchronous HTTP request by default.

        :param bool async_: Perform the request asynchronously
        :return: AuthLoginStatus
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_auth_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_auth_status_with_http_info(**kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_auth_status_with_http_info(self, **kwargs):  # noqa: E501
        """Get Login status

        Get the current login status of the requestor
        This method makes a synchronous HTTP request by default.

        :param bool async: Perform the request asynchronously
        :return: AuthLoginStatus
        """

        all_params = []  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_auth_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/auth/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AuthLoginStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_config(self, **kwargs):  # noqa: E501
        """Return public Scitran configuration information

        This method makes a synchronous HTTP request by default.

        :param bool async_: Perform the request asynchronously
        :return: ConfigOutput
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_config_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_config_with_http_info(**kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_config_with_http_info(self, **kwargs):  # noqa: E501
        """Return public Scitran configuration information

        This method makes a synchronous HTTP request by default.

        :param bool async: Perform the request asynchronously
        :return: ConfigOutput
        """

        all_params = []  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_config_js(self, **kwargs):  # noqa: E501
        """Return public Scitran configuration information in javascript format.

        This method makes a synchronous HTTP request by default.

        :param bool async_: Perform the request asynchronously
        :return: None
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_config_js_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_config_js_with_http_info(**kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_config_js_with_http_info(self, **kwargs):  # noqa: E501
        """Return public Scitran configuration information in javascript format.

        This method makes a synchronous HTTP request by default.

        :param bool async: Perform the request asynchronously
        :return: None
        """

        all_params = []  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_js" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/config.js', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_tree_graph(self, **kwargs):  # noqa: E501
        """Get a description of the flywheel hiearchy

        This method makes a synchronous HTTP request by default.

        :param bool async_: Perform the request asynchronously
        :return: TreeGraph
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_tree_graph_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_tree_graph_with_http_info(**kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_tree_graph_with_http_info(self, **kwargs):  # noqa: E501
        """Get a description of the flywheel hiearchy

        This method makes a synchronous HTTP request by default.

        :param bool async: Perform the request asynchronously
        :return: TreeGraph
        """

        all_params = []  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tree_graph" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/tree/graph', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TreeGraph',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_version(self, **kwargs):  # noqa: E501
        """Get server and database schema version info

        This method makes a synchronous HTTP request by default.

        :param bool async_: Perform the request asynchronously
        :return: VersionOutput
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_version_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_version_with_http_info(**kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def get_version_with_http_info(self, **kwargs):  # noqa: E501
        """Get server and database schema version info

        This method makes a synchronous HTTP request by default.

        :param bool async: Perform the request asynchronously
        :return: VersionOutput
        """

        all_params = []  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_version" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/version', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VersionOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def login(self, **kwargs):  # noqa: E501
        """Login

        Scitran Authentication
        This method makes a synchronous HTTP request by default.

        :param bool async_: Perform the request asynchronously
        :return: AuthLoginOutput
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.login_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.login_with_http_info(**kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def login_with_http_info(self, **kwargs):  # noqa: E501
        """Login

        Scitran Authentication
        This method makes a synchronous HTTP request by default.

        :param bool async: Perform the request asynchronously
        :return: AuthLoginOutput
        """

        all_params = []  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method login" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/login', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AuthLoginOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def logout(self, **kwargs):  # noqa: E501
        """Log Out

        Remove authtokens for user
        This method makes a synchronous HTTP request by default.

        :param bool async_: Perform the request asynchronously
        :return: AuthLogoutOutput
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.logout_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.logout_with_http_info(**kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def logout_with_http_info(self, **kwargs):  # noqa: E501
        """Log Out

        Remove authtokens for user
        This method makes a synchronous HTTP request by default.

        :param bool async: Perform the request asynchronously
        :return: AuthLogoutOutput
        """

        all_params = []  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logout" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/logout', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AuthLogoutOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def lookup_path(self, body, **kwargs):  # noqa: E501
        """Perform path based lookup of a single node in the Flywheel hierarchy

        This will perform a deep lookup of a node. See /resolve for more details. 
        This method makes a synchronous HTTP request by default.

        :param ResolverInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ResolverNode
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.lookup_path_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.lookup_path_with_http_info(body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def lookup_path_with_http_info(self, body, **kwargs):  # noqa: E501
        """Perform path based lookup of a single node in the Flywheel hierarchy

        This will perform a deep lookup of a node. See /resolve for more details. 
        This method makes a synchronous HTTP request by default.

        :param ResolverInput body: (required)
        :param bool async: Perform the request asynchronously
        :return: ResolverNode
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method lookup_path" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `lookup_path`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.ResolverInput.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/lookup', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResolverNode',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def resolve_path(self, body, **kwargs):  # noqa: E501
        """Perform path based lookup of nodes in the Flywheel hierarchy

        This will perform a deep lookup of a node (i.e. group/project/session/acquisition) and its children, including any files. The query path is an array of strings in the following order (by default):    * group id   * project label   * session label   * acquisition label  Additionally, analyses for project/session/acquisition nodes can be resolved by inserting the literal string `\"analyses\"`. e.g. `['scitran', 'MyProject', 'analyses']`.  Files for projects, sessions, acquisitions and analyses can be resolved by inserting the literal string `\"files\"`. e.g. `['scitran', 'MyProject', 'files']`.  An ID can be used instead of a label by formatting the string as `<id:project_id>`. The full path to the node, and the node's children will be included in the response. 
        This method makes a synchronous HTTP request by default.

        :param ResolverInput body: (required)
        :param bool exhaustive: Set to return a complete list regardless of permissions
        :param bool full_tree: Parse full download style paths (e.g. group/PROJECTS/project_label/SUBJECTS/...)
        :param bool minattr: Return only minimal attributes
        :param bool async_: Perform the request asynchronously
        :return: ResolverOutput
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.resolve_path_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.resolve_path_with_http_info(body, **kwargs)  # noqa: E501
            if data and hasattr(data, 'return_value'):
                return data.return_value()
            return data


    def resolve_path_with_http_info(self, body, **kwargs):  # noqa: E501
        """Perform path based lookup of nodes in the Flywheel hierarchy

        This will perform a deep lookup of a node (i.e. group/project/session/acquisition) and its children, including any files. The query path is an array of strings in the following order (by default):    * group id   * project label   * session label   * acquisition label  Additionally, analyses for project/session/acquisition nodes can be resolved by inserting the literal string `\"analyses\"`. e.g. `['scitran', 'MyProject', 'analyses']`.  Files for projects, sessions, acquisitions and analyses can be resolved by inserting the literal string `\"files\"`. e.g. `['scitran', 'MyProject', 'files']`.  An ID can be used instead of a label by formatting the string as `<id:project_id>`. The full path to the node, and the node's children will be included in the response. 
        This method makes a synchronous HTTP request by default.

        :param ResolverInput body: (required)
        :param bool exhaustive: Set to return a complete list regardless of permissions
        :param bool full_tree: Parse full download style paths (e.g. group/PROJECTS/project_label/SUBJECTS/...)
        :param bool minattr: Return only minimal attributes
        :param bool async: Perform the request asynchronously
        :return: ResolverOutput
        """

        all_params = ['body', 'exhaustive', 'full_tree', 'minattr']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resolve_path" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `resolve_path`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'exhaustive' in params:
            query_params.append(('exhaustive', params['exhaustive']))  # noqa: E501
        if 'full_tree' in params:
            query_params.append(('full_tree', params['full_tree']))  # noqa: E501
        if 'minattr' in params:
            query_params.append(('minattr', params['minattr']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = flywheel.models.ResolverInput.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/resolve', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResolverOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)
