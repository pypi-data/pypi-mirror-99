# coding: utf-8

"""
    3Di API

    3Di simulation API (latest version: 3.0)   Framework release: 1.0.16   3Di core release: 2.0.11  deployed on:  07:33AM (UTC) on September 04, 2020  # noqa: E501

    The version of the OpenAPI document: 3.0
    Contact: info@nelen-schuurmans.nl
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from openapi_client.configuration import Configuration


class NumericalSettings(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'id': 'int',
        'simulation_id': 'int',
        'cfl_strictness_factor_1d': 'float',
        'cfl_strictness_factor_2d': 'float',
        'convergence_cg': 'float',
        'flow_direction_threshold': 'float',
        'friction_shallow_water_depth_correction': 'int',
        'general_numerical_threshold': 'float',
        'time_integration_method': 'int',
        'limiter_waterlevel_gradient_1d': 'int',
        'limiter_waterlevel_gradient_2d': 'int',
        'limiter_slope_crossectional_area_2d': 'int',
        'limiter_slope_friction_2d': 'int',
        'max_non_linear_newton_iterations': 'int',
        'max_degree_gauss_seidel': 'int',
        'min_friction_velocity': 'float',
        'min_surface_area': 'float',
        'use_preconditioner_cg': 'int',
        'preissmann_slot': 'float',
        'pump_implicit_ratio': 'float',
        'limiter_slope_thin_water_layer': 'float',
        'use_of_cg': 'int',
        'use_nested_newton': 'bool',
        'flooding_threshold': 'float'
    }

    attribute_map = {
        'id': 'id',
        'simulation_id': 'simulation_id',
        'cfl_strictness_factor_1d': 'cfl_strictness_factor_1d',
        'cfl_strictness_factor_2d': 'cfl_strictness_factor_2d',
        'convergence_cg': 'convergence_cg',
        'flow_direction_threshold': 'flow_direction_threshold',
        'friction_shallow_water_depth_correction': 'friction_shallow_water_depth_correction',
        'general_numerical_threshold': 'general_numerical_threshold',
        'time_integration_method': 'time_integration_method',
        'limiter_waterlevel_gradient_1d': 'limiter_waterlevel_gradient_1d',
        'limiter_waterlevel_gradient_2d': 'limiter_waterlevel_gradient_2d',
        'limiter_slope_crossectional_area_2d': 'limiter_slope_crossectional_area_2d',
        'limiter_slope_friction_2d': 'limiter_slope_friction_2d',
        'max_non_linear_newton_iterations': 'max_non_linear_newton_iterations',
        'max_degree_gauss_seidel': 'max_degree_gauss_seidel',
        'min_friction_velocity': 'min_friction_velocity',
        'min_surface_area': 'min_surface_area',
        'use_preconditioner_cg': 'use_preconditioner_cg',
        'preissmann_slot': 'preissmann_slot',
        'pump_implicit_ratio': 'pump_implicit_ratio',
        'limiter_slope_thin_water_layer': 'limiter_slope_thin_water_layer',
        'use_of_cg': 'use_of_cg',
        'use_nested_newton': 'use_nested_newton',
        'flooding_threshold': 'flooding_threshold'
    }

    def __init__(self, id=None, simulation_id=None, cfl_strictness_factor_1d=None, cfl_strictness_factor_2d=None, convergence_cg=None, flow_direction_threshold=None, friction_shallow_water_depth_correction=None, general_numerical_threshold=None, time_integration_method=None, limiter_waterlevel_gradient_1d=None, limiter_waterlevel_gradient_2d=None, limiter_slope_crossectional_area_2d=None, limiter_slope_friction_2d=None, max_non_linear_newton_iterations=None, max_degree_gauss_seidel=None, min_friction_velocity=None, min_surface_area=None, use_preconditioner_cg=None, preissmann_slot=None, pump_implicit_ratio=None, limiter_slope_thin_water_layer=None, use_of_cg=None, use_nested_newton=None, flooding_threshold=None, local_vars_configuration=None):  # noqa: E501
        """NumericalSettings - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._id = None
        self._simulation_id = None
        self._cfl_strictness_factor_1d = None
        self._cfl_strictness_factor_2d = None
        self._convergence_cg = None
        self._flow_direction_threshold = None
        self._friction_shallow_water_depth_correction = None
        self._general_numerical_threshold = None
        self._time_integration_method = None
        self._limiter_waterlevel_gradient_1d = None
        self._limiter_waterlevel_gradient_2d = None
        self._limiter_slope_crossectional_area_2d = None
        self._limiter_slope_friction_2d = None
        self._max_non_linear_newton_iterations = None
        self._max_degree_gauss_seidel = None
        self._min_friction_velocity = None
        self._min_surface_area = None
        self._use_preconditioner_cg = None
        self._preissmann_slot = None
        self._pump_implicit_ratio = None
        self._limiter_slope_thin_water_layer = None
        self._use_of_cg = None
        self._use_nested_newton = None
        self._flooding_threshold = None
        self.discriminator = None

        if id is not None:
            self.id = id
        if simulation_id is not None:
            self.simulation_id = simulation_id
        self.cfl_strictness_factor_1d = cfl_strictness_factor_1d
        self.cfl_strictness_factor_2d = cfl_strictness_factor_2d
        self.convergence_cg = convergence_cg
        self.flow_direction_threshold = flow_direction_threshold
        self.friction_shallow_water_depth_correction = friction_shallow_water_depth_correction
        self.general_numerical_threshold = general_numerical_threshold
        if time_integration_method is not None:
            self.time_integration_method = time_integration_method
        self.limiter_waterlevel_gradient_1d = limiter_waterlevel_gradient_1d
        self.limiter_waterlevel_gradient_2d = limiter_waterlevel_gradient_2d
        self.limiter_slope_crossectional_area_2d = limiter_slope_crossectional_area_2d
        self.limiter_slope_friction_2d = limiter_slope_friction_2d
        self.max_non_linear_newton_iterations = max_non_linear_newton_iterations
        self.max_degree_gauss_seidel = max_degree_gauss_seidel
        self.min_friction_velocity = min_friction_velocity
        self.min_surface_area = min_surface_area
        self.use_preconditioner_cg = use_preconditioner_cg
        self.preissmann_slot = preissmann_slot
        self.pump_implicit_ratio = pump_implicit_ratio
        self.limiter_slope_thin_water_layer = limiter_slope_thin_water_layer
        self.use_of_cg = use_of_cg
        self.use_nested_newton = use_nested_newton
        self.flooding_threshold = flooding_threshold

    @property
    def id(self):
        """Gets the id of this NumericalSettings.  # noqa: E501


        :return: The id of this NumericalSettings.  # noqa: E501
        :rtype: int
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this NumericalSettings.


        :param id: The id of this NumericalSettings.  # noqa: E501
        :type: int
        """

        self._id = id

    @property
    def simulation_id(self):
        """Gets the simulation_id of this NumericalSettings.  # noqa: E501


        :return: The simulation_id of this NumericalSettings.  # noqa: E501
        :rtype: int
        """
        return self._simulation_id

    @simulation_id.setter
    def simulation_id(self, simulation_id):
        """Sets the simulation_id of this NumericalSettings.


        :param simulation_id: The simulation_id of this NumericalSettings.  # noqa: E501
        :type: int
        """

        self._simulation_id = simulation_id

    @property
    def cfl_strictness_factor_1d(self):
        """Gets the cfl_strictness_factor_1d of this NumericalSettings.  # noqa: E501


        :return: The cfl_strictness_factor_1d of this NumericalSettings.  # noqa: E501
        :rtype: float
        """
        return self._cfl_strictness_factor_1d

    @cfl_strictness_factor_1d.setter
    def cfl_strictness_factor_1d(self, cfl_strictness_factor_1d):
        """Sets the cfl_strictness_factor_1d of this NumericalSettings.


        :param cfl_strictness_factor_1d: The cfl_strictness_factor_1d of this NumericalSettings.  # noqa: E501
        :type: float
        """
        if self.local_vars_configuration.client_side_validation and cfl_strictness_factor_1d is None:  # noqa: E501
            raise ValueError("Invalid value for `cfl_strictness_factor_1d`, must not be `None`")  # noqa: E501

        self._cfl_strictness_factor_1d = cfl_strictness_factor_1d

    @property
    def cfl_strictness_factor_2d(self):
        """Gets the cfl_strictness_factor_2d of this NumericalSettings.  # noqa: E501


        :return: The cfl_strictness_factor_2d of this NumericalSettings.  # noqa: E501
        :rtype: float
        """
        return self._cfl_strictness_factor_2d

    @cfl_strictness_factor_2d.setter
    def cfl_strictness_factor_2d(self, cfl_strictness_factor_2d):
        """Sets the cfl_strictness_factor_2d of this NumericalSettings.


        :param cfl_strictness_factor_2d: The cfl_strictness_factor_2d of this NumericalSettings.  # noqa: E501
        :type: float
        """
        if self.local_vars_configuration.client_side_validation and cfl_strictness_factor_2d is None:  # noqa: E501
            raise ValueError("Invalid value for `cfl_strictness_factor_2d`, must not be `None`")  # noqa: E501

        self._cfl_strictness_factor_2d = cfl_strictness_factor_2d

    @property
    def convergence_cg(self):
        """Gets the convergence_cg of this NumericalSettings.  # noqa: E501

        suitable default is 1.0e-9  # noqa: E501

        :return: The convergence_cg of this NumericalSettings.  # noqa: E501
        :rtype: float
        """
        return self._convergence_cg

    @convergence_cg.setter
    def convergence_cg(self, convergence_cg):
        """Sets the convergence_cg of this NumericalSettings.

        suitable default is 1.0e-9  # noqa: E501

        :param convergence_cg: The convergence_cg of this NumericalSettings.  # noqa: E501
        :type: float
        """
        if self.local_vars_configuration.client_side_validation and convergence_cg is None:  # noqa: E501
            raise ValueError("Invalid value for `convergence_cg`, must not be `None`")  # noqa: E501

        self._convergence_cg = convergence_cg

    @property
    def flow_direction_threshold(self):
        """Gets the flow_direction_threshold of this NumericalSettings.  # noqa: E501

        suitable default is 1e-05  # noqa: E501

        :return: The flow_direction_threshold of this NumericalSettings.  # noqa: E501
        :rtype: float
        """
        return self._flow_direction_threshold

    @flow_direction_threshold.setter
    def flow_direction_threshold(self, flow_direction_threshold):
        """Sets the flow_direction_threshold of this NumericalSettings.

        suitable default is 1e-05  # noqa: E501

        :param flow_direction_threshold: The flow_direction_threshold of this NumericalSettings.  # noqa: E501
        :type: float
        """
        if self.local_vars_configuration.client_side_validation and flow_direction_threshold is None:  # noqa: E501
            raise ValueError("Invalid value for `flow_direction_threshold`, must not be `None`")  # noqa: E501

        self._flow_direction_threshold = flow_direction_threshold

    @property
    def friction_shallow_water_depth_correction(self):
        """Gets the friction_shallow_water_depth_correction of this NumericalSettings.  # noqa: E501

        In case the friction assumptions based on the dominant friction balance gives a structurally underestimation of the friction, you can switch this setting on.   0 is OFF, 1 is maximum between averaged friction and divided channel based friction, 2 is always linearized, 3 linearizes the depth based on a weighted average. In this case the maximum depth of a thin layer needs to be defined. Do not use in combination with interflow. Suitable default is 0 (OFF).  # noqa: E501

        :return: The friction_shallow_water_depth_correction of this NumericalSettings.  # noqa: E501
        :rtype: int
        """
        return self._friction_shallow_water_depth_correction

    @friction_shallow_water_depth_correction.setter
    def friction_shallow_water_depth_correction(self, friction_shallow_water_depth_correction):
        """Sets the friction_shallow_water_depth_correction of this NumericalSettings.

        In case the friction assumptions based on the dominant friction balance gives a structurally underestimation of the friction, you can switch this setting on.   0 is OFF, 1 is maximum between averaged friction and divided channel based friction, 2 is always linearized, 3 linearizes the depth based on a weighted average. In this case the maximum depth of a thin layer needs to be defined. Do not use in combination with interflow. Suitable default is 0 (OFF).  # noqa: E501

        :param friction_shallow_water_depth_correction: The friction_shallow_water_depth_correction of this NumericalSettings.  # noqa: E501
        :type: int
        """
        if self.local_vars_configuration.client_side_validation and friction_shallow_water_depth_correction is None:  # noqa: E501
            raise ValueError("Invalid value for `friction_shallow_water_depth_correction`, must not be `None`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                friction_shallow_water_depth_correction is not None and friction_shallow_water_depth_correction > 2147483647):  # noqa: E501
            raise ValueError("Invalid value for `friction_shallow_water_depth_correction`, must be a value less than or equal to `2147483647`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                friction_shallow_water_depth_correction is not None and friction_shallow_water_depth_correction < -2147483648):  # noqa: E501
            raise ValueError("Invalid value for `friction_shallow_water_depth_correction`, must be a value greater than or equal to `-2147483648`")  # noqa: E501

        self._friction_shallow_water_depth_correction = friction_shallow_water_depth_correction

    @property
    def general_numerical_threshold(self):
        """Gets the general_numerical_threshold of this NumericalSettings.  # noqa: E501

        suitable default is 1.0e-8  # noqa: E501

        :return: The general_numerical_threshold of this NumericalSettings.  # noqa: E501
        :rtype: float
        """
        return self._general_numerical_threshold

    @general_numerical_threshold.setter
    def general_numerical_threshold(self, general_numerical_threshold):
        """Sets the general_numerical_threshold of this NumericalSettings.

        suitable default is 1.0e-8  # noqa: E501

        :param general_numerical_threshold: The general_numerical_threshold of this NumericalSettings.  # noqa: E501
        :type: float
        """
        if self.local_vars_configuration.client_side_validation and general_numerical_threshold is None:  # noqa: E501
            raise ValueError("Invalid value for `general_numerical_threshold`, must not be `None`")  # noqa: E501

        self._general_numerical_threshold = general_numerical_threshold

    @property
    def time_integration_method(self):
        """Gets the time_integration_method of this NumericalSettings.  # noqa: E501

        There are various ways to discretize equation. At the moment only first order semi implicit is supported and tested (EULER_IMPLICIT).  # noqa: E501

        :return: The time_integration_method of this NumericalSettings.  # noqa: E501
        :rtype: int
        """
        return self._time_integration_method

    @time_integration_method.setter
    def time_integration_method(self, time_integration_method):
        """Sets the time_integration_method of this NumericalSettings.

        There are various ways to discretize equation. At the moment only first order semi implicit is supported and tested (EULER_IMPLICIT).  # noqa: E501

        :param time_integration_method: The time_integration_method of this NumericalSettings.  # noqa: E501
        :type: int
        """

        self._time_integration_method = time_integration_method

    @property
    def limiter_waterlevel_gradient_1d(self):
        """Gets the limiter_waterlevel_gradient_1d of this NumericalSettings.  # noqa: E501

        suitable default is 1  # noqa: E501

        :return: The limiter_waterlevel_gradient_1d of this NumericalSettings.  # noqa: E501
        :rtype: int
        """
        return self._limiter_waterlevel_gradient_1d

    @limiter_waterlevel_gradient_1d.setter
    def limiter_waterlevel_gradient_1d(self, limiter_waterlevel_gradient_1d):
        """Sets the limiter_waterlevel_gradient_1d of this NumericalSettings.

        suitable default is 1  # noqa: E501

        :param limiter_waterlevel_gradient_1d: The limiter_waterlevel_gradient_1d of this NumericalSettings.  # noqa: E501
        :type: int
        """
        if self.local_vars_configuration.client_side_validation and limiter_waterlevel_gradient_1d is None:  # noqa: E501
            raise ValueError("Invalid value for `limiter_waterlevel_gradient_1d`, must not be `None`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                limiter_waterlevel_gradient_1d is not None and limiter_waterlevel_gradient_1d > 2147483647):  # noqa: E501
            raise ValueError("Invalid value for `limiter_waterlevel_gradient_1d`, must be a value less than or equal to `2147483647`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                limiter_waterlevel_gradient_1d is not None and limiter_waterlevel_gradient_1d < -2147483648):  # noqa: E501
            raise ValueError("Invalid value for `limiter_waterlevel_gradient_1d`, must be a value greater than or equal to `-2147483648`")  # noqa: E501

        self._limiter_waterlevel_gradient_1d = limiter_waterlevel_gradient_1d

    @property
    def limiter_waterlevel_gradient_2d(self):
        """Gets the limiter_waterlevel_gradient_2d of this NumericalSettings.  # noqa: E501

        suitable default is 1  # noqa: E501

        :return: The limiter_waterlevel_gradient_2d of this NumericalSettings.  # noqa: E501
        :rtype: int
        """
        return self._limiter_waterlevel_gradient_2d

    @limiter_waterlevel_gradient_2d.setter
    def limiter_waterlevel_gradient_2d(self, limiter_waterlevel_gradient_2d):
        """Sets the limiter_waterlevel_gradient_2d of this NumericalSettings.

        suitable default is 1  # noqa: E501

        :param limiter_waterlevel_gradient_2d: The limiter_waterlevel_gradient_2d of this NumericalSettings.  # noqa: E501
        :type: int
        """
        if self.local_vars_configuration.client_side_validation and limiter_waterlevel_gradient_2d is None:  # noqa: E501
            raise ValueError("Invalid value for `limiter_waterlevel_gradient_2d`, must not be `None`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                limiter_waterlevel_gradient_2d is not None and limiter_waterlevel_gradient_2d > 2147483647):  # noqa: E501
            raise ValueError("Invalid value for `limiter_waterlevel_gradient_2d`, must be a value less than or equal to `2147483647`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                limiter_waterlevel_gradient_2d is not None and limiter_waterlevel_gradient_2d < -2147483648):  # noqa: E501
            raise ValueError("Invalid value for `limiter_waterlevel_gradient_2d`, must be a value greater than or equal to `-2147483648`")  # noqa: E501

        self._limiter_waterlevel_gradient_2d = limiter_waterlevel_gradient_2d

    @property
    def limiter_slope_crossectional_area_2d(self):
        """Gets the limiter_slope_crossectional_area_2d of this NumericalSettings.  # noqa: E501


        :return: The limiter_slope_crossectional_area_2d of this NumericalSettings.  # noqa: E501
        :rtype: int
        """
        return self._limiter_slope_crossectional_area_2d

    @limiter_slope_crossectional_area_2d.setter
    def limiter_slope_crossectional_area_2d(self, limiter_slope_crossectional_area_2d):
        """Sets the limiter_slope_crossectional_area_2d of this NumericalSettings.


        :param limiter_slope_crossectional_area_2d: The limiter_slope_crossectional_area_2d of this NumericalSettings.  # noqa: E501
        :type: int
        """
        if self.local_vars_configuration.client_side_validation and limiter_slope_crossectional_area_2d is None:  # noqa: E501
            raise ValueError("Invalid value for `limiter_slope_crossectional_area_2d`, must not be `None`")  # noqa: E501

        self._limiter_slope_crossectional_area_2d = limiter_slope_crossectional_area_2d

    @property
    def limiter_slope_friction_2d(self):
        """Gets the limiter_slope_friction_2d of this NumericalSettings.  # noqa: E501

        This limiter starts working in case the depth based on the downstream water level is 0 and may be useful in sloping areas. This limiter is mandatory if the limiter_slope_crossectional_area_2d settings i greater than 0. Do not use in combination with interflow. Suitable default is 0 (OFF)  # noqa: E501

        :return: The limiter_slope_friction_2d of this NumericalSettings.  # noqa: E501
        :rtype: int
        """
        return self._limiter_slope_friction_2d

    @limiter_slope_friction_2d.setter
    def limiter_slope_friction_2d(self, limiter_slope_friction_2d):
        """Sets the limiter_slope_friction_2d of this NumericalSettings.

        This limiter starts working in case the depth based on the downstream water level is 0 and may be useful in sloping areas. This limiter is mandatory if the limiter_slope_crossectional_area_2d settings i greater than 0. Do not use in combination with interflow. Suitable default is 0 (OFF)  # noqa: E501

        :param limiter_slope_friction_2d: The limiter_slope_friction_2d of this NumericalSettings.  # noqa: E501
        :type: int
        """
        if self.local_vars_configuration.client_side_validation and limiter_slope_friction_2d is None:  # noqa: E501
            raise ValueError("Invalid value for `limiter_slope_friction_2d`, must not be `None`")  # noqa: E501

        self._limiter_slope_friction_2d = limiter_slope_friction_2d

    @property
    def max_non_linear_newton_iterations(self):
        """Gets the max_non_linear_newton_iterations of this NumericalSettings.  # noqa: E501

        suitable default is 20  # noqa: E501

        :return: The max_non_linear_newton_iterations of this NumericalSettings.  # noqa: E501
        :rtype: int
        """
        return self._max_non_linear_newton_iterations

    @max_non_linear_newton_iterations.setter
    def max_non_linear_newton_iterations(self, max_non_linear_newton_iterations):
        """Sets the max_non_linear_newton_iterations of this NumericalSettings.

        suitable default is 20  # noqa: E501

        :param max_non_linear_newton_iterations: The max_non_linear_newton_iterations of this NumericalSettings.  # noqa: E501
        :type: int
        """
        if self.local_vars_configuration.client_side_validation and max_non_linear_newton_iterations is None:  # noqa: E501
            raise ValueError("Invalid value for `max_non_linear_newton_iterations`, must not be `None`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                max_non_linear_newton_iterations is not None and max_non_linear_newton_iterations > 2147483647):  # noqa: E501
            raise ValueError("Invalid value for `max_non_linear_newton_iterations`, must be a value less than or equal to `2147483647`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                max_non_linear_newton_iterations is not None and max_non_linear_newton_iterations < -2147483648):  # noqa: E501
            raise ValueError("Invalid value for `max_non_linear_newton_iterations`, must be a value greater than or equal to `-2147483648`")  # noqa: E501

        self._max_non_linear_newton_iterations = max_non_linear_newton_iterations

    @property
    def max_degree_gauss_seidel(self):
        """Gets the max_degree_gauss_seidel of this NumericalSettings.  # noqa: E501

        Suitable default is 0. Values below are advised for different model types 700 for 1D flow 7 for 1D and 2D flow 5 for surface 2D flow only 7 for surface and groundwater flow 70 for 1D, 2D surface and groundwater flow or higher. Play around with this value in case of groundwater, can speed up your model significantly  # noqa: E501

        :return: The max_degree_gauss_seidel of this NumericalSettings.  # noqa: E501
        :rtype: int
        """
        return self._max_degree_gauss_seidel

    @max_degree_gauss_seidel.setter
    def max_degree_gauss_seidel(self, max_degree_gauss_seidel):
        """Sets the max_degree_gauss_seidel of this NumericalSettings.

        Suitable default is 0. Values below are advised for different model types 700 for 1D flow 7 for 1D and 2D flow 5 for surface 2D flow only 7 for surface and groundwater flow 70 for 1D, 2D surface and groundwater flow or higher. Play around with this value in case of groundwater, can speed up your model significantly  # noqa: E501

        :param max_degree_gauss_seidel: The max_degree_gauss_seidel of this NumericalSettings.  # noqa: E501
        :type: int
        """
        if self.local_vars_configuration.client_side_validation and max_degree_gauss_seidel is None:  # noqa: E501
            raise ValueError("Invalid value for `max_degree_gauss_seidel`, must not be `None`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                max_degree_gauss_seidel is not None and max_degree_gauss_seidel > 2147483647):  # noqa: E501
            raise ValueError("Invalid value for `max_degree_gauss_seidel`, must be a value less than or equal to `2147483647`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                max_degree_gauss_seidel is not None and max_degree_gauss_seidel < 0):  # noqa: E501
            raise ValueError("Invalid value for `max_degree_gauss_seidel`, must be a value greater than or equal to `0`")  # noqa: E501

        self._max_degree_gauss_seidel = max_degree_gauss_seidel

    @property
    def min_friction_velocity(self):
        """Gets the min_friction_velocity of this NumericalSettings.  # noqa: E501

        suitable default is 0.01  # noqa: E501

        :return: The min_friction_velocity of this NumericalSettings.  # noqa: E501
        :rtype: float
        """
        return self._min_friction_velocity

    @min_friction_velocity.setter
    def min_friction_velocity(self, min_friction_velocity):
        """Sets the min_friction_velocity of this NumericalSettings.

        suitable default is 0.01  # noqa: E501

        :param min_friction_velocity: The min_friction_velocity of this NumericalSettings.  # noqa: E501
        :type: float
        """
        if self.local_vars_configuration.client_side_validation and min_friction_velocity is None:  # noqa: E501
            raise ValueError("Invalid value for `min_friction_velocity`, must not be `None`")  # noqa: E501

        self._min_friction_velocity = min_friction_velocity

    @property
    def min_surface_area(self):
        """Gets the min_surface_area of this NumericalSettings.  # noqa: E501

        suitable default is 1.0e-8  # noqa: E501

        :return: The min_surface_area of this NumericalSettings.  # noqa: E501
        :rtype: float
        """
        return self._min_surface_area

    @min_surface_area.setter
    def min_surface_area(self, min_surface_area):
        """Sets the min_surface_area of this NumericalSettings.

        suitable default is 1.0e-8  # noqa: E501

        :param min_surface_area: The min_surface_area of this NumericalSettings.  # noqa: E501
        :type: float
        """
        if self.local_vars_configuration.client_side_validation and min_surface_area is None:  # noqa: E501
            raise ValueError("Invalid value for `min_surface_area`, must not be `None`")  # noqa: E501

        self._min_surface_area = min_surface_area

    @property
    def use_preconditioner_cg(self):
        """Gets the use_preconditioner_cg of this NumericalSettings.  # noqa: E501

        Use preconditioner for matrix solver. Increases simulation speed in most cases. suitable default is 1 (STANDARD)  # noqa: E501

        :return: The use_preconditioner_cg of this NumericalSettings.  # noqa: E501
        :rtype: int
        """
        return self._use_preconditioner_cg

    @use_preconditioner_cg.setter
    def use_preconditioner_cg(self, use_preconditioner_cg):
        """Sets the use_preconditioner_cg of this NumericalSettings.

        Use preconditioner for matrix solver. Increases simulation speed in most cases. suitable default is 1 (STANDARD)  # noqa: E501

        :param use_preconditioner_cg: The use_preconditioner_cg of this NumericalSettings.  # noqa: E501
        :type: int
        """
        if self.local_vars_configuration.client_side_validation and use_preconditioner_cg is None:  # noqa: E501
            raise ValueError("Invalid value for `use_preconditioner_cg`, must not be `None`")  # noqa: E501

        self._use_preconditioner_cg = use_preconditioner_cg

    @property
    def preissmann_slot(self):
        """Gets the preissmann_slot of this NumericalSettings.  # noqa: E501

        suitable default is 0.0  # noqa: E501

        :return: The preissmann_slot of this NumericalSettings.  # noqa: E501
        :rtype: float
        """
        return self._preissmann_slot

    @preissmann_slot.setter
    def preissmann_slot(self, preissmann_slot):
        """Sets the preissmann_slot of this NumericalSettings.

        suitable default is 0.0  # noqa: E501

        :param preissmann_slot: The preissmann_slot of this NumericalSettings.  # noqa: E501
        :type: float
        """
        if self.local_vars_configuration.client_side_validation and preissmann_slot is None:  # noqa: E501
            raise ValueError("Invalid value for `preissmann_slot`, must not be `None`")  # noqa: E501

        self._preissmann_slot = preissmann_slot

    @property
    def pump_implicit_ratio(self):
        """Gets the pump_implicit_ratio of this NumericalSettings.  # noqa: E501


        :return: The pump_implicit_ratio of this NumericalSettings.  # noqa: E501
        :rtype: float
        """
        return self._pump_implicit_ratio

    @pump_implicit_ratio.setter
    def pump_implicit_ratio(self, pump_implicit_ratio):
        """Sets the pump_implicit_ratio of this NumericalSettings.


        :param pump_implicit_ratio: The pump_implicit_ratio of this NumericalSettings.  # noqa: E501
        :type: float
        """
        if self.local_vars_configuration.client_side_validation and pump_implicit_ratio is None:  # noqa: E501
            raise ValueError("Invalid value for `pump_implicit_ratio`, must not be `None`")  # noqa: E501

        self._pump_implicit_ratio = pump_implicit_ratio

    @property
    def limiter_slope_thin_water_layer(self):
        """Gets the limiter_slope_thin_water_layer of this NumericalSettings.  # noqa: E501

        Mandatory when using friction_shallow_water_depth_correction option 3 or limiter_slope_crossectional_area_2d  # noqa: E501

        :return: The limiter_slope_thin_water_layer of this NumericalSettings.  # noqa: E501
        :rtype: float
        """
        return self._limiter_slope_thin_water_layer

    @limiter_slope_thin_water_layer.setter
    def limiter_slope_thin_water_layer(self, limiter_slope_thin_water_layer):
        """Sets the limiter_slope_thin_water_layer of this NumericalSettings.

        Mandatory when using friction_shallow_water_depth_correction option 3 or limiter_slope_crossectional_area_2d  # noqa: E501

        :param limiter_slope_thin_water_layer: The limiter_slope_thin_water_layer of this NumericalSettings.  # noqa: E501
        :type: float
        """
        if self.local_vars_configuration.client_side_validation and limiter_slope_thin_water_layer is None:  # noqa: E501
            raise ValueError("Invalid value for `limiter_slope_thin_water_layer`, must not be `None`")  # noqa: E501

        self._limiter_slope_thin_water_layer = limiter_slope_thin_water_layer

    @property
    def use_of_cg(self):
        """Gets the use_of_cg of this NumericalSettings.  # noqa: E501

        suitable default is 20  # noqa: E501

        :return: The use_of_cg of this NumericalSettings.  # noqa: E501
        :rtype: int
        """
        return self._use_of_cg

    @use_of_cg.setter
    def use_of_cg(self, use_of_cg):
        """Sets the use_of_cg of this NumericalSettings.

        suitable default is 20  # noqa: E501

        :param use_of_cg: The use_of_cg of this NumericalSettings.  # noqa: E501
        :type: int
        """
        if self.local_vars_configuration.client_side_validation and use_of_cg is None:  # noqa: E501
            raise ValueError("Invalid value for `use_of_cg`, must not be `None`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                use_of_cg is not None and use_of_cg > 2147483647):  # noqa: E501
            raise ValueError("Invalid value for `use_of_cg`, must be a value less than or equal to `2147483647`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                use_of_cg is not None and use_of_cg < -2147483648):  # noqa: E501
            raise ValueError("Invalid value for `use_of_cg`, must be a value greater than or equal to `-2147483648`")  # noqa: E501

        self._use_of_cg = use_of_cg

    @property
    def use_nested_newton(self):
        """Gets the use_nested_newton of this NumericalSettings.  # noqa: E501

        Set to 'True' for 1D calculations with closed profiles to handle non-linearity in volume-water level relation. When set to 'False' it will be used if calculations become non-linear. For sewerage systems it is advised to set this setting to 'True'. Otherwise a suitable default is 'False'  # noqa: E501

        :return: The use_nested_newton of this NumericalSettings.  # noqa: E501
        :rtype: bool
        """
        return self._use_nested_newton

    @use_nested_newton.setter
    def use_nested_newton(self, use_nested_newton):
        """Sets the use_nested_newton of this NumericalSettings.

        Set to 'True' for 1D calculations with closed profiles to handle non-linearity in volume-water level relation. When set to 'False' it will be used if calculations become non-linear. For sewerage systems it is advised to set this setting to 'True'. Otherwise a suitable default is 'False'  # noqa: E501

        :param use_nested_newton: The use_nested_newton of this NumericalSettings.  # noqa: E501
        :type: bool
        """
        if self.local_vars_configuration.client_side_validation and use_nested_newton is None:  # noqa: E501
            raise ValueError("Invalid value for `use_nested_newton`, must not be `None`")  # noqa: E501

        self._use_nested_newton = use_nested_newton

    @property
    def flooding_threshold(self):
        """Gets the flooding_threshold of this NumericalSettings.  # noqa: E501

        suitable default is 0.000001  # noqa: E501

        :return: The flooding_threshold of this NumericalSettings.  # noqa: E501
        :rtype: float
        """
        return self._flooding_threshold

    @flooding_threshold.setter
    def flooding_threshold(self, flooding_threshold):
        """Sets the flooding_threshold of this NumericalSettings.

        suitable default is 0.000001  # noqa: E501

        :param flooding_threshold: The flooding_threshold of this NumericalSettings.  # noqa: E501
        :type: float
        """
        if self.local_vars_configuration.client_side_validation and flooding_threshold is None:  # noqa: E501
            raise ValueError("Invalid value for `flooding_threshold`, must not be `None`")  # noqa: E501

        self._flooding_threshold = flooding_threshold

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, NumericalSettings):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, NumericalSettings):
            return True

        return self.to_dict() != other.to_dict()
