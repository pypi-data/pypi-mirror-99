# Copyright 2020 Google LLC. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Task class and related functionality.

Task instructs the work to be peformed. A task is typically generated by the
core task generation loop based on the state of MLMD db.
"""

import abc
import typing
from typing import Dict, List, Optional, Text, Type, TypeVar

import attr
from tfx import types
from tfx.proto.orchestration import pipeline_pb2

from ml_metadata.proto import metadata_store_pb2


# TODO(goutham): Include pipeline key/tag in PipelineUid.
@attr.s(frozen=True)
class PipelineUid:
  """Unique identifier for a pipeline.

  Attributes:
    pipeline_id: Id of the pipeline containing the node. Corresponds to
      `Pipeline.pipeline_info.id` in the pipeline IR.
    pipeline_run_id: This is set only for sync pipelines and corresponds to
      `PipelineRuntimeSpec.pipeline_run_id` in the pipeline IR.
  """
  pipeline_id = attr.ib(type=Text)
  pipeline_run_id = attr.ib(type=Optional[Text])

  @classmethod
  def from_pipeline(cls: Type['PipelineUid'],
                    pipeline: pipeline_pb2.Pipeline) -> 'PipelineUid':
    if pipeline.runtime_spec.HasField('pipeline_run_id'):
      pipeline_run_id = (
          pipeline.runtime_spec.pipeline_run_id.field_value.string_value)
    else:
      pipeline_run_id = None
    return cls(
        pipeline_id=pipeline.pipeline_info.id, pipeline_run_id=pipeline_run_id)


@attr.s(frozen=True)
class NodeUid:
  """Unique identifier for a node in the pipeline.

  Attributes:
    pipeline_uid: The pipeline UID.
    node_id: Node id. Corresponds to `PipelineNode.node_info.id` in the pipeline
      IR.
  """
  pipeline_uid = attr.ib(type=PipelineUid)
  node_id = attr.ib(type=Text)

  @classmethod
  def from_pipeline_node(cls: Type['NodeUid'], pipeline: pipeline_pb2.Pipeline,
                         node: pipeline_pb2.PipelineNode) -> 'NodeUid':
    return cls(
        pipeline_uid=PipelineUid.from_pipeline(pipeline),
        node_id=node.node_info.id)


# Task id can be any hashable type.
TaskId = typing.Hashable

_TaskT = TypeVar('_TaskT', bound='Task')


class Task(abc.ABC):
  """Task instructs the work to be performed."""

  @property
  @abc.abstractmethod
  def task_id(self) -> TaskId:
    """Returns a unique identifier for this task.

    The concrete implementation must ensure that the returned task id is unique
    across all task types.
    """

  @classmethod
  def task_type_id(cls: Type[_TaskT]) -> Text:
    """Returns task type id."""
    return cls.__name__


class HasNodeUid(abc.ABC):
  """Abstract mixin class for node tasks."""

  @property
  @abc.abstractmethod
  def node_uid(self) -> NodeUid:
    """Returns the unique identifier of the node."""


@attr.s(frozen=True)
class ExecNodeTask(Task, HasNodeUid):
  """Task to instruct execution of a node in the pipeline.

  Attributes:
    execution: MLMD execution associated with current node.
    contexts: List of contexts associated with the execution.
    exec_properties: Execution properties of the execution.
    input_artifacts: Input artifacts dict.
    output_artifacts: Output artifacts dict.
    executor_output_uri: URI for the executor output.
    stateful_working_dir: Working directory for the node execution.
    pipeline: The pipeline IR proto containing the node to be executed.
    is_cancelled: Indicates whether this is a cancelled execution. The task
      scheduler is expected to gracefully exit after doing any necessary
      cleanup.
  """
  _node_uid = attr.ib(type=NodeUid)
  execution = attr.ib(type=metadata_store_pb2.Execution)
  contexts = attr.ib(type=List[metadata_store_pb2.Context])
  exec_properties = attr.ib(type=Dict[Text, types.Property])
  input_artifacts = attr.ib(type=Dict[Text, List[types.Artifact]])
  output_artifacts = attr.ib(type=Dict[Text, List[types.Artifact]])
  executor_output_uri = attr.ib(type=Text)
  stateful_working_dir = attr.ib(type=Text)
  pipeline = attr.ib(type=pipeline_pb2.Pipeline)
  is_cancelled = attr.ib(type=bool, default=False)

  @property
  def node_uid(self) -> NodeUid:
    return self._node_uid

  @property
  def task_id(self) -> TaskId:
    return _exec_node_task_id(self.task_type_id(), self.node_uid)


@attr.s(frozen=True)
class CancelNodeTask(Task, HasNodeUid):
  """Task to instruct cancellation of an ongoing node execution."""
  _node_uid = attr.ib(type=NodeUid)

  @property
  def node_uid(self) -> NodeUid:
    return self._node_uid

  @property
  def task_id(self) -> TaskId:
    return (self.task_type_id(), self.node_uid)


def is_exec_node_task(task: Task) -> bool:
  return task.task_type_id() == ExecNodeTask.task_type_id()


def is_cancel_node_task(task: Task) -> bool:
  return task.task_type_id() == CancelNodeTask.task_type_id()


def exec_node_task_id_from_pipeline_node(
    pipeline: pipeline_pb2.Pipeline, node: pipeline_pb2.PipelineNode) -> TaskId:
  """Returns task id of an `ExecNodeTask` from pipeline and node."""
  return _exec_node_task_id(ExecNodeTask.task_type_id(),
                            NodeUid.from_pipeline_node(pipeline, node))


def _exec_node_task_id(task_type_id: Text, node_uid: NodeUid) -> TaskId:
  return (task_type_id, node_uid)
