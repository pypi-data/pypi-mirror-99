# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['yamlett']

package_data = \
{'': ['*']}

install_requires = \
['cloudpathlib>=0,<1',
 'cloudpickle>=1.6.0,<2.0.0',
 'pymongo>=3.11.1,<4.0.0',
 'python-box[all]>=5.2.0,<6.0.0']

setup_kwargs = {
    'name': 'yamlett',
    'version': '0.0.5',
    'description': 'Yet Another ML Experiment Tracking Tool',
    'long_description': '# yamlett - Yet Another Machine Learning Experiment Tracking Tool\n\n1.  [What is `yamlett`?](#what-is-yamlett)\n2.  [Installation](#installation)\n3.  [Getting started](#org4c92758)\n4.  [Examples](#example)\n    1.  [MLflow vs yamlett](#orgb32d187)\n    2.  [Storing large artifacts](#org827a623)\n\n![PyPI](https://img.shields.io/pypi/v/yamlett)\n![PyPI - Python Version](https://img.shields.io/pypi/pyversions/yamlett)\n![PyPI - License](https://img.shields.io/pypi/l/yamlett)\n\n\n<a id="what-is-yamlett"></a>\n\n## What is `yamlett`?\n\n`yamlett` provides a simple but flexible way to track your ML experiments.\n\nIt has a simple interface with only two primitives: `Run` and `Experiment`.\n\n-   A `Run` is used to store information about one iteration of your `Experiment`. You can use it to record any ([BSON](http://bsonspec.org)-serializable) information you want such as model parameters, metrics, or pickled artifacts.\n-   An `Experiment` is a collection of `Run` objects. It has a `name` and it is a wrapper around a `pymongo.collection.Collection` object ([reference](https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection)), meaning that you can query it using `find` or `aggregate`. Think of it as a way to collect all the modeling iterations for a specific project.\n\nThe main difference with other tracking tools (e.g. MLflow) is that `yamlett` lets you save complex structured information using dictionaries or lists and filter on them later using MongoDB queries.\n\n`yamlett` is particularly useful if your experiments are configuration-driven. Once your configuration is loaded as a python object, storing it is as easy as `run.store("config", config)`.\n\n\n<a id="installation"></a>\n\n## Installation\n\n`yamlett` can be installed with `pip`:\n\n```sh\npip install yamlett\n```\n\nIt also requires a MongoDB instance that you can connect to. If you don\'t have one and just want to try out `yamlett`, we provide a [docker compose file](docker-compose.yaml) that starts a MongoDB instance available at `localhost:27017` (along with instances of [Presto](https://prestodb.io) and [Metabase](https://www.metabase.com)).\n\n\n<a id="org4c92758"></a>\n\n## Getting started\n\nIn `yamlett`, `MongoClient` [connection parameters](https://pymongo.readthedocs.io/en/stable/api/pymongo/mongo_client.html#pymongo.mongo_client.MongoClient) can be passed as keyword arguments in both `Run` and `Experiment` to specify what MongoDB instance you want to connect to. If you don\'t pass anything, the default arguments (`localhost:27017`) will be used. If you have a custom MongoDB instance, you can specify its `host` and `port` when creating a `Run` using `run=Run(host="mymongo.host.com", port=27017)`. Once you have a run instantiated, you can store a key/value pair with `run.store(key, value)` and you can look at the stored data with `run.data`.\n\n\n<a id="example"></a>\n\n## Examples\n\n\n<a id="orgb32d187"></a>\n\n### MLflow vs yamlett\n\nIn this section, we compare the same model run but with two different tracking different approaches: MLflow-like vs yamlett.\n\n1.  Set up the experiment\n\n    First, let\'s load a dataset for a simple classification problem that ships with scikit-learn.\n    \n    ```jupyter-python\n    from sklearn.datasets import load_iris\n    \n    X, y = load_iris(return_X_y=True)\n    ```\n    \n    Then, we create a logistic regression model and train that model on the iris dataset, increasing the number of iterations and changing the regularization strength.\n    \n    ```jupyter-python\n    from sklearn.linear_model import LogisticRegression\n    \n    model = LogisticRegression(max_iter=200, C=0.1)\n    model.fit(X, y)\n    ```\n\n2.  MLflow-like tracking\n\n    With `yamlett`, you are free to organize you tracking information so you could decide to store it using a "flat" approach similar to MLflow where each key has an associated value and there can be no nesting.\n    \n    ```jupyter-python\n    from yamlett import Run\n    from sklearn.metrics import f1_score\n    \n    run = Run(id="mlflow-like-run")\n    \n    # store some information about your trained model: its class and its parameters\n    run.store("params_model_class", model.__class__.__name__)\n    for param_name, param_value in model.get_params().items():\n        run.store(f"params_model_{param_name}", param_value)\n    \n    # store information about your data\n    run.store("data_n_features", X.shape[0])\n    run.store("data_n_observations", X.shape[1])\n    \n    # store the F1 score on the train data\n    run.store("metrics_train_f1_score", f1_score(y, model.predict(X), average="weighted"))\n    \n    # you can even store a pickled version of your model on disk\n    run.store("model", model, pickled=True)\n    ```\n    \n    After running this code, we can retrieve the stored information by calling `run.data(resolve=True)`:\n    \n        {\'_id\': \'mlflow-like-run\',\n         \'data_n_features\': 150,\n         \'data_n_observations\': 4,\n         \'metrics_train_f1_score\': 0.9599839935974389,\n         \'model\': LogisticRegression(C=0.1, max_iter=200),\n         \'params_model_C\': 0.1,\n         \'params_model_class\': \'LogisticRegression\',\n         \'params_model_class_weight\': None,\n         \'params_model_dual\': False,\n         \'params_model_fit_intercept\': True,\n         \'params_model_intercept_scaling\': 1,\n         \'params_model_l1_ratio\': None,\n         \'params_model_max_iter\': 200,\n         \'params_model_multi_class\': \'auto\',\n         \'params_model_n_jobs\': None,\n         \'params_model_penalty\': \'l2\',\n         \'params_model_random_state\': None,\n         \'params_model_solver\': \'lbfgs\',\n         \'params_model_tol\': 0.0001,\n         \'params_model_verbose\': 0,\n         \'params_model_warm_start\': False}\n    \n    This approach is straightforward: one scalar for each key in the document. However, one downside is that you need to maintain your own namespace convention. For example here, we used underscores to separate the different levels of information (params, data, metrics, etc) but this can quickly get confusing if chosen incorrectly: is it `params/model/fit_intercept` or `params/model_fit/intercept`? It is also more work than needed when information already comes nicely organized (e.g. `model.get_params()`).\n\n3.  `yamlett` tracking\n\n    The method we propose in this package leverages Python dictionaries / NoSQL DB documents to automatically store your information in a structured way. Let\'s see what it looks like using the same run as above:\n    \n    ```jupyter-python\n    from yamlett import Run\n    from sklearn.metrics import f1_score\n    \n    run = Run(id="yamlett-run")\n    \n    # store your model information\n    model_info = {\n        "class": model.__class__.__name__,\n        "params": model.get_params(),\n    }\n    run.store(f"model", model_info)\n    \n    # store information about your data\n    run.store("data", {"n_features": X.shape[0], "n_observations": X.shape[1]})\n    \n    # store the F1 score on your train data\n    run.store("metrics.f1_score", f1_score(y, model.predict(X), average="weighted"))\n    \n    # you can even store a pickled version of your model on disk\n    run.store("model.artifact", model, pickled=True)\n    ```\n    \n    Once again, let\'s call `run.data(resolve=True)` and see what information we stored:\n    \n        {\'_id\': \'yamlett-run\',\n         \'data\': <Box: {\'n_features\': 150, \'n_observations\': 4}>,\n         \'metrics\': <Box: {\'f1_score\': 0.9599839935974389}>,\n         \'model\': {\'artifact\': LogisticRegression(C=0.1, max_iter=200),\n                   \'class\': \'LogisticRegression\',\n                   \'params\': {\'C\': 0.1,\n                              \'class_weight\': None,\n                              \'dual\': False,\n                              \'fit_intercept\': True,\n                              \'intercept_scaling\': 1,\n                              \'l1_ratio\': None,\n                              \'max_iter\': 200,\n                              \'multi_class\': \'auto\',\n                              \'n_jobs\': None,\n                              \'penalty\': \'l2\',\n                              \'random_state\': None,\n                              \'solver\': \'lbfgs\',\n                              \'tol\': 0.0001,\n                              \'verbose\': 0,\n                              \'warm_start\': False}}}\n    \n    The run information is now stored in a document that can be easily parsed based on its structure. The top level keys of the document are `data`, `metrics`, and `model` making it easier to find information than with long keys in a flat dictionary. For instance, you may want to look at all the metrics for a given run using `run.data()["metrics"]`.\n    \n        <Box: {\'f1_score\': 0.9599839935974389}>\n    \n    Note that `yamlett` does not impose the document hierarchy so you are free to organize your run data as you see fit. Additionally, because `yamlett` is a light abstraction layer on top of MongoDB, you can query runs in an `Experiment` using `find` or `aggregate`. For example, we can retrieve all runs in the default experiment for which:\n    \n    1.  the model was fit with a bias term\n    2.  on a dataset with at least 3000 data points\n    3.  that yielded an F1 score of at least 0.9\n    \n    ```jupyter-python\n    from yamlett import Experiment\n    \n    e = Experiment()\n    \n    e.find(\n        {\n            "model.params.fit_intercept": True,\n            "data.n_observations": {"$gte": 3000},\n            "metrics.f1_score": {"$gte": 0.9},\n        }\n    )\n    ```\n\n\n<a id="org827a623"></a>\n\n### Storing large artifacts\n\nMongoDB has a [maximum document size of 16MB](https://docs.mongodb.com/manual/reference/limits/#BSON-Document-Size). This means that storing large models or outputs along with the run information is not directly possible. `yamlett` still lets you do that with `run.store(key, value, pickled=True)`. When `pickled` is set to `True`, the passed `value` is not directly stored in MongoDB but it is pickled and stored "on disk". By default, your `run` object will store pickled objects in a `.yamlett` folder in the current working directory. However, you can change this by specifying a `path` when you instantiate your `Run`: this path can be a local path or a cloud-based path (e.g. `s3://bucket/experiment/`).\n',
    'author': 'Virgile Landeiro',
    'author_email': 'virgile.landeiro@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/vlandeiro/yamlett',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.6,<4.0',
}


setup(**setup_kwargs)
