# ---------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# ---------------------------------------------------------

import sys
import inspect
import importlib
from enum import Enum
from typing import Union
from pathlib import Path

from azureml._common.exceptions import AzureMLException
from msrest.exceptions import HttpOperationError

from azure.ml.component._restclients.designer.exceptions import ComponentServiceError, ErrorResponseException
from azureml.exceptions._azureml_exception import UserErrorException
from azureml.exceptions import ExperimentExecutionException, ActivityFailedException


# The following usererrors are used to summarize different kinds of user errors in the dashboard.
# TODO: Refine all directly raised UserErrorException to several different kinds of exceptions.
class PipelineValidationError(UserErrorException):
    """
    PipelineComponent level validation error.
    """

    UNKNOWN = 'Unknown'
    # ModuleCycle error situation is: a cycle generated by a set of module nodes, like:
    # module1.input = module3.output
    # module2.input = module1.output
    # module3,input = module2.output
    MODULE_CYCLE = 'ModuleCycle'
    # PipelineRecursion error situation is: there is a loop between pipelines, like:
    # def pipeline1():
    #    pipeline2()
    # def pipeline2():
    #    pipeline1()
    PIPELINE_RECURSION = 'PipelineRecursion'
    EMPTY_PIPELINE = 'EmptyPipeline'

    AGGREGATED = 'Aggregated'

    def __init__(self, message, inner_exception=None, error_type=UNKNOWN):
        super().__init__(message)
        self.inner_exception = inner_exception
        self.error_type = error_type


class ComponentValidationError(UserErrorException):
    """
    Exception raised when the component validation fails.
    """

    UNKNOWN = 'Unknown'
    MISSING_INPUT = 'MissingInput'
    INVALID_INPUT = 'InvalidInput'
    MISSING_PARAMETER = 'MissingParameter'
    MISSING_RUNSETTING_PARAMETER = 'MissingRunSettingParameter'
    PARAMETER_TYPE_MISMATCH = 'ParameterTypeMismatch'
    INVALID_PARAMETER = 'InvalidParameter'
    INVALID_RUNSETTING_PARAMETER = 'InvalidRunSettingParameter'
    INVALID_DATASTORE_TYPE = 'InvalidDatastoreType'

    def __init__(self, message, inner_exception=None, error_type=UNKNOWN):
        super().__init__(message)
        self.inner_exception = inner_exception
        self.error_type = error_type


class KeywordError(UserErrorException):
    """Super class of all type keyword error."""
    def __init__(self, message):
        super().__init__(message)


class UnexpectedKeywordError(KeywordError):
    """Exception raised when an unexpected keyword parameter is provided in dynamic functions."""

    def __init__(self, func_name, keyword, keywords=None):
        message = "%s() got an unexpected keyword argument %r" % (func_name, keyword)
        message += ", valid keywords: %s." % ', '.join('%r' % key for key in keywords) if keywords else "."
        super().__init__(message)


class MultipleValueError(KeywordError):
    """Exception raised when giving multiple value of a keyword parameter in dynamic functions."""

    def __init__(self, func_name, keyword):
        message = "%s() got multiple values for argument %r." % (func_name, keyword)
        super().__init__(message)


class MissingPositionalArgsError(KeywordError):
    """Exception raised when missing positional keyword parameter in dynamic functions."""

    def __init__(self, func_name, missing_args):
        message = "%s() missing %d required positional argument(s): %s." % (
            func_name, len(missing_args), ', '.join('%r' % key for key in missing_args) if missing_args else ".")
        super().__init__(message)


class TooManyPositionalArgsError(KeywordError):
    """Exception raised when too many positional arguments is provided in dynamic functions."""

    def __init__(self, func_name, min_number, max_number, given_number):
        message = "%s() takes %s positional argument but %d were given." % (
            func_name, min_number if min_number == max_number else f'{min_number} to {max_number}', given_number)
        super().__init__(message)


class InvalidTargetSpecifiedError(UserErrorException):
    """Exception raised when an invalid target parameter is provided."""

    def __init__(self, message):
        super().__init__(message)


class CustomerCodeError(UserErrorException):
    """Exception raised when user's code has errors."""
    def __init__(self, error_message, inner_exception=None,):
        msg = "There are some problems in user script, error message: {}".format(error_message)
        super(CustomerCodeError, self).__init__(msg, inner_exception=inner_exception)


class ErrorCategory(Enum):
    # This error indicates that the user provided data is incorrect and causes backend 40x exception
    MTUserError = 'MTUserError'
    SDKUserError = 'SDKUserError'  # This error indicates that the user provided parameter doesn't pass validation
    CustomerUserError = 'CustomerUserError'  # This error indicates that the user's code has errors

    MTError = 'MTError'  # This error indicates that backend has some problems
    InternalSDKError = 'InternalSDKError'  # This error indicates that our package has some problems
    ExternalSDKError = 'ExternalSDKError'  # This error indicates that some dependent packages has problems


def _is_dsl_pipeline_customer_code_error():
    """Check whether the error is raised by customer code in dsl.pipeline"""
    _, _, traceback = sys.exc_info()
    if traceback is None:
        return False
    while traceback.tb_next is not None:
        traceback = traceback.tb_next
    # This is the frame where the exception is actually raises
    last_frame = traceback.tb_frame

    # We find the last frame which is in SDK code instead of customer code or dependencies code
    # by checking whether the code of the frame is under SDK folder.
    sdk_folder = Path(inspect.getfile(importlib.import_module('azure.ml.component'))).parent.resolve().as_posix()

    def is_in_sdk(frame):
        return Path(frame.f_code.co_filename).resolve().as_posix().startswith(sdk_folder)
    last_frame_in_sdk = last_frame
    while last_frame_in_sdk and not is_in_sdk(last_frame_in_sdk):
        last_frame_in_sdk = last_frame_in_sdk.f_back
    if not last_frame_in_sdk:
        return False

    # If the last frame which raises exception is in SDK code, it is not customer error.
    if last_frame == last_frame_in_sdk:
        return False
    # If the last frame in SDK is the pipeline decorator, the exception is caused by customer code, return True
    # Otherwise the exception might be some dependency error, return False
    target_mod, target_func = 'azure.ml.component._pipeline_component_definition_builder', '_get_func_outputs'
    target_file = inspect.getfile(importlib.import_module(target_mod))
    return last_frame_in_sdk.f_code.co_filename == target_file and last_frame_in_sdk.f_code.co_name == target_func


def _is_wrong_func_call_traceback():
    """Check whether the error is raised due to wrong function call, including following scenarios:

    Unexpected keyword: f(unexpected=xx) for f()
    Too many positional argument: f(xx) for f()
    Repeated argument: f(a=1, a=2) for f(a)
    """
    _, _, traceback = sys.exc_info()
    # For such cases, the exception is called in the current frame, so it must not have a traceback.
    return traceback is not None and traceback.tb_next is None


def _is_user_error_from_exception_type(e: Union[Exception, None]):
    """Determine whether if an exception is user error from it's exception type."""
    # Connection error happens on user's network failure, should be user error
    if isinstance(e, ConnectionError):
        return True

    # UserErrorException and KeyboardInterrupt should be sdk user error
    if isinstance(e, (UserErrorException, KeyboardInterrupt)):
        return True


def get_error_category(e: Exception):
    # Sometimes we wrap a exception with another, eg: any exception happens when calling rest client will be wrapped
    # to a ServiceError. We need to check both current exception and it's cause to get the right category.
    if _is_user_error_from_exception_type(e) or _is_user_error_from_exception_type(e.__cause__):
        return ErrorCategory.SDKUserError
    if isinstance(e, CustomerCodeError):
        return ErrorCategory.CustomerUserError
    if _is_dsl_pipeline_customer_code_error():
        return ErrorCategory.CustomerUserError
    if isinstance(e, (ComponentServiceError, ErrorResponseException)):
        code = e.status_code if isinstance(e, ComponentServiceError) else e.response.status_code
        if str(code).startswith('40'):
            # Currently all the 400/401/403/404s are treated as UserErrors.
            # Maybe it could be refined in the future according to more detailed information.
            return ErrorCategory.MTUserError
        return ErrorCategory.MTError

    # HttpOperationError is the exception raised by APIs in other AzureML SDKs.
    if isinstance(e, HttpOperationError):
        if str(e.response.status_code).startswith('40'):
            return ErrorCategory.SDKUserError
        return ErrorCategory.ExternalSDKError

    # ActivityFailedException is raised when an run submitted by user failed;
    # ExperimentExecutionException is raised when an run's output streaming is interrupted by user.
    # So currently we treat these two exceptions as UserError.
    if isinstance(e, (ActivityFailedException, ExperimentExecutionException)):
        return ErrorCategory.CustomerUserError

    # Exception inherited from AzureMLException which are not a user error should be external SDK error.
    if isinstance(e, AzureMLException):
        return ErrorCategory.ExternalSDKError

    return ErrorCategory.InternalSDKError
