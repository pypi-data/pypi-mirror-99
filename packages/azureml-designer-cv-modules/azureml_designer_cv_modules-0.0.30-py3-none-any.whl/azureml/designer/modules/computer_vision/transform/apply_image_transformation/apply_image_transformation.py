from pathlib import Path

import fire

from azureml.studio.core.io.image_directory import ImageDirectory
from azureml.studio.core.io.transformation_directory import ImageTransformationDirectory
from azureml.studio.core.logger import logger
from azureml.studio.core.error import InvalidDirectoryError
from azureml.studio.internal.error import ErrorMapping, InvalidTransformationDirectoryError
from azureml.studio.internal.error_handler import error_handler
from azureml.designer.modules.computer_vision.package_info import PACKAGE_NAME, VERSION

_TRAIN_MODE = 'For training'
_INFER_MODE = 'For inference'
_TRANSFORM_PREFIX_ONLY_IN_TRAIN_MODE = 'Random'


class ApplyImageTransformation:
    def __init__(self):
        self.transform = None

    # Note: to use this module in web service, we have to:
    # 1. include all parameters in 'on_init'/'run' method parameter list to follow webservice contract
    # as this module will be used in webserive.
    # 2. parameter names of 'on_init'/'run' method must be snake lower case format of port name in spec.
    def on_init(self, mode: str,
                input_image_transformation: ImageTransformationDirectory, input_image_directory: ImageDirectory):
        self.transform = self._get_transforms(input_image_transformation, mode)
        logger.info(f'{mode}, got transforms {self.transform}.')

    def run(self, mode: str,
            input_image_transformation: ImageTransformationDirectory, input_image_directory: ImageDirectory):
        logger.info('Applying image transformation to image directory.')
        transformed_dir = input_image_directory.apply_to_images(transform=self.transform)
        return (transformed_dir, )

    def _get_transforms(self, input_image_transformation, mode):
        if mode == _TRAIN_MODE:
            return input_image_transformation.torch_transform

        if mode == _INFER_MODE:
            infer_mode_transforms = [
                t for t in input_image_transformation.transforms if not self._is_only_train_mode_transform(t)
            ]
            return ImageTransformationDirectory.get_torch_transform(infer_mode_transforms)
        else:
            # Will never throw this error thanks to UI constraints
            raise TypeError(f"Unsupported transform type {mode}.")

    @staticmethod
    def _is_only_train_mode_transform(transform):
        # Transform ops to create new samples randomly like 'Random horizontal flip' are used for data augmentation
        # in training, which should be removed in inference because inference samples need to be fixed.
        # use 0 to extract transform op name
        return transform[0].startswith(_TRANSFORM_PREFIX_ONLY_IN_TRAIN_MODE)


@error_handler
def entrance(
        mode,
        input_image_transform_path,
        input_image_dir_path,
        output_path):
    # Add package version log
    logger.info(f'{PACKAGE_NAME} {VERSION}')
    # Validate whether image transformation.
    try:
        input_image_transformation = ImageTransformationDirectory.load(input_image_transform_path)
    except InvalidDirectoryError as e:
        ErrorMapping.rethrow(e, InvalidTransformationDirectoryError(
            arg_name=Path(input_image_transform_path).name,
            reason=e.reason,
            troubleshoot_hint=f"Please make sure input 'image' transformation generated by"
                              f" module 'Init Image Transformation' to '{ApplyImageTransformation.__name__}'."
            ))
    input_image_directory = ImageDirectory.load(input_image_dir_path)
    task = ApplyImageTransformation()
    task.on_init(
        mode=mode, input_image_transformation=input_image_transformation, input_image_directory=input_image_directory)
    output_dir, = task.run(
        mode=mode, input_image_transformation=input_image_transformation, input_image_directory=input_image_directory)
    output_dir.dump(output_path)


if __name__ == '__main__':
    fire.Fire(entrance)
