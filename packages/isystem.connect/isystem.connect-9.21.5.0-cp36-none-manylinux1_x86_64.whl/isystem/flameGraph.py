"""
 This script generates flame graph as SVG image out of profiler XML
 file generated by iSYSTEM winIDEA.
 Script input is profiler XML export with timeline. Prefer binary
 timeline export, since file size is much smaller than XML timeline export.

 This script is not suitable for long recordings. Additionally, interrupt
 routines should be filtered out, since they may appear at any point in
 any stack trace, which makes output image very large and it does not
 present needed information. Use command line option --ignore to specify
 interrupt functions.

 To make it easier to estimate trace size, the following are numbers from one
 of tests:
 Trd file size 258 MB, XML export with indentation file size 4 GB, without
 indentation 3 GB. Binary timeline export 9 MB for XML file with areas
 and statistics, 646 MB for binary timeline file.
 This file had a bit over 28_000_000 timeline events, and before filtering
 interrupt functions it had:
 Number of different stack frames = 2_859_554
 Size of output file with SVG image = 1.3 GB.
 Average stack depth = 76
 Max stack depth = 341
 This script took 16 minutes to process XML file, 7 minutes to process
 file with binary timeline (option --binTimeline).
 Chrome took about 1 hour before reporting rendering error, while FF
 rendered it in about 20 minutes, using about 7 GB of RAM, but responsivnes
 (scrolling) was bad (about a minute to render after scrolling, clicking
 was not detected).

 After filtering several interrupt functions:

 Sample cmd lines:
   python python/exports/isystem/flameGraph.py --binTimeline -c 7 --profExport ../../../tmp/largeProfilerExportBin.xml out.svg
   python python/exports/isystem/flameGraph.py --binTimeline -p -o --profExport targetProjects/fgtest1_flame.xml out.svg

 (c) iSYSTEM Labs d.o.o., 2018
"""

# TODO:
# - Add termination flag to processing function in this script, which
#   can be set from another thread (GUI)

from __future__ import print_function

import sys
import re
import pprint
import threading
import queue
import webbrowser
import hashlib

import isystem.connect as ic
import isystem.diagutils as diagutils

# list indices
E_TIME = 0
R_TIME = 1
NET_TIME = 2
GROSS_TIME = 3
CALLED_NET_TIME = 4

# limitations
MAX_STACK_DEPTH = 300 # if there are more calls on the stack, it is most likely
                      # invalid recording. Cmd line arg --depth can override this.

# misc consts
CTX_NOT_SPECIFIED = -1
MIN_FUNC_DURATION_NS = 1

LOG_ALL = 0
LOG_INFO = 1
LOG_WRN = 2
LOG_ERR = 3
LEVEL_DESC = ['DBG: ', 'INF: ', 'WRN: ', 'ERR: '] # levels are used as indices

LOG_LEVEL = LOG_INFO

GRAPH_WIDTH = 800
TEXT_RIGHT_MARGIN = 200 # space for text (function names) on the right of the graph
TEXT_LEFT_MARGIN = 2
FULL_W = GRAPH_WIDTH + TEXT_RIGHT_MARGIN
RECT_HEIGHT = 20
FONT_SIZE = RECT_HEIGHT
SMALL_BTN_W = 30
SEARCH_BTN_W = 50
UNKNOWN_FUNCTION_ID = -1
UNKNOWN_FUNCTION_NAME = '[unknown]'
RECT_ALL_FUNCTIONS_ID = "rectAllFunctions"
SEARCH_TIME_TXT_ID = 'searchTimeTxt'
SEARCH_COLOR = '00af00'


class AtomicInt:
    def __init__(self):
        self.value = 0
        self.lock = threading.Lock()

    def set(self, value):
        with self.lock:
            self.value = value

    def get(self):
        with self.lock:
            value = self.value
        return value


MAX_PROGRESS = 1000
_progress = AtomicInt()
_isTerminate = AtomicInt()
_logQueue = queue.Queue()
_binFileSize = -1
_eventSize = -1


class ColorMapType:
    """ Enum type for color maps. """
    FLAME = 'flame'
    GRASS = 'grass'
    WATER = 'water'
    RAINBOW = 'rainbow'
    FLAME_W_INVERSE = 'flameWInverse'


class ColorMapIdxAlgorithm:
    """ Enum type for color map index calculation. """
    INC = 'inc'
    DEPTH = 'depth'
    CYCLE = 'cycle'
    HASH = 'hash'


JAVASCRIPT_CODE = """
    <script type="text/ecmascript">
    <![CDATA[
    var zoomStack = [];
    var zoomIdx = 0;
    var searchTime = 0;
    var searchTimeText;
    var allFunctionsRect, svg;

    function initVars(evt) {
        allFunctionsRect = document.getElementById('${rectAllFuncsId}');
        searchTimeText = document.getElementById('${searchTimeText}');
        zoomStack.push(allFunctionsRect);
        if (!isBatik(false)) {
            svg = document.getElementsByTagName("svg")[0];
        }
    }


    // Support for javascript in Batik lacks info in DOM,
    // so skip functions to avoid error pop-up dialogs.
    function isBatik(isShowMsg) {
        if (typeof(navigator) == "undefined") {
            if (isShowMsg) {
                searchTimeText.textContent = "Not impl. in testIDEA. Open graph in FF or Chrome.";
            } else {
                searchTimeText.textContent = "";
            }
            return true;
        }

        return false;
    }


    function setOpacity(node, opacity) {
        node.setAttribute('opacity', opacity)
    }


    function mi(node) {   // mouse in
        if (isBatik(false)) return;

        rectNode  = node.children[0];
        rectNode.style["stroke-width"] = '1.5';
        rectNode.style["stroke"] = 'black';
    }


    function mo(node) {   // mouse out
        if (isBatik(false)) return;

        rectNode  = node.children[0];
        rectNode.style["stroke-width"] = '0';
    }


    function searchDialog() {
        if (isBatik(true)) return;

        var regex = prompt("Find regex:", "");

        if (regex != null) {
            search(regex)
        }
    }


    function search(regex) {

        var re = new RegExp(regex);

        var groups = document.getElementsByTagName("g");
        for(var i = 0; i < groups.length; i++){

            var group = groups[i];

            if (group.attributes['class'] == undefined  ||  group.attributes['class'].value != 'fBox') {
                continue;
            }

            var text = group.children[1].textContent;

            if (text.match(re)) {
                rectAttrs = getRectNodeAttrs(group);
                if (rectAttrs["origFill"] == undefined) {
                    rectAttrs["origFill"] = rectAttrs["fill"].value;
                    searchTime += parseFloat(rectAttrs['timeMs'].value);
                }
                rectAttrs["fill"].value = "#${searchColor}";
            }
        }

        searchTimeText.textContent = " t = " + searchTime;
    }


    function clearSearchResults() {
        if (isBatik(false)) return;

        var groups = document.getElementsByTagName("g");
        searchTime = 0;
        searchTimeText.textContent = "";

        for(var i = 0; i < groups.length; i++){

            var group = groups[i];

            if (group.attributes['class'] == undefined  ||  group.attributes['class'].value != 'fBox') {
                continue;
            }

            rectAttrs = getRectNodeAttrs(group);
            if (rectAttrs["origFill"] != undefined) {
                rectAttrs["fill"].value = rectAttrs["origFill"];
                rectAttrs["origFill"] = undefined;
            }
        }
    }



    // Zooming
    function getRectNodeAttrs(g_node) {
        return g_node.children[0].attributes
    }


    function getTxtNodeAttrs(g_node) {
        return g_node.children[1].attributes
    }


    function zoomAtNode(g_node) {
        var clickedAttr = getRectNodeAttrs(g_node);
        var clickedXleft = parseFloat(clickedAttr["xo"].value);
        var clickedWidthOrig = parseFloat(clickedAttr["wo"].value);
        var clickedXright = clickedXleft + clickedWidthOrig;
        var clickedY = parseFloat(clickedAttr["y"].value);
        var scale = (svg.width.baseVal.value - ${textRightMargin}) / clickedWidthOrig;
        var eps = 0.0001;

        var groups = document.getElementsByTagName("g");
        for(var i = 0; i < groups.length; i++){

            var group = groups[i];

            if (group.attributes['class'] == undefined  ||  group.attributes['class'].value != 'fBox') {
                continue;
            }

            var curRectAttrs = getRectNodeAttrs(group);
            var curRectXleft = parseFloat(curRectAttrs["xo"].value);
            var curRectWidth = parseFloat(curRectAttrs["wo"].value);
            var curRectXright = curRectWidth + curRectXleft;
            var curRectY = parseFloat(curRectAttrs["y"].value);

            // skip elements out of view (to the left or right of clicke rect.)
            if (curRectXright < (clickedXleft + eps)  ||  curRectXleft > (clickedXright - eps)) {

                group.style["display"] = "none";
            } else {
                group.style["display"] = "block";
                curRectAttrs['x'].value = (curRectXleft - clickedXleft) * scale;
                curRectAttrs['width'].value = curRectWidth * scale;

                var txtAttrs = getTxtNodeAttrs(group);
                var txtX = (curRectXleft - clickedXleft) * scale;
                if (txtX < 0) {
                    txtX = 0;
                }
                txtAttrs['x'].value = txtX + ${textLeftMargin};

                if (curRectY > clickedY) {
                    group.style["opacity"] = "0.5";
                } else {
                    group.style["opacity"] = "1.0";
                }
            }
        }

        // move white rectangles
        var whiteRects = document.getElementsByClassName("wrect");
        for(var i = 0; i < whiteRects.length; i++) {

            var whiteRect = whiteRects[i];

            var curRectAttrs = whiteRect.attributes;
            var curRectXleft = parseFloat(curRectAttrs["xo"].value);
            var curRectWidth = parseFloat(curRectAttrs["wo"].value);
            var curRectXright = curRectWidth + curRectXleft;

            // skip elements out of view (to the left or right of clicke rect.)
            if (curRectXleft < clickedXleft  ||  (curRectXleft - 3) > clickedXright) {

                whiteRect.style["display"] = "none";
            } else {
                whiteRect.style["display"] = "block";
                curRectAttrs['x'].value = (curRectXleft - clickedXleft) * scale;
                curRectAttrs['width'].value = curRectWidth * scale;
            }
        }
    }


    function zoom(g_node) {
        if (isBatik(true)) return;

        // remove nodes above current position
        zoomStack.splice(zoomIdx + 1, zoomStack.length);
        zoomStack.push(g_node);
        zoomIdx = zoomStack.length - 1;
        zoomAtNode(g_node);
    }


    function resetZoom(node) {
        if (isBatik(true)) return;

        zoom(allFunctionsRect);
    }


    function previousZoom(node) {
        if (isBatik(true)) return;

        zoomIdx--;
        if (zoomIdx < 0) {
            zoomIdx = 0;
        }

        if (zoomStack.length > 0) {
            zoomAtNode(zoomStack[zoomIdx]);
        } else {
            zoomAtNode(allFunctionsRect);
        }
    }


    function nextZoom(node) {
        if (isBatik(true)) return;

        zoomIdx++;
        if (zoomIdx >= zoomStack.length) {
            zoomIdx = zoomStack.length - 1;
            if (zoomIdx < 0) {
                zoomIdx = 0;
            }
        }

        if (zoomStack.length > 0) {
            zoomAtNode(zoomStack[zoomIdx]);
        } else {
            zoomAtNode(allFunctionsRect);
        }
    }
    ]]>
    </script>
    \n\n"""


def _log(logLevel, msg):
    global _logQueue

    if LOG_LEVEL <= logLevel:
        logMsg = LEVEL_DESC[logLevel] + msg
        _logQueue.put(logMsg + '\n')
        print(logMsg)


def _createColorMap(colorMapType, step):

    colorMap = []
    if step < 1:
        step = 1

    if step > 100:
        step = 100

    if colorMapType == ColorMapType.FLAME:

        r = 255
        b = 0

        for g in range(0, 256, step):
            colorMap.append('{:02x}{:02x}{:02x}'.format(r, g, b))

    elif colorMapType == ColorMapType.FLAME_W_INVERSE:

        r = 255
        b = 0

        for g in range(0, 256, step):
            colorMap.append('{:02x}{:02x}{:02x}'.format(r, g, b))

        for g in range(255, 0, -step):
            colorMap.append('{:02x}{:02x}{:02x}'.format(r, g, b))

    elif colorMapType == ColorMapType.GRASS:
        g = 255
        for redBlue in range(0, 200, step):  # up to 200 to avoid white color
            colorMap.append('{:02x}{:02x}{:02x}'.format(redBlue, g, redBlue))

    elif colorMapType == ColorMapType.WATER:
        r = 0
        b = 255
        for g in range(0, 256, step):
            colorMap.append('{:02x}{:02x}{:02x}'.format(r, g, b))

    elif colorMapType == ColorMapType.RAINBOW:
        colorMap = ['00ff00', 'ff0000', '5050ff', 'ff00ff', '00ffff', 'ffff00',
                    '00c000', 'c00000', '5050d0', 'c000c0', '008080', '808000',
                    'ff80ff', '80ffff', 'ffff80', '80ff80', 'ff8080', '8080ff',
                    'ffffff']
    else:
        raise Exception("Invalid color map name: " + str(colorMapType))

    return colorMap


def readAreasAndFuncStats(profilerData):
    """
    Returns map of <areaId, areaName> and <areaName, (NET_TIME, GROSS_TIME)>.
    """

    areas = {}
    funcStats = {}
    areaIt = profilerData.getAreaIterator(ic.CProfilerArea2.EFunctions)
    while areaIt.hasNext():
        area = areaIt.next()
        # Skip runnables, which are also functions in the same context,
        # but obtained with different analysis (instrumented info).
        if area.getPath() == 'Code':
            areaName = area.getAreaName()
            areaId = area.getAreaId()
            stats = profilerData.getStatistics(areaId)
            funcStats[areaName] = (stats.getNetTotalTime(), stats.getGrossTotalTime())
            areas[areaId] = areaName

    return areas, funcStats


def _isIgnoredArea(evAreaId, evType, ignoredAreaIds, activeIgnoredAreas):
    if evAreaId in ignoredAreaIds:

        if evType == ic.CProfilerTimeEvent.EEvEnter:
            activeIgnoredAreas.add(evAreaId)
            return True

        if evType == ic.CProfilerTimeEvent.EEvExit and evAreaId in activeIgnoredAreas:
            activeIgnoredAreas.remove(evAreaId)
            return True

    # if there is still an interrupt function running, ignore all
    # funcitons called from it
    if activeIgnoredAreas:
        return True

    return False


def _logStep(eventCounter, currentStack, frames):
    if LOG_LEVEL <= LOG_INFO:
        if eventCounter % 100000 == 0:
            print(eventCounter, ' ', end='')
            if LOG_LEVEL <= LOG_ALL:
                print(" ", len(currentStack), len(frames), currentStack)
            if sys.stdout != None: # when started from winIDEA there is not stdout
                sys.stdout.flush()


def _checkForConsistency(areaIdOnStack, evAreaId, inconsistentAreasOnStack,
                         inconsistentAreasWUnexpectedExit, areas, eventContext):

    if areaIdOnStack != evAreaId:
        # There is no valid corrective action, since we do not know
        # what it is redundant - entry on stack or return event?
        # Store info which may help user identify problematic functions.
        inconsistentAreasOnStack.add(areaIdOnStack)
        inconsistentAreasWUnexpectedExit.add(evAreaId)
        # provide info about problems on the fly, since processing may never
        # finish, if the file is long and inconsistent (out of memory)
        _log(LOG_WRN,
             "__INCONSISTENCY__: function return without entry detected. "
             "Flamegraph may not be accurate! Configure this script to ignore "
             "interrupt functions and use one context only. Event area: {} {}"
             "  Area on stack: {}"
             "  Context: {} {}".format(evAreaId, areas.get(evAreaId),
                                       areaIdOnStack, eventContext,
                                       areas.get(areaIdOnStack)))


def _printInconsistencies(areas, areasOnStack, areasWUnexpectedExit):
    if areasWUnexpectedExit:
        _log(LOG_WRN, '')
        _log(LOG_WRN,
             "E: __INCONSISTENCY__ SUMMARY: functions with return without entry detected. " +
             "Flamegraph may not be accurate! Configure this script to ignore " +
             "interrupt functions and use one context only.")
        _log(LOG_WRN, "E: Inconsistent Areas With Unexpected Exit:")
        for intAreaId in areasWUnexpectedExit:
            _log(LOG_WRN, '   - ' + areas[intAreaId])
        _log(LOG_WRN, "\nE: Inconsistent Areas On Stack:")
        for intAreaId in areasOnStack:
            _log(LOG_WRN, '   - ' + areas[intAreaId])
        _log(LOG_WRN, '')


def _prependFunction(frames, evAreaId, recordingStartTime):
    """
    This f. is called, when stack is empty, and event other than E is
    encountered (S, R, or X). This event means that the function started
    execution before recording started. This function puts the new function
    in front of all stack frames detected so far.
    """

    if LOG_LEVEL <= LOG_INFO:
        print("\nFunction with exit without entry detected, area ID = ", evAreaId)

    newFrames = {}

    for stack, frameTimes in frames.items():
        stackAsList = list(stack)
        stackAsList.insert(0, evAreaId)
        newFrames[tuple(stackAsList)] = frameTimes

    currentStackTuple = (evAreaId, )
    frameTimes = newFrames.setdefault(currentStackTuple, [0, 0, 0, 0, 0])
    frameTimes[E_TIME] = recordingStartTime
    frameTimes[R_TIME] = recordingStartTime

    return newFrames, currentStackTuple, [evAreaId]


def _addUnknownFunction(frames, currentStack, missingFuncTime):
    cs = list(currentStack)
    cs.append(UNKNOWN_FUNCTION_ID)
    currentStackTuple = tuple(cs)
    frameTimes = frames.setdefault(currentStackTuple, [0, 0, 0, 0, 0])
    frameTimes[NET_TIME] += missingFuncTime
    frameTimes[GROSS_TIME] += missingFuncTime


def _addNetTimeToCallers(frames, stackTuple, calledNetTime):
    """ Adds net time spent in function to all callers on the stack. """
    for stackDepth in range(1, len(stackTuple) + 1):
        stack = stackTuple[:stackDepth];
        frameTimes = frames[stack]
        frameTimes[CALLED_NET_TIME] += calledNetTime


def _adjustForUnknownFunctions(frames):
    """
    Adjusts measurements by adding 'unknown' functions where net times of
    a function and called functions do not sum up gross time of the function.
    This is needed, because profiler data does not contain calls to unknown
    functions - either not in the list of areas to record, or labels, which are
    not recognized by winIDEA as functions. The difference between recorded net
    time and gross time is then shown as [unknown] in flame graph.
    """

    # to check consistency, add net time of each function to item
    # CALLED_NET_TIME in its callers.
    for stack, frameTimes in frames.items():
        netTime = frameTimes[NET_TIME]
        _addNetTimeToCallers(frames, stack, netTime)

    # 'unknown' functions must be added top down, for example:
    #     f() calls g() calls h()
    # If net time of h() (stack = [f, g, h]) does not match its gross time, this
    # means h has called an unknown function, and this time must be added
    # to f() (stask = [f]), and g() (stack = [f, g]). Only then times of g()
    # may checked for matching times to possibly add 'unknown'.

    # to start at longet stacks, sort them into list of lists, for example:
    # [0] = [stack_1_OfLen_1, stack_2_OfLen_1, stack_3_OfLen_1, ...]  # len = 1
    # [1] = [ [23, 34]      ,  [45, 67]      , [78, 89], ...] # len = 2
    #  .
    #  .
    stacksByLen = []
    for stack in frames:
        while len(stacksByLen) < len(stack):
            stacksByLen.append(list())
        stacksByLen[len(stack) - 1].append(stack)

    # Traverse stacks and add stacks with 'unknown' if needed.
    # longest stacks first, so that 'unknown' added at top levels will
    # propagate to lower levels
    for stackList in reversed(stacksByLen):
        for stack in stackList:
            frameTimes = frames[stack]
            calledNetTime = frameTimes[CALLED_NET_TIME]
            grossTime = frameTimes[GROSS_TIME]

            if calledNetTime < grossTime:
                _addUnknownFunction(frames, stack, grossTime - calledNetTime)
                _addNetTimeToCallers(frames, stack, grossTime - calledNetTime)


def readStackFrames(profilerData, ignoredAreaIds, areas, graphContext, maxStackDepth):
    """
    Takes profiler timeline as input, creates list of stack frames. Each stack
    frame contains a list of function names. Times are added on the fly
    to minimize memory usage.

    Events in profiler XML:
    - E - enter function, provides function start time
    - S - suspend, other function is called
    - R - resume, other function returned
    - X - exit function, provides function end time

    Possible combinations:
    - E -> S, X
    - S -> E (called function), R (when function called is not analyzed)
    - R -> S, X
    - X -> E

    It is possible that timeline does not start with E and does not end with
    X, since recording can start/stop at any time during program flow.

    Data structure:
    {
     #    key           : value
      ['f1', 'f2', 'f3']: {E_TIME: 1234, R_TIME: 1234, netTime: 0, grossTime: 0}
     ...
    }

    On event:
    - 'E': E_TIME = time, R_TIME = time
    - 'S': netTime += time - R_TIME
    - 'R': R_TIME = time
    - 'X': netTime += time - R_TIME,  grossTime += time - E_TIME
    """

    print('Reading timeline events ...')
    frames = {}
    currentStack = []
    timeIter = profilerData.getTimelineIterator()
    eventCounter = 0
    activeIgnoredAreas = set() # stores interrupt f. and f. called form them
    inconsistentAreasOnStack = set()
    inconsistentAreasWUnexpectedExit = set()
    recordingStartTime = None
    endTime = 0
    prevEvType = None

    while timeIter.hasNext():
        timeEvent = timeIter.next()
        evAreaId = timeEvent.getAreaId()
        eventContext = timeEvent.getValue()

        _logStep(eventCounter, currentStack, frames)
        _progress.set(eventCounter * _eventSize / _binFileSize * MAX_PROGRESS)
        if _isTerminate.get() > 0:
            _log(LOG_ERR,
                 ("Reading of timeline canceled by user at event {}/{}\n" +
                  "Wait until events read so far are processed ...")
                 .format(eventCounter, _binFileSize // _eventSize))
            break

        eventCounter += 1

        # ignore other contexts if specified
        if graphContext != CTX_NOT_SPECIFIED and eventContext != graphContext:
            continue

        # ignore non-function areas
        if not evAreaId in areas:
            continue

        evType = timeEvent.getEventType()
        evTime = timeEvent.getTime()
        endTime = evTime

        if recordingStartTime == None:  # remember start of recording
            recordingStartTime = evTime

        if _isIgnoredArea(evAreaId, evType, ignoredAreaIds, activeIgnoredAreas):
            continue

        # if 'maxStackDepth' is not set explicitly by the user to high value,
        if maxStackDepth <= MAX_STACK_DEPTH:
            # verify stack size to avoid unnecessary lenghty parsing
            if len(currentStack) > MAX_STACK_DEPTH:
                raise Exception("Max stack depth reached! Check recording or set " +
                                "parameter --depth above limit " + str(MAX_STACK_DEPTH))

        if evType == ic.CProfilerTimeEvent.EEvEnter:
            currentStack.append(evAreaId)
            # stack (array of funcs on stack) is used as a key in mapping
            currentStackTuple = tuple(currentStack)
            frameTimes = frames.setdefault(currentStackTuple, [0, 0, 0, 0, 0])
            frameTimes[E_TIME] = evTime
            frameTimes[R_TIME] = evTime

        elif (evType == ic.CProfilerTimeEvent.EEvSuspend and
              # Ignore Suspend events ocurring immediately after Exit
              # event.  They appear because of hack in profiler, which
              # adds redundant Suspend event after eXit event to
              # indicate recursive calls to renderer. See mail
              # 'double suspend in case of recursive function', 2018-05-07.
              prevEvType != ic.CProfilerTimeEvent.EEvExit):

            if not currentStack: # function was already running when recording started
                frames, currentStackTuple, currentStack = _prependFunction(frames,
                                                                           evAreaId,
                                                                           recordingStartTime)
            frameTimes = frames.get(currentStackTuple)

            # it may happen that some functions resume execution during
            # recording, for example ISRs. Ignore such cases.
            if frameTimes is not None:
                frameTimes[NET_TIME] += evTime - frameTimes[R_TIME]
            else:
                _log(LOG_WRN, 'S without E. Time, areaId = {} {}'.format(evTime, hex(evAreaId)))


        elif evType == ic.CProfilerTimeEvent.EEvResume:
            if not currentStack: # function was already running when recording started
                frames, currentStackTuple, currentStack  = _prependFunction(frames,
                                                                            evAreaId,
                                                                            recordingStartTime)

            frameTimes = frames.get(currentStackTuple)

            if frameTimes is not None:
                frameTimes[R_TIME] = evTime
            else:
                _log(LOG_WRN, 'R without E. Time, areaId = {} {}'.format(evTime, hex(evAreaId)))

        elif evType == ic.CProfilerTimeEvent.EEvExit:
            if not currentStack: # function was already running when recording started
                frames, currentStackTuple, currentStack  = _prependFunction(frames,
                                                                            evAreaId,
                                                                            recordingStartTime)

            frameTimes = frames.get(currentStackTuple)

            if frameTimes is not None:
                frameTimes[NET_TIME] += evTime - frameTimes[R_TIME]
                frameTimes[GROSS_TIME] += evTime - frameTimes[E_TIME]

                areaIdOnStack = currentStack.pop()
                currentStackTuple = tuple(currentStack)

                _checkForConsistency(areaIdOnStack, evAreaId, inconsistentAreasOnStack,
                                     inconsistentAreasWUnexpectedExit, areas, eventContext)
            else:
                _log(LOG_WRN, 'R without E. Time, areaId = {} {}'.format(evTime, hex(evAreaId)))

        prevEvType = evType
        # ignore other event types - eg. we are not interested in mem writes

    # Functions, which are still on stack did not end when recording stopped.
    # Extend their duration to the end of recording.
    for idx in range(len(currentStack), 0, -1):
        currentStackTuple = tuple(currentStack[:idx])
        frameTimes = frames.get(currentStackTuple)
        if LOG_LEVEL <= LOG_INFO:
            print('F. without exit at end of recording: ', currentStackTuple, frameTimes)

        if frameTimes is not None:
            frameTimes[GROSS_TIME] += endTime - frameTimes[E_TIME]
            if idx == len(currentStack):  # only the topmost f. is active, others are suspended
                frameTimes[NET_TIME] += endTime - frameTimes[R_TIME]

    _log(LOG_INFO, '\nNumber of different stack frames = {}'.format(len(frames)))

    _printInconsistencies(areas, inconsistentAreasOnStack, inconsistentAreasWUnexpectedExit)

    return frames


def _createDemoStackTrace():
    # This f. is used to create demo image for help, uncomment call below
    return {('f',): [0, 0, 2, 10],
            ('f', 'a'): [0, 0, 1, 3],
            ('f', 'a', 'g'): [0, 0, 2, 2],
            ('f', 'b'): [0, 0, 2, 5],
            ('f', 'b', 'g'): [0, 0, 1, 1],
            ('f', 'b', 'h'): [0, 0, 2, 2],
           }

def _replaceIdsWithFuncNames(areas, frames):

    _log(LOG_INFO, 'Replacing IDs with function names ...')
    framesWFuncNames = {}
    maxStackDepth = 0
    allStackDepths = 0
    minNetTime = 10000000000    # 1e9 ns = 1s

    # this loop deletes items as they are being passed to another mapping,
    # so that we do not duplicate memory usage.
    while frames:
        counter = 0
        framesToDelete = []

        for frame, frameTimes in frames.items():

            # get some statistics, may be useful to user for limiting
            # graphs with args 'minTime' and 'depth'.
            stackDepth = len(frame)
            allStackDepths += stackDepth
            if stackDepth > maxStackDepth:
                maxStackDepth = stackDepth

            if frameTimes[NET_TIME] < minNetTime:
                minNetTime = frameTimes[NET_TIME]

            funcNamesList = []
            for funcId in frame:
                funcName = areas.get(funcId)
                funcNamesList.append(funcName)

            framesWFuncNames[tuple(funcNamesList)] = frameTimes

            framesToDelete.append(frame)
            counter += 1
            if counter > 1000:
                break

        for frame in framesToDelete:
            del frames[frame]   # free memory, important for large files

    if framesWFuncNames: # avoid division by 0
        _log(LOG_INFO, '    Average stack depth = {}'.format(allStackDepths/len(framesWFuncNames)))
    _log(LOG_INFO, '    Max stack depth = {}'.format(maxStackDepth))
    _log(LOG_INFO, '    Min net time = {}'.format(minNetTime))

    return framesWFuncNames


def _getIgnoredAreas(areas, ignoredFunctions):

    ignoredAreaIds = set()
    ifNamesSet = set(ignoredFunctions.split(','))

    for areaId, areaName in areas.items():
        if areaName in ifNamesSet:
            ignoredAreaIds.add(areaId)

    return ignoredAreaIds


def analyzeProfilerXMLForGraph(profilerExportFile, isBinaryTimeline,
                               ignoredFunctions, graphContext, maxStackDepth):
    global _binFileSize, _eventSize

    """
    Example of output from this function:
    {('f_L0_a',):                    [49970463, 51313699, 881, 1343982],
     ('f_L0_a', 'f_L1_a'):           [49970535, 51295690, 1817, 1326655],
     ('f_L0_a', 'f_L1_a', 'f_L2_a'): [50864130,
                                      51295436,
                                      3879,
                                      1296654],
     ('f_L0_a', 'f_L1_a', 'f_L2_a', 'funcStubNested'): [51290967,
                                                        51294222,
                                                        4663,
                                                        13636],

      Items 0 and 1 in times list may be ignored - they are abs times
      used during processing. Items 3,4 are netTime, grossTime.
    """

    profilerData = ic.CProfilerData2.createInstance(profilerExportFile,
                                                    isBinaryTimeline)
    try:
        # always check for parser warnings
        warnings = profilerData.getParserWarnings()
        if warnings:
            _log(LOG_WRN, 'XML parser warning(s): {}'.format(warnings))

        if isBinaryTimeline:
            _binFileSize = profilerData.getBinTimelineFileSize()
            _eventSize = profilerData.getBinTimelineEventSize()

        areas, _ = readAreasAndFuncStats(profilerData)
        areas[UNKNOWN_FUNCTION_ID] = UNKNOWN_FUNCTION_NAME
        ignoredAreaIDs = _getIgnoredAreas(areas, ignoredFunctions)
        frames = readStackFrames(profilerData, ignoredAreaIDs, areas, graphContext,
                                 maxStackDepth)
        _adjustForUnknownFunctions(frames)

    finally:
        profilerData.closeParser()  # releases memory and closes XML file

    frames = _replaceIdsWithFuncNames(areas, frames)
    # frames = _createDemoStackTrace() # uncomment for demo image

    # when running from winIDEA there is no stdout
    if LOG_LEVEL <= LOG_INFO  and  sys.stdout != None:
        pprint.pprint(frames)

    return frames


def _writeHeader(outf, width, height, titleText):
    #     width="700pt"
    #     height="332pt"
    #      viewBox="0.00 0.00 700 332.00"
    outf.write("""<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1"
     baseProfile="full"
         width="{w}"
         height="{h}"
         preserveAspectRatio="none"
         viewBox="0.00 0.00 {w} {h}"
         onload="initVars(evt)"
     xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink">
    """.format(w=width, h=height))

    outf.write("""
    <style type="text/css">
        .fBox { font-family: "Arial";}
    </style>
    """)

    jscript = JAVASCRIPT_CODE.replace('${rectAllFuncsId}', RECT_ALL_FUNCTIONS_ID)
    jscript = jscript.replace('${textRightMargin}', str(TEXT_RIGHT_MARGIN))
    jscript = jscript.replace('${textLeftMargin}', str(TEXT_LEFT_MARGIN))
    jscript = jscript.replace('${searchTimeText}', str(SEARCH_TIME_TXT_ID))
    jscript = jscript.replace('${searchColor}', SEARCH_COLOR)

    outf.write(jscript)

    # Buttons for prev/next/reset zoom
    outf.write("""
    <g class = 'zoomBtn' onclick='resetZoom(this)' onmousedown='setOpacity(this, 0.6)' onmouseup='setOpacity(this, 1)'>
        <rect x='{xr1}' y='{yr}' rx = '3' width='{w}' height='{h}' fill='#c0c0c0'/>
        <text x='{xt1}' y='{yt}' font-size="11" font-family="Verdana"
               fill="rgb(0,0,0)" style="cursor:pointer; text-anchor: middle">1:1</text>
        <title>Reset zoom</title>
    </g>
    <g class = 'zoomBtn' onclick='previousZoom(this)' onmousedown='setOpacity(this, 0.6)' onmouseup='setOpacity(this, 1)'>
        <rect x='{xr2}' y='{yr}' rx = '3' width='{w}' height='{h}' fill='#c0c0c0'/>
        <text x='{xt2}' y='{yt}' font-size="11" font-family="Verdana"
               fill="rgb(0,0,0)" style="cursor:pointer; text-anchor: middle">&lt;</text>
        <title>Previous zoom</title>
    </g>
    <g class = 'zoomBtn' onclick='nextZoom(this)' onmousedown='setOpacity(this, 0.6)' onmouseup='setOpacity(this, 1)'>
        <rect x='{xr3}' y='{yr}' rx = '3' width='{w}' height='{h}' fill='#c0c0c0'/>
        <text x='{xt3}' y='{yt}' font-size="11" font-family="Verdana"
               fill="rgb(0,0,0)" style="cursor:pointer; text-anchor: middle">&gt;</text>
        <title>Next zoom</title>
    </g>
    <g class = 'searchBtn' onclick='searchDialog()' onmousedown='setOpacity(this, 0.6)' onmouseup='setOpacity(this, 1)'>
        <rect x='{xr4}' y='{yr}' rx = '3' width='{wsearch}' height='{h}' fill='#c0c0c0'/>
        <text x='{xt4}' y='{yt}' font-size="11" font-family="Verdana"
               fill="rgb(0,0,0)" style="cursor:pointer; text-anchor: middle">Find</text>
        <title>Search functions</title>
    </g>
    <g class = 'searchBtn' onclick='clearSearchResults()' onmousedown='setOpacity(this, 0.6)' onmouseup='setOpacity(this, 1)'>
        <rect x='{xrClr}' y='{yr}' rx = '3' width='{wsearch}' height='{h}' fill='#c0c0c0'/>
        <text x='{xtClr}' y='{yt}' font-size="11" font-family="Verdana"
               fill="rgb(0,0,0)" style="cursor:pointer; text-anchor: middle">Clear</text>
        <title>Clear find results</title>
    </g>
    <g>
        <text x='{xtTime}' y='{yt}' font-size="11" font-family="Verdana" fill="#000000" id="{sTT}"></text>
        <title>Shows sum of gross times of all selected functions.</title>
    </g>
    \n\n""".format(xr1 = 10,
                   xt1 = 10 + SMALL_BTN_W / 2,

                   xr2 = 12 + SMALL_BTN_W,
                   xt2 = 12 + SMALL_BTN_W + SMALL_BTN_W / 2,

                   xr3 = 14 + SMALL_BTN_W * 2,
                   xt3 = 14 + SMALL_BTN_W * 2 + SMALL_BTN_W / 2,

                   xr4 = 22 + SMALL_BTN_W * 3,
                   xt4 = 22 + SMALL_BTN_W * 3 + SEARCH_BTN_W / 2,

                   xrClr = 24 + SMALL_BTN_W * 3 + SEARCH_BTN_W,
                   xtClr = 24 + SMALL_BTN_W * 3 + SEARCH_BTN_W * 3 / 2,

                   xtTime = 28 + SMALL_BTN_W * 3 + SEARCH_BTN_W * 2,

                   yr = 2,
                   yt = RECT_HEIGHT - RECT_HEIGHT / 5, w = SMALL_BTN_W, h = RECT_HEIGHT,
                   wsearch = SEARCH_BTN_W,
                   sTT = SEARCH_TIME_TXT_ID))

    outf.write("""
        <text x='{titleX}' y='{titleY}' font-size="16" font-family="Verdana" fill="#000000" style="font-weight: bold; text-anchor: middle">{titleText}</text>
    \n\n""".format(titleX=width/2, titleY=20, titleText=titleText))


def _writeWhiteRect(outf, x, y, w, h):
    outf.write('    <rect class="wrect" x="{x:.5}" xo="{x:.5}" y="{y}" width="{w}" wo = "{w}" height="{h}" fill="#ffffff"/>\n'
               .format(x=x, y=y, w=w, h=h))


def _writeRect(outf, x, y, w, h, fill, textRect, textFull, timeNs, gid=''):

    if gid:
        gid = ' id="{}"'.format(gid)

    # 'xo' and 'wo' are original values, because 'x' and 'w' get overwritten on
    # zoom operations. For mouse over indication an alternative to functions
    # is css style: .fBox:hover { stroke:black; stroke-width: 1; }
    # but then text is made very bold. If style is applied to rect only, then
    # it is not active when mouse is over text. If style 'pointer-events:none' is
    # specified for text, then it is not selectable and user can not copy it to clipboard.
    outf.write("""    <g class='fBox' onclick="zoom(this)" onmouseover="mi(this)" onmouseout="mo(this)"{gid}>
        <rect x="{x:.7}" xo="{x:.7}" y="{y}" width="{w}" wo="{w}" timeMs='{timeMs}' height="{h}" rx="2" fill="#{fill}"/>
""".format(x=x, y=y, w=w, h=h-RECT_HEIGHT/10, fill=fill, timeMs=timeNs/1000, gid=gid))

    outf.write("""        <text x="{x:.7}" y="{y}" font-size="{fs}" fill="black">{txt}</text>
    """.format(x=x+TEXT_LEFT_MARGIN, y=int(y + h*3/4),
               fs=int(h/2), txt=textRect))

    outf.write("    <title>{}</title>\n    </g>\n\n".format(textFull))


def _writeEnd(outf, width, height):
    # image frame
    outf.write("""<rect x ='0' y = '0' width = '{}' height = '{}' fill-opacity='0.0' style='stroke: #808080; pointer-events:none'/>
    \n\n""".format(width, height))

    outf.write('</svg>')


def _getHashColorIdx(funcName, colorMapSize):
    return int(hashlib.md5(funcName.encode('UTF-8')).hexdigest()[:8], 16) % colorMapSize


def _getColorIdx(funcName, colorIdx, colorMap, stackDepth, maxStackDepth,
                 algorithm):

    if algorithm == ColorMapIdxAlgorithm.INC:
        # Next rectangle gets next color from map. Color is not related
        # to depth level.
        colorIdx += 1
        if colorIdx >= len(colorMap):
            colorIdx = 0

    elif algorithm == ColorMapIdxAlgorithm.DEPTH:
        # Color is related to stack depth level - greater depth, greater color
        # index.
        colorIdx = int((len(colorMap) - 1) / maxStackDepth * stackDepth)

    elif algorithm == ColorMapIdxAlgorithm.CYCLE:
        # Color is related to stack depth level, but colors are cycled.
        colorIdx = (stackDepth - 1) % len(colorMap)
    elif algorithm == ColorMapIdxAlgorithm.HASH:
        # Color is related function name hash value.
        colorIdx = _getHashColorIdx(funcName, len(colorMap))
    else:
        raise Exception('Unknown color map index algorithm: ' + str(algorithm))

    return colorIdx


def _getRectColor(regex, funcName, colorIdx, colorMap, stackDepth, maxStackDepth,
                  colorMapIdxAlg):

    # Always calculate color index, so that it is updated also if regex
    # matches. This way colors do not shift in case of matches.
    colorIdx = _getColorIdx(funcName, colorIdx, colorMap, stackDepth,
                           maxStackDepth, colorMapIdxAlg)

    if regex  and  regex.match(funcName):
        rectColor = SEARCH_COLOR
    else:
        rectColor = colorMap[colorIdx]

    return rectColor, colorIdx


def _getTotalTime(flameData):

    totalTime = 0
    for key in flameData:
        if len(key) == 1:
            totalTime += flameData[key][GROSS_TIME]

    return totalTime


def _getDesc(funcName, frameTimes):
    return "{} ({} us / {} us, {:.4}%)".format(funcName,
                                               frameTimes[NET_TIME] / 1000,
                                               frameTimes[GROSS_TIME] / 1000,
                                               frameTimes[NET_TIME] / frameTimes[GROSS_TIME] * 100)


def _isWriteWhiteRect(currentFrameIdx, sortedKeys):
    # If there is an empty rectangle after the current one,
    # then draw white rect to delete long function names from previous columns.
    # This way the current function name will be visible even if it is
    # longer than rectangle, and will not overlap with previous functions.
    # Returns true, if white rectangle must be drawn.

    currentFrame = sortedKeys[currentFrameIdx]
    topFunction = currentFrame[-1]
    topFunctionIdx = len(currentFrame) - 1

    for frameIdx in range(currentFrameIdx + 1, len(sortedKeys)):

        if len(currentFrame) > len(sortedKeys[frameIdx]):
            break

        # white rectangle is not needed only when the next stack
        # frame contains other function at the same stack depth
        if topFunction != sortedKeys[frameIdx][topFunctionIdx]:
            return False

    return True


def _flameDataToSVG(flameData, minTime, depth, findRegEx, outFileName,
                    titleText, colorMap, colorMapStep, colorMapIdxAlg):

    _log(LOG_INFO, 'Writing svg file ...')

    minTime = float(minTime)
    stackDepthLimit = int(depth)
    totalTimeNs = _getTotalTime(flameData)
    if totalTimeNs == 0: # not possible to show, make it minimal
        totalTimeNs = MIN_FUNC_DURATION_NS

    sortedKeys = sorted(flameData)
    maxStackDepth = 0
    for key in sortedKeys:
        maxStackDepth = max(maxStackDepth, len(key))

    maxStackDepth = min(stackDepthLimit, maxStackDepth)
    imageHeight = RECT_HEIGHT * (maxStackDepth + 3)
    timeScale = GRAPH_WIDTH / totalTimeNs
    regex = re.compile(findRegEx) if findRegEx else None

    with open(outFileName, 'wt') as outf:

        _writeHeader(outf, FULL_W, imageHeight,
                     titleText)

        x = 0.0
        colorIdx = -1  # means not initialized
        colorMap = _createColorMap(colorMap, int(colorMapStep))

        if LOG_LEVEL <= LOG_INFO  and  sys.stdout != None:
            pprint.pprint(colorMap)

        # add rectangle covering all stack frames - contains full time and is
        # used in zooming functionality
        baseDesc = 'all ({}us)'.format(totalTimeNs / 1000)
        _writeRect(outf, x, imageHeight - RECT_HEIGHT, GRAPH_WIDTH, RECT_HEIGHT,
                   'ffffff', baseDesc, baseDesc, totalTimeNs, RECT_ALL_FUNCTIONS_ID)

        for keyIdx, key in enumerate(sortedKeys):

            frameTime = flameData[key]
            stackDepth = len(key)

            if stackDepth > 0 and stackDepth <= stackDepthLimit and frameTime[GROSS_TIME] > minTime:

                funcName = key[stackDepth - 1]
                rectColor, colorIdx = _getRectColor(regex, funcName, colorIdx,
                                                    colorMap, stackDepth, maxStackDepth,
                                                    colorMapIdxAlg)

                isWriteWhiteRect = _isWriteWhiteRect(keyIdx, sortedKeys)
                rectWidth = frameTime[GROSS_TIME] * timeScale
                if isWriteWhiteRect:
                    # print('-------White:', key[stackDepth - 1])
                    _writeWhiteRect(outf,
                                    x = x * timeScale + rectWidth,
                                    y = imageHeight - (stackDepth + 1) * RECT_HEIGHT - 1,
                                    w = FULL_W - x * timeScale - rectWidth,
                                    h = RECT_HEIGHT)

                _writeRect(outf,
                           x = x * timeScale,
                           y = imageHeight - (stackDepth + 1) * RECT_HEIGHT,
                           w = rectWidth,
                           h = RECT_HEIGHT,
                           fill = rectColor,
                           textRect = "{} ({}us)".format(key[stackDepth - 1],
                                                         frameTime[GROSS_TIME]/1000),
                           textFull = _getDesc(funcName, frameTime),
                           timeNs = frameTime[GROSS_TIME])

            x += frameTime[NET_TIME]

        _writeEnd(outf, FULL_W, imageHeight)


def _printStacks(flameData):

    sortedKeys = sorted(flameData)

    print('\nStack                              |  Net time [ms]  |  Gross time [ms]  |  Called net time [ms]')
    print('--------------------------------------------------------------------------------------------------')
    for key in sortedKeys:
        times = flameData[key]
        print(key, ", ", times[NET_TIME] / 1e6, ", ", times[GROSS_TIME] / 1e6, ", ", times[CALLED_NET_TIME]/1e6, sep='')


def _parseArgs(cmdLineArgs):
    opts = diagutils.parseArgs(cmdLineArgs,
        [('-d',
          '--depth',
          'depth',
          MAX_STACK_DEPTH,
          'defines max number of calls on call stack to be shown.'),

         ('-m',
          '--colorMap',
          'colorMap',
          'flame',
          'defines color map: flame, flameWInverse, water, grass, rainbow.'),

         ('-s',
          '--colorMapStep',
          'colorMapStep',
          50,
          'defines how fast colors in color map change. Should be in range 1..100.'),

         ('-a',
          '--colorMapIdxAlg',
          'colorMapIdxAlg',
          'inc',
          'defines algorithm for color map index: inc, depth, cycle, hash.\n' +
          "'inc' - color map index is incremented for next function. " +
          "'depth' - color index increases with stack depth. " +
          "'cycle' - color index increments with stack depth, if there are less " +
                    "colors than stack depth it starts again from 0. " +
          "'hash' - color index is calculated from function hash."),

         ('-t',
          '--title',
          'titleText',
          '',
          'defines graph title.'),

         ('-p',
          '--printStacks',
          'isPrintStacks',
          False,
          'if specified, stack frames with net and gross times are printed to stdout.'),

         ('-n',
          '--mint',
          'minTime',
          '0',
          'if specified, then all frames shorter than this time are not shown.'),

         ('-o',
          '--open',
          'isOpenInSystemViewer',
          False,
          'if present, then generated diagram is opened in OS default viwer.'),

         ('-f',
          '--find',
          'findRegEx',
          '',
          'functions which names match regex will be shown in green color. ' +
          'Regular expression does not need to match complete function name, but ' +
          "only start of it. For example, 'max' will match both 'maxInt' and 'maxFloat'. " +
          "Use '$' to match complete func. name, eg. 'max$'. " +
          "Use operator '|' to match more than one function, eg. 'max|min'. " +
          "Use '.*' to match string in the middle, eg. '.*Color' will match both " +
          "'getColor' and 'setColor'."),

         ('-i',
          '--ignore',
          'ignoredFunctions',
          '',
          'if specified, then the list of given comma-separated function names is used to '
          'ignore timeline events for these functions, and function called by them. '
          ' Use this option to exclude '
          'interrupt functions, because they corrupt stack traces. Do not use spaces '
          'in the list. Example: -i adcISR,canISR'),

         ('-c',
          '--context',
          'context',
          '',
          'if specified, then only functions from this context are shown in ' +
          'flamegraph. It is a must when more than one context exists, otherwise ' +
          'flamegraph will be invalid. ' +
          'Example: -c mainTask'),
        ])

    if not opts.profExport:
        raise Exception("Profiler XML export file name missing in command line " +
                        "aruments ('--profExport')!")

    return opts


def analyze(context, profExportFName, isBinaryTimeline, ignoredFuncs,
            isPrintStacks, maxStackDepth):

    _progress.set(0)

    # print('ctx =======', context, profExportFName, isBinaryTimeline, ignoredFuncs,            isPrintStacks, maxStackDepth)
    graphContext = CTX_NOT_SPECIFIED
    if context:
        graphContext = int(context)

    flameData = analyzeProfilerXMLForGraph(profExportFName,
                                           isBinaryTimeline,
                                           ignoredFuncs,
                                           graphContext,
                                           maxStackDepth)
    if isPrintStacks:
        _printStacks(flameData)

    return flameData


def createGraph(flameData, outFName, isOpenInSystemViewer, minTime, depth, findRegEx,
                titleText, colorMap, colorMapStep, colorMapIdxAlg):


    _flameDataToSVG(flameData, minTime, depth, findRegEx, outFName,
                    titleText, colorMap, colorMapStep, colorMapIdxAlg)

    if isOpenInSystemViewer:
        webbrowser.open_new_tab(outFName)

    print('    Done!')


def getProgress():
    return _progress.get()


def terminate():
    _isTerminate.set(1)


def getLogMsg():

    if not _logQueue.empty():
        try:
            return _logQueue.get(False)
        except:
            pass  # according to doc, empty() == True does not guarantee
                  # get() won't block.

    return None


def _main(cmdLineArgs):
    opts = _parseArgs(cmdLineArgs)

    flameData = analyze(opts.context, opts.profExport, opts.isBinaryTimeline,
                        opts.ignoredFunctions, opts.isPrintStacks,
                        opts.depth)

    createGraph(flameData, opts.outFileName, opts.isOpenInSystemViewer,
                opts.minTime, opts.depth, opts.findRegEx,
                opts.titleText, opts.colorMap, opts.colorMapStep,
                opts.colorMapIdxAlg)


if __name__ == '__main__':
    _main(sys.argv[1:])
