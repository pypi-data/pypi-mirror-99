# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _connect
else:
    import _connect

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _connect.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _connect.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _connect.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _connect.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _connect.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _connect.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _connect.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _connect.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _connect.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _connect.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _connect.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _connect.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _connect.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _connect.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _connect.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _connect.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _connect:
_connect.SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _connect.SHARED_PTR_DISOWN
class ucharArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _connect.ucharArray_swiginit(self, _connect.new_ucharArray(nelements))
    __swig_destroy__ = _connect.delete_ucharArray

    def __getitem__(self, index: "size_t") -> "unsigned char":
        return _connect.ucharArray___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "unsigned char") -> "void":
        return _connect.ucharArray___setitem__(self, index, value)

    def cast(self) -> "unsigned char *":
        return _connect.ucharArray_cast(self)

    @staticmethod
    def frompointer(t: "unsigned char *") -> "ucharArray *":
        return _connect.ucharArray_frompointer(t)

# Register ucharArray in _connect:
_connect.ucharArray_swigregister(ucharArray)

def ucharArray_frompointer(t: "unsigned char *") -> "ucharArray *":
    return _connect.ucharArray_frompointer(t)

WINVER = _connect.WINVER
class CConnectionConfig(object):
    r"""
    This class contains information for connection to winIDEA. Its methods
    return reference to self, so we can use it like this:

    CConnectionConfig config = new CConnectionConfig();
    config.udpDiscoveryPort(5534).instanceId("main");


    All parameters are optional. Set only what is required, default values are
    used for unspecified parameters.



    Python example: advancedWinIDEALaunching.py  
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CConnectionConfig_swiginit(self, _connect.new_CConnectionConfig())

    def workspace(self, workspace: "std::string const &") -> "isys::CConnectionConfig &":
        r"""
         Sets winIDEA workspace. If not empty string, this value is
        compared on searching, and used when starting a new winIDEA instance.
        """
        return _connect.CConnectionConfig_workspace(self, workspace)

    def udpDiscoveryPort(self, udpDiscoveryPort: "int") -> "isys::CConnectionConfig &":
        r""" Sets UDP discovery port."""
        return _connect.CConnectionConfig_udpDiscoveryPort(self, udpDiscoveryPort)

    def instanceId(self, instanceId: "std::string const &") -> "isys::CConnectionConfig &":
        r"""
         Sets winIDEA instance ID. If not empty string, this value is
        compared on searching, and used when starting a new winIDEA instance.
        """
        return _connect.CConnectionConfig_instanceId(self, instanceId)

    def cmdLineParams(self, cmdLineParams: "std::string const &") -> "isys::CConnectionConfig &":
        r"""
         If new instance is started, this command line is used in addition to
        specified ``workspace`` and ``instanceId``.
        """
        return _connect.CConnectionConfig_cmdLineParams(self, cmdLineParams)

    def waitTime(self, waitTime: "IConnect::ELaunchFlags") -> "isys::CConnectionConfig &":
        r"""
        Determines how long the ``isystem.connect`` should wait for running
        instances to respond. Only one of ``lfWaitXXX`` flags from IConnect::ELaunchFlags
        may be specified.
        """
        return _connect.CConnectionConfig_waitTime(self, waitTime)

    def useIPCDiscovery(self, isUseIPCDiscovery: "bool") -> "isys::CConnectionConfig &":
        r"""
         Locally running winIDEA instances will be discovered using local
        IPC discovery. By default this setting is set to true.
        """
        return _connect.CConnectionConfig_useIPCDiscovery(self, isUseIPCDiscovery)

    def visibility(self, visibility: "IConnect::ELaunchFlags") -> "isys::CConnectionConfig &":
        r"""
        Determines how the newly launched instance will start. Only one
        of ``lfShowXXX`` flags from IConnect::ELaunchFlags
        may be specified.
        """
        return _connect.CConnectionConfig_visibility(self, visibility)

    def processId(self, pid: "DWORD") -> "isys::CConnectionConfig &":
        return _connect.CConnectionConfig_processId(self, pid)

    def processTCPPort(self, wTCPPort: "WORD") -> "isys::CConnectionConfig &":
        return _connect.CConnectionConfig_processTCPPort(self, wTCPPort)

    def getWorkspace(self) -> "std::string const &":
        r""" Returns workspace path."""
        return _connect.CConnectionConfig_getWorkspace(self)

    def getUdpDiscoveryPort(self) -> "int":
        r""" Returns UDP discovery port."""
        return _connect.CConnectionConfig_getUdpDiscoveryPort(self)

    def getInstanceId(self) -> "std::string const &":
        r""" Returns instanceId."""
        return _connect.CConnectionConfig_getInstanceId(self)

    def getCmdLineParams(self) -> "std::string const &":
        r""" Returns command line parameters."""
        return _connect.CConnectionConfig_getCmdLineParams(self)

    def getWaitTime(self) -> "IConnect::ELaunchFlags":
        r""" Returns wait time."""
        return _connect.CConnectionConfig_getWaitTime(self)

    def isUseIPCDiscovery(self) -> "bool":
        r""" Returns true, if IPC discovery should be used."""
        return _connect.CConnectionConfig_isUseIPCDiscovery(self)

    def getVisibility(self) -> "IConnect::ELaunchFlags":
        r""" Returns winIDEA window visibility after startup."""
        return _connect.CConnectionConfig_getVisibility(self)

    def getProcessId(self) -> "DWORD":
        r"""
        Returns process id. The id is set after call to findExistingInstance(),
        startNewInstance(), or findOrStartInstance(). It is valid only when
        different from 0.
        """
        return _connect.CConnectionConfig_getProcessId(self)

    def getTCPPort(self) -> "WORD":
        r"""
        Returns TCP port. The port is set after call to findExistingInstance(),
        startNewInstance(), or findOrStartInstance(). It is valid only when
        different from 0.
        """
        return _connect.CConnectionConfig_getTCPPort(self)

    def toString(self) -> "std::string":
        return _connect.CConnectionConfig_toString(self)
    __swig_destroy__ = _connect.delete_CConnectionConfig

# Register CConnectionConfig in _connect:
_connect.CConnectionConfig_swigregister(CConnectionConfig)

class WinIDEAInstanceInfo(object):
    r"""This class contains information about instance of winIDEA as returned by enumeration."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.WinIDEAInstanceInfo_swiginit(self, _connect.new_WinIDEAInstanceInfo(*args))

    def getWorkspace(self) -> "std::string":
        r""" Returns workspace path."""
        return _connect.WinIDEAInstanceInfo_getWorkspace(self)

    def getInstanceId(self) -> "std::string":
        r""" Returns instanceId."""
        return _connect.WinIDEAInstanceInfo_getInstanceId(self)

    def getTcpPort(self) -> "int":
        r""" Returns TCP port."""
        return _connect.WinIDEAInstanceInfo_getTcpPort(self)
    __swig_destroy__ = _connect.delete_WinIDEAInstanceInfo

# Register WinIDEAInstanceInfo in _connect:
_connect.WinIDEAInstanceInfo_swigregister(WinIDEAInstanceInfo)

class ConnectionMgr(object):
    r"""
    This class manages connection to winIDEA.


    Python example: debugIdeTraceProfilerCoverageSample.py  

    Python example: advancedWinIDEALaunching.py 

    Python example enumerates winIDEA instances: showConnectionStatus.py  

    Python example connects to enumerated winIDEA instances: winIDEAInstanceEnumeration.py  
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EVersionIgnore = _connect.ConnectionMgr_EVersionIgnore
    r""" version is not verified"""
    EVersionWarning = _connect.ConnectionMgr_EVersionWarning
    r"""
    version is verified and warning written if winIDEA is
    different version than SDK
    """
    EVersionError = _connect.ConnectionMgr_EVersionError
    r"""
    version is verified and exception thrown if winIDEA is
    different version than SDK
    """

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Constructs the object, and creates IConnect client. The most recently
        used ``isystem.connect`` DLL is used.
        Use one of connection methods to establish connection to winIDEA.
        If this ctor is used, version of winIDEA is verified on connect, and warning
        written to stdout if it does not match *isystem.connect* SDK version.

        |

        *Overload 2:*

        Deprecated: version control is always strict since 9.17.187. Use the
        parameterless constructor instead of this one.

        Constructs the object, and creates IConnect client. The most recently
        used ``isystem.connect`` DLL is used.
        Use one of connection methods to establish connection to winIDEA.

        :type versionControl: int
        :param versionControl: ignored

        |

        *Overload 3:*

        Constructs the object, and creates IConnect client. The specified
        iConnect.dll is used to connect to winIDEA.
        Use one of connection methods to establish connection to winIDEA.

        :type iconnectDllPath: string
        :param iconnectDllPath: The path to iConnect.DLL to be used. If this
            parameter is empty string, standard windows DLL search mechanism will be used.
            You can use this parameter if multiple versions of winIDEA are
            installed on a system and you want to control which version of the DLL
            is used. It should match the version of winIDEA you want to connect to.
            Example value: 'C:/winIDEA/2010/iConnect.dll'

        Python example: connectToWinIDEAVersion.py  


        |

        *Overload 4:*

        Constructs the object, but does not make any calls to winIDEA. If pIConnectClient
        is not connected to winIDEA, call method connectMRU() before creating
        instances of controller classes. This method is intended to be used from
        Python avoiding PyCObject and therefore Python dependencies.

        :type pIConnectClient: int
        :param pIConnectClient: must be of type (CIConnectClientEclipse *)

        Deprecated: 
        """
        _connect.ConnectionMgr_swiginit(self, _connect.new_ConnectionMgr(*args))
    __swig_destroy__ = _connect.delete_ConnectionMgr

    def initLogger(self, id: "std::string const &", fileName: "std::string const &", language: "isys::CLogger::LogFileLanguage") -> "void":
        r"""
        Initializes logger, which is owned by instance of this class. Logger writes
        ``isystem.connect`` calls to log file, so that it produces valid python
        program in most cases. Only some complex calls, which require creation of
        local variables are not logged in a way to be directly executable.

        :type id: string
        :param id: used as prefix in log
                statements. The default value is empty string, which is OK if
                there is only one winIDEA instance. If we are controlling multiple
                targets or multi-core CPUs, then the ID **must** be set to distinguish
                connections in scripts produced by isystem.connect logger.
                If the id is empty, logged statements will look something like:

                    execCtrl.setBP("func1");

                If we set the id to ``main_`` , we get:

                    main_execCtrl.setBP("func1");


        :type fileName: string
        :param fileName: name of the log file
        :type language: int
        :param language: language used for log files statements. Only PYTHON
                is currently fully supported, while JAVA has limited support.

        Python example: dataRecorderWithDAQ.py  
        """
        return _connect.ConnectionMgr_initLogger(self, id, fileName, language)

    def getId(self) -> "std::string const &":
        r""" Returns the ID set by setLogger()."""
        return _connect.ConnectionMgr_getId(self)

    def getLogger(self) -> "isys::CLogger *":
        r""" Returns pointer to logger set by setLogger()."""
        return _connect.ConnectionMgr_getLogger(self)

    def connectMRU(self, *args) -> "void":
        r"""
        Connects to the most recently used winIDEA and opens the given
        workspace. This is a utility method, which suits most needs. For
        complex configurations with more than one winIDEA instance or remote
        instances use other methods as described in documentation of this class.

        If environment variables ICONNECT_PATH and ICONNECT_TCP_PORT
        are defined, then they define the winIDEA to connect to. Otherwise
        winIDEA's internal data is used to connect to the most recently started
        winIDEA. These two environment variables are defined when executing
        Python script interactively from winIDEA.

        :param pszWorkspacePath: specifies a path to the workspace file. If the
                   string is empty (size == 0), the last opened workspace is used.
                   Linux specific: Is is assumed that Wine maps drive Z: to root folder.

        :type winIDEAId: string, optional
        :param winIDEAId: if specified, connection is made to winIDEA, which was
                             started with command line option /id:<winIDEAId>. If empty
                             string, this parameter is ignored.

        :type hostIpAddress: string, optional
        :param hostIpAddress: if specified, this host is used for lookup. If empty,
                                 local host is used.

        :type isUseServerEnvVars: boolean, optional
        :param isUseServerEnvVars: if true, environment vars as set by launching
                                      application are used to connect to winIDEA.
                                      Namely, process ID and TCP port are used. For
                                      example, if Python script was started from winIDEA,
                                      and this flag is ``true``, then the script will be able to
                                      connect only to this instance of winIDEA. Set this
                                      flag to ``false`` to connect to other instances of winIDEA
                                      if required.

        :raises: IllegalStateException if already connected
        :raises: IOException if connecting to winIDEA failed

        Python example: debugIdeTraceProfilerCoverageSample.py  
        """
        return _connect.ConnectionMgr_connectMRU(self, *args)

    def connectMRUEx(self, workspacePath: "std::string const &", isAnyWinIDEAId: "bool", winIDEAId: "std::string const &", hostIpAddress: "std::string const &", isUseServerEnvVars: "bool") -> "void":
        r"""
        Connects to the most recently used winIDEA and opens the given
        workspace. Use this method only if you want to connect to winIDEA with
        no ID specified. For complex configurations with more than one winIDEA
        instance or remote
        instances use other methods as described in documentation of this class.

        If environment variables ICONNECT_PATH and ICONNECT_TCP_PORT
        are defined, then they define the winIDEA to connect to. Otherwise
        winIDEA's internal data is used to connect to the most recently started
        winIDEA. These two environment variables are defined when executing
        Python script interactively from winIDEA.


        :param pszWorkspacePath: specifies a path to the workspace file. If the
                   string is empty (size == 0), the last opened workspace is used.
                   Linux specific: Is is assumed that Wine maps drive Z: to root folder.

        :type isAnyWinIDEAId: boolean
        :param isAnyWinIDEAId: if true, value of winIDEAId parameter is ignored -
                                  connection is made to winIDEA with any ID.

        :type winIDEAId: string
        :param winIDEAId: if isAnyWinIDEAId is false, connection is made to winIDEA, which was
                             started with command line option /id:<winIDEAId>). If empty
                             string, connection is made to winIDEA, which was
                             started **without** command line option /id:<winIDEAId>.

        :type hostIpAddress: string
        :param hostIpAddress: if specified, this host is used for lookup. If empty,
                                 local host is used.

        :type isUseServerEnvVars: boolean
        :param isUseServerEnvVars: if true, environment vars as set by launching
                                      application are used to connect to winIDEA.
                                      Namely, process ID and TCP port are used. For
                                      example, if Python script was started from winIDEA,
                                      and this flag is ``true``, then the script will be able to
                                      connect only to this instance of winIDEA. Set this
                                      flag to ``false`` to connect to other instances of winIDEA
                                      if required.

        :raises: IllegalStateException if already connected
        :raises: IOException if connecting to winIDEA failed
        :raises: IllegalStateException if already connected
        :raises: IOException if connecting to winIDEA failed

        Python example: debugIdeTraceProfilerCoverageSample.py  
        """
        return _connect.ConnectionMgr_connectMRUEx(self, workspacePath, isAnyWinIDEAId, winIDEAId, hostIpAddress, isUseServerEnvVars)

    def findExistingInstance(self, address: "std::string const &", connectionConfig: "CConnectionConfig") -> "int":
        r"""
        Finds existing instance of wiNIDEA if it is running on host specified with parameter
        ``address``. Search criteria is specified with parameters ``workspace``, and
        ``instanceId`` of parameter ``connectionConfig``, if they are not empty strings.

        :type address: string
        :param address: The IP address of the machine where to search for
            running instance of winIDEA. This can be either dotted decimal or an URL. If
            it is empty string, the local host is considered.

        :type connectionConfig: :py:class:`CConnectionConfig`
        :param connectionConfig: configuration parameters for search algorithm.
                   Process ID of found winIDEA instance is returned in this object.
                   See CConnectionConfig for more info.

        :rtype: int
        :return: port number of the running instance, or negative number if
            no running instance, which matches search criteria, was found

        See also: #findOrStartInstance(CConnectionConfig &)
        See also: #startNewInstance(CConnectionConfig &)

        Python example: advancedWinIDEALaunching.py  
        """
        return _connect.ConnectionMgr_findExistingInstance(self, address, connectionConfig)

    def startNewInstance(self, connectionConfig: "CConnectionConfig") -> "int":
        r"""
        Starts new instance of winIDEA with parameters specified in ``connectionConfig``.
        To connect to the new winIDEA instance call method ``connect()`` with
        port number returned by this method.

        :type connectionConfig: :py:class:`CConnectionConfig`
        :param connectionConfig: configuration of the new instance of winIDEA to be started.
                   Process ID of started winIDEA instance is returned in this object.

        :rtype: int
        :return: isystem.connect port of the new winIEDA instance

        See also: #findOrStartInstance(CConnectionConfig &)
        See also: #findExistingInstance(const std::string &, CConnectionConfig &)

        Python example: advancedWinIDEALaunching.py  
        """
        return _connect.ConnectionMgr_startNewInstance(self, connectionConfig)

    def findOrStartInstance(self, connectionConfig: "CConnectionConfig") -> "int":
        r"""
        First tries to find a winIDEA instance, with ``workspace``, and
        ``instanceId`` as specified in ``connectionConfig``. If any of these
        two items is empty string, it is ignored when searching. If matching
        instance of winIDEA is found, its ``isystem.connect`` port number is
        returned. If not, a new instance is started and its ``isystem.connect``
        port number is returned.

        :type connectionConfig: :py:class:`CConnectionConfig`
        :param connectionConfig: configuration parameters for search algorithm and
            creating of new winIDEA instance. Process ID of found/started winIDEA
            instance is returned in this object if shared memory communication is used.
            If TCP/IP is used, then process ID of winIDEA is returned only if winIDEA
            has been started.
            See CConnectionConfig for more info.

        :rtype: int
        :return: port number of winIDEA instance matching the ``workspace`` and
            ``instanceId`` in ``connectionConfig``.

        See also: #startNewInstance(CConnectionConfig &)
        See also: #findExistingInstance(const std::string &, CConnectionConfig &)

        Python example: advancedWinIDEALaunching.py 
        """
        return _connect.ConnectionMgr_findOrStartInstance(self, connectionConfig)

    def connect(self, *args) -> "void":
        r"""
        *Overload 1:*

        Connects to winIDA via TCP/IP at address specified in ``address`` at
        the specified port. TCP/IP server must be enabled in winIDEA for
        this method to work (`Tools | Options |` tab `isystem.connect`).

        :type address: string
        :param address: The IP address of the machine where winIDEA is
            running. This can be either dotted decimal or an URL. If
            it is an empty string, the local host is considered.

        :type iconnectPort: int
        :param iconnectPort: The TCP port to use. This should be the
            same value as configured in winIDEA to which the connection is
            attempted. Default port value is 5315, and can be set in winIDEA' menu *Tools |
            Options | isystem.connect | TCP Connection Port Range*.

        Python example: advancedWinIDEALaunching.py 

        Python example connects to enumerated winIDEA instances: winIDEAInstanceEnumeration.py 


        |

        *Overload 2:*

        Connects to local winIDEA instance with the same configuration
        (workspace, id) as set in input parameter. If it is not running,
        a new instance with the given configuration is started.

        :type connectionConfig: :py:class:`CConnectionConfig`
        :param connectionConfig: expected winIDEA configuration and startup parameters

        Python example: advancedLocalLaunching.py 


        |

        *Overload 3:*

        Connects to winIDEA with the given process ID.

        :type pid: int
        :param pid: Windows process ID

        Python example: advancedLocalLaunching.py 
        """
        return _connect.ConnectionMgr_connect(self, *args)

    def isConnected(self) -> "bool":
        r"""
        Returns true, if connection was established. It returns true, until
        the method disconnect() (which releases connection resources) is called,
        even if winIDEA is closed after the connection is established.

        See also: isAttached()
        """
        return _connect.ConnectionMgr_isConnected(self)

    def enumerateWinIDEAInstances(self, address: "std::string const &", connectionConfig: "CConnectionConfig", instances: "VectorWinIDEAInstanceInfo") -> "void":
        r"""
        This method enumerates instances of winIDEA running at the specified host.

        :type address: string
        :param address: The IP address of the machine where to search for
            running instance of winIDEA. This can be either dotted decimal or an URL. If
            it is empty string, the local host is considered.

        :type connectionConfig: :py:class:`CConnectionConfig`
        :param connectionConfig: configuration parameters for search algorithm and
            creating of new winIDEA instance. See CConnectionConfig for more info.

        :type instances: :py:class:`VectorWinIDEAInstanceInfo`
        :param instances: vector to receive enumeration information. One element
            contains information for one instance found.

        Python example: showConnectionStatus.py  
        """
        return _connect.ConnectionMgr_enumerateWinIDEAInstances(self, address, connectionConfig, instances)

    def disconnect(self, *args) -> "void":
        r"""
        *Overload 1:*

        Disconnects from winIDEA. This method is automatically called by destructor,
        if connection to winIDEA is still active.

        Python example: advancedWinIDEALaunching.py 

        Python example connects to enumerated winIDEA instances: winIDEAInstanceEnumeration.py 


        |

        *Overload 2:*

        Disconnects from winIDEA.

        :type closeServerFlags: int
        :param closeServerFlags: one of ``IConnect::EDetachFlags::dfCloseServer...`` flags
        :type autoSaveFlags: int
        :param autoSaveFlags: one of ``IConnect::EDetachFlags::dfCloseAutoSave...`` flags
        """
        return _connect.ConnectionMgr_disconnect(self, *args)

    def inProcessDisconnect(self) -> "void":
        return _connect.ConnectionMgr_inProcessDisconnect(self)

    def isCoreLaunched(self, coreIndex: "int") -> "bool":
        r"""
        Returns true, if core is already launched, false otherwise.

        :type coreIndex: int
        :param coreIndex: 0 for primary core, 1 for next core, ...
        """
        return _connect.ConnectionMgr_isCoreLaunched(self, coreIndex)

    def launchCore(self, coreIndex: "int", isPrimaryCoreIndexed: "bool"=False) -> "std::string":
        r"""
        Deprecated: This method does not work
        reliably when you have multiple instances of winIDEA with the
        same workspace opened. Use launchCore1() instead.

        Opens another winIDEA instance, which is connected to core
        specified by parameter 'coreIndex'.

        :type coreIndex: int
        :param coreIndex: index of the core, starting with 0. If parameter
                   ``isPrimaryCoreIndexed`` is false, then the primary core is
                   not indexed, so index ``0`` means core 1. This is deprecated
                   usage, which exists for backward compatibility. It is recommended
                   to always set flag ``isPrimaryCoreIndexed`` to ``true``, so all cores
                   can be indexed. Indices may be in range 0..(N - 1), where N is the
                   number of cores.

        :type isPrimaryCoreIndexed: boolean, optional
        :param isPrimaryCoreIndexed: see description of parameter ``coreIndex`` above.

        :rtype: string
        :return: name of the workspace file used by the newly opened instance.
            To use isystem.connect with this core, instantiate another ConnectionMgr
            and use the returned workspace name as parameter to ConnectionMgr::connectMRU().
        """
        return _connect.ConnectionMgr_launchCore(self, coreIndex, isPrimaryCoreIndexed)

    def launchCore1(self, coreIndex: "uint32_t") -> "ConnectionMgr":
        r"""
        Opens another winIDEA instance, which is connected to core
        specified by parameter 'coreIndex'.

        :type coreIndex: int
        :param coreIndex: index of the core, starting with 0.
            Indices may be in range 0..(N - 1), where N is the number of cores.
            Since instance of connection manager on which this method is
            called is usually connected to core 0, this parameter is
            usually >= 1.

        :rtype: :py:class:`ConnectionMgr`
        :return: connection manager already connected to the winIDEA instance.

        Python example: launchSecondCore.py 
        """
        return _connect.ConnectionMgr_launchCore1(self, coreIndex)

    def getIConnectDllVersion(self) -> "isys::CWinIDEAVersion":
        return _connect.ConnectionMgr_getIConnectDllVersion(self)

    def isWarning(self) -> "bool":
        r"""Returns true, if the last operation issued a warning."""
        return _connect.ConnectionMgr_isWarning(self)

    def getLastErrorMsg(self) -> "std::string":
        r"""
        Returns the warning or error message of the last operation. Returns empty
        string, when there was no error or warning.
        """
        return _connect.ConnectionMgr_getLastErrorMsg(self)

    def isAttached(self) -> "bool":
        r"""
        Returns true, if connection to winIDEA is alive. When winIDEA
        is closed, this method returns false.

        See also: isConnected()

        Python example: dataRecorderWithDAQ.py  
        """
        return _connect.ConnectionMgr_isAttached(self)

    @staticmethod
    def isStartedFromWinIDEA() -> "bool":
        r"""Returns true, if application was started from winIDEA, false otherwise."""
        return _connect.ConnectionMgr_isStartedFromWinIDEA()

# Register ConnectionMgr in _connect:
_connect.ConnectionMgr_swigregister(ConnectionMgr)

def ConnectionMgr_isStartedFromWinIDEA() -> "bool":
    r"""Returns true, if application was started from winIDEA, false otherwise."""
    return _connect.ConnectionMgr_isStartedFromWinIDEA()

class CMulticoreConnectionMgr(object):
    r"""
    This class is a container for connection managers. It should be used
    when we want to connect to multi-core target.


    This class manages connections to multicore instances of winIDEA.


    Python example: multicoreConnection.py  
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def connectPrimaryCore(self, *args) -> "ConnectionMgr":
        r"""
        *Overload 1:*

        This method starts winIDEA version, which was the last started in current
        user account. See overload for details.
        See also: connectPrimaryCore(const iconnect::StrVector &, const std::string &, bool,
        const std::string &, const std::string &, const std::string &).

        |

        *Overload 2:*

        This method creates connection to primary core. If
        connection is already established, it disconnects first,
        then reconnects. This is the first method to be called in this class.

        Note that it is highly recommended to specify either `winIDEAWorkspace`
        or `winIDEAId`, so that connection is always made to the primary core.
        Otherwise connection is made to the latest started winIDEA, which is
        usually not the one you intended to connect to, especially in multicore
        configurations.

        :type loggingParams: :py:class:`StrVector`
        :param loggingParams: used for logger configuration. If empty vector, logging of
                                 isystem.connect calls is not performed. Otherwise
                                 `loggingParams[0]` should contain log file name.
                                 If `loggingParams[1]` exists, it is used as prefix in log statements.
        :type winIDEAWorkspace: string
        :param winIDEAWorkspace: path to winIDEA workspace used for connection to winIDEA. If
                                    empty, connection to the most recently used winIDEA is made.
        :type isUseWinIDEAId: boolean
        :param isUseWinIDEAId: if true, parameter winIDEAId is used to connect to
                                  winIDEA with the given ID. If false, connection can be made to
                                  any winIDEA, regardless if it has ID specified or not.
        :type winIDEAId: string
        :param winIDEAId: used only if isUseWinIDEAId is true. If empty string, connection
                             can be made only to winIDEA, which has no ID specified.
        :type primaryCoreId: string
        :param primaryCoreId: id of primary core, may be empty string.
        :type pathToIConnectDll: string
        :param pathToIConnectDll: if not empty string, is should specify full path to
                                     iconnect.dll in winIDEA installation directory, for
                                     example ``'C:\iSystem\winIDEA\iconnect.dll'``.
                                     Specify it when you want to run specific version of winIDEA,
                                     or winIDEA has never been run under current user account,
                                     so ``connectMRU()`` can not find winIDEA. For example,
                                     when starting winIDEA with script running as a service (daemon).

        Example: multicoreConnection.py
        """
        return _connect.CMulticoreConnectionMgr_connectPrimaryCore(self, *args)

    def connectCore(self, coreIndex: "int", coreId: "std::string const &") -> "ConnectionMgr":
        r"""
        Creates connection to core with the given index and assigns
        it the given coreId. Connection to primary core must exist before
        calling this method (call connectPrimaryCore()). If winIDEA for the
        given core is already running, connection to this instance is made.

        :type coreIndex: int
        :param coreIndex: index of the core to connect to. Index 0 is used for
                             primary core (see connectPrimaryCore()), so for this
                             method coreIndex >= 1.
        :type coreId: string
        :param coreId: id, which is assigned to the core with index *coreIndex*.
                          Must *not* be empty string!

        :rtype: :py:class:`ConnectionMgr`
        :return: created connection manager
        """
        return _connect.CMulticoreConnectionMgr_connectCore(self, coreIndex, coreId)

    def getConnectionMgr(self, coreId: "std::string const &") -> "ConnectionMgr":
        r"""
        Returns connection manager for core with the given ID.

        :param coreID: core ID or empty string for primary core.
        """
        return _connect.CMulticoreConnectionMgr_getConnectionMgr(self, coreId)

    def isConnected(self, coreId: "std::string const &") -> "bool":
        r"""
        Returns true, if connection to the given core was established and
        is still alive.
        """
        return _connect.CMulticoreConnectionMgr_isConnected(self, coreId)

    def disconnect(self, *args) -> "void":
        r"""
        Disconnects connection manager with the given core ID. Parameters ``closeServerFlags``
        and ``autoSaveFlags`` are later ORed together. Both of them are specified, because
        Java enums are not int-s, so they can not be ORed together before the call. This is
        also the reason for using IConnect::dfCloseAutoSaveDefault as value for ``closeServerFlags``
        as described below in parameter description.

        :type coreId: string
        :param coreId: id of the core to be disconnected
        :type closeServerFlags: int, optional
        :param closeServerFlags: flags defining if and when winIDEA should close.
                                    Specify one of IConnect::EDetachFlags ``::dfCloseServer...`` flags.
                                    If you do not want winIDEA to close,
                                    specify value IConnect::dfCloseAutoSaveDefault
                                    for this item.
        :type autoSaveFlags: int, optional
        :param autoSaveFlags: flags defining if winIDEA should save unsaved information.
                                       Specify one of IConnect::EDetachFlags ``::dfCloseAutoSave...`` flags.

        Example: multicoreConnection.py
        """
        return _connect.CMulticoreConnectionMgr_disconnect(self, *args)

    def disconnectAll(self) -> "void":
        r"""Disconnects all connection managers."""
        return _connect.CMulticoreConnectionMgr_disconnectAll(self)

    def getCDebugFacade(self, coreId: "std::string const &") -> "CDebugFacade":
        r"""Returns cached CDebugFacade for the given core ID."""
        return _connect.CMulticoreConnectionMgr_getCDebugFacade(self, coreId)

    def getCIDEController(self, coreId: "std::string const &") -> "CIDEController":
        r"""Returns cached CIDEController for the given core ID."""
        return _connect.CMulticoreConnectionMgr_getCIDEController(self, coreId)

    def getCExecutionController(self, coreId: "std::string const &") -> "CExecutionController":
        r"""Returns cached CExecutionController for the given core ID."""
        return _connect.CMulticoreConnectionMgr_getCExecutionController(self, coreId)

    def getCLoaderController(self, coreId: "std::string const &") -> "CLoaderController":
        r"""Returns cached CLoaderController for the given core ID."""
        return _connect.CMulticoreConnectionMgr_getCLoaderController(self, coreId)

    def getCDataEController2(self, coreId: "std::string const &") -> "CDataController2":
        r"""
        Deprecated: since 2016-05-02, 9.12.179, because of typo in method name.
        Call getCDataController2() instead.
        """
        return _connect.CMulticoreConnectionMgr_getCDataEController2(self, coreId)

    def getCDataController2(self, coreId: "std::string const &") -> "CDataController2":
        r"""Returns cached CDataController2 for the given core ID."""
        return _connect.CMulticoreConnectionMgr_getCDataController2(self, coreId)

    def getCHILController(self) -> "CHILController":
        r"""Returns cached CHILController for the given core ID."""
        return _connect.CMulticoreConnectionMgr_getCHILController(self)

    def getConnectedCoreIDs(self) -> "iconnect::StrVector":
        r""" Returns list of all core IDs currently connected."""
        return _connect.CMulticoreConnectionMgr_getConnectedCoreIDs(self)

    def __init__(self):
        _connect.CMulticoreConnectionMgr_swiginit(self, _connect.new_CMulticoreConnectionMgr())
    __swig_destroy__ = _connect.delete_CMulticoreConnectionMgr

# Register CMulticoreConnectionMgr in _connect:
_connect.CMulticoreConnectionMgr_swigregister(CMulticoreConnectionMgr)

class CMemAddress(object):
    r"""
    This class contains memory address including memory area.


    Note: If you are using logging (see ConnectionMgr::setLogger())
    functionality, some methods disable it if an exception is thrown.
    Call ``logger.loggingOn()`` in case of exception.

    See also: CAddressController
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, memArea: "BYTE", address: "ADDRESS_64"):
        _connect.CMemAddress_swiginit(self, _connect.new_CMemAddress(memArea, address))

    def getMemArea(self) -> "BYTE":
        r"""
        Returns memory area. See MemArea.h for meaning of values
        returned by this function - make sure to see enum for your
        target architecture.

        Python example: addressControllerExample.py 
        """
        return _connect.CMemAddress_getMemArea(self)

    def getAddress(self) -> "ADDRESS_64":
        r"""
        Returns address.

        Python example: addressControllerExample.py 
        """
        return _connect.CMemAddress_getAddress(self)

    def toString(self) -> "std::string":
        return _connect.CMemAddress_toString(self)
    __swig_destroy__ = _connect.delete_CMemAddress

# Register CMemAddress in _connect:
_connect.CMemAddress_swigregister(CMemAddress)

class CSymbolInfo(object):
    r"""This class contains information about symbol, such as address, size and type."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, memArea: "BYTE", address: "ADDRESS_64", sizeMAUs: "ADDRESS_64", type: "SType"):
        _connect.CSymbolInfo_swiginit(self, _connect.new_CSymbolInfo(memArea, address, sizeMAUs, type))

    def getMemArea(self) -> "BYTE":
        r"""
        Returns symbol's memory area. See MemArea.h for meaning of values
        returned by this function - make sure to see enum for your
        target architecture.
        """
        return _connect.CSymbolInfo_getMemArea(self)

    def getAddress(self) -> "ADDRESS_64":
        r""" Returns symbol's address."""
        return _connect.CSymbolInfo_getAddress(self)

    def getSizeMAUs(self) -> "ADDRESS_64":
        r""" Returns symbol's size in Memory Addressable Units."""
        return _connect.CSymbolInfo_getSizeMAUs(self)

    def getMType(self) -> "SType":
        r""" Returns symbol's type."""
        return _connect.CSymbolInfo_getMType(self)

    def toString(self) -> "std::string":
        return _connect.CSymbolInfo_toString(self)
    __swig_destroy__ = _connect.delete_CSymbolInfo

# Register CSymbolInfo in _connect:
_connect.CSymbolInfo_swigregister(CSymbolInfo)

class CLineLocation(object):
    r"""
    This class contains information about line location - file name and line
    number.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fileName: "std::string const &", lineNumber: "DWORD"):
        _connect.CLineLocation_swiginit(self, _connect.new_CLineLocation(fileName, lineNumber))

    def getFileName(self) -> "std::string":
        r""" Returns file name."""
        return _connect.CLineLocation_getFileName(self)

    def getLineNumber(self) -> "DWORD":
        r""" Returns line number."""
        return _connect.CLineLocation_getLineNumber(self)

    def toString(self) -> "std::string":
        return _connect.CLineLocation_toString(self)
    __swig_destroy__ = _connect.delete_CLineLocation

# Register CLineLocation in _connect:
_connect.CLineLocation_swigregister(CLineLocation)

class CLineDescription(object):
    r"""
    This adapter class contains line description based on file/line
    contents not on line number. It is used to to define source code line, which
    location may change when source file is modified.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_RESOURCE_FUNCTION = _connect.CLineDescription_E_RESOURCE_FUNCTION
    r""" lines are given relative to function"""
    E_RESOURCE_FILE = _connect.CLineDescription_E_RESOURCE_FILE
    r""" lines are given relative to file"""
    E_RESOURCE_ADDRESS = _connect.CLineDescription_E_RESOURCE_ADDRESS
    r"""
    location is defined by address as string
    in resource name.
    """
    E_SEARCH_ANY = _connect.CLineDescription_E_SEARCH_ANY
    r""" all text is searched"""
    E_SEARCH_CODE = _connect.CLineDescription_E_SEARCH_CODE
    r""" only source code is searched"""
    E_SEARCH_COMMENT = _connect.CLineDescription_E_SEARCH_COMMENT
    r""" only single line comment is searched"""
    E_MATCH_PLAIN = _connect.CLineDescription_E_MATCH_PLAIN
    r""" plain string matching is done anywhere in the line"""
    E_MATCH_REG_EX = _connect.CLineDescription_E_MATCH_REG_EX
    r""" pattern is regular expression"""
    E_MATCH_TEST_POINT_ID = _connect.CLineDescription_E_MATCH_TEST_POINT_ID
    r"""
     pattern is test point id - it should be in comment
     with prefix 'TID: ', for example:  ``int i = 10;  // TID: pattern``

     If single line comment can not be used, the following also works:

    ``i = 10;   /* // TID: myTestPoint * / ``
    """
    ELocalHost = _connect.CLineDescription_ELocalHost
    r""" get source code from host, where testIDEA or script using SDK is running"""
    EWinIDEAHost = _connect.CLineDescription_EWinIDEAHost
    r""" get source code from host, where winIDEA is running"""

    def __init__(self, *args):
        r"""
        Instantiates this class.

        :type resourceType: int
        :param resourceType: defines where to look for location
        :type resourceName: string
        :param resourceName: name of file or function, depending on the first parameter
        :type line: int
        :param line: line in file or function, 0-based. If isSearch is true, this is line
                   where search is started
        :type isSearch: boolean
        :param isSearch: if true, line with the specified pattern is searched
        :type linesRange: int
        :param linesRange: how many lines to search. Set it to 0 for no limit (till the end of file)
        :type searchContext: int
        :param searchContext: see CLineDescription::ESearchContext
        :type matchingType: int
        :param matchingType: see CLineDescription::EMatchingType
        :type searchPattern: string
        :param searchPattern: text pattern to search in lines, format depends on matchingType
        :type lineOffset: int
        :param lineOffset: the number of lines to add to the found line
        :type fileLocation: int, optional
        :param fileLocation: defines where to look for source files - on local host running
                   the script, or on remote host running winIDEA. If winIDEA is running on
                   the same host as script, use the default value.
        """
        _connect.CLineDescription_swiginit(self, _connect.new_CLineDescription(*args))

    def getResourceType(self) -> "isys::CLineDescription::EResourceType":
        r""" Returns type of resource for which location is given."""
        return _connect.CLineDescription_getResourceType(self)

    def getResourceName(self) -> "std::string":
        r""" Returns name of resource where test point is located."""
        return _connect.CLineDescription_getResourceName(self)

    def getLine(self) -> "int":
        r"""
        Returns line number, where test point is set, or where
        search range starts (if pattern is defined). Lines for file
        are 1-based, while lines for function are 0 based and can also be
        negative.
        """
        return _connect.CLineDescription_getLine(self)

    def isSearch(self) -> "bool":
        r"""
        Returns true, if search is to be performed. Otherwise the line
        number returned by getLine() is used to set a test point.
        """
        return _connect.CLineDescription_isSearch(self)

    def getLinesRange(self) -> "int":
        r"""
        Returns the number of lines, which are searched for pattern.
        Value 0 means till the end of file.
        """
        return _connect.CLineDescription_getLinesRange(self)

    def getSearchContext(self) -> "isys::CLineDescription::ESearchContext":
        r""" Returns search context for pattern."""
        return _connect.CLineDescription_getSearchContext(self)

    def getMatchingType(self) -> "isys::CLineDescription::EMatchingType":
        r""" Returns matching type for pattern."""
        return _connect.CLineDescription_getMatchingType(self)

    def getSearchPattern(self) -> "std::string":
        r"""
        Returns search pattern. If this item is not defined (empty
        string is returned), then test point is located in line
        returned by ``getLine()``. No search is performed. Num lines,
        search context, and matching type are ignored.
        """
        return _connect.CLineDescription_getSearchPattern(self)

    def getLineOffset(self) -> "int":
        r"""
        Returns the number of lines, which are added to line found by search
        pattern above.
        """
        return _connect.CLineDescription_getLineOffset(self)

    def getFileLocation(self) -> "isys::CLineDescription::EFileLocation":
        r"""Returns source location."""
        return _connect.CLineDescription_getFileLocation(self)

    def toString(self) -> "std::string":
        r"""
        Returns contents of object as string. Use this for logging/debugging
        purposes only.
        """
        return _connect.CLineDescription_toString(self)
    __swig_destroy__ = _connect.delete_CLineDescription

# Register CLineDescription in _connect:
_connect.CLineDescription_swigregister(CLineDescription)

class CAddressController(object):
    r"""
    This class provides information about symbols and source code -
    sizes and addresses in the memory.


    Python example: debugIdeTraceProfilerCoverageSample.py 

    Python example for method getSymbolAtAddress(): getSymbolAtAddress.py 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        """
        _connect.CAddressController_swiginit(self, _connect.new_CAddressController(connectionMgr))
    __swig_destroy__ = _connect.delete_CAddressController

    def getCodeArea(self, bPhysical: "bool") -> "int":
        r"""
        Returns memory area, where the code is located.

        :type bPhysical: boolean
        :param bPhysical: used only for PowerPC, see MemoryAreas.cpp,
            CCPUInfoHelp::GetCodeArea():
             ``**return** bPhysical ? maPPhysicalPowerPC : maVirtualPowerPC;``

        Python example: debugIdeTraceProfilerCoverageSample.py 
        """
        return _connect.CAddressController_getCodeArea(self, bPhysical)

    def getFunctionAddress(self, functionName: "std::string const &") -> "isys::CMemAddress":
        r"""
        Returns address of a function. If function is located in a *default
        download file*, then its name is enough. If function is located in
        *other download file than the default one*, a fully qualified name
        should be specified in the following format:


        "<moduleName>"#<funcName>,,<downloadFileName>

        where:
        - ``moduleName`` - name of the C source file, which contains the function
        - ``funcName`` - name of the function
        - ``downloadFileName`` - name of the download file, where the function is located

        Module name is optional. It is only needed when there is more than one
        file static function with the same name.

        Example:

        "main.c"#init,,executable.elf


        :type functionName: string
        :param functionName: name of the function

        Python example: debugIdeTraceProfilerCoverageSample.py 
        """
        return _connect.CAddressController_getFunctionAddress(self, functionName)

    def getVariableAddress(self, variableName: "std::string const &") -> "isys::CMemAddress":
        r"""
        Returns address of a variable. Use this method to get address of a simple
        variable. For complex items, for example struct members, use method getExpressionAddress().

        :type variableName: string
        :param variableName: name of the variable

        Python example: debugIdeTraceProfilerCoverageSample.py 
        """
        return _connect.CAddressController_getVariableAddress(self, variableName)

    def getExpressionAddress(self, expression: "std::string const &") -> "isys::CMemAddress":
        r"""
        Returns address of an expression. Expression can be any item with address,
        for example function, variable, struct member, ...

        :type expression: string
        :param expression: any expression with address, for example 'myStruct.x'

        Python example: debugIdeTraceProfilerCoverageSample.py 
        """
        return _connect.CAddressController_getExpressionAddress(self, expression)

    def getLabelAddress(self, labelName: "std::string const &") -> "isys::CMemAddress":
        r"""
        Returns address of a label.

        :type labelName: string
        :param labelName: name of the label

        Python example: addressControllerExample.py 
        """
        return _connect.CAddressController_getLabelAddress(self, labelName)

    def getSymbolInfo(self, flags: "DWORD", expression: "std::string const &") -> "isys::CSymbolInfo":
        r"""
        Returns information about the symbol. It includes:
        - memory area, where it is located (set to 0 for architectures with
          linear memory space)
        - address or the symbol
        - size of the symbol in memory allocation units
        - type

        If you need only address of the symbol, then methods getFunctionAddress(),
        getVariableAddress(), and getLabelAddress() are more convenient.

        :type flags: int
        :param flags:

            | 31       | 30-24      | 23-16      | 15-12       | 11-8         | 7-0          |
            ----------------------------------------------------------------------------------
            | Use File | File Index | Enum Index | Enum Source | Reserved SBZ | EAccessFlags |

            - **EAccessFlags** used if required to resolve the expression.
              See IConnectDebug::EAccessFlags.
            - **Enum Source** - see IConnectDebug::EGetAddressFlags, **gafXXX** flags
            - **Enum Index** - Index of the enumerated symbol to return.
            - **File index** - Index of the symbol (download) file to use. Used only
              if **Use File** flag is set.

        :type expression: string
        :param expression: name of the symbol, for example variable or
                   function name

        Python example: debugIdeTraceProfilerCoverageSample.py 
        """
        return _connect.CAddressController_getSymbolInfo(self, flags, expression)

    def getSymbolAtAddress(self, *args) -> "std::string":
        r"""
        Returns the name of the symbol at the specified address, or empty
        string if there is no symbol at the given address.

        :type symbolType: int
        :param symbolType: Specifies symbol classes to consider, must be one of the following
                   ``IConnectDebug::ESymbolFlags``: ``sVariables``, ``sLabels``, ``sFunctions``,
                   ``sLine``, or ``sConstants``.
        :type memArea: BYTE
        :param memArea: memory area of the object
        :type address: int
        :param address: address of the object
        :type scope: int, optional
        :param scope: defines how exact the symbol search should be. Should be one of
                         ``sScope*`` flags from ``IConnectDebug::ESymbolFlags``.

        Python example: getSymbolAtAddress.py 

        Python example: debugIdeTraceProfilerCoverageSample.py 
        """
        return _connect.CAddressController_getSymbolAtAddress(self, *args)

    def getAnySymbolAtAddress(self, symbolTypes: "DWORD", memArea: "BYTE", address: "ADDRESS_64", scope: "IConnectDebug::ESymbolFlags") -> "std::string":
        r"""
        Returns the name of the symbol at the specified address, or empty
        string if there is no symbol at the given address.

        :param symbolType: Specifies symbol classes to consider, must be one of the following
                   ``IConnectDebug::ESymbolFlags``: ``sVariables``, ``sLabels``, ``sFunctions``,
                   ``sLine``, ``sConstants`` or ORed value of these constants
        :type memArea: BYTE
        :param memArea: memory area of the object
        :type address: int
        :param address: address of the object
        :type scope: int
        :param scope: defines how exact the symbol search should be. Should be one of
                         ``sScope*`` flags from ``IConnectDebug::ESymbolFlags``.

        See also: getSymbolAtAddress
        """
        return _connect.CAddressController_getAnySymbolAtAddress(self, symbolTypes, memArea, address, scope)

    def getAddressOfSourceLine(self, fileName: "std::string const &", line: "int", isReportSize: "bool"=False) -> "iconnect::AddressVector":
        r"""
        Returns vector of addresses used by the given line of source code. If the line
        generates no assembly code (empty lines, for example), an empty vector is returned.
        To get info about memory area, use method getCodeArea(), because executable code
        is always located in the code memory area.

        If source line compiles to a continuous block of code its start address and size
        are reported. Only when source line generates several blocks of object code
        (for example 'for' loop), more than one address item is returned.

        :type fileName: string
        :param fileName: name of the file, where the source line is located
        :type line: int
        :param line: line number
        :type isReportSize: boolean, optional
        :param isReportSize: if set, for every object location both address and size are returned

        Python example: debugIdeTraceProfilerCoverageSample.py  
        """
        return _connect.CAddressController_getAddressOfSourceLine(self, fileName, line, isReportSize)

    def getSourceLineAtAddress(self, *args) -> "isys::CLineLocation":
        r"""
        *Overload 1:*

        Returns the source line which generates code at the given address.
        It is equivalent of ``getSourceLineAtAddress(address, false, false)``.

        :type address: int
        :param address: memory address, where the code generated by the returned
            source line is located

        :rtype: :py:class:`CLineLocation`
        :return: file name and line number if there exits source line for the given
            address, or empty file name and line number set to 0 if there is no such source line.

        Python example: debugIdeTraceProfilerCoverageSample.py 


        |

        *Overload 2:*

        Returns the source line which generates code at the given address.

        :type address: int
        :param address: memory address, where the code generated by the returned
            source line is located

        :type isExact: boolean
        :param isExact: if true, address must be the the first address occupied by
            the source line. If it is not, empty file name and line number set to 0 are returned.

        :type isAbsolutePath: boolean
        :param isAbsolutePath: if true, file name is returned with absolute path

        :rtype: :py:class:`CLineLocation`
        :return: file name and line number if there exits source line for the given
            address, or empty file name and line number set to 0 if there is no such source line.

        Python example: debugIdeTraceProfilerCoverageSample.py 
        """
        return _connect.CAddressController_getSourceLineAtAddress(self, *args)

    def getFunctionNames(self, addresses: "AddressVector", names: "StrVector", types: "IntVector") -> "void":
        r"""
        Returns names of functions at given addresses. If function can not be found
        for an address, empty string or hex address is returned.

        :type addresses: :py:class:`AddressVector`
        :param addresses: input list of function addresses. Address may be located
                             anywhere inside function.
        :param name: output list of function names. On output it has the same
                   number of elements as 'addresses'.
        :type types: :py:class:`IntVector`
        :param types: output list of symbol type at address. Can be IConnectDebug.sFunctions,
                         IConnectDebug.sLabels, or IConnectDebug.sConstants if no function
                         or label is found at the given address.

        Python example: callHierarchy.py
        """
        return _connect.CAddressController_getFunctionNames(self, addresses, names, types)

    def getSourceLocation(self, *args) -> "isys::CLineLocation":
        return _connect.CAddressController_getSourceLocation(self, *args)

    @staticmethod
    def getTestPointIdPrefix() -> "std::string":
        r"""
        Returns const prefix used in search for test point location,
        when matching type is set to E_MATCH_TEST_POINT_ID.
        """
        return _connect.CAddressController_getTestPointIdPrefix()

# Register CAddressController in _connect:
_connect.CAddressController_swigregister(CAddressController)

def CAddressController_getTestPointIdPrefix() -> "std::string":
    r"""
    Returns const prefix used in search for test point location,
    when matching type is set to E_MATCH_TEST_POINT_ID.
    """
    return _connect.CAddressController_getTestPointIdPrefix()

class CBreakpointController(object):
    r"""
    This class controls breakpoints on target.


    Python example for method setBP(): readTargetVariable.py 

    Python example for method setHWBP(): hwBreakpoints.py 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        Python example: breakpointExample.py 
        """
        _connect.CBreakpointController_swiginit(self, _connect.new_CBreakpointController(connectionMgr))
    __swig_destroy__ = _connect.delete_CBreakpointController

    def setBP(self, *args) -> "int":
        r"""
        *Overload 1:*

        Sets breakpoint at the given symbol.

        :type symbolName: string
        :param symbolName: name of symbol in target program, for example
                              function name.
        :type conditionCount: int, optional
        :param conditionCount: the number of times condition has to be met for breakpoint to trigger
        :type conditionExpression: string, optional
        :param conditionExpression: condition that has to be met for breakpoint to trigger

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set

        Python example: breakpointExample.py 

        Python example: readTargetVariable.py 


        |

        *Overload 2:*

        Sets breakpoint at the given location in source code.

        :type lineNumber: int
        :param lineNumber: line number in source file
        :type fileName: string
        :param fileName: name of source code file
        :type conditionCount: int, optional
        :param conditionCount: the number of times condition has to be met for breakpoint to trigger
        :type conditionExpression: string, optional
        :param conditionExpression: condition that has to be met for breakpoint to trigger

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set

        Python example: breakpointExample.py 


        |

        *Overload 3:*

        Sets breakpoint at the given location in source code.

        :type lineNumber: int
        :param lineNumber: line number in source file
        :type fileName: string
        :param fileName: name of source code file
        :type conditionCount: int, optional
        :param conditionCount: the number of times condition has to be met for breakpoint to trigger
        :param conditionExpression: condition that has to be met for breakpoint to trigger

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set

        Python example: breakpointExample.py 


        |

        *Overload 4:*

        Sets breakpoint at the given location in source code.

        :type lineNumber: int
        :param lineNumber: line number in source file
        :type fileName: string
        :param fileName: name of source code file
        :param conditionCount: the number of times condition has to be met for breakpoint to trigger
        :param conditionExpression: condition that has to be met for breakpoint to trigger

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set

        Python example: breakpointExample.py 


        |

        *Overload 5:*

        Sets breakpoint at the given address.

        :type memArea: int
        :param memArea: memory area of the breakpoint
        :type address: int
        :param address: address to set the breakpoint
        :type conditionCount: int, optional
        :param conditionCount: the number of times condition has to be met for breakpoint to trigger
        :type conditionExpression: string, optional
        :param conditionExpression: condition that has to be met for breakpoint to trigger

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set

        Python example: breakpointExample.py 


        |

        *Overload 6:*

        Sets breakpoint at the given address.

        :type memArea: int
        :param memArea: memory area of the breakpoint
        :type address: int
        :param address: address to set the breakpoint
        :type conditionCount: int, optional
        :param conditionCount: the number of times condition has to be met for breakpoint to trigger
        :param conditionExpression: condition that has to be met for breakpoint to trigger

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set

        Python example: breakpointExample.py 


        |

        *Overload 7:*

        Sets breakpoint at the given address.

        :type memArea: int
        :param memArea: memory area of the breakpoint
        :type address: int
        :param address: address to set the breakpoint
        :param conditionCount: the number of times condition has to be met for breakpoint to trigger
        :param conditionExpression: condition that has to be met for breakpoint to trigger

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set

        Python example: breakpointExample.py 
        """
        return _connect.CBreakpointController_setBP(self, *args)

    def setHWBP(self, *args) -> "int":
        r"""
        *Overload 1:*

        Sets hardware breakpoint on the given variable or symbol. This
        method can set only the most basic parameters of one hardware
        breakpoint. If you'd like to set more than one HW breakpoint,
        or options not supported by this method, please set winIDEA options.
        To find options, set some value in HW breakpoint dialog in winIDEA,
        then search for it in winIDEA `Help | Display Options ...`

        Example for PowerPC:

            import isystem.connect as ic

            cmgr = ic.ConnectionMgr()
            cmgr.connectMRU('')

            ide = ic.CIDEController(cmgr)

            #configure the breakpoint
            strRoot = '/iOPEN/Breakpoints.PPC55xx.BP.'
            strCore = '1'
            ide.setOption(strRoot + 'HW.Enabled'              , 'true')
            ide.setOption(strRoot + 'HW.e200[' + strCore + '].Enabled'      , 'true')
            ide.setOption(strRoot + 'HW.e200[' + strCore + '].DAC_Enable[0]', 'true')
            ide.setOption(strRoot + 'HW.e200[' + strCore + '].DAC_Access[0]', 'WR')
            ide.setOption(strRoot + 'e200[' + strCore + '].DAC_Address[0]'  , 'VariableName')

            #apply it to the MCU
            print (ide.serviceCall('/iOPEN/Core.Debug.ApplyInternalBPs', ''))

        :type rwAccess: int
        :param rwAccess: defines read/write access. Should be one of
                            IConnectDebug::EBreakpointFlags
                            which start with ``bHW_acc...:``
                            - IConnectDebug::bHW_accAny
                            - IConnectDebug::bHW_accRD
                            - IConnectDebug::bHW_accWR
                            - IConnectDebug::bHW_accRW
                            - IConnectDebug::bHW_accFetch

        :type accessSize: int
        :param accessSize: defines the size of access area. Should be one
                   of IConnectDebug::EBreakpointFlags which start with
                   bHW_Size...:
                   - IConnectDebug::bHW_SizeDefault
                   - IConnectDebug::bHW_Size1
                   - IConnectDebug::bHW_Size2
                   - IConnectDebug::bHW_Size4
                   - IConnectDebug::bHW_Size8

        :type usedDataBytes: int
        :param usedDataBytes: determines which byte of ``data`` is used for data value
                   comparison (00 = no data, FF = all). It can be set as ORed value of
                   IConnectDebug::EBreakpointFlags which start with ``bHW_Data...:``
                   - IConnectDebug::bHW_DataLSB0
                   - IConnectDebug::bHW_DataLSB1
                   - IConnectDebug::bHW_DataLSB2
                   - IConnectDebug::bHW_DataLSB3

        :type isEntireObject: boolean
        :param isEntireObject: if true, all addresses occupied by object will be
                   monitored, otherwise only the first address is monitored. For example,
                   if symbol is array or struct, any address occupied by the symbol
                   may trigger a breakpoint.

        :type symbolName: string
        :param symbolName: name of symbol in target program, for example
                              variable name.

        :type data: int
        :param data: value used for comparison (access breakpoints only)

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set

        Python example: hwBreakpoints.py 


        |

        *Overload 2:*

        Sets hardware breakpoint on the given address.
        See setHWBP(DWORD, DWORD, DWORD, bool, const std::string &, DWORD)
        for limitations of this method and how to overcome them.

        :type rwAccess: int
        :param rwAccess: defines read/write access. Should be one of
                            IConnectDebug::EBreakpointFlags
                            which start with ``bHW_acc...:``
                            - IConnectDebug::bHW_accAny
                            - IConnectDebug::bHW_accRD
                            - IConnectDebug::bHW_accWR
                            - IConnectDebug::bHW_accRW
                            - IConnectDebug::bHW_accFetch

        :type accessSize: int
        :param accessSize: defines the size of access area. Should be one
                   of IConnectDebug::EBreakpointFlags which start with
                   bHW_Size...:
                   - IConnectDebug::bHW_SizeDefault
                   - IConnectDebug::bHW_Size1
                   - IConnectDebug::bHW_Size2
                   - IConnectDebug::bHW_Size4
                   - IConnectDebug::bHW_Size8

        :type usedDataBytes: int
        :param usedDataBytes: determines which byte of ``data`` is used for data value
                   comparison (00 = no data, FF = all). It can be set as ORed value of
                   IConnectDebug::EBreakpointFlags which start with ``bHW_Data...:``
                   - IConnectDebug::bHW_DataLSB0
                   - IConnectDebug::bHW_DataLSB1
                   - IConnectDebug::bHW_DataLSB2
                   - IConnectDebug::bHW_DataLSB3

        :type memArea: int
        :param memArea: memory area of address

        :type address: int
        :param address: address to be monitored

        :type data: int
        :param data: value used for comparison (access breakpoints only)

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set
        """
        return _connect.CBreakpointController_setHWBP(self, *args)

    def deleteBP(self, *args) -> "int":
        r"""
        *Overload 1:*

        Deletes breakpoint at the given symbol name.

        :type symbolName: string
        :param symbolName: name of symbol in target program, for example
                              function name.

        :rtype: int
        :return: 0 if there was breakpoint before this call (it was deleted),
                    1 if the breakpoint at this location did not exist

        Python example: breakpointExample.py 


        |

        *Overload 2:*

        Deletes breakpoint at the given location in source code.

        :type fileName: string
        :param fileName: name of source code file
        :type lineNumber: int
        :param lineNumber: line number in source file

        :rtype: int
        :return: 0 if operation was successful, 1 if operation was not executed as expected,
            but the target is in the expected state. For example, if there was no breakpoint at the
            specified location, then 1 is returned, because it was not removed, but after the
            method returns there is no breakpoint, as it is expected.

        Python example: breakpointExample.py 


        |

        *Overload 3:*

        Deletes breakpoint at the given address.

        :type memArea: int
        :param memArea: memory area of the breakpoint
        :type address: int
        :param address: address of the existing breakpoint

        :rtype: int
        :return: 0 if operation was successful, 1 if operation was not executed as expected,
            but the target is in the expected state. For example, if there was no breakpoint at the
            specified location, then 1 is returned, because it was not removed, but after the
            method returns there is no breakpoint, as it is expected.

        Python example: breakpointExample.py 
        """
        return _connect.CBreakpointController_deleteBP(self, *args)

    def deleteHWBP(self, *args) -> "int":
        r"""
        *Overload 1:*

        Deletes hardware breakpoint at the given symbol name.

        :type symbolName: string
        :param symbolName: name of symbol in target program, for example
                              function name.

        :rtype: int
        :return: 0 if operation was successful, 1 if operation was not executed as expected,
            but the target is in the expected state. For example, if there was no breakpoint at the
            specified location, then 1 is returned, because it was not removed, but after the
            method returns there is no breakpoint, as it is expected.

        |

        *Overload 2:*

        Deletes hardware breakpoint at the given address.

        :type memArea: int
        :param memArea: memory area of the breakpoint
        :type address: int
        :param address: address of the breakpoint

        :rtype: int
        :return: 0 if operation was successful, 1 if operation was not executed as expected,
            but the target is in the expected state. For example, if there was no breakpoint at the
            specified location, then 1 is returned, because it was not removed, but after the
            method returns there is no breakpoint, as it is expected.
        """
        return _connect.CBreakpointController_deleteHWBP(self, *args)

    def deleteAll(self) -> "int":
        r"""
        Deletes all execution breakpoints.

        :rtype: int
        :return: 0 if there were breakpoints to delete,
                    1 if no breakpoints were deleted because none existed.

        Python example: breakpointExample.py 
        """
        return _connect.CBreakpointController_deleteAll(self)

    def deleteAllHWBP(self) -> "int":
        r"""
        Deletes all hardware breakpoints.

        :rtype: int
        :return: 0 if there were breakpoints to delete,
                    1 if no breakpoints were deleted because none existed.
        """
        return _connect.CBreakpointController_deleteAllHWBP(self)

    def setEnabled(self, *args) -> "int":
        r"""
        *Overload 1:*

        Enables / disables the breakpoint at the given symbol name.

        :type isEnabled: boolean
        :param isEnabled: set to true to enable the breakpoint, false to disable it
        :type symbolName: string
        :param symbolName: name of symbol in target program, for example
                              function name.

        Python example: breakpointExample.py 


        |

        *Overload 2:*

        Enables / disables the breakpoint at the given source line.

        :type isEnabled: boolean
        :param isEnabled: set to true to enable the breakpoint, false to disable it
        :type fileName: string
        :param fileName: name of source code file
        :type lineNumber: int
        :param lineNumber: line number in source file

        Python example: breakpointExample.py 


        |

        *Overload 3:*

        Enables / disables the breakpoint at the given address.

        :type isEnabled: boolean
        :param isEnabled: set to true to enable the breakpoint, false to disable it
        :type memArea: int
        :param memArea: memory area of the breakpoint
        :type address: int
        :param address: address of the breakpoint

        Python example: breakpointExample.py 
        """
        return _connect.CBreakpointController_setEnabled(self, *args)

    def setHWEnabled(self, *args) -> "int":
        r"""
        *Overload 1:*

        Enables / disables hardware breakpoint at the given symbol name.

        :type isEnabled: boolean
        :param isEnabled: set to true to enable the breakpoint, false to disable it
        :type symbolName: string
        :param symbolName: name of symbol in target program, for example
                              function name.

        |

        *Overload 2:*

        Enables / disables hardware breakpoint at the given address.

        :type isEnabled: boolean
        :param isEnabled: set to true to enable the breakpoint, false to disable it
        :type memArea: int
        :param memArea: memory area of the breakpoint
        :type address: int
        :param address: address of the breakpoint
        """
        return _connect.CBreakpointController_setHWEnabled(self, *args)

    def setHWEnabledAll(self, isEnabled: "bool") -> "int":
        r"""
        Sets enabled status of all **hardware** breakpoints.

        :type isEnabled: boolean
        :param isEnabled: set to true to enable breakpoints, false to disable them
        """
        return _connect.CBreakpointController_setHWEnabledAll(self, isEnabled)

    def setEnabledAll(self, isEnabled: "bool") -> "int":
        r"""
        Sets enabled status of all breakpoints.

        :type isEnabled: boolean
        :param isEnabled: set to true to enable breakpoints, false to disable them

        Python example: breakpointExample.py 
        """
        return _connect.CBreakpointController_setEnabledAll(self, isEnabled)

    def reapplyAll(self) -> "int":
        r"""
        Reapplies all currently active breakpoints. Use this method, if your
        application has overwritten software breakpoints, for example when
        the code in RAM is overwritten by target application after download.
        """
        return _connect.CBreakpointController_reapplyAll(self)

# Register CBreakpointController in _connect:
_connect.CBreakpointController_swigregister(CBreakpointController)

class CDAQSample(object):
    r"""
    Sample acquired by the DAQ system.

    dataRecorderWithDAQ.py Python example
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CDAQSample_swiginit(self, _connect.new_CDAQSample())

    def getIndex(self) -> "WORD":
        r""" index of the DAQ item"""
        return _connect.CDAQSample_getIndex(self)

    def getCoreID(self) -> "WORD":
        r""" CPU Core ID"""
        return _connect.CDAQSample_getCoreID(self)

    def getTime(self) -> "QWORD":
        r"""Returns time of acquisition in microseconds."""
        return _connect.CDAQSample_getTime(self)

    def getData(self) -> "std::vector< BYTE,std::allocator< BYTE > > const &":
        r""" acquisition data in flat memory layout. Use CDAQController.getDataValue to extract a well formed type"""
        return _connect.CDAQSample_getData(self)

    def toString(self) -> "std::string":
        r""" Returns contents of this object in human readable form."""
        return _connect.CDAQSample_toString(self)
    __swig_destroy__ = _connect.delete_CDAQSample

# Register CDAQSample in _connect:
_connect.CDAQSample_swigregister(CDAQSample)

class CDAQInfo(object):
    r"""
    Capabilities information about the DAQ system.

    Python example: dataRecorderWithDAQ.py
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CDAQInfo_swiginit(self, _connect.new_CDAQInfo())

    def getMaxItems(self) -> "WORD":
        r""" maximum number of DAQ items configurable"""
        return _connect.CDAQInfo_getMaxItems(self)

    def getBufSize(self) -> "DWORD":
        r""" size of sample buffer"""
        return _connect.CDAQInfo_getBufSize(self)

    def getMaxItemSize(self) -> "BYTE":
        r"""
        :rtype: BYTE
        :return: maximum size of a DAQ item
        """
        return _connect.CDAQInfo_getMaxItemSize(self)

    def getTick_ns(self) -> "DWORD":
        r"""
        Deprecated: in 9.21.2, always returns 1000. Times returned by CDAQSample::getTime()
        are always in microseconds now, so this method is no longer needed.

        Returns duration of DAQ clock tick in ns. All times returned by methods in
        ``CDAQ`` classes are returned as the number of DAQ clock ticks. Use value
        returned by this method to calculate real time:

         realTimeInSeconds = daqTime * getTick_ns() / 1'000'000'000.0
        """
        return _connect.CDAQInfo_getTick_ns(self)

    def getCoreID(self) -> "BYTE":
        r"""
        Deprecated: in 9.21.2, always throws. Call CDAQSample::getCoreID() instead,
        because samples may be from different cores.
        """
        return _connect.CDAQInfo_getCoreID(self)

    def getNumItems(self) -> "WORD":
        r"""
        Deprecated: in 9.21.2, always throws. Call CDAQController::getNumItems() instead.

        :rtype: int
        :return: currently configured number of DAQ items
        """
        return _connect.CDAQInfo_getNumItems(self)

    def toString(self) -> "std::string":
        r""" Returns contents of this object in human readable form."""
        return _connect.CDAQInfo_toString(self)
    __swig_destroy__ = _connect.delete_CDAQInfo

# Register CDAQInfo in _connect:
_connect.CDAQInfo_swigregister(CDAQInfo)

class CDAQStatus(object):
    r"""
    Status information about the DAQ system.

    Python example: dataRecorderWithDAQ.py
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, qwTime: "QWORD", dwLastLoopTime: "DWORD", dwNumSamplesAvailable: "DWORD", dwNumLoops: "DWORD", bOverflow: "bool", bGlobalEnable: "bool"):
        _connect.CDAQStatus_swiginit(self, _connect.new_CDAQStatus(qwTime, dwLastLoopTime, dwNumSamplesAvailable, dwNumLoops, bOverflow, bGlobalEnable))

    def getTime(self) -> "QWORD":
        r""" Current time in DAQ ticks."""
        return _connect.CDAQStatus_getTime(self)

    def getLastLoopTime(self) -> "DWORD":
        r""" Maximum DAQ loop time since last status check."""
        return _connect.CDAQStatus_getLastLoopTime(self)

    def getNumSamplesAvailable(self) -> "DWORD":
        r""" Number of samples ready for readout."""
        return _connect.CDAQStatus_getNumSamplesAvailable(self)

    def getNumLoops(self) -> "DWORD":
        r""" Number of loops executed since configuration reset."""
        return _connect.CDAQStatus_getNumLoops(self)

    def getOverflow(self) -> "bool":
        r""" Indicates whether an overflow in the DAQ sample buffer has occurred since last status check."""
        return _connect.CDAQStatus_getOverflow(self)

    def getGlobalEnable(self) -> "bool":
        r""" Returns ``true`` if global DAQ sampling is enabled."""
        return _connect.CDAQStatus_getGlobalEnable(self)

    def getCoreEnable(self) -> "bool":
        r"""
        Deprecated: in 9.21.2. Always returns the same value as getGlobalEnable().

        Returns ``true`` if DAQ sampling on this core is enabled.
        """
        return _connect.CDAQStatus_getCoreEnable(self)

    def toString(self) -> "std::string":
        r""" Returns contents of this object in human readable form."""
        return _connect.CDAQStatus_toString(self)
    __swig_destroy__ = _connect.delete_CDAQStatus

# Register CDAQStatus in _connect:
_connect.CDAQStatus_swigregister(CDAQStatus)

class CDAQController(object):
    r"""
    This class controls DAQ (Data AcQuisition) system. It enables acquisition of
    data on target in non-blocking mode, but time precision is not as exact as
    with batch access, which is a blocking call.

    Call methods in the following sequence:

        attachHW()
        info()
        configure()
        enableGlobal(True)  // starts reading vars and placing them in DAQ buffer
        [status(),] read()  // repeat
        enableGlobal(False) // stops reading vars, but DAQ buffer may contain yet unread data
        [status(),] Read,   // repeat until done
        detachHW()

    Python example: dataAcquisition.py 

    Python example: dataRecorderWithDAQ.py 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    daqSampleMax = _connect.CDAQController_daqSampleMax
    r""" maximum sampling"""
    daqSample1ms = _connect.CDAQController_daqSample1ms
    r""" 1ms   sampling resolution"""
    daqSample10ms = _connect.CDAQController_daqSample10ms
    r""" 10ms  sampling resolution"""
    daqSample100ms = _connect.CDAQController_daqSample100ms
    r""" 100ms sampling resolution"""
    daqSample1s = _connect.CDAQController_daqSample1s
    r""" 1 s   sampling resolution"""

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        Python example: dataRecorderWithDAQ.py
        """
        _connect.CDAQController_swiginit(self, _connect.new_CDAQController(connectionMgr))
    __swig_destroy__ = _connect.delete_CDAQController

    def attachHW(self) -> "void":
        r"""
        Attach to DAQ engine.

        Python example: dataRecorderWithDAQ.py
        """
        return _connect.CDAQController_attachHW(self)

    def detachHW(self) -> "void":
        r"""
        Detach from DAQ engine.

        Python example: dataRecorderWithDAQ.py
        """
        return _connect.CDAQController_detachHW(self)

    def configReset(self) -> "void":
        r"""
        Deprecated: in 9.21.2 and later. If you are still using
                    the deprecated `configAdd()` methods, call
                    this method to clear all added samples.

        Resets DAQ configuration.

        Python example: dataRecorderWithDAQ.py
        """
        return _connect.CDAQController_configReset(self)

    def configAdd(self, *args) -> "DWORD":
        r"""
        *Overload 1:*

        Deprecated: in 9.21.2, use method `configure()`.

        Adds a DAQ item to configuration.

        :param bySize: size of the item in bytes
        :param byMemArea: memory area of the item
        :param aAddress: address of the item
        :param bySampling: sampling policy

        :rtype: int
        :return: the handle/index of the item. This value will be reported in the acquired samples.

        Python example: dataRecorderWithDAQ.py

        |

        *Overload 2:*

        Deprecated: in 9.21.2, use method `configure()`.

        Adds a DAQ item to configuration.

        :type symbol: string
        :param symbol: name of the variable to monitor
        :param bySampling: sampling policy

        :rtype: int
        :return: the handle/index of the item. This value will be reported in the acquired samples.

        Python example: dataRecorderWithDAQ.py

        |

        *Overload 3:*

        Deprecated: in 9.21.2, use method `configure()`.

        Adds a DAQ item to configuration.

        :type symbol: string
        :param symbol: name of the variable to monitor
        :param bySampling: sampling policy

        :rtype: int
        :return: the handle/index of the item. This value will be reported in the acquired samples.

        Python example: dataRecorderWithDAQ.py
        """
        return _connect.CDAQController_configAdd(self, *args)

    def configure(self, configItems: "DAQConfigVector") -> "void":
        r"""
        Configures DAQ with the given items. It is not allowed to call
        `configure()` when DAQ is enabled (after `enagleGlobal(True)`
        was called and before `enableGlobal(False)` was called.)

        See also: CDAQConfigItem
        """
        return _connect.CDAQController_configure(self, configItems)

    def getNumItems(self) -> "size_t":
        r"""
        :rtype: int
        :return: currently configured number of DAQ items
        """
        return _connect.CDAQController_getNumItems(self)

    def enableGlobal(self, enable: "bool") -> "void":
        r"""
        Enables or disables DAQ acquisition. This has to be enabled
        so that data can be acquired through the DAQ on any core. Call
        it after `configure()` or `configAdd()` calls.

        :type enable: boolean
        :param enable: defines whether the global DAQ is enabled or not

        Python example: dataRecorderWithDAQ.py
        """
        return _connect.CDAQController_enableGlobal(self, enable)

    def enableCore(self, enable: "bool") -> "void":
        r"""
        Deprecated: in 9.21.2 and later this method has no effect. You may
                    remove it from your code.

        Enables or disables DAQ acquisition on this particular core. This has to
        be enabled so that data can be acquired through the DAQ on this particular
        core.

        :type enable: boolean
        :param enable: defines whether DAQ on the controlled core is enabled or not

        Python example: dataRecorderWithDAQ.py
        """
        return _connect.CDAQController_enableCore(self, enable)

    def info(self) -> "isys::CDAQInfo":
        r"""
        Returns the information about DAQ capabilities.

        Python example: dataRecorderWithDAQ.py
        """
        return _connect.CDAQController_info(self)

    def status(self) -> "isys::CDAQStatus":
        r"""
        Returns the current status of the DAQ system.

        Python example: dataRecorderWithDAQ.py
        """
        return _connect.CDAQController_status(self)

    def read(self, samples: "DAQSampleVector", maxSamples: "DWORD"=0) -> "void":
        r"""
        Reads acquired data.

        :param dwMaxSamples: defines the maximum number of samples to read. If 0
                   is specified, all current acquired samples will be loaded. Not
                   used in SDK versions 9.21.2 and later.

        :rtype: void
        :return: the acquired DAQ samples.

        Python example: dataRecorderWithDAQ.py
        """
        return _connect.CDAQController_read(self, samples, maxSamples)

    def getDataValue(self, sample: "CDAQSample") -> "isys::CValueType":
        r"""
        Returns the value of the acquired sample in CValueType format.
        If sample configuration was given as address and size (not with
        symbol name), then unsigned integral type is assumed.

        :type sample: :py:class:`CDAQSample`
        :param sample: previously acquired sample.

        :rtype: :py:class:`CValueType`
        :return: value in CValueType format

        Python example: dataRecorderWithDAQ.py
        """
        return _connect.CDAQController_getDataValue(self, sample)

# Register CDAQController in _connect:
_connect.CDAQController_swigregister(CDAQController)

class CDAQConfigItem(object):
    r"""This class contains configuration of one DAQ item."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Creates DAQ sampling item at the given address in memory. Core and SoC
        indices are set to 0.

        :param bySize: size of the item in bytes
        :param byMemArea: memory area of the item
        :param aAddress: address of the item
        :param bySampling: sampling policy

        |

        *Overload 2:*

        Creates DAQ sampling item at the given address in memory. Core and SoC
        indices are set to 0.

        :param bySize: size of the item in bytes
        :param byMemArea: memory area of the item
        :param aAddress: address of the item
        :param bySampling: sampling policy

        |

        *Overload 3:*

        Creates DAQ sampling item at the given address in memory. Core and SoC
        indices are set to 0.

        :param bySize: size of the item in bytes
        :param byMemArea: memory area of the item
        :param aAddress: address of the item
        :param bySampling: sampling policy

        |

        *Overload 4:*

        Creates DAQ sampling item at the given address in memory. Core and SoC
        indices are set to 0.

        :param bySize: size of the item in bytes
        :param byMemArea: memory area of the item
        :param aAddress: address of the item
        :param bySampling: sampling policy

        |

        *Overload 5:*

        Creates DAQ sampling item for the given symbol in memory.

        :param symbol: name of the variable to monitor
        :param bySampling: sampling policy

        |

        *Overload 6:*

        Creates DAQ sampling item for the given symbol in memory.

        :param symbol: name of the variable to monitor
        :param bySampling: sampling policy

        |

        *Overload 7:*

        Creates DAQ sampling item for the given symbol in memory.

        :param symbol: name of the variable to monitor
        :param bySampling: sampling policy

        |

        *Overload 8:*

        Creates DAQ sampling item for the given symbol in memory.

        :param symbol: name of the variable to monitor
        :param bySampling: sampling policy

        |

        *Overload 9:*

        Creates DAQ sampling item for program counter register (PC).

        :param bySize: size of the PC in bytes
        :param bySampling: sampling policy

        |

        *Overload 10:*

        Creates DAQ sampling item for program counter register (PC).

        :param bySize: size of the PC in bytes
        :param bySampling: sampling policy

        |

        *Overload 11:*

        Creates DAQ sampling item for program counter register (PC).

        :param bySize: size of the PC in bytes
        :param bySampling: sampling policy

        |

        *Overload 12:*

        Creates DAQ sampling item for program counter register (PC).

        :param bySize: size of the PC in bytes
        :param bySampling: sampling policy
        """
        _connect.CDAQConfigItem_swiginit(self, _connect.new_CDAQConfigItem(*args))

    def toString(self) -> "std::string":
        r""" Returns contents of this object in human readable form."""
        return _connect.CDAQConfigItem_toString(self)
    __swig_destroy__ = _connect.delete_CDAQConfigItem

# Register CDAQConfigItem in _connect:
_connect.CDAQConfigItem_swigregister(CDAQConfigItem)

class CValueType(object):
    r"""
    This is a wrapper class for iConnect SType and SValue. Since some languages do
    not support unions, there are special getter methods for obtaining the value.

    **Important:** If there was an error in evaluation, this class will contain
    error description instead of the value. Method isError() should be called
    always when an instance of this class is returned from ``isystem.connect`` methods,
    for example CDataController::evaluate() or CDataController::readValue().

    This class is immutable.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EDecimal = _connect.CValueType_EDecimal
    r"""
    All integers, from 8 to 64-bit, are returned as string in decimal format.
    Has no effect for other types like floats or addresses.
    """
    EHex = _connect.CValueType_EHex
    r"""
    All integers, from 8 to 64-bit, are returned as string in hexadecimal format.
    Has no effect for other types like floats or addresses.
    """
    EChar = _connect.CValueType_EChar
    r""" 8-bit integers in range 32-127 are returned as characters"""

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new object with type and value.

        |

        *Overload 2:*

        Initializes new object with type, value, and string result of
        evaluation.

        |

        *Overload 3:*

        This ctor sets 64 bit integer value.

        :type type: :py:class:`SType`
        :param type: must be set to tSigned or tUnsigned, bit size must be
                   less than 65.
        :type value: int
        :param value: the value

        |

        *Overload 4:*

        This ctor sets float value.

        :type type: :py:class:`SType`
        :param type: must be set to tFloat, bit size must be 32 or 64.
        :type value: float
        :param value: the value

        |

        *Overload 5:*

        This ctor sets double value.

        :type type: :py:class:`SType`
        :param type: must be set to tFloat, bit size must be 64.
        :type value: float
        :param value: the value

        |

        *Overload 6:*

        This ctor initializes object with signed data.

        :type bitSize: int
        :param bitSize: size of value in bits
        :type value: int
        :param value: the value

        |

        *Overload 7:*

        This ctor initializes object with signed data.

        :type bitSize: int
        :param bitSize: size of value in bits
        :type value: int
        :param value: the value

        |

        *Overload 8:*

        This ctor sets 32 bit float value as follows:

        SType.m_byType = tFloat;
        SType.m_byBitSize = 32;


        :type value: float
        :param value: the value

        |

        *Overload 9:*

        This ctor sets 64 bit float value as follows:

        SType.m_byType = tFloat;
        SType.m_byBitSize = 64;


        :type value: float
        :param value: the value

        |

        *Overload 10:*

        This ctor sets address value.

        :type type: :py:class:`SType`
        :param type: must be set to tAddress
        :type address: :py:class:`CAddress`
        :param address: the address

        |

        *Overload 11:*

        This ctor sets numeric values and string value, depending on the type
        specified. It is preferred to use this method from Java for unsigned types.

        :type type: :py:class:`SType`
        :param type: the type, no restrictions
        :type value: string
        :param value: string containing integer to be set. Example: "324".
                         Only characters up to first non-digit character are used.

        |

        *Overload 12:*

        This ctor is used to report error. Used for example wehn reading SFRs,
        since some SFRs can not be read due to access restrictions, while
        most of them are read without problems.

        :type errorMsg: string
        :param errorMsg: string containing error description
        """
        _connect.CValueType_swiginit(self, _connect.new_CValueType(*args))

    def isError(self) -> "bool":
        r"""
        Returns true, if the object contains error message instead of value.
        Call getResult() to get the error message.
        """
        return _connect.CValueType_isError(self)

    def getType(self) -> "SType const &":
        r"""
        Returns iConnect type. It is preferred to use one of 'isType...()'
         and 'getBitSize()' methods instead of this one.
        """
        return _connect.CValueType_getType(self)

    def getValue(self) -> "SValue const &":
        r""" Returns iConnect value."""
        return _connect.CValueType_getValue(self)

    def getResult(self, *args) -> "std::string const":
        r"""
        *Overload 1:*

        Returns string value, which is either the evaluation result or error
        message if isError() returns true. This method should be used for
        logging or debugging only. Use other getters to obtain values
        for further processing.

        |

        *Overload 2:*

        Returns string value, which is either the evaluation result or error
        message if isError() returns true.
        This method should be used for logging or debugging only. Use other
        getters to obtain values for further processing.

        :type format: int
        :param format: result format has effect only for integer values.
        """
        return _connect.CValueType_getResult(self, *args)

    def isTypeUnsigned(self) -> "bool":
        r""" Returns true, if the value is of unsigned type."""
        return _connect.CValueType_isTypeUnsigned(self)

    def isTypeSigned(self) -> "bool":
        r""" Returns true, if the value is of signed type."""
        return _connect.CValueType_isTypeSigned(self)

    def isTypeFloat(self) -> "bool":
        r""" Returns true, if the value is of float type."""
        return _connect.CValueType_isTypeFloat(self)

    def isTypeAddress(self) -> "bool":
        r""" Returns true, if the value is of address type."""
        return _connect.CValueType_isTypeAddress(self)

    def isTypeCompound(self) -> "bool":
        r""" Returns true, if the value is of signed type."""
        return _connect.CValueType_isTypeCompound(self)

    def getBitSize(self) -> "int":
        r""" Returns size of value in bits."""
        return _connect.CValueType_getBitSize(self)

    def getInt(self) -> "int":
        r"""
        Returns integer value for bit sizes 8, 16, and 32.

        :raises: IOException if bit size given in ctor does not
                     match 8, 16, or 32, or type is not tSigned or tUnsigned.
        """
        return _connect.CValueType_getInt(self)

    def getLong(self) -> "long long":
        r"""
        Returns long integer value for bit sizes 8, 16, 32, and 64.

        :raises: IOException if bit size given in ctor does not
                     match 8, 16, 32, or 64, or type is not tSigned or tUnsigned.
        """
        return _connect.CValueType_getLong(self)

    def getFloat(self) -> "float":
        r"""
        Returns float value. If the value is of type integer it is converted to float.

        :raises: IOException if bit size is not 32, or type is not
                                tSigned, or tUnsigned, or tFloat
        """
        return _connect.CValueType_getFloat(self)

    def getDouble(self) -> "double":
        r"""
        Returns double value. If the value is of type integer or float, it is
        converted to double.

        :raises: IOException if bit size is not 32, or 64, or type is not
                                tSigned, or tUnsigned, or tFloat
        """
        return _connect.CValueType_getDouble(self)

    def getAddress(self) -> "CAddress":
        r"""
        Returns address.

        :raises: IOException if type is not  tSigned, or tUnsigned, or tFloat.
        """
        return _connect.CValueType_getAddress(self)
    __swig_destroy__ = _connect.delete_CValueType

# Register CValueType in _connect:
_connect.CValueType_swigregister(CValueType)

class CVariable(object):
    r"""
    This immutable class contains information about variable or function
    parameter.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Instantiates object. Constructor is not intended to be used by clients.

        |

        *Overload 2:*
        Instantiates object. Constructor is not intended to be used by clients.
        """
        _connect.CVariable_swiginit(self, _connect.new_CVariable(*args))

    def getName(self) -> "std::string":
        r""" Returns variable name."""
        return _connect.CVariable_getName(self)

    def getQualifiedName(self) -> "std::string":
        r""" Return qualified variable name."""
        return _connect.CVariable_getQualifiedName(self)

    def getType(self) -> "std::string":
        r""" Returns variable type as string."""
        return _connect.CVariable_getType(self)

    def getArrayDimension(self) -> "int64_t":
        r""" Returns variable type as string."""
        return _connect.CVariable_getArrayDimension(self)

    def getNumBytes(self) -> "int64_t":
        r""" Returns size in bytes. Deprecated, use getSize*64() instead."""
        return _connect.CVariable_getNumBytes(self)

    def getSize(self) -> "int64_t":
        r""" Returns size in bytes."""
        return _connect.CVariable_getSize(self)

    def getTypeAsEnum(self) -> "iEclipse::IVariable::EType":
        r""" Returns of variable type as enum value."""
        return _connect.CVariable_getTypeAsEnum(self)

    def getScope(self) -> "std::string":
        r""" Returns scope, for example class name."""
        return _connect.CVariable_getScope(self)
    __swig_destroy__ = _connect.delete_CVariable

# Register CVariable in _connect:
_connect.CVariable_swigregister(CVariable)

class CFunction(object):
    r"""This immutable class contains information about function."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r""" Instantiates object. Constructor is not intended to be used by clients."""
        _connect.CFunction_swiginit(self, _connect.new_CFunction(*args))

    def getName(self) -> "std::string":
        r""" Returns function name without any qualifiers like scope or parameters."""
        return _connect.CFunction_getName(self)

    def getQualifiedName(self) -> "std::string":
        r"""
        Returns function name. This name may not be fully qualified,
        but depends on setting in winiDEA (for example just enough decorated
        to be unique).
        """
        return _connect.CFunction_getQualifiedName(self)

    def getScope(self) -> "std::string":
        r""" Returns function scope, for example class name."""
        return _connect.CFunction_getScope(self)

    def getReturnType(self) -> "std::string":
        r""" Returns function's return type."""
        return _connect.CFunction_getReturnType(self)

    def getModuleIndex(self) -> "int":
        r""" Returns index of the source file."""
        return _connect.CFunction_getModuleIndex(self)

    def getParameters(self) -> "isys::VariableVector":
        r"""Returns function parameters."""
        return _connect.CFunction_getParameters(self)

    def getLocalVars(self) -> "isys::VariableVector":
        r"""Returns function local variables (including parameters)."""
        return _connect.CFunction_getLocalVars(self)

    def getCallsToFunction(self, functionAddresses: "AddressVector") -> "void":
        r"""
        Returns addresses, where calls to this function are located.

        See also: isys::CAddressController::getFunctionNames()

        Python example: callHierarchy.py
        """
        return _connect.CFunction_getCallsToFunction(self, functionAddresses)

    def getCallsFromFunction(self, functionAddresses: "AddressVector") -> "void":
        r"""
        Returns addresses of functions, which are called from this function.
        If some function is called from more than one location in this
        function, then its address appears more than once in ``functionAddresses``.

        See also: isys::CAddressController::getFunctionNames()

        Python example: callHierarchy.py
        """
        return _connect.CFunction_getCallsFromFunction(self, functionAddresses)
    __swig_destroy__ = _connect.delete_CFunction

# Register CFunction in _connect:
_connect.CFunction_swigregister(CFunction)

class CStackFrame(object):
    r"""This class contains information about one stack frame."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r""" Instantiates object. Constructor is not intended to be used by clients."""
        _connect.CStackFrame_swiginit(self, _connect.new_CStackFrame(*args))

    def getAddress(self) -> "int64_t":
        r""" Returns address of a stack frame."""
        return _connect.CStackFrame_getAddress(self)

    def getMemArea(self) -> "unsigned char":
        r"""
        Returns memory area of a stack frame. See MemArea.h for meaning of values
        returned by this function - make sure to see enum for your
        target architecture.
        """
        return _connect.CStackFrame_getMemArea(self)

    def getFileName(self) -> "std::string":
        r""" Returns name of file, where the execution point is located."""
        return _connect.CStackFrame_getFileName(self)

    def getLineNumber(self) -> "int":
        r""" Returns the source code line number, where the execution point is located."""
        return _connect.CStackFrame_getLineNumber(self)

    def getFunction(self) -> "isys::CFunction":
        r""" Returns function information."""
        return _connect.CStackFrame_getFunction(self)

    def getPartition(self) -> "int":
        r"""
        Returns index of download file, where this function is located.
        Use it as parameter to getSymbols() if module name is needed.
        """
        return _connect.CStackFrame_getPartition(self)
    __swig_destroy__ = _connect.delete_CStackFrame

# Register CStackFrame in _connect:
_connect.CStackFrame_swigregister(CStackFrame)

class CModule(object):
    r"""This immutable class contains information about source code file."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Instantiates object. Constructor is not intended to be used by clients.
        :type path: string
        :param path: source file name including folder relative to winIDEA workspace
                        or abs path, if the file is not below winIDEA workspace dir.
                        Example: 'src\comomn\main.c'
        :type name: string
        :param name: source file name without folder. Example: 'main.c'
        """
        _connect.CModule_swiginit(self, _connect.new_CModule(*args))

    def getPath(self) -> "std::string":
        r""" Returns file path."""
        return _connect.CModule_getPath(self)

    def getName(self) -> "std::string":
        r""" Returns file name."""
        return _connect.CModule_getName(self)
    __swig_destroy__ = _connect.delete_CModule

# Register CModule in _connect:
_connect.CModule_swigregister(CModule)

class CType(object):
    r"""This immutable class contains information about data type."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r""" Instantiates object. Constructor is not intended to be used by clients."""
        _connect.CType_swiginit(self, _connect.new_CType(*args))

    def getName(self) -> "std::string":
        r""" Returns type name."""
        return _connect.CType_getName(self)

    def getType(self) -> "SType2":
        r""" Returns type information."""
        return _connect.CType_getType(self)
    __swig_destroy__ = _connect.delete_CType

# Register CType in _connect:
_connect.CType_swigregister(CType)

class CTypedef(object):
    r"""This immutable class contains information about typedef."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r""" Instantiates object. Constructor is not intended to be used by clients."""
        _connect.CTypedef_swiginit(self, _connect.new_CTypedef(*args))

    def getTypedefName(self) -> "std::string":
        r""" Returns typedef name."""
        return _connect.CTypedef_getTypedefName(self)

    def getTypeName(self) -> "std::string":
        r""" Returns type name."""
        return _connect.CTypedef_getTypeName(self)
    __swig_destroy__ = _connect.delete_CTypedef

# Register CTypedef in _connect:
_connect.CTypedef_swigregister(CTypedef)

class CMemoryAccess(object):
    r""" This class contains information about available memory access types."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, accessInfo: "BYTE"):
        _connect.CMemoryAccess_swiginit(self, _connect.new_CMemoryAccess(accessInfo))

    def canRead(self) -> "bool":
        r""" Returns true, if read is available."""
        return _connect.CMemoryAccess_canRead(self)

    def canWrite(self) -> "bool":
        r""" Returns true, if writ is available."""
        return _connect.CMemoryAccess_canWrite(self)

    def canReadInRealtime(self) -> "bool":
        r""" Returns true, if read in real time is available."""
        return _connect.CMemoryAccess_canReadInRealtime(self)

    def canWriteInRealtime(self) -> "bool":
        r""" Returns true, if write in real time is available."""
        return _connect.CMemoryAccess_canWriteInRealtime(self)
    __swig_destroy__ = _connect.delete_CMemoryAccess

# Register CMemoryAccess in _connect:
_connect.CMemoryAccess_swigregister(CMemoryAccess)

class CSystemMemoryAreas(object):
    r"""
    This class contains information about system memory areas. This class
    is not intended to be instantiated by clients. Call
    CDataController::getSystemMemoryAreas() to get instance of this class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getMemAreaCodeVirtual(self) -> "int":
        r""" Returns virtual memory area of code symbols."""
        return _connect.CSystemMemoryAreas_getMemAreaCodeVirtual(self)

    def getMemAreaCodePhysical(self) -> "int":
        r""" Returns physical memory area of code."""
        return _connect.CSystemMemoryAreas_getMemAreaCodePhysical(self)

    def getMemAreaDataVirtual(self) -> "int":
        r""" Returns virtual memory area of data symbols."""
        return _connect.CSystemMemoryAreas_getMemAreaDataVirtual(self)

    def getMemAreaDataPhysical(self) -> "int":
        r""" Returns physical memory area of data."""
        return _connect.CSystemMemoryAreas_getMemAreaDataPhysical(self)

    def getMemAreaSFR(self) -> "int":
        r""" Returns memory area of SFR space."""
        return _connect.CSystemMemoryAreas_getMemAreaSFR(self)
    __swig_destroy__ = _connect.delete_CSystemMemoryAreas

# Register CSystemMemoryAreas in _connect:
_connect.CSystemMemoryAreas_swigregister(CSystemMemoryAreas)

class CStackUsage(object):
    r"""
    This class contains information about stack usage. Clients should not
    instantiate this class, call method CDataController::getStackUsage()
    to get instances of this class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CStackUsage_swiginit(self, _connect.new_CStackUsage())

    def getBase(self) -> "ADDRESS_64":
        r""" Returns base address of stack."""
        return _connect.CStackUsage_getBase(self)

    def getSize(self) -> "ADDRESS_64":
        r""" Returns size of stack."""
        return _connect.CStackUsage_getSize(self)

    def getUsed(self) -> "ADDRESS_64":
        r""" Returns used size of stack."""
        return _connect.CStackUsage_getUsed(self)
    __swig_destroy__ = _connect.delete_CStackUsage

# Register CStackUsage in _connect:
_connect.CStackUsage_swigregister(CStackUsage)

class CDataController(object):
    r"""
    This class enables access to data on the target - memory, variables,
    and registers.



    **Qualified Variable Names**

    When variables are specified by name, for example in ``evaluate()`` or
    ``modify()`` methods, it may happen that more than one variables in
    different source or download files share the same name. In such case
    we have to specify the fully qualified variable name in the following
    format:

    "<moduleName>"#<varName>,,<downloadFileName>

    where:
    - ``moduleName`` - name of the C source file, which contains variable
    - ``varName`` - name of the variable
    - ``downloadFileName`` - name of the download file, where the variable is located

    Example:

    "main.c"#iCounter,,executable.elf


    The same syntax is used for function names, see also
    CAddressController::getFunctionName().


    Another type of variables are function static variables, which have to
    be prefixed with ``<functionName>##``, for example:

    myFunction##myStaticVar


    The same syntax can be used in winIDEA's Watch window.


    batchAccess.py Python example for batch access. 

    dataRecorder.py Python module for batch access and watch expressions. 

    variablesChart.py Python module for plotting of watch expressions. 

    debugIdeTraceProfilerCoverageSample.py Python example for data handling methods. 

    listFunctions.py Python example for method getSymbols(). 

    evaluateExpression.py Python example for method evaluate(). 

    readTargetVariable.py Another Python example for method evaluate(). 

    readRegister.py Python example for method readRegister(). 

    writeRegister.py Python example for method writeRegister(). 

    webserver.py Python example with web server providing results of method evaluate(). 

    serviceFunctions.py Python example for service functions. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    estFunctions = _connect.CDataController_estFunctions
    r""" get functions"""
    estGlobalVariables = _connect.CDataController_estGlobalVariables
    r""" get global variables"""
    estModules = _connect.CDataController_estModules
    r""" get modules"""
    PARTITION_DEFAULT = _connect.CDataController_PARTITION_DEFAULT
    r""" The default download file is sued."""
    PARTITION_CURRENT = _connect.CDataController_PARTITION_CURRENT
    r""" The current download file is used."""

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        Python example: listFunctions.py 
        """
        _connect.CDataController_swiginit(self, _connect.new_CDataController(connectionMgr))
    __swig_destroy__ = _connect.delete_CDataController

    def getCPUInfo(self) -> "CCPUInfo":
        r"""
        Returns CPU info. See definition of this struct in globdefs.h for enum
        constants which describe CPU type.
        """
        return _connect.CDataController_getCPUInfo(self)

    def getMemoryAreaBytesPerMAU(self, memArea: "int") -> "int":
        r"""
        Returns the number of bytes per addressable memory unit.

        :type memArea: int
        :param memArea: memory area for which to return the number

        Python example: codeStoreExample.py 
        """
        return _connect.CDataController_getMemoryAreaBytesPerMAU(self, memArea)

    def readMemory(self, accessFlags: "IConnectDebug::EAccessFlags", memArea: "BYTE", aAddress: "ADDRESS_64", aNumMAUs: "ADDRESS_64", bytesPerMAU: "BYTE") -> "std::vector< BYTE,std::allocator< BYTE > >":
        r"""
        This method reads memory block and returns data and access info.
        Returned vector contains data in the first ``(aNumMAUs * bytesPerMAU)``
        bytes, and access info in ``aNumMAUs`` bytes at offset
        ``(aNumMAUs * bytesPerMAU)``.

        Access info bytes tell us, whether read for MAU succeeded or not. Each byte
        is set to ``ACCESS_OK`` or `ACCESS_FAIL`. These two constants are
        defined in globdefs.h.

        Contents of the returned vector:

            [(target memory data, size = aNumMAUs * bytesPerMAU) (access info, size = aNumMAUs)]


        :type accessFlags: int
        :param accessFlags: use IConnectDebug::EAccessFlags
        :type memArea: BYTE
        :param memArea: memory space. Definitions for individual
                           CPUs are provided in MemArea.h
        :type aAddress: int
        :param aAddress: address of the memory location
        :type aNumMAUs: int
        :param aNumMAUs: number of MAUs (memory addressable units) to read.

        :param byBytesPerMAU: Number of BYTE type locations required to
              fit one MAU (memory addressable unit). The number of bytes
              required for every MAU is:

              | MAU Size in bits| Bytes Required per MAU|
              -------------------------------------------
              | 1 - 8           |             1         |
              | 9 - 16          |             2         |
              | 17 - 32         |             4         |

              Almost all microprocessors supported by our tools have 1 byte of
              data stored at one address, so this value is usually set to 1.
              winIDEA will check this parameter and return ICONNECT_E_SIZE in
              case of mismatch.

        :raises: IOException in case of an error


            Python example: debugIdeTraceProfilerCoverageSample.py 
        """
        return _connect.CDataController_readMemory(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU)

    def writeMemory(self, accessFlags: "IConnectDebug::EAccessFlags", memArea: "BYTE", aAddress: "ADDRESS_64", aNumMAUs: "ADDRESS_64", bytesPerMAU: "BYTE", buff: "VectorBYTE") -> "std::vector< BYTE,std::allocator< BYTE > >":
        r"""
        Writes block of data to target memory, and returns access information.

        :type accessFlags: int
        :param accessFlags: use IConnectDebug::EAccessFlags
        :type memArea: BYTE
        :param memArea: memory space. Definitions for individual
                           CPUs are provided in MemArea.h
        :type aAddress: int
        :param aAddress: address of the memory location
        :type aNumMAUs: int
        :param aNumMAUs: number of MAUs (memory addressable units) to read.

        :param byBytesPerMAU: Number of BYTE type locations required to
              fit one MAU (memory addressable unit). The number of bytes
              required for every MAU is:

              | MAU Size in bits| Bytes Required per MAU|
              -------------------------------------------
              | 1 - 8           |             1         |
              | 9 - 16          |             2         |
              | 17 - 32         |             4         |

              Almost all microprocessors supported by our tools have 1 byte of
              data stored at one address, so this value is usually set to 1.
              winIDEA will check this parameter and return ICONNECT_E_SIZE in
              case of mismatch.

        :type buff: std::vector< BYTE,std::allocator< BYTE > >
        :param buff: vector, which contains data to be written to memory on the target.
            Languages other than C++ should instantiate class ``VectorBYTE`` for this parameter.
            Examples:

            Python:
                buff = isystem.connect.VectorBYTE([0, 0, 0, 0xff])

            Java:
                VectorBYTE buff = new VectorBYTE();
                buff.add((short)0);
                buff.add((short)0);
                buff.add((short)0);
                buff.add((short)255);


        :raises: IOException in case of an error

        :rtype: std::vector< BYTE,std::allocator< BYTE > >
        :return: accessInfo contains write status, one byte per MAU for each MAU. Byte
            at index 0 contains access info for MAU at address **aAddress**, byte at index 1
            contains access info for MAU at address **aAddress** + **1**, ...
            See ACCESS_OK and ACCESS_FAIL in globdefs.h for possible values of access info bytes.


            Python example: debugIdeTraceProfilerCoverageSample.py
        """
        return _connect.CDataController_writeMemory(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU, buff)

    def writeMemoryNAI(self, accessFlags: "IConnectDebug::EAccessFlags", memArea: "BYTE", aAddress: "ADDRESS_64", aNumMAUs: "ADDRESS_64", bytesPerMAU: "BYTE", buff: "VectorBYTE") -> "void":
        r"""
        Writes block of data to target memory. This method is faster than
        writeMemory(), because no access information is returned.

        :type accessFlags: int
        :param accessFlags: use IConnectDebug::EAccessFlags
        :type memArea: BYTE
        :param memArea: memory space. Definitions for individual
                           CPUs are provided in MemArea.h
        :type aAddress: int
        :param aAddress: address of the memory location
        :type aNumMAUs: int
        :param aNumMAUs: number of MAUs (memory addressable units) to read.

        :param byBytesPerMAU: Number of BYTE type locations required to
              fit one MAU (memory addressable unit). The number of bytes
              required for every MAU is:

              | MAU Size in bits| Bytes Required per MAU|
              -------------------------------------------
              | 1 - 8           |             1         |
              | 9 - 16          |             2         |
              | 17 - 32         |             4         |

              Almost all microprocessors supported by our tools have 1 byte of
              data stored at one address, so this value is usually set to 1.
              winIDEA will check this parameter and return ICONNECT_E_SIZE in
              case of mismatch.

        :type buff: std::vector< BYTE,std::allocator< BYTE > >
        :param buff: vector, which contains data to be written to memory on the target.
            Languages other than C++ should instantiate class ``VectorBYTE`` for this parameter.
            Examples:

            Python:
                buff = isystem.connect.VectorBYTE([0, 0, 0, 0xff])

            Java:
                VectorBYTE buff = new VectorBYTE();
                buff.add((short)0);
                buff.add((short)0);
                buff.add((short)0);
                buff.add((short)255);


        :raises: IOException in case of an error

        See also: writeMemory()

        Python example: see debugIdeTraceProfilerCoverageSample.py
        for writeMemory() example.
        """
        return _connect.CDataController_writeMemoryNAI(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU, buff)

    def readRegister(self, accessFlags: "IConnectDebug::EAccessFlags", registerName: "std::string const &") -> "isys::CValueType":
        r"""
        Reads the specified general purpose register. For SFRs please use
        method evaluate().

        :type accessFlags: int
        :param accessFlags: see IConnectDebug::EAccessFlags for available flags, except
                               **fCacheCode**
        :type registerName: string
        :param registerName: name of the register to read

        :raises: IOException in case of an error

        Python example: readRegister.py 

        Python example: debugIdeTraceProfilerCoverageSample.py
        """
        return _connect.CDataController_readRegister(self, accessFlags, registerName)

    def writeRegister(self, accessFlags: "IConnectDebug::EAccessFlags", registerName: "std::string const &", registerInfo: "CValueType") -> "void":
        r"""
        Writes to the specified register. Example:

          # bit size is 32, value is 1234567
          r1Value = isystem.connect.CValueType(32, 1234567)
          debug.writeRegister(IConnectDebug.fMonitor, 'R1', r1Value)

        Longer way, if we use specific data types:

          # first we should define value type
          valueType = isystem.connect.SType()
          valueType.m_byType = isystem.connect.SType.tSigned
          valueType.m_byBitSize = 32

          # create 'Value' with type and value
          r0Value = isystem.connect.CValueType(valueType, 5678)

          debug.writeRegister(0, "R0", r0Value)


        :type accessFlags: int
        :param accessFlags: see IConnectDebug::EAccessFlags for available flags, except
                               **fCacheCode**
        :type registerName: string
        :param registerName: name of the register to write to
        :param value: a value to be written to the register

        :raises: IOException in case of an error

        Python example : writeRegister.py 

        Python example: debugIdeTraceProfilerCoverageSample.py
        """
        return _connect.CDataController_writeRegister(self, accessFlags, registerName, registerInfo)

    def readValue(self, accessFlags: "IConnectDebug::EAccessFlags", memArea: "BYTE", aAddress: "ADDRESS_64", type: "SType") -> "isys::CValueType":
        r"""
        Reads a value from the target system. This function resembles
        readMemory() but additionally it formats the value according to the
        type specified (including endian conversions).


        Example:

        debug = ic.CDebugFacade(cmgr)

        varType = ic.SType()
        varType.m_byBitSize = 32
        varType.m_byType = ic.SType.tSigned

        memArea = 0
        addr = 1073768999

        value = debug.readValue(ic.IConnectDebug.fMonitor, memArea, addr, varType)

        print "Result = ", value.getInt()


        :type accessFlags: int
        :param accessFlags: use IConnectDebug::EAccessFlags, except **fCore**, and **fSFR**
        :type memArea: BYTE
        :param memArea: memory area, definitions for individual CPUs are provided in MemArea.h
        :type aAddress: int
        :param aAddress: address of the memory location of the first access.
        :type type: :py:class:`SType`
        :param type: variable containing the type info of value to be read

        :raises: IOException in case of an error


            Python example: debugIdeTraceProfilerCoverageSample.py
        """
        return _connect.CDataController_readValue(self, accessFlags, memArea, aAddress, type)

    def writeValue(self, *args) -> "void":
        r"""
        *Overload 1:*

        Writes a value to the target system. This function resembles writeMemory()
        but additionally it formats the value according to the type
        specified (including endian conversions).

        :type accessFlags: int
        :param accessFlags: use IConnectDebug::EAccessFlags, except **fCore**, **fSFR**,
                               and **fCacheXXX**.
        :type memArea: BYTE
        :param memArea: memory space. Definitions for individual CPUs are provided in MemArea.h
        :type aAddress: int
        :param aAddress: address of the memory location of the first access
        :type value: :py:class:`CValueType`
        :param value: variable containing the value to write

        :raises: IOException in case of an error

        Python example: ideControllerExample.py

        |

        *Overload 2:*

        Writes a value to the target system. This function resembles writeMemory()
        but additionally it formats the value according to the type
        specified (including endian conversions).

        :type accessFlags: int
        :param accessFlags: use IConnectDebug::EAccessFlags, except **fCore**, **fSFR**,
                               and **fCacheXXX**.
        :type isNotRefreshWinIDEAGUIAfterWrite: boolean
        :param isNotRefreshWinIDEAGUIAfterWrite: if true, winIDEA windows are not refreshed after
                                                    write operation - this speeds up operation.
        :type memArea: BYTE
        :param memArea: memory space. Definitions for individual CPUs are provided in MemArea.h
        :type aAddress: int
        :param aAddress: address of the memory location of the first access
        :type value: :py:class:`CValueType`
        :param value: variable containing the value to write

        :raises: IOException in case of an error

        Python example: ideControllerExample.py
        """
        return _connect.CDataController_writeValue(self, *args)

    def evaluate(self, *args) -> "isys::CValueType":
        r"""
        *Overload 1:*

        Calls evaluate(IConnectDebug::EAccessFlags, IConnectDebug::EEvaluate, const std::string &expression)
        with ``evaluateFlags = IConnectDebug::efDefaultMemAreaDisplay``.


        Python example: debugIdeTraceProfilerCoverageSample.py 

        Python example with online value graph: chartSample.py 

        Simple Python example: evaluateExpression.py 

        Python module for plotting of watch expressions: variablesChart.py 

        Another Python example reading integer: readTargetVariable.py 

        Python example with web server providing results of this method: webserver.py 


        |

        *Overload 2:*

        Evaluates an expression. Works only for simple types.
        See also 'Qualified Variable Names'.

        :param dwAccessFlags: IConnectDebug::EAccessFlags determine what kind of
                                 memory access is permitted if required to resolve the expression
        :type evaluateFlags: int
        :param evaluateFlags: define result format
        :type expression: string
        :param expression: any C syntax expression. CPU registers (including SFRs)
                              can be used in expression with prefix '@', for example
                              '@R0'.

        :raises: IOException if complex type is given or in case of an error
        """
        return _connect.CDataController_evaluate(self, *args)

    def modify(self, *args) -> "std::string":
        r"""
        *Overload 1:*
         See modify(IConnectDebug::EAccessFlags, IConnectDebug::EEvaluate, const std::string &, const CValueType &, bool) .

        Python example: dataWriteModifyExample.py

        |

        *Overload 2:*
         See modify(IConnectDebug::EAccessFlags, IConnectDebug::EEvaluate, const std::string &, const CValueType &, bool) .



        Python example: dataWriteModifyExample.py

        |

        *Overload 3:*
         See modify(IConnectDebug::EAccessFlags, IConnectDebug::EEvaluate, const std::string &, const CValueType &, bool) .



        Python example: dataWriteModifyExample.py

        |

        *Overload 4:*

        Modifies expression to value. The expression must evaluate to
        a *lvalue*.
        See also 'Qualified Variable Names'.

        :type accessFlags: int
        :param accessFlags: determines what kind of
                                 memory access is permitted if required to resolve the expression,
        :type evaluateFlags: int
        :param evaluateFlags: define result format.
        :type expression: string
        :param expression: any C syntax expression that evaluates to a lvalue
        :type value: :py:class:`CValueType`
        :param value: contains the value to write to **expression**
        :type readBack: boolean, optional
        :param readBack: set to false to skip reading back the value

        :rtype: string
        :return: result of evaluation as string or error description in case of error.
                           For example for expression 'a = 10' return value is '10'.

        :raises: IOException in case of an error

        Python example: dataWriteModifyExample.py

        |

        *Overload 5:*

        Modifies expression to value. The expression must evaluate to
        a *lvalue*.
        See also 'Qualified Variable Names'.

        :type accessFlags: int
        :param accessFlags: determines what kind of
                                 memory access is permitted if required to resolve the expression,
        :type evaluateFlags: int
        :param evaluateFlags: define result format.
        :type expression: string
        :param expression: any C syntax expression that evaluates to a lvalue
        :type value: :py:class:`CValueType`
        :param value: contains the value to write to **expression**
        :param readBack: set to false to skip reading back the value

        :rtype: string
        :return: result of evaluation as string or error description in case of error.
                           For example for expression 'a = 10' return value is '10'.

        :raises: IOException in case of an error

        Python example: dataWriteModifyExample.py

        |

        *Overload 6:*

        Modifies expression to string value. The expression must evaluate to
        a *lvalue*.
        See also 'Qualified Variable Names'.

        :type accessFlags: int
        :param accessFlags: determines what kind of
                                 memory access is permitted if required to resolve the expression,
        :type evaluateFlags: int
        :param evaluateFlags: define result format.
        :type expression: string
        :param expression: any C syntax expression that evaluates to a lvalue
        :type value: string
        :param value: contains the value to write to **expression**
        :type readBack: boolean, optional
        :param readBack: set to false to skip reading back the value

        :raises: IOException in case of an error

        Python example: dataWriteModifyExample.py

        |

        *Overload 7:*

        Modifies expression to string value. The expression must evaluate to
        a *lvalue*.
        See also 'Qualified Variable Names'.

        :type accessFlags: int
        :param accessFlags: determines what kind of
                                 memory access is permitted if required to resolve the expression,
        :type evaluateFlags: int
        :param evaluateFlags: define result format.
        :type expression: string
        :param expression: any C syntax expression that evaluates to a lvalue
        :type value: string
        :param value: contains the value to write to **expression**
        :param readBack: set to false to skip reading back the value

        :raises: IOException in case of an error

        Python example: dataWriteModifyExample.py
        """
        return _connect.CDataController_modify(self, *args)

    def batchAccess(self, dwBatchAccessFlags: "DWORD", pBatchAccessHeader: "SBatchAccessHeader", batchAccessItems: "VectorBatchAccessItem", batchAccessItemResults: "VectorBatchAccessResult") -> "bool":
        r"""
        Performs multiple memory accesses, using deterministic delays.

        :type dwBatchAccessFlags: int
        :param dwBatchAccessFlags: see enum EFlags in SBatchAccessHeader, flags that
                                      start with prefix 'fl'
        :type pBatchAccessHeader: :py:class:`SBatchAccessHeader`
        :param pBatchAccessHeader: see SBatchAccessHeader
        :type batchAccessItems: std::vector< SBatchAccessItem,std::allocator< SBatchAccessItem > >
        :param batchAccessItems:  items defining the type
                                      and time of an individual access.

        :type batchAccessItemResults: std::vector< SBatchAccessItemResult,std::allocator< SBatchAccessItemResult > >
        :param batchAccessItemResults:  objects that will
                                            receive the results of every individual
                                            access.

        :rtype: boolean
        :return: true if OK, false if the specified time restrictions could
                    not be kept

        :raises: IOException if one of the accesses failed
        :raises: FeatureNotImplementedException if batch access is not implemented for your target

        Example:

          const int NUM_ITEMS = 1;  // just one item to execute in every run
          const int NUM_RUNS  = 100;   // perform so many iterations

          SBatchAccessHeader  BAH = {0};
          SBatchAccessItem    aBAI[NUM_ITEMS];
          memset(aBAI, 0, sizeof aBAI);

          // define header
          BAH.m_dwFlags       = SBatchAccessHeader::flRealTime; // use real-time access
          BAH.m_dwFlags       |= SBatchAccessHeader::flWantTimeStamp;
          BAH.m_dwNumItems    = NUM_ITEMS;
          BAH.m_dwNumRuns     = NUM_RUNS;
          BAH.m_qwRunInterval = 500;                            // every 500 us

          // Define item(s), ``iCounter`` in this case. Call CAddressController::getSymbolInfo()
          // to get ``aSizeMAUs``, ``byMemArea``, and ``aAddress`` of ``iCounter``.

          aBAI[0].m_byFlags   = SBatchAccessItem::flRead;       // it's a read
          aBAI[0].m_bySize    = (BYTE)aSizeMAUs;                // size or iCounter
          aBAI[0].m_byMemArea = byMemArea;                      // memory area of iCounter
          aBAI[0].m_aAddress  = aAddress;                       // address of iCounter

          SBatchAccessItemResult aBAIR[NUM_ITEMS * NUM_RUNS];   // make space for results

          bool hr = batchAccess(0, &BAH, aBAI, aBAIR);


        Python example: batchAccess.py 

        Python module for batch access and watch expressions: dataRecorder.py 
        """
        return _connect.CDataController_batchAccess(self, dwBatchAccessFlags, pBatchAccessHeader, batchAccessItems, batchAccessItemResults)

    def jtagScan(self, dwScanFlags: "DWORD", dwNumBits: "DWORD", tdi: "VectorBYTE", isOutputRequested: "bool", tdo: "VectorBYTE") -> "void":
        r"""
        Deprecated: 

        Performs JTAG scan operation.

        :type dwScanFlags: int
        :param dwScanFlags: scan flags, see DebugService_JTAG::EScan.
        :type dwNumBits: int
        :param dwNumBits: the number of I/O bits
        :type tdi: std::vector< BYTE,std::allocator< BYTE > >
        :param tdi: vector of bytes containing input data. If it is empty,
                   input is ignored. If it is not empty, but its size is less than
                   ``(dwNumBits + 7) / 8``, then IndexOutOfBoundsException
                   is thrown.
        :type isOutputRequested: boolean
        :param isOutputRequested: if true, then ``tdo`` parameter is filled with
                   output data. Otherwise no output data is provided.
        :type tdo: std::vector< BYTE,std::allocator< BYTE > >
        :param tdo: vector to receive output data. May be empty on input.

        Python example: debugIdeTraceProfilerCoverageSample.py 
        """
        return _connect.CDataController_jtagScan(self, dwScanFlags, dwNumBits, tdi, isOutputRequested, tdo)

    def setJtagLine(self, line: "DWORD", level: "BYTE") -> "void":
        r"""
        Deprecated: 

        Sets JTAG line to the given value.
        Example:

        dataCtrl.setJtagLine(DebugService_JTAG::lRESET, 0);


        :type line: int
        :param line: line number, see DebugService_JTAG::ELine for possible values
        :type level: BYTE
        :param level: value to set, should be 0 or 1
        """
        return _connect.CDataController_setJtagLine(self, line, level)

    def setOcdPortTristate(self, isTristate: "bool") -> "void":
        r"""
        Sets state of OCD port.

        :type isTristate: boolean
        :param isTristate: if true, the port is set to tristate.

        Python example: serviceFunctions.py 
        """
        return _connect.CDataController_setOcdPortTristate(self, isTristate)

    def eraseFlash(self, nDevice: "int"=-1) -> "void":
        r"""
        Erases FLASH memory.

        :type nDevice: int, optional
        :param nDevice: if -1 all FLASH devices are processed, otherwise only the specified device

        Python example: serviceFunctions.py 
        """
        return _connect.CDataController_eraseFlash(self, nDevice)

    def secureFlash(self, nDevice: "int"=-1) -> "void":
        r"""
        Secures FLASH memory.

        :type nDevice: int, optional
        :param nDevice: if -1 all FLASH devices are processed, otherwise only the specified device

        Python example: serviceFunctions.py 
        """
        return _connect.CDataController_secureFlash(self, nDevice)

    def unsecureFlash(self, nDevice: "int"=-1) -> "void":
        r"""
        Unsecures FLASH memory.

        :type nDevice: int, optional
        :param nDevice: if -1 all FLASH devices are processed, otherwise only the specified device

        Python example: serviceFunctions.py 
        """
        return _connect.CDataController_unsecureFlash(self, nDevice)

    @staticmethod
    def setByte(array: "BYTE *", idx: "int", value: "BYTE") -> "void":
        r"""
        Sets array element at index ``idx`` to ``value``. This is general method, which
        can be used to set arrays, which are required as ``isystem.connect`` function
        parameters or are elements of ``isystem.connect`` structures, for example
        ``SBatchAccessItem``.

        Python example: batchAccess.py 
        """
        return _connect.CDataController_setByte(array, idx, value)

    @staticmethod
    def getByte(array: "BYTE *", idx: "int") -> "BYTE":
        r"""
        Gets array element at index ``idx``. This is general method, which
        can be used to read arrays, which are returned by  ``isystem.connect`` function
        parameters or are elements of ``isystem.connect`` structures, for example
        ``SBatchAccessItem``.

        Python example: batchAccess.py 
        """
        return _connect.CDataController_getByte(array, idx)

    @staticmethod
    def byteArrayToVector(array: "BYTE *", len: "size_t") -> "std::vector< BYTE,std::allocator< BYTE > >":
        r"""
        This method converts byte array to std::vector<BYTE>, which is supported by
        SWIG and provides better access than pure C arrays.
        """
        return _connect.CDataController_byteArrayToVector(array, len)

    @staticmethod
    def vectorToByteArray(buff: "VectorBYTE", array: "BYTE *", size: "size_t") -> "void":
        r"""This method converts std::vector<BYTE> to byte array."""
        return _connect.CDataController_vectorToByteArray(buff, array, size)

    def getSymbols(self, *args) -> "void":
        r"""
        Gets list of all symbols of the specified type. Symbols must be downloaded
        in winIDEA before this function is called.

        :type symbolsType: int
        :param symbolsType: type of symbols to retrieve
        :type symbolNames: :py:class:`StrVector`
        :param symbolNames: after return this vector contains names of all
                               symbols of the specified type from download file.
        :type partition: int, optional
        :param partition: index of download file to get symbols from



        Python example: listFunctions.py
        """
        return _connect.CDataController_getSymbols(self, *args)

    def getStackFrames(self, isActiveFrameOnly: "bool", isAbsPaths: "bool", stackFrames: "StackFrameVector") -> "void":
        r"""
        Gets list of current stack frames on a target. The
        stack frame information depends on compiler debug info and may not
        be always available.

        :type isActiveFrameOnly: boolean
        :param isActiveFrameOnly: if true, only the active frame is returned. This
                                     can be much faster than retrieving all frames.
        :type isAbsPaths: boolean
        :param isAbsPaths: if true, absolute paths are returned

        :type stackFrames: :py:class:`StackFrameVector`
        :param stackFrames: vector to receive stack frame objects

        Python example: stackFrames.py
        """
        return _connect.CDataController_getStackFrames(self, isActiveFrameOnly, isAbsPaths, stackFrames)

    def getVariables(self, partition: "int", variables: "VariableVector") -> "void":
        r"""
        Returns list of global variables in a download file.

        :type partition: int
        :param partition: partition number, or PARTITION_CURRENT for current download file or
                             PARTITION_DEFAULT for default download file.
        :type variables: :py:class:`VariableVector`
        :param variables: vector to receive result

        Python example: globalSymbols.py
        """
        return _connect.CDataController_getVariables(self, partition, variables)

    def getLabels(self, partition: "int", labels: "VariableVector") -> "void":
        r"""
        Returns list of labels in a download file.

        :type partition: int
        :param partition: partition number, or PARTITION_CURRENT for current download file or
                             PARTITION_DEFAULT for default download file.
        :type labels: :py:class:`VariableVector`
        :param labels: vector to receive result

        Python example: globalSymbols.py
        """
        return _connect.CDataController_getLabels(self, partition, labels)

    def getModules(self, partition: "int", modules: "ModuleVector") -> "void":
        r"""
        Returns list of source code files which were used to generate a download file.

        :type partition: int
        :param partition: partition number, or PARTITION_CURRENT for current download file or
                             PARTITION_DEFAULT for default download file.
        :type modules: :py:class:`ModuleVector`
        :param modules: vector to receive result

        Python example: globalSymbols.py
        """
        return _connect.CDataController_getModules(self, partition, modules)

    def getFunctions(self, partition: "int", functions: "FunctionVector") -> "void":
        r"""
        Returns list of functions in a download file.

        :type partition: int
        :param partition: partition number, or PARTITION_CURRENT for current download file or
                             PARTITION_DEFAULT for default download file.
        :type functions: :py:class:`FunctionVector`
        :param functions: vector to receive result

        Python example: globalSymbols.py
        """
        return _connect.CDataController_getFunctions(self, partition, functions)

    def getTypes(self, partition: "int", types: "TypeVector") -> "void":
        r"""
        Returns list of types in a download file.

        :type partition: int
        :param partition: partition number, or PARTITION_CURRENT for current download file or
                             PARTITION_DEFAULT for default download file.
        :type types: :py:class:`TypeVector`
        :param types: vector to receive result

        Python example: globalSymbols.py
        """
        return _connect.CDataController_getTypes(self, partition, types)

    def getTypedefs(self, partition: "int", typedefs: "TypedefVector") -> "void":
        r"""
        Returns list of typedefs in a download file.

        :type partition: int
        :param partition: partition number, or PARTITION_CURRENT for current download file or
                             PARTITION_DEFAULT for default download file.
        :type typedefs: :py:class:`TypedefVector`
        :param typedefs: vector to receive result

        Python example: globalSymbols.py
        """
        return _connect.CDataController_getTypedefs(self, partition, typedefs)

    def getPartitions(self, paths: "StrVector", fileNames: "StrVector") -> "void":
        r"""
        Returns a list of download files.

        :type paths: :py:class:`StrVector`
        :param paths: vector to receive paths of download files
        :type fileNames: :py:class:`StrVector`
        :param fileNames: vector to receive names of download files

        Python example: globalSymbols.py
        """
        return _connect.CDataController_getPartitions(self, paths, fileNames)

    def getMacros(self, partition: "int", names: "StrVector", values: "StrVector") -> "void":
        r"""
        Returns a list of macros in the given partition.

        :type partition: int
        :param partition: partition number, or PARTITION_CURRENT for current download file or
                             PARTITION_DEFAULT for default download file.
        :type names: :py:class:`StrVector`
        :param names: vector, which will contain names of macros on return.
        :type values: :py:class:`StrVector`
        :param values: vector, which will contain values of macros on return.
        """
        return _connect.CDataController_getMacros(self, partition, names, values)

    def canAccessMemory(self) -> "isys::CMemoryAccess":
        r"""
        Returns type of available target memory access.

        Python example: availableMemoryAccess.py 
        """
        return _connect.CDataController_canAccessMemory(self)

    def getSystemMemoryAreas(self) -> "isys::CSystemMemoryAreas":
        r"""
        This method returns information about memory areas available on a
        target.
        """
        return _connect.CDataController_getSystemMemoryAreas(self)

    def getDefaultEndian(self) -> "EEndian":
        r"""Returns default CPU endian mode."""
        return _connect.CDataController_getDefaultEndian(self)

    def getStackUsage(self) -> "isys::CStackUsage":
        r"""
        Returns information about maximum stack usage since
        seedStack() was called.

        Python example: stackUsage.py
        """
        return _connect.CDataController_getStackUsage(self)

    def seedStack(self) -> "void":
        r"""
        Writes the given values to stack memory area. 


        Memory locations
        and value are defined with options ``Debug.StackUsage.*`` in winIDEA, which
        can be configured with ``Debug`` | ``Debug`` ``Options`` | ``Stack`` ``Usage``
        dialog or method configureStackUsage() in this class.

        Python example: stackUsage.py
        """
        return _connect.CDataController_seedStack(self)

    def configureStackUsage(self, *args) -> "void":
        r"""
        *Overload 1:*

        Deprecated: use configureStackUsage(string, string, unsigned char),
                           because it accepts also symbols and expressions.

        |

        *Overload 2:*

        Configures winIDEA options used for measuring stack usage.
        This method changes values of options ``Debug.StackUsage.*``
        in winIDEA. This method must be called **before** download, for settings to
        take effect. After downalod you should call seedStack() without parameters
        to seed the stack memory region.

        :type start: string
        :param start: starting address. If both ``start`` and
                         ``end`` are empty strings, then
                         stack usage monitoring is disabled.
        :type end: string
        :param end: end address - value at this address is not modified,
                       so that ``size = end - start``. If both
                       ``start`` and ``end`` are empty strings,
                       then stack usage monitoring is disabled.
        :type value: unsigned char
        :param value: value to write to the stack. Not that this value
            should not interfere with other values written to stack to get
            reliable stack usage with getStackUsage().

        Python example: stackUsage.py
        """
        return _connect.CDataController_configureStackUsage(self, *args)

    def csCreate(self) -> "CCodeStore":
        r"""
        This method creates an empty code store object

        :rtype: :py:class:`CCodeStore`
        :return: 
            - CCodeStore object

        Python example: codeStore_MotorolaSave.py 
        """
        return _connect.CDataController_csCreate(self)

    def csGetDownloaded(self, memArea: "BYTE", fileDownload: "std::string const &", data: "bool") -> "CCodeStore":
        r"""
        This method retrieves all downloaded code.

        :type memArea: BYTE
        :param memArea: specifies the memory space for which the downloaded code should be retrieved
        :type fileDownload: string
        :param fileDownload: if empty, all downloaded code is retrieved, otherwise only for the specified file
        :type data: boolean
        :param data: true to retrieve the data. Otherwise only address information is retrieved.

        :rtype: :py:class:`CCodeStore`
        :return: 
            - CCodeStore object containing the downloaded code

        Python example: codeStoreExample.py 
        """
        return _connect.CDataController_csGetDownloaded(self, memArea, fileDownload, data)

    def csReadMemory(self, memArea: "BYTE", rspSource: "isys::CCodeStoreSPtr const &") -> "CCodeStore":
        r"""
        This method reads memory to the given ``rspSource`` object.

        :type memArea: BYTE
        :param memArea: specifies the memory space from which to read
        :type rspSource: :py:class:`CCodeStore`
        :param rspSource: a CCodeStore object filled with items (address and size), which should be read

        :rtype: :py:class:`CCodeStore`
        :return: 
            - CCodeStore object containing the read memory

        Python example: codeStoreExample.py 
        """
        return _connect.CDataController_csReadMemory(self, memArea, rspSource)

    def csVerifyDownloaded(self, *args) -> "CCodeStore":
        r"""
        This method verifies downloaded data with the given file.

        :type memArea: BYTE
        :param memArea: specifies the memory space for which the verify
                           should be performed

        :type fileDownload: string
        :param fileDownload: if empty, all downloaded code is verified,
                                otherwise only for the specified file

        :type fileReport: string
        :param fileReport: file path to which the report should be written.
                              If empty no report is generated

        :type verifyAgainst: int, optional
        :param verifyAgainst: can be one of IConnectDebug2::ccSrcLoaded,
                                 IConnectDebug2::ccSrcInFiles,
                                 or IConnectDebug2::ccSrcFiltered.

        :rtype: :py:class:`CCodeStore`
        :return: 
            - CCodeStore object containing the differences between loaded and
                         read-back code. All data values are ICodeCache::EDifType::dtDif

        Python example: codeStoreExample.py 
        """
        return _connect.CDataController_csVerifyDownloaded(self, *args)

    def csDif(self, rsp1: "isys::CCodeStoreSPtr const &", rsp2: "isys::CCodeStoreSPtr const &", flDifferent: "bool"=True, flNotIn1: "bool"=True, flNotIn2: "bool"=True, flEqual: "bool"=False) -> "CCodeStore":
        r"""
        This method returns differences between two SPCodeStore instances.

        :type rsp1: :py:class:`CCodeStore`
        :param rsp1: the first CCodeStore object
        :type rsp2: :py:class:`CCodeStore`
        :param rsp2: the second CCodeStore object
        :type flDifferent: boolean, optional
        :param flDifferent: report locations present in both objects, but with different contents
        :type flNotIn1: boolean, optional
        :param flNotIn1: report locations that are not in rsp1, but present int rsp2
        :type flNotIn2: boolean, optional
        :param flNotIn2: report locations that are not in rsp2, but present int rsp1
        :type flEqual: boolean, optional
        :param flEqual: report locations with equal contents

        :rtype: :py:class:`CCodeStore`
        :return: 
            - CCodeStore object containing the differences between rsp1 and rsp2. Data values use ICodeCache::EDifType encoding

        Python example: codeStoreDifExample.py 
        """
        return _connect.CDataController_csDif(self, rsp1, rsp2, flDifferent, flNotIn1, flNotIn2, flEqual)

# Register CDataController in _connect:
_connect.CDataController_swigregister(CDataController)

def CDataController_setByte(array: "BYTE *", idx: "int", value: "BYTE") -> "void":
    r"""
    Sets array element at index ``idx`` to ``value``. This is general method, which
    can be used to set arrays, which are required as ``isystem.connect`` function
    parameters or are elements of ``isystem.connect`` structures, for example
    ``SBatchAccessItem``.

    Python example: batchAccess.py 
    """
    return _connect.CDataController_setByte(array, idx, value)

def CDataController_getByte(array: "BYTE *", idx: "int") -> "BYTE":
    r"""
    Gets array element at index ``idx``. This is general method, which
    can be used to read arrays, which are returned by  ``isystem.connect`` function
    parameters or are elements of ``isystem.connect`` structures, for example
    ``SBatchAccessItem``.

    Python example: batchAccess.py 
    """
    return _connect.CDataController_getByte(array, idx)

def CDataController_byteArrayToVector(array: "BYTE *", len: "size_t") -> "std::vector< BYTE,std::allocator< BYTE > >":
    r"""
    This method converts byte array to std::vector<BYTE>, which is supported by
    SWIG and provides better access than pure C arrays.
    """
    return _connect.CDataController_byteArrayToVector(array, len)

def CDataController_vectorToByteArray(buff: "VectorBYTE", array: "BYTE *", size: "size_t") -> "void":
    r"""This method converts std::vector<BYTE> to byte array."""
    return _connect.CDataController_vectorToByteArray(buff, array, size)

class CRegisterInfo(object):
    r""" Wrapper for register info."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, regName: "TCHAR *", type: "SType"):
        _connect.CRegisterInfo_swiginit(self, _connect.new_CRegisterInfo(regName, type))

    def getRegisterName(self) -> "std::string":
        r""" Returns register name."""
        return _connect.CRegisterInfo_getRegisterName(self)

    def getType(self) -> "SType":
        r""" Returns register type."""
        return _connect.CRegisterInfo_getType(self)
    __swig_destroy__ = _connect.delete_CRegisterInfo

# Register CRegisterInfo in _connect:
_connect.CRegisterInfo_swigregister(CRegisterInfo)

class SDisassemblyLine(object):
    r""" Wrapper for disassembly line."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    address = property(_connect.SDisassemblyLine_address_get, _connect.SDisassemblyLine_address_set)
    opCode = property(_connect.SDisassemblyLine_opCode_get, _connect.SDisassemblyLine_opCode_set)
    opCodeArgs = property(_connect.SDisassemblyLine_opCodeArgs_get, _connect.SDisassemblyLine_opCodeArgs_set)
    fileName = property(_connect.SDisassemblyLine_fileName_get, _connect.SDisassemblyLine_fileName_set)
    lineNumber = property(_connect.SDisassemblyLine_lineNumber_get, _connect.SDisassemblyLine_lineNumber_set)
    functionName = property(_connect.SDisassemblyLine_functionName_get, _connect.SDisassemblyLine_functionName_set)
    functionOffset = property(_connect.SDisassemblyLine_functionOffset_get, _connect.SDisassemblyLine_functionOffset_set)
    branchTarget = property(_connect.SDisassemblyLine_branchTarget_get, _connect.SDisassemblyLine_branchTarget_set)
    length = property(_connect.SDisassemblyLine_length_get, _connect.SDisassemblyLine_length_set)
    isBranch = property(_connect.SDisassemblyLine_isBranch_get, _connect.SDisassemblyLine_isBranch_set)
    isCall = property(_connect.SDisassemblyLine_isCall_get, _connect.SDisassemblyLine_isCall_set)
    isConditional = property(_connect.SDisassemblyLine_isConditional_get, _connect.SDisassemblyLine_isConditional_set)
    isIndirect = property(_connect.SDisassemblyLine_isIndirect_get, _connect.SDisassemblyLine_isIndirect_set)

    def __init__(self, *args):
        _connect.SDisassemblyLine_swiginit(self, _connect.new_SDisassemblyLine(*args))
    __swig_destroy__ = _connect.delete_SDisassemblyLine

# Register SDisassemblyLine in _connect:
_connect.SDisassemblyLine_swigregister(SDisassemblyLine)

class CDataComposite(object):
    r"""
    This class contains information about expression and its children
    (elements of structure or array).

    See also: CDataController2::evaluateComposite()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CDataComposite_swiginit(self, _connect.new_CDataComposite(*args))

    def getVariable(self) -> "isys::CVariable":
        r""" Returns object containing name and type of an expression."""
        return _connect.CDataComposite_getVariable(self)

    def isValueSet(self) -> "bool":
        r""" Returns true, if value is set."""
        return _connect.CDataComposite_isValueSet(self)

    def getValue(self) -> "isys::CValueType":
        r"""
        Returns value of an object if isValueSet() returns true, otherwise
        an exception is thrown.
        """
        return _connect.CDataComposite_getValue(self)

    def getChildren(self, children: "VectorDataComposite") -> "void":
        r"""Returns elements of a struct or an array."""
        return _connect.CDataComposite_getChildren(self, children)
    __swig_destroy__ = _connect.delete_CDataComposite

# Register CDataComposite in _connect:
_connect.CDataComposite_swigregister(CDataComposite)

class CDataController2(CDataController):
    r"""
    This class contains advanced methods, which are needed for complex projects,
    for example Eclipse debugger plug-in.


    **IMPORTANT: Resources allocated by calls to some methods of this class
    must be explicitly released. This is true also for managed languages like Java
    and C#. Improper allocation/releasing of resources may crash application! **
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        r""" Instantiates object associated with the given connection."""
        _connect.CDataController2_swiginit(self, _connect.new_CDataController2(connectionMgr))
    __swig_destroy__ = _connect.delete_CDataController2

    def getTargetInfo(self) -> "iEclipse::SInfo":
        r"""Obtains general info about the target, not provided with other methods."""
        return _connect.CDataController2_getTargetInfo(self)

    def getRegisterInfo(self, registerIdx: "int") -> "isys::CRegisterInfo":
        r"""
        Provides info about a register. Only main registers can be accessed
        by this method. Use GetCPUSFR() and SFRValue() to access SFRs.

        :param dwFlags: must be zero
        :type registerIdx: int
        :param registerIdx: register index. Call getTargetInfo() to get the number
                   of registers on the target. Index should be in range [0 .. SInfo.m_dwNumRegisters - 1]
        """
        return _connect.CDataController2_getRegisterInfo(self, registerIdx)

    def getDisassembly(self, *args) -> "iEclipse::IDisassemblyBlock *":
        r"""
        *Overload 1:*

        This method provides disassembly of the given source code block.
        The returned resource must be released with call to method
        release() after usage.

        :type flags: int
        :param flags: see iEclipse::IConnectEclipse::EDisassemblyFlags for possible values
        :type fileName: string
        :param fileName: name of the source code file
        :type lineNumber: int
        :param lineNumber: starting line number of the code block
        :type numLines: int
        :param numLines: number of source code lines to get disassembly for

        |

        *Overload 2:*

        This method provides disassembly of the given source code block.
        The returned resource must be released with call to method
        release() after usage.

        :type flags: int
        :param flags: see iEclipse::IConnectEclipse::EDisassemblyFlags for possible values
        :type memArea: BYTE
        :param memArea: memory area of the code block
        :type startAddress: int
        :param startAddress: starting address of the code block
        :type numMAUs: int
        :param numMAUs: number of memory allocation units to get disassembly for
        """
        return _connect.CDataController2_getDisassembly(self, *args)

    def getStackFrameInfo(self, isActiveFrameOnly: "bool", isAbsolutePath: "bool") -> "iEclipse::IStackFrameInfo *":
        r"""
        Provides the current stack frames.
        The returned resource must be released with call to method
        release() after usage.

        :type isActiveFrameOnly: boolean
        :param isActiveFrameOnly: if true, only the active stack frame is
                   is retrieved. This way the method call is much faster.
        :type isAbsolutePath: boolean
        :param isAbsolutePath: if true, absolute paths are returned
        """
        return _connect.CDataController2_getStackFrameInfo(self, isActiveFrameOnly, isAbsolutePath)

    def release(self, *args) -> "void":
        r"""
        *Overload 1:*
        Releases instance of iEclipse::IStackFrameInfo.

        |

        *Overload 2:*
        Releases instance of iEclipse::IExpressionType.

        |

        *Overload 3:*
        Releases instance of iEclipse::IDisassemblyBlock.

        |

        *Overload 4:*
        Releases instance of iEclipse::IGlobals.

        |

        *Overload 5:*
        Releases instance of iEclipse::IConfiguration.

        |

        *Overload 6:*
        Releases instance of iEclipse::ICPUSFR.
        """
        return _connect.CDataController2_release(self, *args)

    def setStackFrameContext(self, flags: "DWORD", context: "DWORD") -> "void":
        r"""
        Sets active stack frame. Variables of the selected stack frame are
        available for evaluator (see methods CDataController::evaluate() and
        CDataController::modify()).

        :type flags: int
        :param flags: reserved, should be 0
        :type context: int
        :param context: index of the stack frame to be selected
        """
        return _connect.CDataController2_setStackFrameContext(self, flags, context)

    def getExpressionType(self, flags: "DWORD", expression: "std::string const &") -> "iEclipse::IExpressionType *":
        r"""
        Provides information about expression. This method can be used to get
        information about complex variables, for example members of a structure,
        elements of array, ...
        The returned resource must be released with call to method
        release() after usage.

        :type flags: int
        :param flags: reserved, should be 0
        :type expression: string
        :param expression: C expression, for example `myStruct.counter`,
                   or `p->a[0]`


            Python example: arrayChart.py 
        """
        return _connect.CDataController2_getExpressionType(self, flags, expression)

    def getGlobals(self, flags: "DWORD", partition: "DWORD") -> "iEclipse::IGlobals *":
        r"""
        Provides information about global items in a program. The returned object
        contains only information requested by ``flags``.
        The returned resource must be released with call to method
        release() after usage.

        :type flags: int
        :param flags: see iEclipse::IConnectEclipse::EGetGlobalsFlags for possible values
        :type partition: int
        :param partition: partition index
        """
        return _connect.CDataController2_getGlobals(self, flags, partition)

    def getConfiguration(self, flags: "DWORD") -> "iEclipse::IConfiguration *":
        r"""
        Returns program configuration, for example partitions.
        The returned resource must be released with call to method
        release() after usage.

        :type flags: int
        :param flags: reserved, should be 0.
        """
        return _connect.CDataController2_getConfiguration(self, flags)

    def getCPUSFRs(self, flags: "DWORD") -> "iEclipse::ICPUSFR *":
        r"""
        Provides information about CPU's SFRs.
        The returned resource must be released with call to method
        release() after usage.

        :type flags: int
        :param flags: one of values defined in iEclipse::IConnectEclipse::EGetCPUSFR.
        """
        return _connect.CDataController2_getCPUSFRs(self, flags)

    def readSFR(self, dwHandle: "DWORD", type: "SType") -> "isys::CValueType":
        r"""
        Reads SFR.


        IMPORTANT: Always check for error on return value: retVal.isError()
        to avoid misinterpretation of results!

        :type dwHandle: int
        :param dwHandle: handle of the SFR

        :type type: :py:class:`SType`
        :param type: defines SFR type. Required to return valid CValueType object on output.

        :rtype: :py:class:`CValueType`
        :return: SFR value. The type info of return value is set to input parameter 'type'.
            If the call succeeds, but register value is not valid, CValueType.isError()
            returns true, and CValueType.getResult() returns error description.
        """
        return _connect.CDataController2_readSFR(self, dwHandle, type)

    def writeSFR(self, flags: "DWORD", dwHandle: "DWORD", value: "CValueType") -> "isys::CValueType":
        r"""
        Writes value to SFR, then optionally reads it, to get the actual value.
        The type part of CValueType is not used.

        :type flags: int
        :param flags: flags of type ESFRValue. Values may be ORed together. Bit
            svWrite is also set by this method, so flags == 0 will also perform write.

        :type dwHandle: int
        :param dwHandle: handle of the SFR

        :rtype: :py:class:`CValueType`
        :return: read SFR value, if ``isWriteThenRead`` is true, otherwise
            the input value is returned. Type in return value is always the same as type
            in input value.
        """
        return _connect.CDataController2_writeSFR(self, flags, dwHandle, value)

    def evaluateComposite(self, accessFlags: "IConnectDebug::EAccessFlags", expression: "std::string const &", isGetValue: "bool", maxArrayElements: "int") -> "CDataComposite":
        r"""
        Evaluates expression which may refer to composed data, for example
        arrays and structures. Let's have:

        MyStruct a[10]

        Returned object will contain information about array (type of elements and size),
        and 10 elements, each of them containing also elements of ``MyStruct``.

        :type accessFlags: int
        :param accessFlags: see IConnectDebug::EAccessFlags, usually we specify
                               IConnectDebug::fMonitor or IConnectDebug::fRealTime.
        :type expression: string
        :param expression: C expression or name of variable to be evaluated.
        :type isGetValue: boolean
        :param isGetValue: if true, values of all elements are evaluated - call
                              CDataComposite::getValue() to get the value.
                              If false, only structure of composite is returned - types
                              and children of elements. Call
                              to CDataElement::getValue() will throw an exception in this case.
        :type maxArrayElements: int
        :param maxArrayElements: max number of array elements to show. Since arrays may be
                              very large, setting of this parameter can enable getting of
                              structures with large arrays.

        :rtype: :py:class:`CDataComposite`
        :return: object containing information about the given expression and its children.



        Python example: evaluateComposite.py 
        """
        return _connect.CDataController2_evaluateComposite(self, accessFlags, expression, isGetValue, maxArrayElements)

# Register CDataController2 in _connect:
_connect.CDataController2_swigregister(CDataController2)

class CPUStatus(object):
    r"""
    This class contains CPU status. It is not intended to be instantiated by
    clients.

    Note: Due to hardware restrictions, the stop reason is not always reliable
    on all architectures (methods **isStopReason...()**).

    See also: IConnectDebug::GetStatus
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, isStopReasonAvailable: "bool"):
        _connect.CPUStatus_swiginit(self, _connect.new_CPUStatus(isStopReasonAvailable))

    def isMustInit(self) -> "bool":
        r""" Returns true, if the debug system must initialize."""
        return _connect.CPUStatus_isMustInit(self)

    def isStopped(self) -> "bool":
        r""" Returns true, if CPU is stopped."""
        return _connect.CPUStatus_isStopped(self)

    def isRunning(self) -> "bool":
        r""" Returns true, if CPU is running."""
        return _connect.CPUStatus_isRunning(self)

    def isReset(self) -> "bool":
        r""" Returns true, if CPU is held in reset."""
        return _connect.CPUStatus_isReset(self)

    def isHalted(self) -> "bool":
        r""" Returns true, if CPU is halted by target."""
        return _connect.CPUStatus_isHalted(self)

    def isWaiting(self) -> "bool":
        r""" Returns true, if CPU is halted by emulator."""
        return _connect.CPUStatus_isWaiting(self)

    def isAttach(self) -> "bool":
        r""" Returns true, if debugger is initialized and waiting for hot attach on the target."""
        return _connect.CPUStatus_isAttach(self)

    def isIdle(self) -> "bool":
        r""" Returns true, if CPU is idle."""
        return _connect.CPUStatus_isIdle(self)

    def isStopReasonExplicit(self) -> "bool":
        r"""
        Returns true, if CPU is in stopped state, and was stopped explicitly by
                   the user.
        """
        return _connect.CPUStatus_isStopReasonExplicit(self)

    def isStopReasonBP(self) -> "bool":
        r""" Returns true, if CPU is in stopped state, and was stopped due to execution BP hit."""
        return _connect.CPUStatus_isStopReasonBP(self)

    def isStopReasonStep(self) -> "bool":
        r"""
        Returns true, if CPU is in stopped state, and was stopped CPU is stopped
                   after a step/over/until/until return command.
        """
        return _connect.CPUStatus_isStopReasonStep(self)

    def isStopReasonHW(self) -> "bool":
        r"""
        Returns true, if CPU is in stopped state, and was stopped after a hardware
                   breakpoint hit.
        """
        return _connect.CPUStatus_isStopReasonHW(self)

    def getExecutionPoint(self) -> "ADDRESS_64":
        r"""Returns current execution address."""
        return _connect.CPUStatus_getExecutionPoint(self)

    def getExecutionArea(self) -> "BYTE":
        r"""Returns current execution area."""
        return _connect.CPUStatus_getExecutionArea(self)

    def getMSID(self, rsmsid: "SMSID") -> "void":
        r"""
        Returns current execution point MSID. Valid when in stopped state.

        Python example: executionPointManipulationExample.py 
        """
        return _connect.CPUStatus_getMSID(self, rsmsid)

    def toString(self) -> "std::string":
        r"""Returns human readable contents of the object."""
        return _connect.CPUStatus_toString(self)
    __swig_destroy__ = _connect.delete_CPUStatus

# Register CPUStatus in _connect:
_connect.CPUStatus_swigregister(CPUStatus)

class CExecutionController(object):
    r"""
    This class can be used to control the execution of the program on a target.
    Methods which start execution have two overloads. The second overload has
    additional parameter, which specifies wait for stop timeout. Functionally
    this call is equivalent to calling the first overload and ``waitForStop()``,
    but the first approach uses less CPU time, because pooling is done at lower
    levels in winIDEA.



    callTargetFunction.py Python example for method call(). 

    getSymbolAtAddress.py Python example for method runUntilFunction(). 

    hotAttach.py Python example for methods hotAttach() and hotDetach(). 

    debugIdeTraceProfilerCoverageSample.py Python example for execution methods. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    TOUT_NONE = _connect.CExecutionController_TOUT_NONE
    r"""
    does not wait for stop, returns immediately.
    The target may still be running, when
    method returns.
    """
    TOUT_1s = _connect.CExecutionController_TOUT_1s
    r""" waits at most 1 s for stop"""
    TOUT_10s = _connect.CExecutionController_TOUT_10s
    r""" waits at most 10 s for stop"""
    TOUT_100s = _connect.CExecutionController_TOUT_100s
    r""" waits at most 100 s for stop"""
    TOUT_INF = _connect.CExecutionController_TOUT_INF
    r"""
    waits forever for stop. WARNING: Since winIDEA GUI is blocked during
    wait, you may have to switch off the emulator if target never stops.
    """

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        """
        _connect.CExecutionController_swiginit(self, _connect.new_CExecutionController(connectionMgr))
    __swig_destroy__ = _connect.delete_CExecutionController

    def getIConnectDebug(self) -> "IConnectDebug *":
        r"""
        Returns the **isystem.connect** Debug interface. Use this method only when
        some functionality of the IConnectDebug interface
        is not accessible from wrapper classes.
        """
        return _connect.CExecutionController_getIConnectDebug(self)

    def hotAttach(self) -> "int":
        r"""
        Hot-attaches to the target.

        :rtype: int
        :return: 0 if OK, else it is warning. Exception is thrown
            in case of error.



        Python example: hotAttach.py 
        """
        return _connect.CExecutionController_hotAttach(self)

    def hotDetach(self) -> "int":
        r"""
        Hot-detaches from the target.

        :rtype: int
        :return: 0 if OK, else it is warning. Exception is thrown
            in case of error.



        Python example: hotAttach.py 
        """
        return _connect.CExecutionController_hotDetach(self)

    def run(self, *args) -> "int":
        r"""
        *Overload 1:*

        Runs the program. The function is non-blocking. When it returns, the
        program might still be running (if it didn't hit a breakpoint, for example).
        Call getStatus() to check the target state, or one of wait...() methods in this
        class to wait for non-running state.

        :rtype: int
        :return: 'S_OK'

        Python example: debugIdeTraceProfilerCoverageSample.py 


        |

        *Overload 2:*

        Runs the program.

        :param timoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.
        :type throwOnTimeout: boolean, optional
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns S_FALSE when timeout is specified and the target is still
                    running (timeout expired).

        |

        *Overload 3:*

        Runs the program.

        :param timoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns S_FALSE when timeout is specified and the target is still
                    running (timeout expired).
        """
        return _connect.CExecutionController_run(self, *args)

    def runUntilReturn(self, *args) -> "int":
        r"""
        *Overload 1:*

        Runs the program until return. The function is non-blocking. When it returns, the
        program might still be running. Call getStatus() to check the target state.

        :rtype: int
        :return: 'S_OK'

        Python example: executionPointManipulationExample.py 


        |

        *Overload 2:*

        Runs the program until return.

        :param timoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.
        :type throwOnTimeout: boolean, optional
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: executionPointManipulationExample.py 


        |

        *Overload 3:*

        Runs the program until return.

        :param timoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: executionPointManipulationExample.py 
        """
        return _connect.CExecutionController_runUntilReturn(self, *args)

    def runUntilAddress(self, *args) -> "int":
        r"""
        *Overload 1:*

        Runs the program until the address is reached. This method is non-blocking.
        When it returns, the program might still be running. Call getStatus() or waitUntilStopped()
        to be sure that the program has stopped (note that the program can also stop
        for other reasons, for example a breakpoint, so checking an address may also
        be needed in some cases).

        :type memArea: BYTE
        :param memArea: memory space. Definitions for individual CPUs are provided in MemArea.h
        :type address: int
        :param address: of the memory location

        :rtype: int
        :return: 'S_OK'

        Python example: executionPointManipulationExample.py 


        |

        *Overload 2:*

        Runs the program until the address is reached.

        :type memArea: BYTE
        :param memArea: memory space. Definitions for individual CPUs are provided in MemArea.h
        :type address: int
        :param address: of the memory location
        :param timoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.
        :type throwOnTimeout: boolean, optional
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: executionPointManipulationExample.py 


        |

        *Overload 3:*

        Runs the program until the address is reached.

        :type memArea: BYTE
        :param memArea: memory space. Definitions for individual CPUs are provided in MemArea.h
        :type address: int
        :param address: of the memory location
        :param timoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: executionPointManipulationExample.py 
        """
        return _connect.CExecutionController_runUntilAddress(self, *args)

    def runUntilFunction(self, *args) -> "int":
        r"""
        *Overload 1:*

        Runs the program until the start of the function is reached. This method is
        non-blocking. When it returns, the program might still be running. Call waitUntilStopped()
        to be sure that the program has stopped (note that the program can also stop
        for other reasons, for example a breakpoint, so checking an address may also
        be needed in some cases).

        :type functionName: string
        :param functionName: name of the function

        :rtype: int
        :return: 'S_OK'


            Python example: getSymbolAtAddress.py 

            Python example: debugIdeTraceProfilerCoverageSample.py 

            Python example: executionPointManipulationExample.py 


        |

        *Overload 2:*

        Runs the program until the start of the function is reached. Note that the
        program can also stop for other reasons,
        for example a breakpoint, so checking an address may also
        be needed in some cases, or call the overload with parameter *throwOnUnexpectedStop*.

        :type functionName: string
        :param functionName: name of the function
        :param timoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.
        :type throwOnTimeout: boolean, optional
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: executionPointManipulationExample.py 


        |

        *Overload 3:*

        Runs the program until the start of the function is reached. Note that the
        program can also stop for other reasons,
        for example a breakpoint, so checking an address may also
        be needed in some cases, or call the overload with parameter *throwOnUnexpectedStop*.

        :type functionName: string
        :param functionName: name of the function
        :param timoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: executionPointManipulationExample.py 


        |

        *Overload 4:*

        Runs the program until the start of the function is reached. This method
        differs from other runUntil...() methods in verification of stop address.
        If it differs from function address, a status code is returned or IOException
        is thrown.

        :type functionName: string
        :param functionName: name of the function
        :param timoutMode: specifies whether to wait until the target is stopped
                              and how long to wait. Must not be CExecutionController::TOUT_NONE,
                              or results are unpredictable.

        :type throwOnTimeout: boolean
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :type throwOnUnexpectedStop: boolean
        :param throwOnUnexpectedStop: if true, and the function is not reached because
                   target stopped for some other reason, an IOException is thrown.

        :rtype: int
        :return: 'S_OK' if the target is stopped at the specified function.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired). Returns 'ICONNECT_S_MSG_FAIL' when the
                    target is stopped, but not at the specified function.
        """
        return _connect.CExecutionController_runUntilFunction(self, *args)

    def setSlowRun(self, isSlowRun: "bool") -> "int":
        r"""
        If ``isSlowRun`` is set to ``true``, then execution is done by stepping through
        code on the target. This mode enables usage of analyzer on targets without
        trace capabilities.

        **Note**: This method must be called BEFORE analyzer is started!

        :type isSlowRun: boolean
        :param isSlowRun: if true, slow run is enabled, if false, normal run is used

        :rtype: int
        :return: 'S_OK' if mode is changed, S_FALSE if mode was already set
        :raises: FeatureNotImplementedException if slow run is not implemented for the target
        :raises: IOException if changing of the slow run mode is not possible at that moment
        :raises: IllegalStateException in case of other errors

        Python example: slowRun.py 
        """
        return _connect.CExecutionController_setSlowRun(self, isSlowRun)

    def gotoAddress(self, memArea: "BYTE", address: "ADDRESS_64") -> "void":
        r"""
        Moves execution point to the given address.

        :type memArea: BYTE
        :param memArea: memory space. Definitions for individual CPUs are provided in MemArea.h
        :type address: int
        :param address: of the memory location

        Python example: executionPointManipulationExample.py 
        """
        return _connect.CExecutionController_gotoAddress(self, memArea, address)

    def gotoFunction(self, functionName: "std::string const &") -> "void":
        r"""
        Moves execution point to the start of the given function.

        :type functionName: string
        :param functionName: name of the function

        Python example: executionPointManipulationExample.py 
        """
        return _connect.CExecutionController_gotoFunction(self, functionName)

    def reset(self, *args) -> "void":
        r"""Resets the target."""
        return _connect.CExecutionController_reset(self, *args)

    def resetAndRun(self, *args) -> "int":
        r"""
        *Overload 1:*

        Resets the target.

        :rtype: int
        :return: 'S_OK' or if operation was executed, but there is a warning (for example
                    license will soon expire), `ICONNECT_S_MSG_WARN` is returned. In case of
                    error an exception is thrown.

        |

        *Overload 2:*

        Resets the target.

        :param timoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).
        """
        return _connect.CExecutionController_resetAndRun(self, *args)

    def stop(self) -> "void":
        r"""
        Stops the execution.


        Python example: debugIdeTraceProfilerCoverageSample.py 
        """
        return _connect.CExecutionController_stop(self)

    def stepHigh(self, *args) -> "int":
        r"""
        Steps one statement in the source code. Enters functions.

        :type timeoutMode: int, optional
        :param timeoutMode: defines how log to wait for target stop
        :type throwOnTimeout: boolean, optional
        :param throwOnTimeout: if true, exception is thrown on timeout. If false,
                                  caller should check return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: executionPointManipulationExample.py 

        Python example: stepSample.py 
        """
        return _connect.CExecutionController_stepHigh(self, *args)

    def stepOverHigh(self, *args) -> "int":
        r"""
        Steps one statement in the source code, does not enter functions.

        :type timeoutMode: int, optional
        :param timeoutMode: defines how log to wait for target stop
        :type throwOnTimeout: boolean, optional
        :param throwOnTimeout: if true, exception is thrown on timeout. If false,
                                  caller should check return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: stepSample.py 
        """
        return _connect.CExecutionController_stepOverHigh(self, *args)

    def stepInst(self, *args) -> "int":
        r"""
        Executes one machine instruction. Enters subroutines.

        :type timeoutMode: int, optional
        :param timeoutMode: defines how log to wait for target stop
        :type throwOnTimeout: boolean, optional
        :param throwOnTimeout: if true, exception is thrown on timeout. If false,
                                  caller should check return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: executionPointManipulationExample.py 

        Python example: stepSample.py 
        """
        return _connect.CExecutionController_stepInst(self, *args)

    def stepOverInst(self, *args) -> "int":
        r"""
        Executes one machine instruction, does not enter subroutines.

        :type timeoutMode: int, optional
        :param timeoutMode: defines how log to wait for target stop
        :type throwOnTimeout: boolean, optional
        :param throwOnTimeout: if true, exception is thrown on timeout. If false,
                                  caller should check return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: stepSample.py 
        """
        return _connect.CExecutionController_stepOverInst(self, *args)

    def call(self, *args) -> "std::string":
        r"""
        *Overload 1:*

        Calls function on the target. 

        Required preconditions:
        - the code must be downloaded to the target
        - target must be initialized at least to the point where stack is set up
        - target/compiler pair must be supported by isystem.connect. Most modern
          targets and compilers are supported. If this function does not work,
          check isystem web page or ask iSystem support for current status of supported
          platforms.
        - all function parameters must be of primitive types (char, int, float, ...)


        :type functionName: string
        :param functionName: name of the function to call

        :rtype: string
        :return: function return value as string. Numbers are also returned as strings.
                    If function is of type ``void``, string ``'no type information'``
                    is returned.


            Python example: callTargetFunction.py 

            Python example which shows how to record trace of a single function: targetCallWithTrace.py 


        |

        *Overload 2:*

        Calls function on the target. 

        See #call(const std::string &) for list of preconditions.

        :type functionName: string
        :param functionName: name of the function to call
        :type param1: string
        :param param1: the first function parameter. Numbers should be given as a string.

        :rtype: string
        :return: function return value as string. Numbers are also returned as strings.


            Python example: callTargetFunction.py 


        |

        *Overload 3:*

        Calls function on the target. 

        See #call(const std::string &) for list of preconditions.

        :type functionName: string
        :param functionName: name of the function to call
        :type param1: string
        :param param1: the first function parameter. Numbers should be given as a string.
        :type param2: string
        :param param2: the second function parameter. Numbers should be given as a string.

        :rtype: string
        :return: function return value as string. Numbers are also returned as strings.


            Python example: callTargetFunction.py 


        |

        *Overload 4:*

        Calls function on the target. 

        See #call(const std::string &) for list of preconditions.

        :type functionName: string
        :param functionName: name of the function to call
        :type param1: string
        :param param1: the first function parameter. Numbers should be given as a string.
        :type param2: string
        :param param2: the second function parameter. Numbers should be given as a string.
        :type param3: string
        :param param3: the third function parameter. Numbers should be given as a string.

        :rtype: string
        :return: function return value as string. Numbers are also returned as strings.


            Python example: callTargetFunction.py 


        |

        *Overload 5:*

        Calls function on the target. 

        See #call(const std::string &) for list of preconditions.

        :type functionName: string
        :param functionName: name of the function to call
        :type params: :py:class:`StrVector`
        :param params: list of function parameters. Numbers should be given as strings.

        :rtype: string
        :return: function return value as string. Numbers are also returned as strings.


            Python example: callTargetFunction.py 
        """
        return _connect.CExecutionController_call(self, *args)

    def getCPUStatus(self, wantStopReason: "bool"=True) -> "isys::CPUStatus":
        r"""
        Returns execution status of the target.

        :type wantStopReason: boolean, optional
        :param wantStopReason: if true, stop reason is set in the returned object

        Python example: getSymbolAtAddress.py 
        """
        return _connect.CExecutionController_getCPUStatus(self, wantStopReason)

    def setPollingEnabled(self, isEnabled: "bool") -> "void":
        r"""
        Enables/disables polling of target status in winIDEA.

        :type isEnabled: boolean
        :param isEnabled: if true, polling is enabled


            Python example: debugIdeTraceProfilerCoverageSample.py 
        """
        return _connect.CExecutionController_setPollingEnabled(self, isEnabled)

    def setBlueBoxTristateStatus(self, isTristate: "bool") -> "void":
        r"""
        Sets outputs of BlueBox debug connector to tristate or out mode.

        :type isTristate: boolean
        :param isTristate: if true, outputs are set to tristate
        """
        return _connect.CExecutionController_setBlueBoxTristateStatus(self, isTristate)

    def setBlueBoxTargetConnection(self, isConnected: "bool") -> "void":
        r"""
        Activates/deactivates BlueBox target connection.

        :type isConnected: boolean
        :param isConnected: if true, the emulator is connected to the target
        """
        return _connect.CExecutionController_setBlueBoxTargetConnection(self, isConnected)

    def waitUntilStopped(self, timeoutMs: "int"=0, pollingIntervalMs: "DWORD"=100, isThrow: "bool"=False) -> "bool":
        r"""
        This method polls CPU status with the given polling interval and
        returns when CPU is stopped or timeout expires. This method waits
        if CPU is in any other state than stopped state, for example ``running``,
        ``halted``, ``must`` ``init``, ...

        :param timeout: timeout in milliseconds. 0 means infinite timeout
        :param pollingInterval: time in milliseconds between two readings of the CPU status
        :type isThrow: boolean, optional
        :param isThrow: if true and timeout occurs, an exception is thrown
        :rtype: boolean
        :return: true if CPU is in stopped state, false if timeout expired and isThrow == false


            Python example: debugIdeTraceProfilerCoverageSample.py 
        """
        return _connect.CExecutionController_waitUntilStopped(self, timeoutMs, pollingIntervalMs, isThrow)

    def waitWhileRunning(self, timeoutMs: "int", pollingIntervalMs: "DWORD"=100, isThrow: "bool"=False) -> "bool":
        r"""
        This method polls CPU status with the given polling interval and
        returns when CPU is no longer running or timeout expires. The difference
        to waitUntilStopped() method is that waitUntilStopped() expects
        exactly ``stopped`` state to return - it won't return on ``must`` ``init`` state,
        for example. waitWhileRunning() method will wait only if the target
        is in ``running`` state - it will
        return on any other state, for example ``stopped``, ``must`` ``init``, ``halted``, ...

        :param timeout: timeout in milliseconds. 0 means infinite timeout
        :param pollingInterval: time in milliseconds between two readings of the CPU status
        :type isThrow: boolean, optional
        :param isThrow: if true and timeout occurs, an exception is thrown
        :rtype: boolean
        :return: true if CPU is not running, false if timeout expired and isThrow == false
        """
        return _connect.CExecutionController_waitWhileRunning(self, timeoutMs, pollingIntervalMs, isThrow)

# Register CExecutionController in _connect:
_connect.CExecutionController_swigregister(CExecutionController)

class CHILChannel(object):
    r"""
    This immutable class contains information about HIL channel
    parameter.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r""" Instantiates object. Constructor is not intended to be used by clients."""
        _connect.CHILChannel_swiginit(self, _connect.new_CHILChannel(*args))

    def getName(self) -> "std::string":
        r""" Returns channel name."""
        return _connect.CHILChannel_getName(self)

    def getQualifiedName(self) -> "std::string":
        r""" Returns channel qualified name."""
        return _connect.CHILChannel_getQualifiedName(self)

    def isAvailable(self) -> "bool":
        r""" Returns true if the channel is avaialble - on the hardware module and not explicitly disabled."""
        return _connect.CHILChannel_isAvailable(self)

    def getType(self) -> "DWORD":
        r""" Returns the type of the channel. IHILChannel::mc_cit encoding is used"""
        return _connect.CHILChannel_getType(self)

    def getIndex(self) -> "DWORD":
        r""" Returns the index of the channel within its type group."""
        return _connect.CHILChannel_getIndex(self)

    def getUnit(self) -> "std::string":
        r""" Returns the units measured by an analog channel."""
        return _connect.CHILChannel_getUnit(self)

    def getAMin(self) -> "double":
        r""" Returns the minimum value an analog channel can assume."""
        return _connect.CHILChannel_getAMin(self)

    def getAMax(self) -> "double":
        r""" Returns the minimum value an analog channel can assume."""
        return _connect.CHILChannel_getAMax(self)
    __swig_destroy__ = _connect.delete_CHILChannel

# Register CHILChannel in _connect:
_connect.CHILChannel_swigregister(CHILChannel)

class CHILController(object):
    r"""
    This class controls HIL (Hardware In the Loop).

    Python example: hilControllerExample.py 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        """
        _connect.CHILController_swiginit(self, _connect.new_CHILController(connectionMgr))
    __swig_destroy__ = _connect.delete_CHILController

    def read(self, paths: "std::string const &", bufferSize: "DWORD"=4096, dwFlags: "DWORD"=0, dwGenParam: "DWORD"=0) -> "std::string":
        r"""
        Reads data from HIL. Consult your hardware manual for available parameters.
        For iSystem's I/O module on IC5000 you get the list of available paths to
        parameters with HIL monitor in winIDEA:
        - Open "Plugins | Options" dialog, then move "HIL Monitor" from "Available" to "Loaded", click OK
        - Select "Plugins | HIL Monitor" to open the HIL Monitor window.

        :type paths: string
        :param paths: paths to parameters to read separated by '\n'. Example for
                                    iSystem IO module:

                          read("DIN.DIN0\\nDIN.DIN1");



        :type bufferSize: int, optional
        :param bufferSize: allocated buffer to receive data. If it is to small,
                              IllegalSizeException is thrown.

        :type dwFlags: int, optional
        :param dwFlags: reserved, should be zero

        :type dwGenParam: int, optional
        :param dwGenParam: reserved, should be zero

        :rtype: string
        :return: string of values for each path, separated by '\n'

        Python example: hilControllerExample.py 
        """
        return _connect.CHILController_read(self, paths, bufferSize, dwFlags, dwGenParam)

    def write(self, values: "std::string const &", dwFlags: "DWORD"=0, dwGenParam: "DWORD"=0) -> "void":
        r"""
        Writes data to HIL. Consult your hardware manual for available parameters.
        For iSystem's I/O module on IC5000 you get the list of available paths to
        parameters with HIL monitor in winIDEA:
        - Open "Plugins | Options" dialog, then move "HIL Monitor" from "Available" to "Loaded", click OK
        - Select "Plugins | HIL Monitor" to open the HIL Monitor window.

        :type values: string
        :param values: data to be written to HIL module given as ``path: value``
                          pairs separated by '\n'. Example for iSystem IO module:

                          write("DOUT.DOUT0: LOW");


        :type dwFlags: int, optional
        :param dwFlags: reserved, should be zero

        :type dwGenParam: int, optional
        :param dwGenParam: reserved, should be zero

        Python example: hilControllerExample.py 
        """
        return _connect.CHILController_write(self, values, dwFlags, dwGenParam)

    def getDescriptors(self) -> "DataDescriptor::IItemDescriptors const *":
        return _connect.CHILController_getDescriptors(self)

    def getChannels(self, channels: "HILChannelVector") -> "void":
        r"""
        Deprecated: does not support new hardware, currently has no replacement

        Returns list of channels in the HIL.

        :type channels: :py:class:`HILChannelVector`
        :param channels: vector to receive result

        See also: isys::CHILChannel

        Python example: hilControllerExample.py
        """
        return _connect.CHILController_getChannels(self, channels)

# Register CHILController in _connect:
_connect.CHILController_swigregister(CHILController)

class CMPC5xxxController(object):
    r"""
    This class controls MPC5xxx specific features.

    MPC5xxx_TLB_ReadWrite.py Python example.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        """
        _connect.CMPC5xxxController_swiginit(self, _connect.new_CMPC5xxxController(connectionMgr))
    __swig_destroy__ = _connect.delete_CMPC5xxxController

    def getTLB(self, dwEntry: "DWORD") -> "DebugService_MPC55xx::STLBEntry":
        r"""
        Gets a TLB entry.

        :type dwEntry: int
        :param dwEntry: index of the entry to be read

        :rtype: :py:class:`STLBEntry`
        :return: TLB entry contents in MAS format
        """
        return _connect.CMPC5xxxController_getTLB(self, dwEntry)

    def setTLB(self, dwEntry: "DWORD", rTLBEntry: "STLBEntry") -> "void":
        r"""
        Sets a TLB entry.

        :type dwEntry: int
        :param dwEntry: index of the entry to be read

        :type rTLBEntry: :py:class:`STLBEntry`
        :param rTLBEntry: TLB entry in MAS format
        """
        return _connect.CMPC5xxxController_setTLB(self, dwEntry, rTLBEntry)

# Register CMPC5xxxController in _connect:
_connect.CMPC5xxxController_swigregister(CMPC5xxxController)

class CIDEData(object):
    r"""
    This class contains winIDEA window location and process ID. This class is
    not intended to be instantiated by clients. Use method
    CIDEData::getWinIDEAVersion() to obtain the current winIDEA version.

    See also: CIDEController
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getLeft(self) -> "LONG":
        r""" Returns coordinate of the left edge of winIDEA window."""
        return _connect.CIDEData_getLeft(self)

    def getTop(self) -> "LONG":
        r""" Returns coordinate of the top edge of winIDEA window."""
        return _connect.CIDEData_getTop(self)

    def getRight(self) -> "LONG":
        r""" Returns coordinate of the right edge of winIDEA window."""
        return _connect.CIDEData_getRight(self)

    def getBottom(self) -> "LONG":
        r""" Returns coordinate of the bottom edge of winIDEA window."""
        return _connect.CIDEData_getBottom(self)

    def getPID(self) -> "DWORD":
        r""" Returns process ID of winDEA process."""
        return _connect.CIDEData_getPID(self)
    __swig_destroy__ = _connect.delete_CIDEData

# Register CIDEData in _connect:
_connect.CIDEData_swigregister(CIDEData)
cvar = _connect.cvar
POSTFIX_ENABLE_PROFILER = cvar.POSTFIX_ENABLE_PROFILER
POSTFIX_ENABLE_COVERAGE = cvar.POSTFIX_ENABLE_COVERAGE
OPT_VAL_TRUE = cvar.OPT_VAL_TRUE
OPT_VAL_FALSE = cvar.OPT_VAL_FALSE

class CIDECapabilities(object):
    r"""
    This class contains capabilities of the current hardware setup.
    This class is not intended to be instantiated by users. Call
    isys::CIDEController::getCapabilities() to get an instance.


    See also: CIDEController
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, capabilities: "DWORD"):
        _connect.CIDECapabilities_swiginit(self, _connect.new_CIDECapabilities(capabilities))

    def isDebugAvailable(self) -> "bool":
        r""" Returns true if debugging is supported."""
        return _connect.CIDECapabilities_isDebugAvailable(self)

    def isTraceAvailable(self) -> "bool":
        r""" Returns true if trace is supported."""
        return _connect.CIDECapabilities_isTraceAvailable(self)

    def isCoverageAvailable(self) -> "bool":
        r""" Returns true if coverage is supported."""
        return _connect.CIDECapabilities_isCoverageAvailable(self)

    def isProfilerAvailable(self) -> "bool":
        r""" Returns true if profiler is supported."""
        return _connect.CIDECapabilities_isProfilerAvailable(self)
    __swig_destroy__ = _connect.delete_CIDECapabilities

# Register CIDECapabilities in _connect:
_connect.CIDECapabilities_swigregister(CIDECapabilities)

class COptionValue(object):
    r"""
    This class wraps structure SOptionValue defined in i_Options.h

    See also: CIDEController
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes the object. Uses default separators,
        and does not allocate output buffer. Use this ctor when
        you want to GET option value (EOptionValue::ofGet).

        |

        *Overload 2:*

        Initializes input string with the given value. Uses default separators,
        and does not allocate output buffer.

        |

        *Overload 3:*

        Initializes input integer with the given value. Uses default separators,
        and does not allocate output buffer.

        |

        *Overload 4:*

        Initializes input float with the given value. Uses default separators,
        and does not allocate output buffer.
        """
        _connect.COptionValue_swiginit(self, _connect.new_COptionValue(*args))
    __swig_destroy__ = _connect.delete_COptionValue

    def setSeparators(self, pathSeparator: "char"=0, valueSeparator: "char"=0, optionSeparator: "char"=0) -> "void":
        r"""Sets separators for multiple options."""
        return _connect.COptionValue_setSeparators(self, pathSeparator, valueSeparator, optionSeparator)

    def getOutputBuffer(self) -> "char const *":
        r"""Returns contents of the output buffer."""
        return _connect.COptionValue_getOutputBuffer(self)

    def getOptionValue(self) -> "SOptionValue *":
        r"""
        Returns pointer to the wrapped structure. Use this method only
        if this class does not provide the required functionality. Returned
        pointer is valid until this object is deleted.
        """
        return _connect.COptionValue_getOptionValue(self)

# Register COptionValue in _connect:
_connect.COptionValue_swigregister(COptionValue)

class CIDEController(object):
    r"""
    This class can be used to control winIDEA IDE behavior.


    Python example for window resizing: debugIdeTraceProfilerCoverageSample.py 

    Python example for method setOption(): setOptionSample.py 

    Python example for method getOptionStr(): profiler2Example.py 

    Python example for method getCapabilities(): verifyDownloadAndGetCapabilities.py 

    Python example for dynamic option handling: dynamicOptions.py 

    Python example for method commitOptions(): findFreeEmulator.py 

    Python example for methods setOption() and commitOptions(): setCommitOption.py 

    Python example reads communication options: showConnectionStatus.py 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ViewType_Project = _connect.CIDEController_ViewType_Project
    r""" Project view"""
    ViewType_Symbols = _connect.CIDEController_ViewType_Symbols
    r""" Symbols view"""
    ViewType_Callstack = _connect.CIDEController_ViewType_Callstack
    r""" Callstack view"""
    ViewType_Locals = _connect.CIDEController_ViewType_Locals
    r""" Locals view"""
    ViewType_This = _connect.CIDEController_ViewType_This
    r""" This view"""
    ViewType_Disassembly = _connect.CIDEController_ViewType_Disassembly
    r""" Disassembly view"""
    ViewType_CoreRegisters = _connect.CIDEController_ViewType_CoreRegisters
    r""" Core Registers view"""
    ViewType_Terminal = _connect.CIDEController_ViewType_Terminal
    r""" Terminal view"""
    ViewType_Tasks = _connect.CIDEController_ViewType_Tasks
    r""" Tasks view"""
    ViewType_SFRs = _connect.CIDEController_ViewType_SFRs
    r""" SFRs view"""
    ViewType_Output = _connect.CIDEController_ViewType_Output
    r""" Otput view"""
    ViewType_Build = _connect.CIDEController_ViewType_Build
    r""" Build view"""
    ViewType_FindInFiles = _connect.CIDEController_ViewType_FindInFiles
    r""" Find In Files view"""
    ViewType_Tools = _connect.CIDEController_ViewType_Tools
    r""" Tools view"""
    ViewType_Script = _connect.CIDEController_ViewType_Script
    r""" Scripts view"""
    ViewType_Progress = _connect.CIDEController_ViewType_Progress
    r""" Progress view"""
    ViewType_Watch = _connect.CIDEController_ViewType_Watch
    r""" Watch view"""
    ViewType_Memory = _connect.CIDEController_ViewType_Memory
    r""" Memory view"""
    ViewType_SFR = _connect.CIDEController_ViewType_SFR
    r""" SFR view"""
    ViewType_FrameworkPlugin = _connect.CIDEController_ViewType_FrameworkPlugin
    r""" Framework Plugin view"""
    ViewType_Document = _connect.CIDEController_ViewType_Document
    r""" Document view"""
    ViewType_NoneView = _connect.CIDEController_ViewType_NoneView
    ViewState_Opened = _connect.CIDEController_ViewState_Opened
    r""" view opened"""
    ViewState_Closed = _connect.CIDEController_ViewState_Closed
    r""" view closed"""
    ViewState_Undefined = _connect.CIDEController_ViewState_Undefined
    DEFAULT_OPTION_BUFFER_SIZE = _connect.CIDEController_DEFAULT_OPTION_BUFFER_SIZE
    r"""
    Buffer size for data received from winIDEA. If this buffer size is too small,
    use method 'option()' instead of specialized 'getOptionStr()'.
    """
    HOOK_NONE = _connect.CIDEController_HOOK_NONE
    HOOK_ICONNECT_CALL = _connect.CIDEController_HOOK_ICONNECT_CALL
    HOOK_ALL = _connect.CIDEController_HOOK_ALL
    WINIDEA_EXE_DIR = _connect.CIDEController_WINIDEA_EXE_DIR
    r""" directory of winIDEA executable"""
    WORKSPACE_DIR = _connect.CIDEController_WORKSPACE_DIR
    r""" directory of winIDEA workspace file"""
    WORKSPACE_FILE_NAME = _connect.CIDEController_WORKSPACE_FILE_NAME
    r""" name of winIDEA workspace file"""
    EDebugAPI = _connect.CIDEController_EDebugAPI
    r""" debug API"""
    EAnalyzerAPI = _connect.CIDEController_EAnalyzerAPI
    r""" analyzer API"""
    EiTestAPI = _connect.CIDEController_EiTestAPI
    r""" isystem.test API"""

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        """
        _connect.CIDEController_swiginit(self, _connect.new_CIDEController(connectionMgr))
    __swig_destroy__ = _connect.delete_CIDEController

    def getWinIDEAVersion(self) -> "isys::CWinIDEAVersion":
        r"""
        Returns winIDEA version. Supported only on winIDEA versions 9.9 and higher.
        On versions lower than that, it always returns 0.0.0.

        Python example: debugIdeTraceProfilerCoverageSample.py 
        """
        return _connect.CIDEController_getWinIDEAVersion(self)

    def isWinIDEAOpenVersion(self) -> "bool":
        r"""
        Returns true, if winIDEA is open version, false for
        professional version.
        """
        return _connect.CIDEController_isWinIDEAOpenVersion(self)

    def isAPICompatible(self, apiCategory: "isys::CIDEController::EAPICategory") -> "bool":
        r"""
        Returns true, if the given API category is compatible between
        the client and winIDEA of different versions. Client version is
        determined by SDK automatically and winIDEA version is taken from
        connected winIDEA. Connection to winIDEA must be established
        before calling this method.

        :type apiCategory: int
        :param apiCategory: API category to get compatibility info for.
        """
        return _connect.CIDEController_isAPICompatible(self, apiCategory)

    def getPath(self, pathType: "isys::CIDEController::EPathType") -> "std::string":
        r"""
        Returns path or file name of winIDEA item, for example name of
        the workspace file currently opened in winIDEA.

        :type pathType: int
        :param pathType: specifies which path or file name the function should return.

        Python example: ideControllerExample.py 
        """
        return _connect.CIDEController_getPath(self, pathType)

    def closeAllDocuments(self) -> "void":
        r"""
        Closes all documents opened in winIDEA. It has the same functionality as
        CDocumentController::closeAll(), but can be used even if we have no document
        opened via *isystem.connect*.
        """
        return _connect.CIDEController_closeAllDocuments(self)

    def saveAllDocuments(self) -> "void":
        r"""Saves all documents opened in winIDEA."""
        return _connect.CIDEController_saveAllDocuments(self)

    def activate(self) -> "isys::CIDEData":
        r""" Activates the winIDEA window - it gets focus."""
        return _connect.CIDEController_activate(self)

    def minimize(self) -> "isys::CIDEData":
        r"""
        Minimizes winIDEA window.

        Python example: debugIdeTraceProfilerCoverageSample.py 
        """
        return _connect.CIDEController_minimize(self)

    def maximize(self) -> "isys::CIDEData":
        r"""
        Maximizes winIDEA window.

        Python example: debugIdeTraceProfilerCoverageSample.py 
        """
        return _connect.CIDEController_maximize(self)

    def restore(self) -> "isys::CIDEData":
        r"""
        Restores winIDEA window to previous position and size.

        Python example: debugIdeTraceProfilerCoverageSample.py 
        """
        return _connect.CIDEController_restore(self)

    def getPID(self) -> "isys::CIDEData":
        r"""
        Returns object containing process ID of winIDEA instance. To obtain
        the process ID call CIDEData::getPID() on returned object, for example:

           ideData = ideCtrl.getPID()
           pid = ideData.getPID()
        """
        return _connect.CIDEController_getPID(self)

    def move(self, left: "int", top: "int", right: "int", bottom: "int") -> "isys::CIDEData":
        r"""
        Moves and resizes winIDEA window to the given rectangle.

        :type left: int
        :param left: position of the left window edge in screen coordinates
        :type top: int
        :param top: position of the top window edge in screen coordinates
        :type right: int
        :param right: position of the right window edge in screen coordinates
        :type bottom: int
        :param bottom: position of the bottom window edge in screen coordinates

        Python example: ideControllerExample.py 
        """
        return _connect.CIDEController_move(self, left, top, right, bottom)

    def refreshUI(self) -> "void":
        r"""
        Refreshes winIDEA UI. Call this method, when previous calls to isystem.connect
        methods disabled UI refresh (usually for speed reasons).

        See also: CDataController::writeValue(IConnectDebug::EAccessFlags, bool, BYTE, DWORD, const CValueType &)

        Python example: ideControllerExample.py 
        """
        return _connect.CIDEController_refreshUI(self)

    def bringWinIDEAToTop(self) -> "void":
        r"""
        Makes winIDEA window the top window. Works only on winIDEA 9.9 and later.
        Does nothing on winIDEA 9.7 and earlier versions.
        """
        return _connect.CIDEController_bringWinIDEAToTop(self)

    def getNumClients(self) -> "int":
        r"""
        Returns the number of connected iConnect clients (including the calling one).
        On winIDEA 9.7 and earlier always returns -1.
        """
        return _connect.CIDEController_getNumClients(self)

    def getCapabilities(self) -> "isys::CIDECapabilities":
        r"""
        Returns capabilities of the current hardware setup.

        Python example: verifyDownloadAndGetCapabilities.py 
        """
        return _connect.CIDEController_getCapabilities(self)

    def setMsgBoxHook(self, isHookOn: "bool") -> "void":
        r"""
        Deprecated! Use ``setMsgBoxHook(EHookMode`` ``hookMode)`` instead!
        This method behaves like setMsgBoxHook(EHookMode::ICONNECT_CALL).

        Controls displaying of message boxes in winIDEA, when errors
        occur during isystem.connect calls. An isystem.connect call can cause an error
        condition in winIDEA which under normal circumstances brings up a
        modal message box. Such message boxes require user intervention which is
        not desired during isystem.connect operation. winIDEA can therefore hook
        such messages, taking default decisions when they occur.

        :type isHookOn: boolean
        :param isHookOn: if true, message box is NOT displayed

        :raises: IOException in case of an error
        """
        return _connect.CIDEController_setMsgBoxHook(self, isHookOn)

    def setMsgBoxHookMode(self, hookMode: "isys::CIDEController::EHookMode") -> "void":
        r"""
        Controls displaying of message boxes in winIDEA. An ``isystem.connect`` call can cause an error
        condition in winIDEA which under normal circumstances brings up a
        modal message box. Such message boxes require user intervention which is
        not desired during ``isystem.connect`` operation. This method can be used
        to suppress such messages.

        :type hookMode: int
        :param hookMode: specifices which message boxes are hooked
                   - EHookMode::HOOK_NONE - no hooking, all message boxes are shown
                   - EHookMode::HOOK_ICONNECT_CALL - only message boxes which occur during
                                                ``isystem.connect`` call are not shown. This
                                                mode is sufficient in most cases, and keeps
                                                normal behavior in manual usage of winIDEA.
                   - EHookMode::HOOK_ALL - all message boxes are hooked. This means also message boxes
                                      in manual mode. For example, if we start download from winIDEA,
                                      but target is not connected, there will be no error message box!
                                      The reason for this mode is that some errors do not ocurr
                                      immediately during ``isystem.connect`` call, but only when
                                      the operation completes in another thread. An example of such
                                      case is profiler, where we start the profiler, but error
                                      ocurrs later during recording. Use this mode only when really
                                      necessary.
        """
        return _connect.CIDEController_setMsgBoxHookMode(self, hookMode)

    def isMsgBoxHookOn(self) -> "bool":
        r"""
        Returns true, if message boxes are disabled either by EHookMode::HOOK_ICONNECT_CALL
        or EHookMode::HOOK_ALL.

        See also: #setMsgBoxHookMode(EHookMode)
        """
        return _connect.CIDEController_isMsgBoxHookOn(self)

    def getMsgBoxHookMode(self) -> "isys::CIDEController::EHookMode":
        r"""
        Returns message box hook mode.

        See also: #setMsgBoxHookMode(EHookMode)
        """
        return _connect.CIDEController_getMsgBoxHookMode(self)

    def iOpenDisconnect(self) -> "void":
        r"""
        Disconnect winIDEA from emulator. This method is equivalent to
        winIDEA menu command 'Tools | Disconnect'.

        Python example: ideControllerExample.py 
        """
        return _connect.CIDEController_iOpenDisconnect(self)

    def getDefaultDownloadFile(self) -> "std::string":
        r"""
        Returns default download file as set in winIDEA, Debug | Files for download.
        Throws FileNotFoundException if there is no download file with symbols or
        `Load Symbols` check box is not selected in winIDEA.
        """
        return _connect.CIDEController_getDefaultDownloadFile(self)

    def option(self, *args) -> "bool":
        r"""
        *Overload 1:*

        This is general method for setting winIDEA options. Use
        ``set/getOption()`` methods for simple cases.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        Example in Python:

        import isystem.connect as ic

        ide = ic.CIDEController(conMgr)
        optVal = isystem.connect.COptionValue("myString")
        flags = ic.ofValBuffer | ic.ofSet
        ide.option(flags, "myscope", "myoption", optVal)



        :type flags: int
        :param flags: see EOptionFlags in i_Option.h and EOptionFlags in IConnectIDE.

        :type scope: string
        :param scope: defines the destination. It may be file name in
                         case of documents or CLSID in case of plugins.

        :type option: string
        :param option: option to set, depends also on ``flags`` used

        :type optValue: :py:class:`COptionValue`
        :param optValue: data for option manipulation, see isys::COptionValue

        |

        *Overload 2:*

        This is general method for setting winIDEA options. Destination and
        scope (document name) are encoded in optionURL.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type flags: int
        :param flags: see EOptionFlags in IConnectIDE.

        :param option: URL of option to set.

        :type optValue: :py:class:`COptionValue`
        :param optValue: data for option manipulation, see isys::COptionValue
        """
        return _connect.CIDEController_option(self, *args)

    def setOptionsMap(self, moduleTypeId: "std::string const &", assignmentsMap: "std::string const &") -> "void":
        r"""
        Sets multiple of options with one call.

        :type moduleTypeId: string
        :param moduleTypeId: defines module type and ID combined. See constants beginning with
                                        ``OPT_DEST_...`` defined in this file for available
                                        module types, for example CIDEController::OPT_DEST_IDE.

                                        If moduleType is OPT_DEST_DOCUMENT, append document name.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if moduleID must be specified.


                             <optionPath> path defining the option. 


                             Examples:

               setOptionsMap("/IDE/", "Debug.DownloadFiles.File[0].Path: prog.elf")
               setOptionsMap("/Document/sample_profiler.trd/", "SessionTrigger.Item.Profiler.ExecArea[1].Name: func1")
        """
        return _connect.CIDEController_setOptionsMap(self, moduleTypeId, assignmentsMap)

    def getOptionsMap(self, moduleTypeId: "std::string const &", options: "std::string const &", bufferSize: "int") -> "std::string":
        r"""
        Returns values of multiple options separated by '\n'.

        :type moduleTypeId: string
        :param moduleTypeId: defines module type and ID combined. See constants beginning with
                                        ``OPT_DEST_...`` defined in this file for available
                                        module types, for example CIDEController::OPT_DEST_IDE.

                                        If moduleType is OPT_DEST_DOCUMENT, append document name.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if moduleID must be specified.


                             <optionPath> path defining the option. 


                             Examples:

               getOptionsMap("/IDE/", "Debug.DownloadFiles.File[0].Path\nDebug.DownloadFiles.File[1].Path", 1000);
               getOptionsMap("/Document/sample_profiler.trd/", "SessionTrigger.Item.Profiler.ExecArea[0].Name\nSessionTrigger.Item.Profiler.ExecArea[1].Name", 1000);
        """
        return _connect.CIDEController_getOptionsMap(self, moduleTypeId, options, bufferSize)

    def setOptionJSON(self, optionUrl: "std::string const &", valueJSON: "std::string const &") -> "void":
        r"""
        Sets winIDEA options of an object from a JSON formatted string
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        Example:

          ide.setOption("/IOPEN/Hardware", strJSON)


        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /IOPEN/Communication


        :type valueJSON: string
        :param valueJSON: value to be assigned to the object

        :raises: IOException in case of failure.
        """
        return _connect.CIDEController_setOptionJSON(self, optionUrl, valueJSON)

    def setOption_str(self, optionUrl: "std::string const &", value: "std::string const &") -> "void":
        r"""
        This method should be used in languages, where oveloading makes
        problems, for example Tcl.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        See also: setOption(const std::string &, const std::string &);
        """
        return _connect.CIDEController_setOption_str(self, optionUrl, value)

    def setOption_u32(self, optionUrl: "std::string const &", value: "DWORD") -> "void":
        r"""
        Sets winIDEA option.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        Example:

          ide.setOption("/IDE/Debug.Symbols.Format.MaxParseUpload", 256)


        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart



        :type value: int
        :param value: value to be assigned to the option

        :raises: IOException in case of failure.

        See also: #setOption(std::string, std::string)

        This method should be used in languages, where oveloading makes
        problems.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        See also: setOption(const std::string &, DWORD);
        """
        return _connect.CIDEController_setOption_u32(self, optionUrl, value)

    def setOption_f64(self, optionUrl: "std::string const &", value: "double") -> "void":
        r"""
        This method should be used in languages, where oveloading makes
        problems, for example Tcl.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        See also: setOption(const std::string &, double);
        """
        return _connect.CIDEController_setOption_f64(self, optionUrl, value)

    def setOption(self, *args) -> "void":
        r"""
        *Overload 1:*

        Sets winIDEA option.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        Example:

          ide.setOption(ofDestIOPEN, "", "Hardware.Emulator", "iC5000")


        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plugins.

        :type option: string
        :param option: paths to option

        :type value: string
        :param value: value of option

        :raises: IOException in case of failure.

        Python example: dynamicOptions.py 


        |

        *Overload 2:*

        Sets winIDEA option.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plugins.

        :type option: string
        :param option: paths to option

        :type value: int
        :param value: value of option

        :raises: IOException in case of failure.

        See also: #setOption(DWORD, std::string, std::string, std::string)

        |

        *Overload 3:*

        Sets winIDEA option.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plugins.

        :type option: string
        :param option: paths to option

        :type value: float
        :param value: value of option

        :raises: IOException in case of failure.

        See also: #setOption(DWORD, std::string, std::string, std::string)

        |

        *Overload 4:*

        Sets winIDEA option.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        Example:

          ide.setOption("/IOPEN/Hardware.Emulator", "iC3000")


        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart


        :type value: string
        :param value: value to be assigned to the option

        :raises: IOException in case of failure.

        Python example: setCommitOption.py 

        Python example: setOptionSample.py Another 


        |

        *Overload 5:*

        Sets winIDEA option.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        Example:

          ide.setOption("/IDE/Debug.Symbols.Format.VagueFloatPrecision", 1e-005)



        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart


        :type value: float
        :param value: value to be assigned to the option

        :raises: IOException in case of failure.

        See also: setOption(std::string, std::string)

        |

        *Overload 6:*

        Sets winIDEA option.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        Example:

          ide.setOption("/Document/traceTest.trd/TraceExport.TimeFrom", 5000000000)



        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart


        :type value: int
        :param value: value to be assigned to the option

        :raises: IOException in case of failure.

        See also: setOption(std::string, std::string)

        |

        *Overload 7:*

        Sets winIDEA option.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        Example:

          ide.setOption("/IDE/Debug.DownloadFiles.File[0].Load", true)



        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart


        :type value: boolean
        :param value: value to be assigned to the option

        :raises: IOException in case of failure.

        See also: setOption(std::string, std::string)
        """
        return _connect.CIDEController_setOption(self, *args)

    def optionExists(self, option: "std::string const &") -> "bool":
        r"""
        Returns true, if the given option exists, false otherwise.

        :param optionUrl: url of the option with value, not just part of option path.
                             Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart
        """
        return _connect.CIDEController_optionExists(self, option)

    def getOptionStr(self, *args) -> "std::string":
        r"""
        *Overload 1:*

        Returns winIDEA option of type string.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plugins.

        :param option: paths to option

        Python example: dynamicOptions.py 


        |

        *Overload 2:*

        Returns winIDEA option of type string.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart


        Python example: profiler2Example.py 

        Python example with dynamic options: dynamicOptions.py 

        Python example reads communication options: showConnectionStatus.py  
        """
        return _connect.CIDEController_getOptionStr(self, *args)

    def getOptionJSON(self, optionUrl: "std::string const &") -> "std::string":
        r"""
        Returns winIDEA options of an object as JSON formatted string
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code
        """
        return _connect.CIDEController_getOptionJSON(self, optionUrl)

    def getOptionInt(self, *args) -> "int64_t":
        r"""
        *Overload 1:*

        Returns winIDEA option of type integer.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plugins.

        :type option: string
        :param option: paths to option

        |

        *Overload 2:*

        Returns winIDEA option of type integer.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart


        Python example: dynamicOptions.py 
        """
        return _connect.CIDEController_getOptionInt(self, *args)

    def getOptionFloat(self, *args) -> "double":
        r"""
        *Overload 1:*

        Returns winIDEA option of type float.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plug-ins.

        :type option: string
        :param option: paths to option

        |

        *Overload 2:*

        Returns winIDEA option of type float.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart
        """
        return _connect.CIDEController_getOptionFloat(self, *args)

    def getEnumElements(self, optionUrl: "std::string const &", elements: "StrStrMap") -> "void":
        return _connect.CIDEController_getEnumElements(self, optionUrl, elements)

    def getOptionDataDescriptor(self, optionUrl: "std::string const &") -> "DataDescriptor::IDescriptor *":
        return _connect.CIDEController_getOptionDataDescriptor(self, optionUrl)

    def getMenuStructure(self, optionUrl: "std::string const &") -> "isys::IMenuStructure *":
        return _connect.CIDEController_getMenuStructure(self, optionUrl)

    def release(self, *args) -> "void":
        return _connect.CIDEController_release(self, *args)

    def getDynamicOptionSize(self, *args) -> "DWORD":
        r"""
        *Overload 1:*

        Returns current number of items in dynamic option.

        **Dynamic** **options** are arrays of
        options, which size is not fixed. They may have 0..N items. Example of dynamic
        option are breakpoints. There may be any number of breakpoints in the program, and
        each of them contains several attributes, for example location and enabled status.
        See 'Help | Display Option...' in winIDEA. Make sure that ``Values`` check-box is not
        checked and click the ``Display`` button. All options with '[]' are dynamic. If there
        is a number, for example '[32]', the option has fixed size.

        Example:

        ide.getDynamicOptionSize(ofDestIDE, "", "ExecBPs.BP");


        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plugins.

        :type option: string
        :param option: path to option

        Python example: dynamicOptions.py 


        |

        *Overload 2:*

        Returns current number of items in dynamic option.

        Example:

        ide.getDynamicOptionSize("/IDE/ExecBPs.BP");


        See also: getDynamicOptionSize() for description of ``dynamic`` options
        """
        return _connect.CIDEController_getDynamicOptionSize(self, *args)

    def findDynamicOption(self, urlBase: "std::string const &", elementName: "std::string const &", strToFind: "std::string const &") -> "int":
        r"""
        This method returns index of option with the given value. For example,
        if we have an array of options


        "/a/b.c[idx].d" = x


        and we specify:

        urlBase = "/a/b.c"
        elementName = "d"
        strToFind = "e"


        then this method will return the first ``idx``, for which ``x == "e"``.
        If the item is not found, -1 is returned.

        :type urlBase: string
        :param urlBase: url of the dynamic option, without index
        :type elementName: string
        :param elementName: name of the element in the array of dynamic options
        :type strToFind: string
        :param strToFind: value of the dynamic option to look for

        Python example: dynamicOptions.py 
        """
        return _connect.CIDEController_findDynamicOption(self, urlBase, elementName, strToFind)

    def getDynamicOptions(self, urlBase: "std::string const &", elementName: "std::string const &", optionValues: "StrVector") -> "void":
        r"""
        Returns all values of dynamic options for the given urlBase
        and element.
        Example:

        Get all function names in profiler for current trigger. URL for the first
        name is
        ``/Document/sample_profiler.trd/SessionTrigger.Item.Profiler.ExecArea[0].Name``

        Specify parameters as:

         urlBase = "/Document/sample_profiler.trd/SessionTrigger.Item.Profiler.ExecArea"
         elementName = "Name"


        :param part: of url up to index
        :param part: of url after index
        :type optionValues: :py:class:`StrVector`
        :param optionValues: vector to contain option values on return

        Python example: dynamicOptions.py 
        """
        return _connect.CIDEController_getDynamicOptions(self, urlBase, elementName, optionValues)

    def addDynamicOption(self, *args) -> "int":
        r"""
        *Overload 1:*

        Adds item at the specified index in dynamic option. Default values are used for
        all members of the item. Use method setOption() to define the values.

        Example:

        ide.addDynamicOption(ofDestIDE, "", "ExecBPs.BP");  // add empty breakpoint


        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plugins.

        :param option: path to option

        :type index: int, optional
        :param index: item index. If set to -1, item is appended to the end of the list.

        :rtype: int
        :return: index of the added element. Useful when input ``index`` was set to -1.

        Python example: dynamicOptions.py 


        |

        *Overload 2:*

        Adds item at the specified index in dynamic option. Default values are used for
        all members of the item. Use method setOption() to define the values.

        Example:

        ide.addDynamicOption("/IDE/ExecBPs.BP");  // appends an empty breakpoint


        :type index: int, optional
        :param index: item index. If set to -1, item is appended to the end of the list.

        :rtype: int
        :return: index of the added element. Useful when input ``index`` was set to -1.

        Python example: dynamicOptions.py 


        |

        *Overload 3:*

        Adds item at the specified index in dynamic option. Default values are used for
        all members of the item. Use method setOption() to define the values.

        Example:

        ide.addDynamicOption("/IDE/ExecBPs.BP");  // appends an empty breakpoint


        :param index: item index. If set to -1, item is appended to the end of the list.

        :rtype: int
        :return: index of the added element. Useful when input ``index`` was set to -1.

        Python example: dynamicOptions.py 
        """
        return _connect.CIDEController_addDynamicOption(self, *args)

    def addDynamicOptionUrl(self, optionUrl: "std::string const &", index: "int"=-1) -> "std::string":
        r"""
        This is a helper method, which performs the same operation as addDynamicOption(const std::string &, int),
        but returns URL of the added option instead of its index.

        See also: addDynamicOption(const std::string &, int)

        Python example: dynamicOptions.py 
        """
        return _connect.CIDEController_addDynamicOptionUrl(self, optionUrl, index)

    def removeDynamicOption(self, *args) -> "void":
        r"""
        *Overload 1:*

        Removes item at the specified index in dynamic option.

        Example:

        ide.removeDynamicOption(ofDestIDE, "", "ExecBPs.BP", 2);


        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plugins.

        :param option: path to option

        :type index: int, optional
        :param index: item index. If set to -1, all items are removed.

        |

        *Overload 2:*

        Removes item at the specified index in dynamic option.

        Example:

        ide.removeDynamicOption("/IDE/ExecBPs.BP");


        :type index: int, optional
        :param index: item index. If set to -1, all items are removed.

        Python example: dynamicOptions.py 


        |

        *Overload 3:*

        Removes item at the specified index in dynamic option.

        Example:

        ide.removeDynamicOption("/IDE/ExecBPs.BP");


        :param index: item index. If set to -1, all items are removed.

        Python example: dynamicOptions.py 
        """
        return _connect.CIDEController_removeDynamicOption(self, *args)

    def commitOptions(self, *args) -> "void":
        r"""
        *Overload 1:*

        Deprecated: This method terminates debugging session in most cases.
        Since all options are applied at start of debugging session, this
        method is no longer needed. For options applied during debugging session,
        use service call. For example, to apply hardware breakpoints, call

            serviceCall('/iOPEN/Core.Debug.ApplyInternalBPs', '')

        Contact iSYSTEM support if you need other options to be applied during debug session.

        ---

        Commits options previously set by option() and setOption() methods.

        :type optionUrl: string
        :param optionUrl: url of the option to commit. Can also be module type
                             only, for example "/IOPEN/" or "/IDE/". Both '/' must be
                             present, as they are in the examples.

        Python example: setCommitOption.py 


        |

        *Overload 2:*

        Deprecated: This method terminates debugging session in most cases.
        Since all options are applied at start of debugging session, this
        method is no longer needed. For options applied during debugging session,
        use service call. For example, to apply hardware breakpoints, call

            serviceCall('/iOPEN/Core.Debug.ApplyInternalBPs', '')

        Contact iSYSTEM support if you need other options to be applied during debug session.

        ---

        Commits options previously set by option() and setOption() methods.
        Note that document and plugin destinations cannot use this function as they require
        the path to the document or plugin. Use commitOptions('/Document/<path>') function instead

        :type destFlags: int
        :param destFlags: one of ``ofDest...`` flags from ::EOptionFlags.

        Python example: findFreeEmulator.py 
        """
        return _connect.CIDEController_commitOptions(self, *args)

    def serviceCall(self, *args) -> "std::string":
        r"""
        *Overload 1:*

        Deprecated: call method ``'invoke(std::string, iconnect::StrStrMap, iconnect::StrStrMap)'``
        This method invokes functions within winIDEA process. Use this
        method only when instructed by iSystem support.

        :type funcUrl: string
        :param funcUrl: name of the winIDEA service function to call, for
                           example: ``'/IDE/Divide'``
        :type params: string
        :param params: function parameters as comma separated ``key: value`` pairs,
                                   for example: ``'Dividend: 10, Divisor: 3'``
        :type bufferSize: int, optional
        :param bufferSize: buffer size for data received from winIDEA. Usually there is no need
                              to set this value.

        :rtype: string
        :return: function result as comma separated ``key: value`` pairs,
                                   for example: ``'Quotient: 5, Remainder: 0'``

        **IMPORTANT: Never parse returned string with your code, because format may change in the future.
                      Always use parseServiceCallMap() for parsing, then retrieve values from
                      mapping.**

        Python example: serviceCall.py 


        |

        *Overload 2:*

        Deprecated: call method ``'invoke(std::string, iconnect::StrStrMap, iconnect::StrStrMap)'``
        This method invokes functions within winIDEA process. Use this
        method only when instructed by iSystem support.

        :type funcUrl: string
        :param funcUrl: name of the winIDEA service function to call, for
                           example: ``'/IDE/Divide'``
        :type inParams: :py:class:`StrStrMap`
        :param inParams: input parameters as mapping
        :type outParams: :py:class:`StrStrMap`
        :param outParams: output parameters as mapping
        :type bufferSize: int, optional
        :param bufferSize: buffer size for data received from winIDEA. Usually there is no need
                              to set this value.

        :rtype: string
        :return: function result as comma separated ``key: value`` pairs,
                             for example: ``'Quotient: 5, Remainder: 0'``
                             This information is the same as returned in ``outParams``.

        **IMPORTANT: Never parse returned string with your code, because format may change in the future.
                      Always use returned ``outParams`` mapping.**

        Python example: serviceCall.py 


        |

        *Overload 3:*

        Deprecated: call method ``'invoke(std::string, iconnect::StrStrMap, iconnect::StrStrMap)'``
        This method invokes functions within winIDEA process. Use this
        method only when instructed by iSystem support.

        :type funcUrl: string
        :param funcUrl: name of the winIDEA service function to call, for
                           example: ``'/IDE/Divide'``
        :type inParams: :py:class:`StrStrMap`
        :param inParams: input parameters as mapping
        :type outParams: :py:class:`StrStrMap`
        :param outParams: output parameters as mapping
        :param bufferSize: buffer size for data received from winIDEA. Usually there is no need
                              to set this value.

        :rtype: string
        :return: function result as comma separated ``key: value`` pairs,
                             for example: ``'Quotient: 5, Remainder: 0'``
                             This information is the same as returned in ``outParams``.

        **IMPORTANT: Never parse returned string with your code, because format may change in the future.
                      Always use returned ``outParams`` mapping.**

        Python example: serviceCall.py 
        """
        return _connect.CIDEController_serviceCall(self, *args)

    def invoke(self, *args) -> "std::string":
        r"""
        This method invokes functions within winIDEA process. Use this
        method only when instructed by iSystem support.

        :type funcUrl: string
        :param funcUrl: name of the winIDEA service function to call, for
                           example: ``'/IDE/Divide'``
        :type inParams: :py:class:`StrStrMap`
        :param inParams: input parameters as mapping
        :type outParams: :py:class:`StrStrMap`
        :param outParams: output parameters as mapping
        :type bufferSize: int, optional
        :param bufferSize: buffer size for data received from winIDEA. Usually there is no need
                              to set this value.

        :rtype: string
        :return: function result as comma separated ``key: value`` pairs,
                             for example: ``'Quotient: 5, Remainder: 0'``
                             This information is the same as returned in ``outParams``.

        **IMPORTANT: Never parse returned string with your code, because format may change in the future.
                      Always use returned ``outParams`` mapping.**

        Python example: invoke.py 
        """
        return _connect.CIDEController_invoke(self, *args)

    @staticmethod
    def parseServiceCallMap(str: "std::string const &", outParams: "StrStrMap") -> "void":
        r"""
        Deprecated: due to serviceCall() methods deprecation this one is not needed anymore,
        call ``'invoke(std::string, iconnect::StrStrMap, iconnect::StrStrMap)'``
        Parses the given string and returns mapping of strings. The string should be
        obtained as return value from service call.

        :type str: string
        :param str: string returned by method serviceCall(const std::string &, const std::string &, int)
        :type outParams: :py:class:`StrStrMap`
        :param outParams: mapping to receive parsed key/value pairs.
        """
        return _connect.CIDEController_parseServiceCallMap(str, outParams)

    def setInterruptsDisable(self, interruptFlags: "int64_t"=0xffff) -> "int64_t":
        r"""
        This method is a convenient shortcut to disable target interrupts during
        some winIDEA operations, and to restore the previous state.

        If called with the default argument value, all interrupts are disabled.
        Returns current setting, which can be used on next call to restore the
        the interrupt enabled/disabled setting.
        The returned value can only be used as parameter to this method
        to restore previous state. The meaning of bits is internal to this
        method. If you would like to have finer control over interrupts,
        then set options ``/IDE/Debug.Debugging.DisableIRQ_...`` manually.
        """
        return _connect.CIDEController_setInterruptsDisable(self, interruptFlags)

    def cdToWinIDEAWorkspaceDir(self) -> "std::string":
        r"""
        Changes working directory to winIDEA workspace directory.

        :rtype: string
        :return: working directory before this function was called
        """
        return _connect.CIDEController_cdToWinIDEAWorkspaceDir(self)

    def getLicenseDescription(self) -> "std::string":
        r""" Returns license description."""
        return _connect.CIDEController_getLicenseDescription(self)

    def openView(self, *args) -> "void":
        r"""
        Opens specified winIDEA view, for example Symbols, Callstack, etc.

        :type type: int
        :param type: type of the view, must be one of `CIDEController::ViewType`. This parameter is sufficient for opening singleton views.
        :type name: string, optional
        :param name: name of the view. This is required for opening specified non-singleton view, but only if once opened via GUI (manually).
            Memory view is an example of such view.
        """
        return _connect.CIDEController_openView(self, *args)

    def closeView(self, *args) -> "void":
        r"""
        Closes specified winIDEA view, for example Symbols, Callstack, etc.

        :type type: int
        :param type: type of the view, must be one of `CIDEController::ViewType`. This parameter is sufficient for closing singleton views
            or all non-singleton views of certain type.
        :type name: string, optional
        :param name: name of the view. This is required for closing non-singleton view with a certain name, but only if once opened via GUI (manually).
            Memory view is an example of such view.
        """
        return _connect.CIDEController_closeView(self, *args)

    def closeAllViews(self) -> "void":
        r"""Closes all documents and views."""
        return _connect.CIDEController_closeAllViews(self)

    def enumerateViewTypes(self, data: "std::vector< isys::ViewTypeData,std::allocator< isys::ViewTypeData > > &") -> "void":
        r"""
        Enumerates complete view types (singleton and non-singleton), providing data for each type.
        :type data: std::vector< isys::ViewTypeData,std::allocator< isys::ViewTypeData > >
        :param data: vector of `CIDEController::ViewTypeData` elements
        """
        return _connect.CIDEController_enumerateViewTypes(self, data)

    def enumerateAllViews(self, data: "ViewDataVector") -> "void":
        r"""
        Enumerates complete views (singleton and existing non-singleton), providing data for each of it.
        :type data: std::vector< isys::ViewData,std::allocator< isys::ViewData > >
        :param data: vector of `CIDEController::ViewData` elements
        """
        return _connect.CIDEController_enumerateAllViews(self, data)

    def enumerateView(self, type: "isys::CIDEController::ViewType", data: "ViewDataVector") -> "void":
        r"""
        Enumerates all views of specified type.
        :type type: int
        :param type: view type
        :type data: std::vector< isys::ViewData,std::allocator< isys::ViewData > >
        :param data: vector of `CIDEController::ViewData` elements
        """
        return _connect.CIDEController_enumerateView(self, type, data)

    def exportViewLayout(self, filePath: "std::string const") -> "void":
        r"""
        Exports layout as workspace template.
        :type filePath: string
        :param filePath: path to the file with *.jswt extension (Json Workspace Template). Can be an absolute path or relative to the workspace.
        """
        return _connect.CIDEController_exportViewLayout(self, filePath)

    def importViewLayout(self, filePath: "std::string const") -> "void":
        r"""
        Imports layout from workspace template.
        :type filePath: string
        :param filePath: path to the file with *.jswt extension (Json Workspace Template). Can be an absolute path or relative to the workspace.
        """
        return _connect.CIDEController_importViewLayout(self, filePath)

    def getLValue(self, key: "std::string const &") -> "std::string":
        return _connect.CIDEController_getLValue(self, key)

# Register CIDEController in _connect:
_connect.CIDEController_swigregister(CIDEController)
CIDEController.ADVANCED_KEY_0 = _connect.cvar.CIDEController_ADVANCED_KEY_0
CIDEController.EVALUATION_LICENSE_STR = _connect.cvar.CIDEController_EVALUATION_LICENSE_STR
CIDEController.LICENSE_DESCRIPTION = _connect.cvar.CIDEController_LICENSE_DESCRIPTION
CIDEController.OPT_DEST_IDE = _connect.cvar.CIDEController_OPT_DEST_IDE
CIDEController.OPT_DEST_DOCUMENT = _connect.cvar.CIDEController_OPT_DEST_DOCUMENT
CIDEController.OPT_DEST_IOPEN = _connect.cvar.CIDEController_OPT_DEST_IOPEN
CIDEController.OPT_DEST_PLUGIN = _connect.cvar.CIDEController_OPT_DEST_PLUGIN
CIDEController.OPT_DEST_HIL = _connect.cvar.CIDEController_OPT_DEST_HIL

def CIDEController_parseServiceCallMap(str: "std::string const &", outParams: "StrStrMap") -> "void":
    r"""
    Deprecated: due to serviceCall() methods deprecation this one is not needed anymore,
    call ``'invoke(std::string, iconnect::StrStrMap, iconnect::StrStrMap)'``
    Parses the given string and returns mapping of strings. The string should be
    obtained as return value from service call.

    :type str: string
    :param str: string returned by method serviceCall(const std::string &, const std::string &, int)
    :type outParams: :py:class:`StrStrMap`
    :param outParams: mapping to receive parsed key/value pairs.
    """
    return _connect.CIDEController_parseServiceCallMap(str, outParams)

class ViewTypeData(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_connect.ViewTypeData_type_get, _connect.ViewTypeData_type_set, doc=r""" view type""")
    name = property(_connect.ViewTypeData_name_get, _connect.ViewTypeData_name_set, doc=r""" view type name""")
    isSingleton = property(_connect.ViewTypeData_isSingleton_get, _connect.ViewTypeData_isSingleton_set, doc=r""" singleton status""")

    def __init__(self):
        _connect.ViewTypeData_swiginit(self, _connect.new_ViewTypeData())
    __swig_destroy__ = _connect.delete_ViewTypeData

# Register ViewTypeData in _connect:
_connect.ViewTypeData_swigregister(ViewTypeData)

class ViewData(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_connect.ViewData_type_get, _connect.ViewData_type_set, doc=r""" view type""")
    state = property(_connect.ViewData_state_get, _connect.ViewData_state_set, doc=r""" view state""")
    name = property(_connect.ViewData_name_get, _connect.ViewData_name_set, doc=r""" view name""")
    typeName = property(_connect.ViewData_typeName_get, _connect.ViewData_typeName_set, doc=r""" view type name""")

    def __init__(self):
        _connect.ViewData_swiginit(self, _connect.new_ViewData())
    __swig_destroy__ = _connect.delete_ViewData

# Register ViewData in _connect:
_connect.ViewData_swigregister(ViewData)

class DownloadListMember(object):
    r"""Description of file in winIDEA download list."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    fileName = property(_connect.DownloadListMember_fileName_get, _connect.DownloadListMember_fileName_set, doc=r""" Name of the file.""")
    options = property(_connect.DownloadListMember_options_get, _connect.DownloadListMember_options_set, doc=r""" Advanced download options from winIDEA dialog""")

    def __init__(self):
        _connect.DownloadListMember_swiginit(self, _connect.new_DownloadListMember())
    __swig_destroy__ = _connect.delete_DownloadListMember

# Register DownloadListMember in _connect:
_connect.DownloadListMember_swigregister(DownloadListMember)

class CDownloadConfiguration(object):
    r"""
    This class contains data used for download to target. At least one of methods
    setCodeOffset() or setSymbolsOffset() should be called to define which
    data should be downloaded.

    This class is intended to be used with methods CLoaderController::targetDownload() and
    CLoaderController::addToDownloadList().



    Python example: addFileToDownloadList.py 

    Python example with target download: targetDownload.py 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ftBinary = _connect.CDownloadConfiguration_ftBinary
    r""" binary format"""
    ftIntelHex = _connect.CDownloadConfiguration_ftIntelHex
    r""" Intel hex format"""
    ftMotorolaS = _connect.CDownloadConfiguration_ftMotorolaS
    r""" MotorolaS format"""
    ftTektronix = _connect.CDownloadConfiguration_ftTektronix
    r""" Tektronix format"""
    ftExtendedTektronix = _connect.CDownloadConfiguration_ftExtendedTektronix
    r""" ExtendedTektronix format"""
    ftUBROF = _connect.CDownloadConfiguration_ftUBROF
    r""" UBROF format"""
    ftOMF166 = _connect.CDownloadConfiguration_ftOMF166
    r""" OMF166 format"""
    ftICFOFF = _connect.CDownloadConfiguration_ftICFOFF
    r""" ICFOFF format"""
    ftOMF51 = _connect.CDownloadConfiguration_ftOMF51
    r""" OMF51 format"""
    ftSLOText = _connect.CDownloadConfiguration_ftSLOText
    r""" SLOText format"""
    ftMicrotek = _connect.CDownloadConfiguration_ftMicrotek
    r""" Microtek format"""
    ftIEEE695 = _connect.CDownloadConfiguration_ftIEEE695
    r""" IEEE695 format"""
    ftAD2500 = _connect.CDownloadConfiguration_ftAD2500
    r""" AD2500 format"""
    ftAXE = _connect.CDownloadConfiguration_ftAXE
    r""" AXE format"""
    ftByteCraftCOD = _connect.CDownloadConfiguration_ftByteCraftCOD
    r""" ByteCraftCOD format"""
    ftMotorolaSymbolic = _connect.CDownloadConfiguration_ftMotorolaSymbolic
    r""" MotorolaSymbolic format"""
    ftHiTech = _connect.CDownloadConfiguration_ftHiTech
    r""" HiTech format"""
    ftOMF86 = _connect.CDownloadConfiguration_ftOMF86
    r""" OMF86 format"""
    ftOMF96 = _connect.CDownloadConfiguration_ftOMF96
    r""" OMF96 format"""
    ftOMF251 = _connect.CDownloadConfiguration_ftOMF251
    r""" OMF251 format"""
    ftProspero = _connect.CDownloadConfiguration_ftProspero
    r""" Prospero format"""
    ftLogitechModula2 = _connect.CDownloadConfiguration_ftLogitechModula2
    r""" LogitechModula2 format"""
    ftELF = _connect.CDownloadConfiguration_ftELF
    r""" ELF format"""
    ftMARC4 = _connect.CDownloadConfiguration_ftMARC4
    r""" MARC4 format"""
    ftCR16COFF = _connect.CDownloadConfiguration_ftCR16COFF
    r""" CR16COFF format"""
    ftTMSCOFF = _connect.CDownloadConfiguration_ftTMSCOFF
    r""" TMSCOFF format"""
    ftStabs = _connect.CDownloadConfiguration_ftStabs
    r""" Stabs format"""
    ftZardoz = _connect.CDownloadConfiguration_ftZardoz
    r""" Zardoz format"""

    def __init__(self):
        r""" Constructor initializes fields to default values."""
        _connect.CDownloadConfiguration_swiginit(self, _connect.new_CDownloadConfiguration())

    def setCodeOffset(self, offset: "ADDRESS") -> "isys::CDownloadConfiguration &":
        r""" Sets code offset. If this method is not called, code is not downloaded."""
        return _connect.CDownloadConfiguration_setCodeOffset(self, offset)

    def setSymbolsOffset(self, offset: "ADDRESS") -> "isys::CDownloadConfiguration &":
        r""" Sets symbols offset. If this method is not called, symbols are not downloaded."""
        return _connect.CDownloadConfiguration_setSymbolsOffset(self, offset)

    def setMemoryArea(self, *args) -> "isys::CDownloadConfiguration &":
        r"""
        *Overload 1:*
        Legacy method - does nothing. Use setMemoryArea(const std::string &memoryArea).

        |

        *Overload 2:*
        Sets memory area. If this method is not called, default memory area is used.
        """
        return _connect.CDownloadConfiguration_setMemoryArea(self, *args)

    def getMemoryArea(self) -> "std::string":
        r""" Gets memory area."""
        return _connect.CDownloadConfiguration_getMemoryArea(self)

    def setUsedInFullDownload(self, isUsedInFullDownload: "bool") -> "isys::CDownloadConfiguration &":
        r"""
         If ``isUsedInFullDownload`` is true, then the file is used when full download is performed.
        Set to ``false`` by default.
        """
        return _connect.CDownloadConfiguration_setUsedInFullDownload(self, isUsedInFullDownload)

    def setIsProjectOutputFile(self, isProjectOutputFile: "bool") -> "isys::CDownloadConfiguration &":
        return _connect.CDownloadConfiguration_setIsProjectOutputFile(self, isProjectOutputFile)

    def setInProjectTargetDir(self, isInProjectTargetDir: "bool") -> "isys::CDownloadConfiguration &":
        r"""
         If ``isInProjectTargetDir`` is true, the file is taken from the project target directory.
        Set to ``false`` by default.
        """
        return _connect.CDownloadConfiguration_setInProjectTargetDir(self, isInProjectTargetDir)

    def setTypeEqualByName(self, isTypeEqualByName: "bool") -> "isys::CDownloadConfiguration &":
        r"""
         If ``isTypeEqualByName`` is set to true, types with the same name are
        assumed to be equal. Set to ``false`` by default.
        """
        return _connect.CDownloadConfiguration_setTypeEqualByName(self, isTypeEqualByName)

    def setDownloadFileFormat(self, format: "isys::CDownloadConfiguration::DownloadFileFormats") -> "isys::CDownloadConfiguration &":
        r""" Sets the download file format. Binary format is set by default."""
        return _connect.CDownloadConfiguration_setDownloadFileFormat(self, format)

    def setRealTimeAccess(self, isRealTimeAccess: "bool") -> "isys::CDownloadConfiguration &":
        r""" Sets real-time access. Off by default."""
        return _connect.CDownloadConfiguration_setRealTimeAccess(self, isRealTimeAccess)

    def setForceConvert(self, isForceConvert: "bool") -> "isys::CDownloadConfiguration &":
        r"""
        If ``isForceConvert`` is true, it forces conversion of elf file to
        winIDEA download format. This is
        important if you want to download symbols/code only. False
        by default.
        """
        return _connect.CDownloadConfiguration_setForceConvert(self, isForceConvert)

    def setUseAbsolutePath(self, isUseAbsolutePath: "bool") -> "isys::CDownloadConfiguration &":
        r"""
         If set to true,
        the specified path is not converted into workspace
        relative path. Has effect only with ``addToDownloadList()``.
        """
        return _connect.CDownloadConfiguration_setUseAbsolutePath(self, isUseAbsolutePath)

    def isForceConvert(self) -> "bool":
        r"""
         Returns force download setting.

        See also: setForceConvert()
        """
        return _connect.CDownloadConfiguration_isForceConvert(self)

    def isRealTimeAccess(self) -> "bool":
        r""" Returns true, if real-time access is set."""
        return _connect.CDownloadConfiguration_isRealTimeAccess(self)

    def isUseAbsolutePath(self) -> "bool":
        r"""
         Returns the ``use`` ``absolute`` ``path`` setting

        See also: setUseAbsolutePath()
        """
        return _connect.CDownloadConfiguration_isUseAbsolutePath(self)
    __swig_destroy__ = _connect.delete_CDownloadConfiguration

# Register CDownloadConfiguration in _connect:
_connect.CDownloadConfiguration_swigregister(CDownloadConfiguration)

class CLoaderController(object):
    r"""
    This class can be used for downloading executables to the target.


    Python example for method addToDownloadList(): addFileToDownloadList.py 

    Python exampl: for method getDownloadList(): advancedDownloadOptions.py 

    Python example for method verifyDownload(): verifyDownloadAndGetCapabilities.py 

    Python example with target download: targetDownload.py 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DLIST_PRIMARY = _connect.CLoaderController_DLIST_PRIMARY
    r""" use the main download list"""
    DLIST_TARGET = _connect.CLoaderController_DLIST_TARGET
    r""" use target download list"""

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        """
        _connect.CLoaderController_swiginit(self, _connect.new_CLoaderController(connectionMgr))
    __swig_destroy__ = _connect.delete_CLoaderController

    def download(self) -> "int":
        r"""
        Downloads executable to the target. The download files are defined in winIDEA,
        menu *Debug | Files for download*. This method resets the target.

        :rtype: int
        :return: S_OK in case of success, S_FALSE in case of warning (but successful download).
        :raises: IOException in case of an error

        Python example: addFileToDownloadList.py 
        """
        return _connect.CLoaderController_download(self)

    def downloadWithoutCode(self) -> "int":
        r"""
        Download without code - initialize target and load symbols. The download
        files are defined in winIDEA,
        menu *Debug | Files for download*.

        :rtype: int
        :return: S_OK in case of success, S_FALSE in case of warning (but successful download).
        :raises: IOException in case of an error
        """
        return _connect.CLoaderController_downloadWithoutCode(self)

    def targetDownload(self, *args) -> "int":
        r"""
        *Overload 1:*

        This method downloads the file not in the winIDEA's download list
        (see *Debug | Files for download*), without reseting the target and
        initializing emulation.

        :type downloadConfig: :py:class:`CDownloadConfiguration`
        :param downloadConfig: download configuration
        :type fileName: string
        :param fileName: the file to be downloaded
        :type cmdLineOptions: string
        :param cmdLineOptions: command line options for download. These options contain
                   settings from winIDEA advanced download options dialog (Debug | Files for download
                   | tab Download Files | button Properties | button Advanced).
                   To see how to format this string, set options manually
                   in winIDEA, and then call method getDownloadList() and print the ``options``
                   attribute of the returned items.

        :rtype: int
        :return: S_OK in case of success, S_FALSE in case of warning (but successful download).
        :raises: IOException in case of an error

        Python example: targetDownload.py 


        |

        *Overload 2:*

        This is specialized version of the more general
        method targetDownload(CDownloadConfiguration &, const std::string &, const std::string &).
        It downloads code and symbols, memory area is not used, no real-time access.
        It is equivalent to the following code snippet:

        CDownloadConfiguration downloadConfig;
        downloadConfig.setCodeOffset(0).setSymbolsOffset(0).setDownloadFileFormat(format);

        loader.targetDownload(downloadConfig, fileName, "");


        :type format: int
        :param format: format of the download file
        :type fileName: string
        :param fileName: the file to be downloaded

        :rtype: int
        :return: S_OK in case of success, S_FALSE in case of warning (but successful download).
        :raises: IOException in case of an error

        Python example: targetDownload.py 
        """
        return _connect.CLoaderController_targetDownload(self, *args)

    def downloadFromList(self, *args) -> "int":
        r"""
        *Overload 1:*

        Downloads file from winIDEA's download list.

        :type listType: int
        :param listType: selects main or target download list in
                            winIDEA (see dialog Debug | Files For Download...)
        :type fileName: string
        :param fileName: name of the file to download
        :type isRealTime: boolean
        :param isRealTime: if true, real-time access is performed.

        :rtype: int
        :return: S_OK in case of success, S_FALSE in case of warning (but successful download).
        :raises: IOException in case of an error

        |

        *Overload 2:*

        Downloads file from winIDEA's download list.

        :type listType: int
        :param listType: selects main or target download list in
                            winIDEA (see dialog Debug | Files For Download...)
        :type fileIndex: int
        :param fileIndex: index of the file in the list
        :type isRealTime: boolean
        :param isRealTime: if true, real-time access is performed.

        :rtype: int
        :return: S_OK in case of success, S_FALSE in case of warning (but successful download).
        :raises: IOException in case of an error
        """
        return _connect.CLoaderController_downloadFromList(self, *args)

    def addToDownloadList(self, *args) -> "void":
        r"""
        *Overload 1:*

        Adds a file to download list in winIDEA (see dialog Debug | Files For Download...
        or Debug | Configure Session... in case of MMS sample).

        :type listType: int
        :param listType: selects main or target download list in
                            winIDEA (see dialog Debug | Files For Download...
                            or Debug | Configure Session... in case of MMS sample)

        :type fileName: string
        :param fileName: name of the file to add

        :type isAbsolutePath: boolean
        :param isAbsolutePath: if true, the specified path is not converted into
                                  workspace relative path

        :type options: string
        :param options: command line options for download. These options contain
                   settings from winIDEA advanced download options dialog (Debug | Files for download
                   | tab Download Files | button Properties | button Advanced or Debug | Configure Session
                   | tab SoCs | button Edit... | tab TargetFiles in case of MMS sample)
                   To see how to format this string, set options manually
                   in winIDEA, and then call method getDownloadList() and print the ``options``
                   attribute of the returned items.

        |

        *Overload 2:*

        Adds a file to download list in winIDEA (see dialog Debug | Files For Download...).

        :type downloadConfig: :py:class:`CDownloadConfiguration`
        :param downloadConfig: download configuration
        :type listType: int
        :param listType: selects main or target download list in
                            winIDEA
        :type fileName: string
        :param fileName: the file to be downloaded
        :type cmdLineOptions: string
        :param cmdLineOptions: command line options for download. These options contain
                   settings from winIDEA advanced download options dialog (Debug | Files for download
                   | tab Download Files | button Properties | button Advanced or Debug | Configure Session
                   | tab SoCs | button Edit... | tab TargetFiles in case of MMS sample).
                   To see how to format this string, set options manually
                   in winIDEA, and then call method getDownloadList() and print the ``options``
                   attribute of the returned items.

        Python example: addFileToDownloadList.py
        """
        return _connect.CLoaderController_addToDownloadList(self, *args)

    def removeFromDownloadList(self, listType: "isys::CLoaderController::DownloadListType", fileIndex: "int") -> "int":
        r"""
        Removes file at the given index from the list.

        :type listType: int
        :param listType: selects main or target download list in
                            winIDEA (see dialog Debug | Files For Download...
                            or Debug | Configure Session... in case of MMS sample)
        :type fileIndex: int
        :param fileIndex: index of file to be removed from the list.

        :rtype: int
        :return: S_FALSE if there is no file at the given index.
        """
        return _connect.CLoaderController_removeFromDownloadList(self, listType, fileIndex)

    def clearDownloadList(self, listType: "isys::CLoaderController::DownloadListType") -> "void":
        r"""
        Removes all files from the specified download list.

        :type listType: int
        :param listType: selects main or target download list in
                            winIDEA (see dialog Debug | Files For Download...
                                       or Debug | Configure Session... in case of MMS sample)
        """
        return _connect.CLoaderController_clearDownloadList(self, listType)

    def verifyDownload(self) -> "void":
        r"""
        Verifies download.

        :raises: IOException if verification can not be performed
        :raises: IllegalStateException if verification detects error in download

        Python example: verifyDownloadAndGetCapabilities.py
        """
        return _connect.CLoaderController_verifyDownload(self)

    def getDownloadList(self, listType: "isys::CLoaderController::DownloadListType", isAbsolutePath: "bool") -> "isys::CLoaderController::DownloadListVector const &":
        r"""
        Deprecated: see example addRemoveDownloadFile.py  for more flexible
                    handling of download files.

        Gets list of files to be downloaded from winIDEA.

        :param listFlags: selects main or target download
                             list in winIDEA (see dialog Debug | Files For Download...)
        :type isAbsolutePath: boolean
        :param isAbsolutePath: if true, absolute paths are returned

        :raises: IOException in case of an error

        Python example for method getDownloadList(): advancedDownloadOptions.py
        """
        return _connect.CLoaderController_getDownloadList(self, listType, isAbsolutePath)

# Register CLoaderController in _connect:
_connect.CLoaderController_swigregister(CLoaderController)

class CWorkspaceController(object):
    r"""
    This class provides methods for handling current workspace in winIDEA.


    workspaceController.py Python example.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        """
        _connect.CWorkspaceController_swiginit(self, _connect.new_CWorkspaceController(connectionMgr))
    __swig_destroy__ = _connect.delete_CWorkspaceController

    def getIConnectIDE(self) -> "IConnectIDE *":
        r"""
        Returns the **isystem.connect** IDE interface. Use this method only when
        some functionality of the IConnectIDE interface regarding workspace handling
        is not accessible from this wrapper.
        """
        return _connect.CWorkspaceController_getIConnectIDE(self)

    def newWS(self, workspaceFileName: "std::string const &") -> "void":
        r"""
        Creates a new workspace.

        :type workspaceFileName: string
        :param workspaceFileName: file name of the workspace

        :raises: IOException in case of an error
        """
        return _connect.CWorkspaceController_newWS(self, workspaceFileName)

    def open(self, workspaceFileName: "std::string const &") -> "bool":
        r"""
        Returns true, if the workspace has been opened, false if the workspace is already
        opened in winIDEA.

        :type workspaceFileName: string
        :param workspaceFileName: file name of the workspace

        :raises: IOException in case of an error

        workspaceController.py Python example.
        """
        return _connect.CWorkspaceController_open(self, workspaceFileName)

    def save(self) -> "void":
        r"""
        Saves workspace.

        :raises: IOException in case of an error
        """
        return _connect.CWorkspaceController_save(self)

    def saveAs(self, workspaceFileName: "std::string const &") -> "void":
        r"""
        Saves workspace to a new file.

        :type workspaceFileName: string
        :param workspaceFileName: file name of the workspace

        :raises: IOException in case of an error
        """
        return _connect.CWorkspaceController_saveAs(self, workspaceFileName)

    def close(self) -> "void":
        r"""
        Closes workspace. If there are some changes, winIDEA prompts user to
        save the changes.

        :raises: IOException in case of an error
        """
        return _connect.CWorkspaceController_close(self)

    def closeDiscard(self) -> "void":
        r"""
        Closes workspace and discards all changes.

        :raises: IOException in case of an error

        Python example: workspaceController.py
        """
        return _connect.CWorkspaceController_closeDiscard(self)

# Register CWorkspaceController in _connect:
_connect.CWorkspaceController_swigregister(CWorkspaceController)

class CBuildStatus(object):
    r"""
    This class contains status of the build manager. It is not intended to be
    instantiated by clients. Returned by CProjectController::getStatus().

    See also: CProjectController
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def isIdle(self) -> "bool":
        r""" Returns true, if winIDEA build manager is in idle state."""
        return _connect.CBuildStatus_isIdle(self)

    def isIdleWError(self) -> "bool":
        r"""
         Returns true, if winIDEA build manager is in idle state, and there were
        errors in the last build.

        See also: #getNumErrors
        See also: #getNumWarnings
        """
        return _connect.CBuildStatus_isIdleWError(self)

    def isConfigError(self) -> "bool":
        r""" Returns true, if winIDEA build manager is not properly configured."""
        return _connect.CBuildStatus_isConfigError(self)

    def isActive(self) -> "bool":
        r""" Returns true, if winIDEA build manager is building."""
        return _connect.CBuildStatus_isActive(self)

    def getNumErrors(self) -> "int":
        r""" Not implemented yet - will return the number of errors in the last build."""
        return _connect.CBuildStatus_getNumErrors(self)

    def getNumWarnings(self) -> "int":
        r""" Not implemented yet - will return the number of warnings in the last build."""
        return _connect.CBuildStatus_getNumWarnings(self)
    __swig_destroy__ = _connect.delete_CBuildStatus

# Register CBuildStatus in _connect:
_connect.CBuildStatus_swigregister(CBuildStatus)

class CBuildOptions(object):
    r"""
    This class provides access to build manager options. Do not instantiate
    this class directly, but use CProjectController::options() instead.

    File is defined either by `>proj>file` or by `>proj>groups...>file`

    Available options:

      |  Scope                        | Option            |
      |-------------------------------|-------------------|
      |  >proj>                 |  OutputFile       |
      |  >proj>                 |  ExternalMakePath |
      |  >proj>:Compile         |  ExtInput         |
      |  >proj>:Compile         |  ExtOutput
      |  >proj>:Assemble        |  ExtInput
      |  >proj>:Assemble        |  ExtOutput
      |  >proj>:Link            |  ExtInput
      |  >proj>:Compile         |  ExtInclude
      |  >proj>:Link            |  RunAfterPath
      |  >proj>:Link            |  RunAfterParam
      |  >proj>                 |  ToolsetDir
      |  >proj>:Compile         |  Path
      |  >proj>:Assemble        |  Path
      |  >proj>:Link            |  Path
      |  >proj>:Assemble        |  RunAfterPath
      |  >proj>:Assemble        |  RunAfterParam
      |  >proj>:Compile         |  RunAfterPath
      |  >proj>:Compile         |  RunAfterParam
      |  >proj>                 |  RootDir
      |  >proj>                 |  ExternalMakeParam
      |  >proj>:Assemble        |  ExtAdditional
      |  >proj>:Compile         |  ExtAdditional
      |  >proj>:Link            |  ExtAdditional
      |  >proj>:Link            |  PathSeparator
      |  >proj>:Assemble        |  ExtInclude
      |  >proj>:Make            |  RunBeforePath
      |  >proj>:Make            |  RunBeforeParam
      |  >proj>:Compile         |  DefinesPrefix
      |  >proj>:Compile         |  DefinesPostfix
      |                          ||
      |  >proj>                 |  ExternalMakeOn
      |  >proj>                 |  RunWithRelativePaths
      |  >proj>                 |  CopyToTargetDir
      |                          ||
      |  >proj>                 |  ChangeWorkingDir
      |  >proj>                 |  DisplayParam
      |  >proj>:Compile         |  CaptureOutput
      |  >proj>:Assemble        |  CaptureOutput
      |  >proj>:Link            |  CaptureOutput
      |  >proj>:Compile         |  UseCMD
      |  >proj>:Assemble        |  UseCMD
      |  >proj>:Link            |  UseCMD
      |  >proj>                 |  ShowTool
      |                               |  BeepWhenDone
      |  >proj>                 |  WarnIncludeNotFound
      |                          ||
      |  >proj>::target         |  OutputDir
      |  >proj>file             |  ExcludeFromMake
      |                          ||
      |  >proj>:Link:target     |  CmdLine
      |  >proj>:Link:target     |  IndirectionPath
      |  >proj>:Make:target     |  CmdLine
      |  >proj>:Build:target    |  CmdLine
      |  >proj>:Link:target     |  CRLF
      |  >proj>:Link:target     |  TranslateChar
      |                          ||
      |  >proj>:Compile:target  |  RunAssembler
      |  >proj>:Compile:target  |  CmdLine
      |  >proj>file:Compile:target |  CmdLine
      |  >proj>:Assemble:target    |  CmdLine
      |  >proj>file:Assemble:target|   CmdLine
      |  >proj>:Compile:target     |  Defines
      |  >proj>file:Compile:target |  Defines
      |                          ||
      |  >proj>:Make            |  Mode
      |  >proj>:Make            |  Path
      |                          ||
      |  >proj>:Build           |  Mode
      |  >proj>:Build           |  Path
      |                          ||
      |  >proj>                 |  Environment
      |                          ||
      |  >proj>:Assemble        |  DepScan
      |  >proj>:Assemble        |  DepReqBlanksFront
      |  >proj>:Assemble        |  DepAllowBlanksFront
      |  >proj>:Assemble        |  DepKeyword
      |  >proj>:Assemble        |  DepStartPath
      |  >proj>:Assemble        |  DepEndPath
      |                          ||
      |  >proj>                 |  IncludePath       // ofaEnum
      |  >proj>                 |  IncludePath>path  // ofaAdd, ofaRmv,
      |  >proj>                 |  IncludePath>path   0/1  // ofaSet, ofaGet subdir
      |                          ||
      |  >proj>                 |  Name
      |  >proj>                 |  Target         // ofaEnum
      |  >proj>::target         |  Target         // ofaRmv, ofaAdd (the value defines the target from which to copy settings)
      |  >proj>::target         |  Target         // ofaSet, ofaGet
      |  >proj>                 |  Group          // ofaEnum
      |  >proj>group>        |  Group          // ofaRmv, ofaAdd
      |  >proj>                 |  Filter
      |                          ||
      |  set to TRUE if the below is not empty||
      |  >proj>:Compile         |  CustomFilter
      |                          ||
      |  >proj>:Assemble        |  CustomFilter
      |                          ||
      |  >proj>:Link            |  CustomFilter
      |                          ||
      |  >proj>                 |  CustomFilter
      |                          ||
      |  >proj>::target         |  Name
      |                          ||
      |  >proj>group>        |  Name
      |  >proj>group>        |  File           // enum only

    See also: CProjectController
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def get(self, *args) -> "std::string":
        r"""
        *Overload 1:*

        Returns option at the given index.

        See class description for available scope and options.

        :raises: IllegalStateException if index is out of range.
        :raises: IOException if any other error occurred

        |

        *Overload 2:*

        Returns the requestred option.

        See class description for available scope and options.

        :raises: IOException if error occurred
        """
        return _connect.CBuildOptions_get(self, *args)

    def set(self, scope: "std::string const &", option: "std::string const &", value: "std::string const &") -> "void":
        r"""
        Sets the build manager option.

        See class description for available scope and options.

        :raises: IOException if error occurred
        """
        return _connect.CBuildOptions_set(self, scope, option, value)

    def add(self, scope: "std::string const &", option: "std::string const &", value: "std::string const &") -> "void":
        r"""
        Adds the build manager option.

        See class description for available scope and options.

        :raises: IOException if error occurred
        """
        return _connect.CBuildOptions_add(self, scope, option, value)

    def remove(self, scope: "std::string const &", option: "std::string const &") -> "void":
        r"""
        Removes the build manager option.

        See class description for available scope and options.

        :raises: IOException if error occurred
        """
        return _connect.CBuildOptions_remove(self, scope, option)

    def move(self, scope: "std::string const &", option: "std::string const &", value: "std::string const &") -> "void":
        r"""
        Moves the build manager option.

        See class description for available scope and options.

        :raises: IOException if error occurred
        """
        return _connect.CBuildOptions_move(self, scope, option, value)
    __swig_destroy__ = _connect.delete_CBuildOptions

# Register CBuildOptions in _connect:
_connect.CBuildOptions_swigregister(CBuildOptions)

class CProjectController(object):
    r"""
    This class provides access to winIDEA project manager.

    projectController.py Python example. 

    debugIdeTraceProfilerCoverageSample.py Python example for method getStatus(). 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        r"""
         Constructs the object.

        projectController.py Python example. 
        """
        _connect.CProjectController_swiginit(self, _connect.new_CProjectController(connectionMgr))
    __swig_destroy__ = _connect.delete_CProjectController

    def getIConnectProject(self) -> "IConnectProject *":
        r"""
        Returns the **isystem.connect** Project interface. Use this method only when
        some functionality of the IConnectProject interface regarding project handling
        is not accessible from this wrapper.
        """
        return _connect.CProjectController_getIConnectProject(self)

    def compile(self, fileName: "std::string const &") -> "void":
        r"""
        Compiles the specified file.

        :type fileName: string
        :param fileName: the file to compile. The file must be included in the active project.
        """
        return _connect.CProjectController_compile(self, fileName)

    def link(self, suppressPostLinkActions: "bool"=False) -> "void":
        r"""
        Links the active project.

        :type suppressPostLinkActions: boolean, optional
        :param suppressPostLinkActions: if true, automatic post-link actions are not performed
        """
        return _connect.CProjectController_link(self, suppressPostLinkActions)

    def make(self, suppressPostLinkActions: "bool"=False) -> "void":
        r"""
        Makes the active project.

        :type suppressPostLinkActions: boolean, optional
        :param suppressPostLinkActions: if true, automatic post-link actions are not performed
        """
        return _connect.CProjectController_make(self, suppressPostLinkActions)

    def build(self, suppressPostLinkActions: "bool"=False) -> "void":
        r"""
        Builds the active project.

        :type suppressPostLinkActions: boolean, optional
        :param suppressPostLinkActions: if true, automatic post-link actions are not performed

        projectController.py Python example. 
        """
        return _connect.CProjectController_build(self, suppressPostLinkActions)

    def isUpToDate(self) -> "bool":
        r"""
         Returns ``true`` if project is up to date, or ``false`` if sources are newer than
        executable.

        projectController.py Python example. 
        """
        return _connect.CProjectController_isUpToDate(self)

    def setTarget(self, makeTargetName: "std::string const &") -> "void":
        r"""Sets make target in winIDEA. See winIDEA menu option ``Project`` | ``Targets``."""
        return _connect.CProjectController_setTarget(self, makeTargetName)

    def importProject(self, xmlFileName: "std::string const &") -> "int":
        r"""
        Imports project from XML file.

        :rtype: int
        :return: 0 on OK, -1 if warning. Call getWarningMessage() to get the message.
        :raises: IOException in case of error
        See also: exportProject()

        projectController.py Python example. 
        """
        return _connect.CProjectController_importProject(self, xmlFileName)

    def exportProject(self, xmlFileName: "std::string const &") -> "int":
        r"""
        Exports project to XML file.

        :rtype: int
        :return: 0 on OK, -1 if warning. Call getWarningMessage() to get the message.
        :raises: IOException in case of error
        See also: importProject()

        projectController.py Python example. 
        """
        return _connect.CProjectController_exportProject(self, xmlFileName)

    def dependencies(self) -> "void":
        r"""Updates dependencies."""
        return _connect.CProjectController_dependencies(self)

    def stop(self) -> "void":
        r"""Stops the current operation."""
        return _connect.CProjectController_stop(self)

    def customOperation(self, operation: "std::string const &", parameters: "std::string const &") -> "void":
        r"""
        Runs custom operation.

        :type operation: string
        :param operation: operation to run
        :type parameters: string
        :param parameters: parameters of the operation
        """
        return _connect.CProjectController_customOperation(self, operation, parameters)

    def getStatus(self) -> "isys::CBuildStatus":
        r"""
        Returns the object with information about the current build manager
        status.

        projectController.py Python example. 

        debugIdeTraceProfilerCoverageSample.py Python example. 
        """
        return _connect.CProjectController_getStatus(self)

    def options(self) -> "isys::CBuildOptions &":
        r"""
         Returns reference to build options associated with this build manager.
        Use this reference to get/set build options.
        """
        return _connect.CProjectController_options(self)

    def enumerateProjectOption(self, scope: "std::string const &", option: "std::string const &", index: "int", isReturnRelativePath: "bool") -> "std::string":
        r"""
        This method can enumerate build targets, groups, and files in project.

        :type scope: string
        :param scope: scope should be of format: ">project>group>file name|translator|target"
                         If project or target are blank, the current project/active target is assumed.
                         Examples:


            |Scope Format    |  Option     |Returns|
            ----------------------------------------
            |">"             | "Group"     |project group|
            |">"             | "File"      |project file|


        :type option: string
        :param option: name of the option to get
        :type index: int
        :param index: index of item to retrieve. When end of list is reached, empty string is returned.
        :type isReturnRelativePath: boolean
        :param isReturnRelativePath: if true, relative paths are returned

        See also: CBuildOptions for list of scopes and options.

        projectController.py Python example. 
        """
        return _connect.CProjectController_enumerateProjectOption(self, scope, option, index, isReturnRelativePath)

    def modifyProjectOption(self, cmd: "IConnectProject::EOptionFlags", cmdFlags: "DWORD", scope: "std::string const &", option: "std::string const &", value: "std::string const &") -> "std::string":
        r"""
        This is a general method for configuration of project manager in winIDEA.

        :type cmd: int
        :param cmd: command. If you need command *ofaEnum*, use more convenient method
                       enumerateProjectOption().
        :type cmdFlags: int
        :param cmdFlags: this parameter may contain the second part of cmd, for example *ofaRelativePaths*,
                            or-ed with index when needed
        :type scope: string
        :param scope: scope should be of format: ">project>group>file name|translator|target"
                         If project or target are blank, the current project/active target is assumed.
                         Examples:


            |Scope Format              |Location |Scope example               |  Option          | Value|
            ---------------------------------------------------------------------------------------------
            |""                        |Global   |""                          | "BeepWhenDone"   |"1"|
            |">project>"               |Project  |">Files>"                   | "ToolsetDir"     | "$(EXEDIR)\gcc"|
            |">project>group>"         |Group    |">Files>Source Files>"      | "Name"           | "Sources"|
            |">project>group>file name"|File     |">Files>Source Files>main.c"| "ExcludeFromMake"| "0"|
            |">project>file path"      |File     |">Files>c:\test\main.c"     | "ExcludeFromMake"| "0"|


        :type option: string
        :param option: name of the option to get or set.
        :type value: string
        :param value: new option value when set or add is used. Should be empty string on get.

        See also: CBuildOptions for list of scopes and options.

        projectController.py Python example. 
        """
        return _connect.CProjectController_modifyProjectOption(self, cmd, cmdFlags, scope, option, value)

    def getWarningMessage(self) -> "std::string":
        r"""
        Returns warning message for methods in this class, which have returned
        warning error code, for example when importProject() or exportProject()
        return -1.

        projectController.py Python example. 
        """
        return _connect.CProjectController_getWarningMessage(self)

# Register CProjectController in _connect:
_connect.CProjectController_swigregister(CProjectController)

EXPORT_TrcAsText = _connect.EXPORT_TrcAsText
EXPORT_TrcAsCSV = _connect.EXPORT_TrcAsCSV
EXPORT_TrcAsXML = _connect.EXPORT_TrcAsXML
EXPORT_TrcAsBinary = _connect.EXPORT_TrcAsBinary
EXPORT_ProfilerAsText = _connect.EXPORT_ProfilerAsText
EXPORT_ProfilerAsCSV = _connect.EXPORT_ProfilerAsCSV
EXPORT_ProfilerAsXML = _connect.EXPORT_ProfilerAsXML
EXPORT_ProfilerAsBinary = _connect.EXPORT_ProfilerAsBinary
EXPORT_ProfilerAsText1 = _connect.EXPORT_ProfilerAsText1
EXPORT_ProfilerAsXMLBinaryTimeline = _connect.EXPORT_ProfilerAsXMLBinaryTimeline
EXPORT_ProfilerAsBTF = _connect.EXPORT_ProfilerAsBTF
EXPORT_ProfilerAsMDF = _connect.EXPORT_ProfilerAsMDF
EXPORT_CCAsHTML = _connect.EXPORT_CCAsHTML
EXPORT_CCAsText = _connect.EXPORT_CCAsText
EXPORT_CCAsCSV = _connect.EXPORT_CCAsCSV
EXPORT_CCAsXML = _connect.EXPORT_CCAsXML
EXPORT_CCAsReviewHTML = _connect.EXPORT_CCAsReviewHTML
EXPORT_CCAsReviewText = _connect.EXPORT_CCAsReviewText
EXPORT_CCAsXML2 = _connect.EXPORT_CCAsXML2
EXPORT_CCAsGCOV = _connect.EXPORT_CCAsGCOV
class CAnalyzerStatus(object):
    r"""
    Deprecated: Call getAnalyzerStatus() or getDocumentStatus() to obtain
                CAnalyzerSessionStatus() or CDocumentSattus() instead.

    This class contains analyzer status. It should not be instantiated by
    clients. Call CAnalyzerDocController::getStatus() to get instance of this class.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, hResult: "DWORD"):
        r"""
        This object should not be instantiated by clients - call method
        getStatus() to get the current analyzer status.
        """
        _connect.CAnalyzerStatus_swiginit(self, _connect.new_CAnalyzerStatus(hResult))

    def isErrorInBuffer(self) -> "bool":
        r""" Returns true, if some recordings are incomplete due to OCT bottleneck."""
        return _connect.CAnalyzerStatus_isErrorInBuffer(self)

    def isBufferOverrun(self) -> "bool":
        r""" Returns true, if session was terminated automatically when buffer was full."""
        return _connect.CAnalyzerStatus_isBufferOverrun(self)

    def isRecordingError(self) -> "bool":
        r""" Returns true, if there was error in recording."""
        return _connect.CAnalyzerStatus_isRecordingError(self)

    def isError(self) -> "bool":
        r""" Returns true if any of the above errors occurs."""
        return _connect.CAnalyzerStatus_isError(self)

    def isLoading(self) -> "bool":
        r""" Returns true, if analyzer is loading data to PC."""
        return _connect.CAnalyzerStatus_isLoading(self)

    def isWaiting(self) -> "bool":
        r""" Returns true, if analyzer is waiting for the trigger to occur."""
        return _connect.CAnalyzerStatus_isWaiting(self)

    def isOpening(self) -> "bool":
        r"""
        Returns true, if analyzer document is still in file opening phase. For large
        .trd files the process of reading the file info into memory can take
        some time.
        """
        return _connect.CAnalyzerStatus_isOpening(self)

    def isDocumentEmpty(self) -> "bool":
        r""" Returns true, if analyzer document is empty (nothing was recorded)."""
        return _connect.CAnalyzerStatus_isDocumentEmpty(self)

    def isActive(self) -> "bool":
        r"""
        Returns ``true`` if the document start action is still running
        (recording is still running),
        ``false`` otherwise.
        When recording stops, this method returns false,
        even if loading and analysis of data is still in progress.

        See also: isBusy
        :raises: IOException in case of an error.
        """
        return _connect.CAnalyzerStatus_isActive(self)

    def isBusy(self) -> "bool":
        r"""
        Returns ``true`` if the document is still changing, either because
        of recording or loading/analysis still running. Returns
        ``false`` otherwise.

        See also: isActive
        :raises: IOException in case of an error.
        """
        return _connect.CAnalyzerStatus_isBusy(self)

    def getReturnCode(self) -> "DWORD":
        return _connect.CAnalyzerStatus_getReturnCode(self)

    def toString(self) -> "std::string":
        r""" Returns object data as YAML string."""
        return _connect.CAnalyzerStatus_toString(self)
    __swig_destroy__ = _connect.delete_CAnalyzerStatus

# Register CAnalyzerStatus in _connect:
_connect.CAnalyzerStatus_swigregister(CAnalyzerStatus)

class CAnalyzerSessionStatus(object):
    r"""
    This class contains analyzer status. It should not be instantiated by
    clients. Call CAnalyzerDocController::getAnalyzerStatus() to get instance of this class.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, hResult: "DWORD"):
        r"""
        This object should not be instantiated by clients - call method
        getStatus() to get the current analyzer status.
        """
        _connect.CAnalyzerSessionStatus_swiginit(self, _connect.new_CAnalyzerSessionStatus(hResult))

    def isRecorderIdle(self) -> "bool":
        r""" Returns true, if analyzer is waiting for the trigger to occur."""
        return _connect.CAnalyzerSessionStatus_isRecorderIdle(self)

    def isRecorderWaiting(self) -> "bool":
        r""" Returns true, if analyzer is waiting for the trigger to occur."""
        return _connect.CAnalyzerSessionStatus_isRecorderWaiting(self)

    def isRecorderSampling(self) -> "bool":
        r""" Returns true, if analyzer is waiting for the trigger to occur."""
        return _connect.CAnalyzerSessionStatus_isRecorderSampling(self)

    def isUploading(self) -> "bool":
        r""" Returns true, if analyzer is loading data from emulator to PC."""
        return _connect.CAnalyzerSessionStatus_isUploading(self)

    def isAnalyzing(self) -> "bool":
        r""" Returns true, if analyzer is analyzing recorded data."""
        return _connect.CAnalyzerSessionStatus_isAnalyzing(self)

    def isErrorInTraceStream(self) -> "bool":
        r"""
        Returns true, if error in trace stream was detected.
        Possible sources are: OCT bottleneck, stream decoder error.
        """
        return _connect.CAnalyzerSessionStatus_isErrorInTraceStream(self)

    def isBufferOverrun(self) -> "bool":
        r""" Returns true, if session was terminated automatically when buffer was full."""
        return _connect.CAnalyzerSessionStatus_isBufferOverrun(self)

    def isError(self) -> "bool":
        r""" Returns true if any of the above errors occurs."""
        return _connect.CAnalyzerSessionStatus_isError(self)

    def toString(self) -> "std::string":
        r""" Returns object data as YAML string."""
        return _connect.CAnalyzerSessionStatus_toString(self)
    __swig_destroy__ = _connect.delete_CAnalyzerSessionStatus

# Register CAnalyzerSessionStatus in _connect:
_connect.CAnalyzerSessionStatus_swigregister(CAnalyzerSessionStatus)

class CDocumentStatus(object):
    r"""
    This class contains document status. It should not be instantiated by
    clients. Call CAnalyzerDocController::getDocumentStatus() to get instance of this class.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, hResult: "DWORD"):
        r"""
        This object should not be instantiated by clients - call method
        getDocumentStatus() to get the current analyzer status.
        """
        _connect.CDocumentStatus_swiginit(self, _connect.new_CDocumentStatus(hResult))

    def isSerializing(self) -> "bool":
        r"""
        Returns true, if analyzer document is in file opening or saving phase. For large
        .trd files the process of reading/writing the file can take
        some time.
        """
        return _connect.CDocumentStatus_isSerializing(self)

    def isEmpty(self) -> "bool":
        r""" Returns true, if analyzer document is empty (nothing was recorded)."""
        return _connect.CDocumentStatus_isEmpty(self)

    def isDirty(self) -> "bool":
        r""" Returns true, if analyzer document is dirty (changed but not saved)."""
        return _connect.CDocumentStatus_isDirty(self)

    def isCanStart(self) -> "bool":
        r""" Returns true, if document action start is available."""
        return _connect.CDocumentStatus_isCanStart(self)

    def toString(self) -> "std::string":
        r"""
        Returns object data as string. This should be used for logging or debugging
        purposes only as format may change in future versions.
        """
        return _connect.CDocumentStatus_toString(self)
    __swig_destroy__ = _connect.delete_CDocumentStatus

# Register CDocumentStatus in _connect:
_connect.CDocumentStatus_swigregister(CDocumentStatus)

class CDocumentController(object):
    r"""This class can be used to handle documents in winIDEA."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >", fileName: "std::string const &", mode: "std::string const &"):
        r"""
        Creates a new document or opens an existing one.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        :type mode: string
        :param mode: document open mode. 'u' opens existing file for update (file
                        must exist), 'w' opens existing file and deletes contents,
                        or creates a new file, 'a' opens existing file and keeps
                        contents, or creates a new file if it does not exist.
        :type fileName: string
        :param fileName: if not an empty string, it is used, otherwise
                   the user is prompted for fileName by winIDEA. In the later
                   case this object can not be used, because the file name
                   is known only in winIDEA.

        :raises: IOException in case of an error.

        Python example: debugIdeTraceProfilerCoverageSample.py
        """
        _connect.CDocumentController_swiginit(self, _connect.new_CDocumentController(connectionMgr, fileName, mode))
    __swig_destroy__ = _connect.delete_CDocumentController

    def getIConnectIDE(self) -> "IConnectIDE3 *":
        r"""
        Returns the **isystem.connect** IDE interface. Use this method only when
        some functionality of the IConnectIDE interface regarding workspace handling
        is not accessible from this wrapper.
        """
        return _connect.CDocumentController_getIConnectIDE(self)

    def start(self) -> "void":
        r"""
        Starts default document action. Starts recording if
        the document type is coverage, profiler or trace, or executes the script
        if it is a script document. Existing contents of analyzer document is always
        deleted when this method is called. It is possible to preserve existing
        coverage information by calling method resume(), instead of this method.

        Note: If analyzer is started, then option 'Reactivate session after CPU stop'
              has no effect. Analyzer will *not* be automatically started.

        :raises: IOException in case of an error.

        Python example: profiler2Example.py
        """
        return _connect.CDocumentController_start(self)

    def start1(self) -> "void":
        r"""
        Starts alternate document action. Repeats analysis on a previously recorded data
        if the document type is analyzer. Usage example: if document is recorded as
        trace (trace trigger is used), but we want to perform profiler analysis later
        (with profiler trigger).

        :raises: IOException in case of an error.

        Python example: trace2Profile.py
        """
        return _connect.CDocumentController_start1(self)

    def stop(self) -> "void":
        r"""
        Stops document action. For analyzer documents this action is deprecated. Use one of
        stop...() methods of CAnalyzerController instead.


        This method triggers the following state transitions on analyzer document:
        - **waiting for trigger:** forces trigger, sampling starts
        - **sampling:** stops sampling, enters loading state and waits until loading is finished
        - **loading (data from emulator to PC):** waits until loading finishes, does NOT stop it!
        - **analyzing:** stops analysis. If coverage and profiler analysis are running, call this
                     method twice to stop both.
        - **idle:** does nothing

        For script document this method terminates the script.

        :raises: IOException in case of an error.

        Python example: profiler2Example.py
        """
        return _connect.CDocumentController_stop(self)

    def resume(self) -> "void":
        r"""
        Starts recording but keeps existing coverage data.
        Works on coverage analyzer documents only.

        :raises: IOException in case of an error.

        Python example: coverageWithAppend.py
        """
        return _connect.CDocumentController_resume(self)

    def close(self) -> "void":
        r"""
        Closes the document. If the document is changed but not saved, winIDEA
        prompts user if he would like to save the file.

        :raises: IOException in case of an error.

        Python example: debugIdeTraceProfilerCoverageSample.py
        """
        return _connect.CDocumentController_close(self)

    def closeDiscard(self) -> "void":
        r"""
        Closes the document and discards any unsaved changes.

        :raises: IOException in case of an error.

        Python example: workspaceController.py
        """
        return _connect.CDocumentController_closeDiscard(self)

    def closeAll(self) -> "void":
        r"""
        Closes all documents. If there are no documents opened via *isystem.connect*,
        CIDEController::closeAllDocuments() can also be used.

        :raises: IOException in case of an error.
        """
        return _connect.CDocumentController_closeAll(self)

    def reset(self, resetScope: "IConnectIDE::EDocumentResetParameter") -> "void":
        r"""
        Resets contents of the document.

        :type resetScope: int
        :param resetScope: defines which part of the document to reset.
        """
        return _connect.CDocumentController_reset(self, resetScope)

    def save(self) -> "void":
        r"""
         Saves the document.

        :raises: IOException in case of an error.

        Python example: debugIdeTraceProfilerCoverageSample.py
        """
        return _connect.CDocumentController_save(self)

    def saveAs(self, fileName: "std::string const &", isForceOverwrite: "bool"=False) -> "void":
        r"""
        Saves the document with a new name.

        :raises: IOException in case of an error.
        """
        return _connect.CDocumentController_saveAs(self, fileName, isForceOverwrite)

    def saveCopy(self, newFileName: "std::string const &") -> "void":
        r"""
        Saves copy of the document under a given file name. The name of the
        opened document does not change. If the destination file already exists,
        it is overwritten. Use this method to save intermediate results, for
        example coverage between several runs.

        :raises: IOException in case of an error.

        Python example: debugIdeTraceProfilerCoverageSample.py
        """
        return _connect.CDocumentController_saveCopy(self, newFileName)

    def saveAsPrompt(self) -> "void":
        r"""
         Saves the document, winIDEA prompts the user for a new name.

        :raises: IOException in case of an error.
        """
        return _connect.CDocumentController_saveAsPrompt(self)

    def setMarker(self, lineNumber: "int") -> "void":
        r"""
         Sets marker at the given line - implemented only for text documents.

        :raises: IOException in case of an error.

        Python example: markerExample.py
        """
        return _connect.CDocumentController_setMarker(self, lineNumber)

    def clearMarker(self) -> "void":
        r"""
         Clears the existing marker - implemented only for text documents.

        :raises: IOException in case of an error.

        Python example: markerExample.py
        """
        return _connect.CDocumentController_clearMarker(self)

    def setFocus(self, lineNumber: "int") -> "void":
        r"""
        Sets focus to the view containing the document.

        :raises: IOException in case of an error.

        Python example: markerExample.py
        """
        return _connect.CDocumentController_setFocus(self, lineNumber)

# Register CDocumentController in _connect:
_connect.CDocumentController_swigregister(CDocumentController)

class CAnalyzerDocController(CDocumentController):
    r"""
    This class is a base class for analyzer documents (trace, coverage and profiler).
    Clients should not instantiate this class directly, but should use one of
    derived classes instead (CTraceController, CCoverageController2, or
    CProfilerController2).



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ANALYZER = _connect.CAnalyzerDocController_ANALYZER
    r""" trace document"""
    CODE_COVERAGE = _connect.CAnalyzerDocController_CODE_COVERAGE
    r"""
    code coverage document. For internal use only,
    instantiate class CCoverageController instead.
    """
    PROFILER = _connect.CAnalyzerDocController_PROFILER
    r"""
    profiler document. For internal use only,
    instantiate class CProfilerController2 instead.
    """
    ETraceOnly = _connect.CAnalyzerDocController_ETraceOnly
    r""" trace is recorded, but no profiler or coverage analysis is performed"""
    ECoverage = _connect.CAnalyzerDocController_ECoverage
    r""" coverage only"""
    EProfiler = _connect.CAnalyzerDocController_EProfiler
    r""" profiler only"""
    EBoth = _connect.CAnalyzerDocController_EBoth
    r""" profiler and coverage"""

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >", type: "isys::CAnalyzerDocController::EDocumentType", fileName: "std::string const &", mode: "std::string const &", createObjectOnly: "bool"=False):
        r"""
        Creates a new document or opens an existing one. If existing document
        is opened for writing, (mode = 'w'), then document contents is
        erased, but other data, for example triggers, is not cleared.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        :type type: int
        :param type: defines the type of document to open. Usage of
                   CODE_COVERAGE for this parameter is deprecated. Instantiate class
                   CCodeCoverage instead.

        :type fileName: string
        :param fileName: if not an empty string, it is used, otherwise
                   the user is prompted for fileName by winIDEA. In the later
                   case this object can not be used, because the file name
                   is known only in winIDEA. It is highly recommended to use
                   extension ``*.trd`` for trace documents and ``*.ccv`` for
                   coverage documents.

        :type mode: string
        :param mode: document open mode. 'u' opens existing file for update (file
                        must exist), 'w' opens existing file and deletes contents,
                        or creates a new file, 'a' opens existing file and keeps
                        contents, or creates a new file if it does not exist.

        :raises: IOException in case of an error.
        """
        _connect.CAnalyzerDocController_swiginit(self, _connect.new_CAnalyzerDocController(connectionMgr, type, fileName, mode, createObjectOnly))
    __swig_destroy__ = _connect.delete_CAnalyzerDocController

    def isActive(self) -> "bool":
        r"""
        Returns ``true`` if the document start action is still running,
        ``false`` otherwise. When recording stops, this method returns false,
        even if loading and analysis of data is still in progress.

        See also: isBusy
        :raises: IOException in case of an error.

        Python example: debugIdeTraceProfilerCoverageSample.py
        """
        return _connect.CAnalyzerDocController_isActive(self)

    def isBusy(self) -> "bool":
        r"""
        Returns ``true`` if the document is still changing, either because
        recording or loading/analysis is still running. Returns
        ``false`` otherwise.

        See also: isActive
        :raises: IOException in case of an error.
        """
        return _connect.CAnalyzerDocController_isBusy(self)

    def setDirty(self, isDirty: "bool") -> "void":
        r"""Sets dirty status of the document."""
        return _connect.CAnalyzerDocController_setDirty(self, isDirty)

    def abort(self) -> "void":
        r"""
        Aborts loading of document contents from a file. Use this method only
        when opening a really large documents and contents is not needed,
        otherwise call waitUntilLoaded() and wait until document contents is
        loaded. Has no effect when analyzer is running.
        """
        return _connect.CAnalyzerDocController_abort(self)

    def stopSampling(self) -> "void":
        r"""
        Stops sampling (recording) operation. After this action
        loading of data starts. Does nothing if sampling has already finished.

        :raises: IOException in case of an error.

        Python example: debugIdeTraceProfilerCoverageSample.py
        """
        return _connect.CAnalyzerDocController_stopSampling(self)

    def stopUploading(self) -> "void":
        r"""
        Stops transfer of data to PC. Continues with analysis of data already transferred
        to PC. To completely stop analyzer, call stopAnalyzing() after this call.
        """
        return _connect.CAnalyzerDocController_stopUploading(self)

    def stopAnalyzing(self) -> "void":
        r"""
        Stops analysis of analyzer data. To unconditionally stop analyzer immediately, call
        stopUploading() before this call.
        """
        return _connect.CAnalyzerDocController_stopAnalyzing(self)

    def stopLoadingOrSaving(self) -> "void":
        r"""Stops load or save operation."""
        return _connect.CAnalyzerDocController_stopLoadingOrSaving(self)

    def getStatus(self) -> "isys::CAnalyzerStatus":
        r"""
        Deprecated: Call getAnalyzerSessionStatus() or getDocumentStatus() instead.

        Returns analyzer status. Use this method to check for
        analyzer status and recording errors.

        Python example: trace2Example.py
        """
        return _connect.CAnalyzerDocController_getStatus(self)

    def getAnalyzerSessionStatus(self) -> "isys::CAnalyzerSessionStatus":
        r"""
        Returns analyzer session status. Use this method to check for
        analyzer status and recording errors.
        """
        return _connect.CAnalyzerDocController_getAnalyzerSessionStatus(self)

    def getDocumentStatus(self) -> "isys::CDocumentStatus":
        r"""Returns analyzer document status."""
        return _connect.CAnalyzerDocController_getDocumentStatus(self)

    def getActiveTriggerIndex(self) -> "int":
        r"""
        Returns index of the currently active trigger. If you want to get
        the active trigger name, call method:


        triggerName = getTriggerOption(index, "Name").


        See also: getTriggerOption
        """
        return _connect.CAnalyzerDocController_getActiveTriggerIndex(self)

    def createTrigger(self, triggerName: "std::string const &") -> "int":
        r"""
        Creates trigger with the given name. Call method setAnalysisType() to
        define analysis type.
        """
        return _connect.CAnalyzerDocController_createTrigger(self, triggerName)

    def setAnalysisType(self, triggerIndex: "int", analysisType: "isys::CAnalyzerDocController::EAnalysisType") -> "void":
        r"""
        This method sets analysis type on the given trigger. If trigger is
        created with CProfilerController2, it is set to profiler only analysis
        by default. Similar is true for coverage. To perform both types of analysis
        on the same recording, call this method with analysisType set to
        EBoth.
        """
        return _connect.CAnalyzerDocController_setAnalysisType(self, triggerIndex, analysisType)

    def removeTrigger(self, triggerName: "std::string const &") -> "int":
        r"""
        Removes profiler or trace trigger.

        :type triggerName: string
        :param triggerName: name of the trigger to remove

        :rtype: int
        :return: -1 if trigger with the given name did not exist, otherwise non-negative
                    value is returned

        Python example: profiler2Example.py
        """
        return _connect.CAnalyzerDocController_removeTrigger(self, triggerName)

    def getTriggerIndex(self, triggerName: "std::string const &", isThrowException: "bool"=True) -> "int":
        r"""
        Returns the index of the trigger with the given name.

        :type triggerName: string
        :param triggerName: name of analyzer trigger as specified in
                               'Analyzer Configuration' toolbar drop down list
                               in ``winIDEA`` analyzer window (the one with a
                               hammer and text). It is also accessible
                               as winIDEA option with URL
                               ``/Document/<fileName>/Trigger.Items[<index>].Name``.
                               where ``<index>`` is the value returned by
                               this method.

        :type isThrowException: boolean, optional
        :param isThrowException: if trigger with the given name is not found, and:
                                    - this parameter is set to ``true``, then an
                                      ``IllegalArgumentException`` is thrown.
                                    - this parameter is set to ``false``, then -1 is
                                      returned.

        Python example: profiler2Example.py
        """
        return _connect.CAnalyzerDocController_getTriggerIndex(self, triggerName, isThrowException)

    def select(self, *args) -> "void":
        r"""
        *Overload 1:*

        Selects trigger from 'Analyzer Configuration'
        toolbar drop down list in ``winIDEA`` (the one with a
        hammer and text)

        :type triggerName: string
        :param triggerName: name of the trigger in the list

        Python example: profiler2Example.py

        |

        *Overload 2:*

        Selects trigger from 'Analyzer Configuration'
        toolbar drop down list in ``winIDEA`` (the one with a
        hammer and text)

        :type index: int
        :param index: index of the trigger in the list
        See also: getTriggerIndex

        Python example: profiler2Example.py
        """
        return _connect.CAnalyzerDocController_select(self, *args)

    def waitUntilLoaded(self, timeoutMs: "int"=0, pollingIntervalMs: "DWORD"=100, isThrow: "bool"=False) -> "bool":
        r"""
        This method polls analyzer status with the given polling interval and
        returns when analyzer stops loading samples from the hardware, or
        timeout expires.

        :param timeout: timeout in milliseconds. 0 means infinite timeout
        :param pollingInterval: time in milliseconds between two readings of the analyzer status
        :type isThrow: boolean, optional
        :param isThrow: if true and timeout occurs, an exception is thrown
        :rtype: boolean
        :return: true if CPU is in stopped state, false if timeout expired and isThrow == false

        Python example: profiler2Example.py
        """
        return _connect.CAnalyzerDocController_waitUntilLoaded(self, timeoutMs, pollingIntervalMs, isThrow)

    def getNumberOfTriggers(self) -> "int":
        r"""
        Returns the number of triggers defined in the opened document.

        Python example: profiler2Example.py
        """
        return _connect.CAnalyzerDocController_getNumberOfTriggers(self)

    def getDocumentOptionURL(self, postfix: "std::string const &") -> "std::string":
        r"""
        This utility method returns URL of analyzer document option.
        The returned URL is composed as
        ``'/Document/' + fileName + '/' + postfix``. Use this method
        when you have to set some option, which is not accessible with methods of
        this class or derived classes.

        Python example: profiler2Example.py
        """
        return _connect.CAnalyzerDocController_getDocumentOptionURL(self, postfix)

    def getTriggerOption(self, index: "int", triggerOption: "std::string const &") -> "std::string":
        r"""
        Returns value of trigger option, for example
        trigger name, buffer size, trigger position, ...

        :type triggerOption: string
        :param triggerOption: part of the URL, which is following the
                                 ``Items[]`` part. For example, name of the trigger
                                 at index 0
                                 for analyzer file ``Sample5554_profiler.trd`` is specified
                                 with winIDEA option URL
                                 ``/Document/Sample5554_profiler.trd/Trigger.Items[0].Name``.
                                 To get it by this method, we define ``index`` as 0 and
                                 ``triggerOption`` as 'Name'.

                                 Another example - to get sampling starting point, we
                                 call this method as: ``getTriggerOption(0, "HW.Recorder.Start");``

        :type index: int
        :param index: trigger index, see methods getTriggerIndex() and getNumberOfTriggers()

        Python example: profiler2Example.py
        """
        return _connect.CAnalyzerDocController_getTriggerOption(self, index, triggerOption)

    def setTriggerOption(self, *args) -> "void":
        r"""
        *Overload 1:*

        Sets value of the trigger option, for example trigger name, buffer size,
        trigger position, ...

        :type index: int
        :param index: trigger index, see methods getTriggerIndex() and getNumberOfTriggers()

        :type triggerOption: string
        :param triggerOption: part of the URL, which is following the
                                 ``Items[]`` part. For example, the **name**
                                 of the trigger at index 0
                                 for analyzer file ``Sample5554_profiler.trd`` is specified
                                 with winIDEA option URL:



                                 ``/Document/Sample5554_profiler.trd/Trigger.Items[0].Name``



                                 To set the trigger name we call this method as:



                                 ``setTriggerOption(0, "Name", "myTrig"); ``



                                 Another example - to set sampling starting point, we
                                 call this method as:


        ``setTriggerOption(0, "HW.Recorder.Start", "Immediately");``

        :type newValue: string
        :param newValue: new value of the config. property, see the ``Options`` dialog in winIDEA
                            for the list of options and possible values of each option.

        Python example: profiler2Example.py

        |

        *Overload 2:*

        Sets value of the trigger option, for example trigger name, buffer size,
        trigger position, ...

        :type triggerOption: string
        :param triggerOption: part of the URL, which is following the
                                 ``Items[]`` part. For example, the **name**
                                 of the trigger at index 0
                                 for analyzer file ``Sample5554_profiler.trd`` is specified
                                 with winIDEA option URL:



                                 ``/Document/Sample5554_profiler.trd/Trigger.Items[0].Name``.



                                 To set the trigger name we call this method as:



                                 ``setTriggerOption(0, "Name", "myTrig"); ``



                                 Another example - to set sampling starting point, we
                                 call this method as:


        ``setTriggerOption(0, "HW.Recorder.Start", "Immediately");``

        :type index: int
        :param index: trigger index, see methods getTriggerIndex() and getNumberOfTriggers()

        :type newValue: int
        :param newValue: new value of the config. property, see the ``Options`` dialog in winIDEA
                            for the list of options and possible values of each option.
        """
        return _connect.CAnalyzerDocController_setTriggerOption(self, *args)

    def setExportFormat(self, exportFormat: "std::string const &") -> "void":
        r"""
        Deprecated: use method exportData() in derived classes.

        Sets export format for trace and coverage documents.

        :type exportFormat: string
        :param exportFormat: name of the export format as written in combo box
            in the winIDEA's export dialog. Supported values are also available as
            static members of this class. See CAnalyzerDocController::exportCCAsHTML,
            CAnalyzerDocController::exportCCAsText, ...

        :raises: IOException in case of an error.
        """
        return _connect.CAnalyzerDocController_setExportFormat(self, exportFormat)

    def exportAs(self, *args) -> "void":
        r"""
        *Overload 1:*

        Deprecated: use method exportData() in derived classes.

        Exports data to the given file and in the given format.

        :type scope: int
        :param scope: export all or selection only, see IConnectIDE::EDocumentExportParameter
        :type fileName: string
        :param fileName: name of the file to export the document to
        :type format: int
        :param format: index of the format in combo box in the winIDEA's export dialog. If
            it is set to 0xFFFFFFFF, the currently selected export format is used.
            See setExportFormat(). For analyzer documents the method
            ``CProfilerController2::exportData()`` should be used.

        :raises: IOException in case of an error.

        |

        *Overload 2:*

        Deprecated: use method exportData() in derived classes.

        Exports data to the given file and in the given format.

        :type scope: int
        :param scope: export all or selection only, see IConnectIDE::EDocumentExportFlags
        :type fileName: string
        :param fileName: name of the file to export the document to
        :param exportFormat: name of the export format as written in combo box
            in the winIDEA's export dialog. Supported values are also available as
            static members of this class. See CAnalyzerDocController::exportCCAsHTML,
            CAnalyzerDocController::exportCCAsText, ...
            For analyzer documents the method ``CProfilerController2::exportData()``
            should be used.

        :raises: IOException in case of an error.
        """
        return _connect.CAnalyzerDocController_exportAs(self, *args)

    def exportAsAndLaunchViewer(self, scope: "IConnectIDE::EDocumentExportParameter", fileName: "std::string const &", format: "DWORD") -> "void":
        r"""
        Deprecated: use method exportData() in derived classes.

        Exports the document and launches the system default viewer for the specified
        document type, for example web browser for HTML documents.

        :type scope: int
        :param scope: export all or selection only, see IConnectIDE::EDocumentExportFlags
        :type fileName: string
        :param fileName: name of the file to export the document to
        :type format: int
        :param format: index of the format in combo box in the winIDEA's export dialog. If
            it is set to 0xFFFFFFFF, the currently selected export format is used.
            See setExportFormat(). For analyzer documents the method
            ``CProfilerController2::exportData()`` should be used.

        :raises: IOException in case of an error.
        """
        return _connect.CAnalyzerDocController_exportAsAndLaunchViewer(self, scope, fileName, format)

    def setMarker(self) -> "void":
        r"""Not available for analyzer documents - does nothing."""
        return _connect.CAnalyzerDocController_setMarker(self)

# Register CAnalyzerDocController in _connect:
_connect.CAnalyzerDocController_swigregister(CAnalyzerDocController)
CAnalyzerDocController.exportCCAsHTML = _connect.cvar.CAnalyzerDocController_exportCCAsHTML
CAnalyzerDocController.exportCCAsText = _connect.cvar.CAnalyzerDocController_exportCCAsText
CAnalyzerDocController.exportCCAsCSV = _connect.cvar.CAnalyzerDocController_exportCCAsCSV
CAnalyzerDocController.exportCCAsXML = _connect.cvar.CAnalyzerDocController_exportCCAsXML
CAnalyzerDocController.exportCCAsXML2 = _connect.cvar.CAnalyzerDocController_exportCCAsXML2
CAnalyzerDocController.exportCCAsGCOV = _connect.cvar.CAnalyzerDocController_exportCCAsGCOV
CAnalyzerDocController.exportCCAsReviewHTML = _connect.cvar.CAnalyzerDocController_exportCCAsReviewHTML
CAnalyzerDocController.exportCCAsReviewText = _connect.cvar.CAnalyzerDocController_exportCCAsReviewText
CAnalyzerDocController.exportTrcAsText = _connect.cvar.CAnalyzerDocController_exportTrcAsText
CAnalyzerDocController.exportTrcAsCSV = _connect.cvar.CAnalyzerDocController_exportTrcAsCSV
CAnalyzerDocController.exportTrcAsBinary = _connect.cvar.CAnalyzerDocController_exportTrcAsBinary
CAnalyzerDocController.exportTrcAsXML = _connect.cvar.CAnalyzerDocController_exportTrcAsXML
CAnalyzerDocController.exportProfilerAsXML = _connect.cvar.CAnalyzerDocController_exportProfilerAsXML
CAnalyzerDocController.exportProfilerAsText1 = _connect.cvar.CAnalyzerDocController_exportProfilerAsText1
CAnalyzerDocController.exportProfilerAsBTF = _connect.cvar.CAnalyzerDocController_exportProfilerAsBTF
CAnalyzerDocController.exportProfilerAsMDF = _connect.cvar.CAnalyzerDocController_exportProfilerAsMDF

class CTerminalDocController(object):
    r"""This class handles terminal window as a document."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        r"""
        Opens a terminal window.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        :raises: IOException in case of an error.
        """
        _connect.CTerminalDocController_swiginit(self, _connect.new_CTerminalDocController(connectionMgr))
    __swig_destroy__ = _connect.delete_CTerminalDocController

    def close(self) -> "void":
        r"""
         Closes the terminal window.

        :raises: IOException in case of an error.
        """
        return _connect.CTerminalDocController_close(self)

    def start(self) -> "void":
        r"""
        Starts communication in the terminal window.

        :raises: IOException in case of an error.
        """
        return _connect.CTerminalDocController_start(self)

    def stop(self) -> "void":
        r"""
        Stops communication in the terminal window.

        :raises: IOException in case of an error.
        """
        return _connect.CTerminalDocController_stop(self)

    def saveAs(self, fileName: "std::string const &") -> "void":
        r"""
        Saves contents of the terminal window to file.

        :type fileName: string
        :param fileName: name of the destination file

        :raises: IOException in case of an error.
        """
        return _connect.CTerminalDocController_saveAs(self, fileName)

    def reset(self) -> "void":
        r"""
        Clears history buffer.

        :raises: IOException in case of an error.
        """
        return _connect.CTerminalDocController_reset(self)

# Register CTerminalDocController in _connect:
_connect.CTerminalDocController_swigregister(CTerminalDocController)

class CCoverageFormatBase(object):
    r"""
    This is abstract base class for coverage export format containers.
    Clients should not instantiate this class directly, they should
    instantiate one of its derived classes.
    See inheritance diagram for list of available formats.

    See also: CCoverageExportConfig::setFormatter()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EFmtHTML = _connect.CCoverageFormatBase_EFmtHTML
    r""" export as HTML"""
    EFmtText = _connect.CCoverageFormatBase_EFmtText
    r""" export as text"""
    EFmtXML = _connect.CCoverageFormatBase_EFmtXML
    r"""
    export as XML. This format should be used
    if parsing data with CCoverageData2 is needed
    """
    EFmtCSV = _connect.CCoverageFormatBase_EFmtCSV
    r""" export as Comma Separated Values format"""
    EFmtGCOV = _connect.CCoverageFormatBase_EFmtGCOV
    r""" export in gcov (GNU coverage) format"""

    def __init__(self, exportFormat: "isys::CCoverageFormatBase::EExportFormat"):
        _connect.CCoverageFormatBase_swiginit(self, _connect.new_CCoverageFormatBase(exportFormat))

    def getExportFormat(self) -> "isys::CCoverageFormatBase::EExportFormat":
        r""" Returns coverage export format."""
        return _connect.CCoverageFormatBase_getExportFormat(self)

    def getExportFormatAsStr(self) -> "std::string":
        r"""
        Returns string containing export format, which can be used for
        setting of option
        ``/Document/<file name>/Coverage.Export.Format``

        See also: getExportFormat()
        """
        return _connect.CCoverageFormatBase_getExportFormatAsStr(self)

    def setOptions(self, ide: "CIDEController", docFileName: "std::string const &") -> "void":
        r"""
        Sets export format configuration options in winIDEA. Normally these
        options are set by CCoverageController2::exportData(), so there is no
        need for clients to call this method explicitly.
        """
        return _connect.CCoverageFormatBase_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CCoverageFormatBase

# Register CCoverageFormatBase in _connect:
_connect.CCoverageFormatBase_swigregister(CCoverageFormatBase)

class CCoverageHTMLExportFormat(CCoverageFormatBase):
    r"""This class configures format of HTML export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Creates object with default values."""
        _connect.CCoverageHTMLExportFormat_swiginit(self, _connect.new_CCoverageHTMLExportFormat())
    __swig_destroy__ = _connect.delete_CCoverageHTMLExportFormat

# Register CCoverageHTMLExportFormat in _connect:
_connect.CCoverageHTMLExportFormat_swigregister(CCoverageHTMLExportFormat)

class CCoverageTextExportFormat(CCoverageFormatBase):
    r"""This class configures format of Text export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Creates object with default values."""
        _connect.CCoverageTextExportFormat_swiginit(self, _connect.new_CCoverageTextExportFormat())
    __swig_destroy__ = _connect.delete_CCoverageTextExportFormat

# Register CCoverageTextExportFormat in _connect:
_connect.CCoverageTextExportFormat_swigregister(CCoverageTextExportFormat)

class CCoverageCSVExportFormat(CCoverageFormatBase):
    r"""This class configures format of CSV export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Creates object with default values."""
        _connect.CCoverageCSVExportFormat_swiginit(self, _connect.new_CCoverageCSVExportFormat())
    __swig_destroy__ = _connect.delete_CCoverageCSVExportFormat

# Register CCoverageCSVExportFormat in _connect:
_connect.CCoverageCSVExportFormat_swigregister(CCoverageCSVExportFormat)

class CCoverageXMLExportFormat(CCoverageFormatBase):
    r"""This class configures format of XML export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Creates object with default values."""
        _connect.CCoverageXMLExportFormat_swiginit(self, _connect.new_CCoverageXMLExportFormat())
    __swig_destroy__ = _connect.delete_CCoverageXMLExportFormat

# Register CCoverageXMLExportFormat in _connect:
_connect.CCoverageXMLExportFormat_swigregister(CCoverageXMLExportFormat)

class CCoverageExportConfig(object):
    r"""
    This class contains information about type of contents and format of
    the file, which will contain exported coverage data.

    See also: CCoverageController2::exportData()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EScopeAll = _connect.CCoverageExportConfig_EScopeAll
    EScopeVisible = _connect.CCoverageExportConfig_EScopeVisible
    EScopeConfigured = _connect.CCoverageExportConfig_EScopeConfigured

    def __init__(self):
        r"""
        Constructs object with default settings, as described with each method.

        Python example: coverage2Example.py
        """
        _connect.CCoverageExportConfig_swiginit(self, _connect.new_CCoverageExportConfig())

    def setFileName(self, fileName: "std::string const &") -> "isys::CCoverageExportConfig &":
        r"""
        Sets the name of the exported file or folder name for HTML export.
        If this method is not called, or
        ``fileName`` is empty string, then the existing export file name in
        winIDEA is used.

        Python example: coverage2Example.py
        """
        return _connect.CCoverageExportConfig_setFileName(self, fileName)

    def setFormatter(self, formatter: "isys::CCoverageFormatBaseSPtr &") -> "isys::CCoverageExportConfig &":
        r"""
        Sets formatter object, which configures export file format. If this
        method is not called, XML formatter with default settings is used.

        Example:


            formatter = ic.CCoverageXMLExportFormat()
            exportCfg.setFormatter(formatter)


        See also: CCoverageFormatBase
        """
        return _connect.CCoverageExportConfig_setFormatter(self, formatter)

    def setFormatVariant(self, formatVariant: "std::string const &") -> "isys::CCoverageExportConfig &":
        r"""
        Sets variant format. Unless there is some other template provided in
        winIDEA installation folder, set it to 'default'.
        """
        return _connect.CCoverageExportConfig_setFormatVariant(self, formatVariant)

    def setLaunchViewer(self, isLaunchViewer: "bool") -> "isys::CCoverageExportConfig &":
        r"""
        If set to ``true``, launches the system default
        viewer for the specified document type after export, for example
        notepad for text documents (default: ``false)``.
        """
        return _connect.CCoverageExportConfig_setLaunchViewer(self, isLaunchViewer)

    def setExportModules(self, isExportModules: "bool") -> "isys::CCoverageExportConfig &":
        r"""
        If set to ``true``, coverage of modules (source files) is exported (default:
        ``true)``.
        """
        return _connect.CCoverageExportConfig_setExportModules(self, isExportModules)

    def setExportModuleLines(self, isExportModuleLines: "bool") -> "isys::CCoverageExportConfig &":
        r"""
        If set to ``true``, coverage lines info in modules (source files)
        is exported (default: ``false)``.
        """
        return _connect.CCoverageExportConfig_setExportModuleLines(self, isExportModuleLines)

    def setExportSources(self, isExportSources: "bool") -> "isys::CCoverageExportConfig &":
        r"""
        If set to ``true``, complete source files with coverage info are
        exported (including lines without generated object code)
        (default: ``false)``.
        """
        return _connect.CCoverageExportConfig_setExportSources(self, isExportSources)

    def setExportFunctions(self, isExportFunctions: "bool") -> "isys::CCoverageExportConfig &":
        r""" If set to ``true``, function coverage is exported (default: ``true)``."""
        return _connect.CCoverageExportConfig_setExportFunctions(self, isExportFunctions)

    def setExportFunctionLines(self, isExportFunctionLines: "bool") -> "isys::CCoverageExportConfig &":
        r"""
         If set to ``true``, coverage of lines in functions is exported
        (default: ``false)``.
        """
        return _connect.CCoverageExportConfig_setExportFunctionLines(self, isExportFunctionLines)

    def setExportFunctionAsm(self, isExportFunctionAsm: "bool") -> "isys::CCoverageExportConfig &":
        r"""
        If set to ``true``, assembler coverage information for function is exported (default: ``false)``.
        Assembler information is given in address order.
        """
        return _connect.CCoverageExportConfig_setExportFunctionAsm(self, isExportFunctionAsm)

    def setExportAsm(self, isExportAsm: "bool") -> "isys::CCoverageExportConfig &":
        r"""
         If set to ``true``, assembler coverage information is exported (default: ``false)``.
        Assembler information is given in source line order (some source lines may generate code
        at several address blocks ('for' loop, for example).
        """
        return _connect.CCoverageExportConfig_setExportAsm(self, isExportAsm)

    def setExportRanges(self, isExportRanges: "bool") -> "isys::CCoverageExportConfig &":
        r""" If set to ``true``, range coverage information is exported (default: ``false)``."""
        return _connect.CCoverageExportConfig_setExportRanges(self, isExportRanges)

    def setModulesFilter(self, modulesFilter: "std::string const &") -> "isys::CCoverageExportConfig &":
        r""" Defines wildcard expression for modules to be exported, for example: eval*.c"""
        return _connect.CCoverageExportConfig_setModulesFilter(self, modulesFilter)

    def setFunctionsFilter(self, functionsFilter: "std::string const &") -> "isys::CCoverageExportConfig &":
        r""" Defines wildcard expression for functions to be exported, for example: init_*"""
        return _connect.CCoverageExportConfig_setFunctionsFilter(self, functionsFilter)

    def setTestId(self, testId: "std::string const &") -> "isys::CCoverageExportConfig &":
        r"""
         Sets test ID. This information is written to exported file.
        If this method is not called, existing value in the document is preserved.
        """
        return _connect.CCoverageExportConfig_setTestId(self, testId)

    def setDescription(self, desc: "std::string const &") -> "isys::CCoverageExportConfig &":
        r"""
         Sets human description of measurement. This information is written to exported file.
        If this method is not called, existing value in the document is preserved.
        """
        return _connect.CCoverageExportConfig_setDescription(self, desc)

    def setComment(self, comment: "std::string const &") -> "isys::CCoverageExportConfig &":
        r"""
         Sets comment. This information is written to exported file.
        If this method is not called, existing value in the document is preserved.
        """
        return _connect.CCoverageExportConfig_setComment(self, comment)

    def setSoftware(self, sw: "std::string const &") -> "isys::CCoverageExportConfig &":
        r"""
         Sets description of software used for measurement. This information is written to exported file.
        If this method is not called, existing value in the document is preserved.
        """
        return _connect.CCoverageExportConfig_setSoftware(self, sw)

    def setHardware(self, hw: "std::string const &") -> "isys::CCoverageExportConfig &":
        r"""
         Sets description of hardware used for measurement. This information is written to exported file.
        If this method is not called, existing value in the document is preserved.
        """
        return _connect.CCoverageExportConfig_setHardware(self, hw)

    def getFileName(self) -> "std::string":
        r""" Returns coverage file name."""
        return _connect.CCoverageExportConfig_getFileName(self)

    def getFormatVariant(self) -> "std::string":
        r""" Returns variant of the selected format to use for export."""
        return _connect.CCoverageExportConfig_getFormatVariant(self)

    def isLaunchViewer(self) -> "bool":
        r""" Returns true, if viewer should be launched after export."""
        return _connect.CCoverageExportConfig_isLaunchViewer(self)

    def isExportModules(self) -> "bool":
        r""" Returns true, if modules (source files) should be exported."""
        return _connect.CCoverageExportConfig_isExportModules(self)

    def isExportModuleLines(self) -> "bool":
        r""" Returns true, if lines in modules (source files) should be exported."""
        return _connect.CCoverageExportConfig_isExportModuleLines(self)

    def isExportSources(self) -> "bool":
        r""" Returns true, if complete source files should be exported."""
        return _connect.CCoverageExportConfig_isExportSources(self)

    def isExportFunctions(self) -> "bool":
        r""" Returns true, if functions should be exported."""
        return _connect.CCoverageExportConfig_isExportFunctions(self)

    def isExportFunctionLines(self) -> "bool":
        r""" Returns true, if function lines should be exported."""
        return _connect.CCoverageExportConfig_isExportFunctionLines(self)

    def isExportFunctionAsm(self) -> "bool":
        r"""
         Returns true, if assembler info in address order should be exported.
        See also: setExportFunctionAsm()
        """
        return _connect.CCoverageExportConfig_isExportFunctionAsm(self)

    def isExportAsm(self) -> "bool":
        r"""
         Returns true, if assembler info in source line order should be exported.
        See also: setExportAsm()
        """
        return _connect.CCoverageExportConfig_isExportAsm(self)

    def isExportRange(self) -> "bool":
        r""" Returns true, if range info should be exported."""
        return _connect.CCoverageExportConfig_isExportRange(self)

    def getModulesFilter(self) -> "std::string":
        r""" Returns filter for modules."""
        return _connect.CCoverageExportConfig_getModulesFilter(self)

    def getFunctionsFilter(self) -> "std::string":
        r""" Returns filter for functions."""
        return _connect.CCoverageExportConfig_getFunctionsFilter(self)

    def getTestId(self) -> "std::string":
        r"""
        Returns test ID. This method returns empty string or string set
        by setTestId(), not value from the document.
        """
        return _connect.CCoverageExportConfig_getTestId(self)

    def getDescription(self) -> "std::string":
        r"""
         Returns human description of measurement. This method returns empty string or string set
        by setDescription(), not value from the document.
        """
        return _connect.CCoverageExportConfig_getDescription(self)

    def getComment(self) -> "std::string":
        r"""
         Returns comment. This method returns empty string or string set
        by setComment(), not value from the document.
        """
        return _connect.CCoverageExportConfig_getComment(self)

    def getSoftware(self) -> "std::string":
        r"""
         Returns description of software used for measurement. This method returns empty
        string or string set
        by setSoftware(), not value from the document.
        """
        return _connect.CCoverageExportConfig_getSoftware(self)

    def getHardware(self) -> "std::string":
        r"""
         Returns description of hardware used for measurement. This method returns empty
        string or string set
        by setHardware(), not value from the document.
        """
        return _connect.CCoverageExportConfig_getHardware(self)

    def setOptions(self, ide: "CIDEController", docFileName: "std::string const &") -> "void":
        r"""Writes options to winIDEA."""
        return _connect.CCoverageExportConfig_setOptions(self, ide, docFileName)

    def toString(self) -> "std::string":
        r"""Returns contents of this object in human readable form."""
        return _connect.CCoverageExportConfig_toString(self)
    __swig_destroy__ = _connect.delete_CCoverageExportConfig

# Register CCoverageExportConfig in _connect:
_connect.CCoverageExportConfig_swigregister(CCoverageExportConfig)

class CCoverageController2(CAnalyzerDocController):
    r"""
    This class implements coverage functionality with a document
    oriented interface. It replaces the old CCoverageController,
    which is deprecated now. If you need some functionality from the
    old class, which is missing in this one, please contact iSystem
    support, rather than using the old class. If you use the
    old class, your code will no longer work once the deprecated
    class will be removed in the future versions of ``isystem.connect``.


    Portability list

    CCoverageController()  -->  CCoverageController2()
                                File name and open mode are required.

    isCoverageAvailable ()        -->  not implemented in CCoverageController2
    isBranchCoverageAvailable ()  -->  not implemented in CCoverageController2
    isHWCoverageAvailable ()      -->  not implemented in CCoverageController2
    isOfflineCoverageAvailable () -->  not implemented in CCoverageController2

    setConfiguration()   --> use createTrigger(), setProvideAssemblerInfo()

    all ``range`` methods --> use ``area`` handling methods (addArea(), removeArea(), ...)

    getCoverageBitmap()      --> no longer available, use class CCoverageData2
    getCoverageStatistics()  --> use class CCoverageData2
    getStatisticsForSymbol() --> use class CCoverageData2



    This class can be used to configure coverage, run recording, and export
    the recorded data. However, it has no methods to get recorded information.
    For this purpose a separate class called CCoverageData2 should be used.


    Use only methods documented for this class. If a method from the base class is
    not documented here, do not use it. 




    Python example with recording and simple data reading: coverage2Example.py


    Python example with detailed data reading  - uses only class CCoverageData2: coverageData.py


    Python example for measuring coverage of a single function: coverageOfSingleFunction.py
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EAreaFolder = _connect.CCoverageController2_EAreaFolder
    r""" folder with sources"""
    EAreaModule = _connect.CCoverageController2_EAreaModule
    r""" source file"""
    EAreaFunction = _connect.CCoverageController2_EAreaFunction
    r""" function"""
    EAreaRange = _connect.CCoverageController2_EAreaRange
    r""" address range"""
    EAreaImage = _connect.CCoverageController2_EAreaImage
    r""" download file"""
    EScopeAllDownloadedCode = _connect.CCoverageController2_EScopeAllDownloadedCode
    r"""
    All downloaded code is measured,
    adding or removing areas with methods
    in this class has no effect.
    """
    EScopeEntireMemory = _connect.CCoverageController2_EScopeEntireMemory
    r"""
    All memory is measured,
    adding or removing areas with methods
    in this class has no effect.
    """
    EScopeCustom = _connect.CCoverageController2_EScopeCustom
    r"""
    only coverage of areas added
    with ``addArea()`` method
    in this class is measured
    """

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >", fileName: "std::string const &", mode: "std::string const &"):
        r"""
        Instantiates object and opens or creates coverage document in
        ``winIDEA``.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        :type mode: string
        :param mode: document open mode. 'u' opens existing file for update (file
                        must exist), 'w' opens existing file and deletes contents,
                        or creates a new file, 'a' opens existing file and keeps
                        contents, or creates a new file if it does not exist.

        :type fileName: string
        :param fileName: if not an empty string, it is used, otherwise
                   the user is prompted for fileName by winIDEA. In the later
                   case this object can not be used, because the file name
                   is known only in winIDEA.

        Python example: coverage2Example.py
        """
        _connect.CCoverageController2_swiginit(self, _connect.new_CCoverageController2(connectionMgr, fileName, mode))
    __swig_destroy__ = _connect.delete_CCoverageController2

    def createTrigger(self, triggerName: "std::string const &") -> "int":
        r"""
        Creates a new coverage trigger. Trigger contains information about
        what coverage should record (which functions, modules, ...)
        and how to record it (when to start, buffer size, ...).

        :type triggerName: string
        :param triggerName: name of the trigger

        :rtype: int
        :return: index of the created trigger

        :raises: IllegalArgumentException if the trigger already exists

        Python example: coverage2Example.py
        """
        return _connect.CCoverageController2_createTrigger(self, triggerName)

    def setScope(self, triggerIndex: "int", scope: "isys::CCoverageController2::ECoverageScope") -> "void":
        r"""
        Sets scope to be included in coverage measurement. If ``EScopeCustom``
        is set, use method ``addArea()`` to define areas to be included in coverage
        measurements.

        :type triggerIndex: int
        :param triggerIndex: index of analyzer trigger as returned by ``createTrigger()``,
                   ``getActiveTriggerIndex()`` or ``getTriggerIndex()``

        :type scope: int
        :param scope: defines which part of memory to include in coverage
                         measurements
        """
        return _connect.CCoverageController2_setScope(self, triggerIndex, scope)

    def getScope(self, triggerIdx: "int") -> "isys::CCoverageController2::ECoverageScope":
        r"""
        Returns scope to be included in coverage measurement.

        :param triggerIndex: index of analyzer trigger as returned by ``createTrigger()``,
                   ``getActiveTriggerIndex()`` or ``getTriggerIndex()``

        See also: setScope
        """
        return _connect.CCoverageController2_getScope(self, triggerIdx)

    def setProvideAssemblerInfo(self, triggerIdx: "int", isProvideAssemblerInfo: "bool") -> "void":
        r"""
        Sets option to include assembler instructions in measured coverage.

        :param triggerIndex: index of analyzer trigger as returned by ``createTrigger()``,
                   ``getActiveTriggerIndex()`` or ``getTriggerIndex()``

        :type isProvideAssemblerInfo: boolean
        :param isProvideAssemblerInfo: if set to ``true``, assembler information
                                          is provided with coverage.
        """
        return _connect.CCoverageController2_setProvideAssemblerInfo(self, triggerIdx, isProvideAssemblerInfo)

    def isProvideAssemblerInfo(self, triggerIdx: "int") -> "bool":
        r"""
        Returns true if assembler info should be provided with coverage.

        :param triggerIndex: index of analyzer trigger as returned by ``createTrigger()``,
                   ``getActiveTriggerIndex()`` or ``getTriggerIndex()``
        """
        return _connect.CCoverageController2_isProvideAssemblerInfo(self, triggerIdx)

    def setIgnoreUnreachableCode(self, isIgnoreUnreachableCode: "bool") -> "void":
        r"""
        If set to true, then the code inside the function which is not reachable by
        sequential or (conditional)direct branch flow is not considered for coverage
        statistics.
        Set it to true, when compiler generates data between instructions (for example
        branch addresses) and you want to get 100% coverage.
        """
        return _connect.CCoverageController2_setIgnoreUnreachableCode(self, isIgnoreUnreachableCode)

    def isIgnoreUnreachableCode(self) -> "bool":
        r"""See also: setIgnoreUnreachableCode()"""
        return _connect.CCoverageController2_isIgnoreUnreachableCode(self)

    def addArea(self, triggerIndex: "int", areaType: "isys::CCoverageController2::ECoverageAreaType", areaName: "std::string const &") -> "int":
        r"""
        Adds area (module, function, ...) to be included in coverage measurement. This
        method has effect only if method ``setScope()`` was called with ``EScopeCustom``
        as scope value.

        :type triggerIndex: int
        :param triggerIndex: index of analyzer trigger as returned by ``createTrigger()``,
                   ``getActiveTriggerIndex()`` or ``getTriggerIndex()``

        :type areaType: int
        :param areaType: type of area

        :type areaName: string
        :param areaName: name of image file, module, function, ... Modules must be
                   specified with relative path if they are not in winIDEA workspace folder.

        See also: getAreas
        """
        return _connect.CCoverageController2_addArea(self, triggerIndex, areaType, areaName)

    def removeArea(self, triggerIndex: "int", areaType: "isys::CCoverageController2::ECoverageAreaType", areaName: "std::string const &") -> "int":
        r"""
        Removes area, which has been previously added with addArea(), from
        coverage measurement.

        :type triggerIndex: int
        :param triggerIndex: index of analyzer trigger as returned by ``createTrigger()``,
                   ``getActiveTriggerIndex()`` or ``getTriggerIndex()``

        :type areaType: int
        :param areaType: type of area

        :type areaName: string
        :param areaName: name of image file, module, function, ... Modules must be
                   specified with relative path if they are not in winIDEA workspace folder.

        :rtype: int
        :return: -1 if area with the give name was not found (not removed), 0 if area
                    with the given name exists, but is not of the specified type (not removed),
                    1 if area was found and removed

        See also: addArea
        """
        return _connect.CCoverageController2_removeArea(self, triggerIndex, areaType, areaName)

    def removeAllAreas(self, triggerIndex: "int") -> "void":
        r"""
        Removes all areas of the given type from coverage measurement.

        See also: addArea
        """
        return _connect.CCoverageController2_removeAllAreas(self, triggerIndex)

    def getAreas(self, triggerIndex: "int", areaType: "isys::CCoverageController2::ECoverageAreaType", areas: "StrVector") -> "void":
        r"""
        Returns list of currently configured areas.

        See also: addArea
        See also: removeArea
        """
        return _connect.CCoverageController2_getAreas(self, triggerIndex, areaType, areas)

    def exportData(self, exportConfig: "CCoverageExportConfig") -> "void":
        r"""
        Exports coverage data according to the given configuration.
        Example:


        coverage = CCoverageController2(connectionMgr, "coverage.trd", "w")

        ...

        cfg = CCoverageExportConfig().setFileName('coverageResult.xml') \
                                     .setExportSources(True) \
                                     .setExportFunctionLines(True)
        coverage.exportData(cfg)


        :type exportConfig: :py:class:`CCoverageExportConfig`
        :param exportConfig: object with parameters for export - defines which
                                items to export and their format

        See also: CCoverageExportConfig

        Python example: coverage2Example.py ,
                        coverageExport.py ,
                        coverageToHtml.py
        """
        return _connect.CCoverageController2_exportData(self, exportConfig)

    def merge(self, files: "StrVector") -> "void":
        r"""
        This method merges coverage information from the given list of
        analyzer files to this document.

        **Note:**
        If this document is configured
        to show only certain areas (functions), then only those areas will
        be visible after merging. It is recommended to create a new document
        before merging, because it has all areas visible by default.

        **Limitations:**
        You can only merge results, if all analyzer documents were
        obtained with the same target code.

        :raises: IOException if one of source files is not found or in
            case of merging error.

        Python example: coverageMerge.py
        """
        return _connect.CCoverageController2_merge(self, files)

    def areaType2Str(self, areaType: "isys::CCoverageController2::ECoverageAreaType") -> "std::string":
        r"""
        Returns string, which can be used to set option
        ``/Document/<fileName>/Trigger.Items[<idx1>].Coverage.Include[<idx2>].Type``.

        :type areaType: int
        :param areaType: type of area
        """
        return _connect.CCoverageController2_areaType2Str(self, areaType)

    def scope2Str(self, scope: "isys::CCoverageController2::ECoverageScope") -> "std::string":
        r"""
        Returns string, which can be used to set option
        ``/Document/<fileName>/Trigger.Items[<idx1>].Coverage.Scope``.

        :type scope: int
        :param scope: coverage scope
        """
        return _connect.CCoverageController2_scope2Str(self, scope)

    def scope2Enum(self, scope: "std::string const &") -> "isys::CCoverageController2::ECoverageScope":
        r"""
        Returns enum value for the given scope string.

        :type scope: string
        :param scope: one of strings specified for option
            ``/Document/<fileName>/Trigger.Items[<idx1>].Coverage.Scope``
            See winIDEA, ``Help | Display Option``, select ``Document`` and
            analyzer document with coverage trigger defined.
        """
        return _connect.CCoverageController2_scope2Enum(self, scope)

# Register CCoverageController2 in _connect:
_connect.CCoverageController2_swigregister(CCoverageController2)

class CCoverageMetaInfo(object):
    r"""
    This class contains information from coverage info node
    as entered in the 'Set Information' dialog in winIDEA.
    This node appears at the start of coverage XML export, and
    there is only one instance per document. Call method
    CCoverageData2::getCoverageMetaInfo() to get instance of this class.



    Python example: coverageData.py 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getName(self) -> "std::string":
        r""" Returns tester's name as entered in 'Set Information' dialog."""
        return _connect.CCoverageMetaInfo_getName(self)

    def getId(self) -> "std::string":
        r""" Returns coverage ID as entered in 'Set Information' dialog."""
        return _connect.CCoverageMetaInfo_getId(self)

    def getDate(self) -> "std::string":
        r""" Returns recording date."""
        return _connect.CCoverageMetaInfo_getDate(self)

    def getTime(self) -> "std::string":
        r""" Returns recording time."""
        return _connect.CCoverageMetaInfo_getTime(self)

    def getSoftware(self) -> "std::string":
        r""" Returns covered software info as entered in 'Set Information' dialog."""
        return _connect.CCoverageMetaInfo_getSoftware(self)

    def getHardware(self) -> "std::string":
        r""" Returns hardware info as entered in 'Set Information' dialog."""
        return _connect.CCoverageMetaInfo_getHardware(self)

    def getDescription(self) -> "std::string":
        r""" Returns description as entered in 'Set Information' dialog."""
        return _connect.CCoverageMetaInfo_getDescription(self)

    def getComment(self) -> "std::string":
        r""" Returns comment as entered in 'Set Information' dialog."""
        return _connect.CCoverageMetaInfo_getComment(self)

    def __init__(self):
        _connect.CCoverageMetaInfo_swiginit(self, _connect.new_CCoverageMetaInfo())
    __swig_destroy__ = _connect.delete_CCoverageMetaInfo

# Register CCoverageMetaInfo in _connect:
_connect.CCoverageMetaInfo_swigregister(CCoverageMetaInfo)

class CCoverageSource(object):
    r"""
    This class contains information about coverage of a source line in the
    same way as it is shown on the left edge of winIDEA source code editor.
    It contains data from <src>, and <src><al> nodes.


    Python example: coverageData.py 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EAreaExecuted = _connect.CCoverageSource_EAreaExecuted
    r""" All instructions in the line were executed (xml text: '0e')"""
    EAreaNotExecuted = _connect.CCoverageSource_EAreaNotExecuted
    r""" No instructions in the line were executed (xml text: '0n')"""
    EAreaPartiallyExecuted = _connect.CCoverageSource_EAreaPartiallyExecuted
    r"""
    Some instructions in the line were
    executed (xml text: '0m' (mixed))
    """
    EConditionBoth = _connect.CCoverageSource_EConditionBoth
    r"""
    Line contains a condition, which was executed both
    ways (xml text: '1b')
    """
    EMixedStateOfMultipleConditions = _connect.CCoverageSource_EMixedStateOfMultipleConditions
    r"""
    Line contains multiple conditions, not all of
    them were executed both ways (xml text: '1m')
    """
    EConditionNotExecuted = _connect.CCoverageSource_EConditionNotExecuted
    r"""
    Line contains a condition, which was not executed
    (xml text: '1n')
    """
    EConditionWasNeverTrue = _connect.CCoverageSource_EConditionWasNeverTrue
    r"""
    Line contains condition, which was never executed
    as ``true`` (xml text: '1nt')
    """
    EConditionWasAlwaysTrue = _connect.CCoverageSource_EConditionWasAlwaysTrue
    r"""
    Line contains condition, which was never executed
    as ``false`` (xml text: '1t')
    """
    EOutOfange = _connect.CCoverageSource_EOutOfange
    r"""
    Debug info is there for this source line but it was
    not configured for coverage (xml text: 'r')
    """
    EEmpty = _connect.CCoverageSource_EEmpty
    r""" There is no debug info for this source line. (xml text: 'e')"""

    def getSourceLineText(self) -> "std::string":
        r""" Returns source code text in the line."""
        return _connect.CCoverageSource_getSourceLineText(self)

    def getSourceLineNumber(self) -> "int":
        r""" Returns the line number."""
        return _connect.CCoverageSource_getSourceLineNumber(self)

    def getAddress(self) -> "std::string":
        r""" Returns address as text."""
        return _connect.CCoverageSource_getAddress(self)

    def getNumAsmOpCodes(self) -> "size_t":
        r""" Returns the number of assembler op codes for source line."""
        return _connect.CCoverageSource_getNumAsmOpCodes(self)

    def getAsmOpCodeInfo(self, idx: "int") -> "CCoverageSource":
        r"""
        This method returns assembler op code coverage info.

        Python example: coverageData.py 
        """
        return _connect.CCoverageSource_getAsmOpCodeInfo(self, idx)

    def getCoverageMarker(self) -> "isys::CCoverageSource::ESrcLineCoverageMarkers":
        r"""
        Returns source code coverage marker. See
        CCoverageSource::ESrcLineCoverageMarkers for details.
        """
        return _connect.CCoverageSource_getCoverageMarker(self)

    def __init__(self):
        _connect.CCoverageSource_swiginit(self, _connect.new_CCoverageSource())
    __swig_destroy__ = _connect.delete_CCoverageSource

# Register CCoverageSource in _connect:
_connect.CCoverageSource_swigregister(CCoverageSource)

class CCoverageStatistic2(object):
    r"""
    This class contains information about coverage area (function or
    data), which coverage has been measured.



    Python example: coverageData.py
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EAnyArea = _connect.CCoverageStatistic2_EAnyArea
    r""" Matches any other area when retrieving data."""
    EImages = _connect.CCoverageStatistic2_EImages
    r""" This area contains statistic for all download files."""
    EImage = _connect.CCoverageStatistic2_EImage
    r""" This area contains statistic for one download file."""
    EFolder = _connect.CCoverageStatistic2_EFolder
    r""" This area contains statistic for source files in one folder."""
    EModule = _connect.CCoverageStatistic2_EModule
    r""" This area contains statistic for one source file."""
    EFunction = _connect.CCoverageStatistic2_EFunction
    r""" This area contains statistic for one function."""
    ESrcLine = _connect.CCoverageStatistic2_ESrcLine
    r""" This area contains statistic for one source line."""
    EAsm = _connect.CCoverageStatistic2_EAsm
    r""" This area contains statistic for one assembler instruction."""
    ERange = _connect.CCoverageStatistic2_ERange
    r"""
    This area contains statistic for one memory range, usually
    this is one assembler instruction.
    """
    ERanges = _connect.CCoverageStatistic2_ERanges
    r"""
    This area contains statistic for memory ranges which
    were not found in debug information.
    """

    def __init__(self, areaType: "isys::CCoverageStatistic2::EAreaType"):
        _connect.CCoverageStatistic2_swiginit(self, _connect.new_CCoverageStatistic2(areaType))

    def getParent(self) -> "CCoverageStatistic2":
        r"""
        Returns parent of this statistic. Hierarchy ``parentArea -> childrenAreas`` is
        defined as:
        images -> image -> folder -> module -> function -> line -> asm -> range``


        Parent information is available only when complete file is loaded into memory.
        If CCoverageData2::createInstance() was called with ``isLoadDataInMemory = false``,
        then this method always returns null reference.
        """
        return _connect.CCoverageStatistic2_getParent(self)

    def getNumChildren(self) -> "size_t":
        r"""
        Returns the number of children areas, for example the number of source files
        in a folder (use only when complete
        file is loaded to memory (method createInstance() was called
        with ``isLoadDataInMemory`` = ``true))``.


        Python example: coverageData.py 
        """
        return _connect.CCoverageStatistic2_getNumChildren(self)

    def getChild(self, idx: "int") -> "CCoverageStatistic2":
        r"""
        Returns child area for the given index (available only when complete
        file is loaded to memory (method createInstance() was called
        with ``isLoadDataInMemory`` = ``true))``.


        Python example: coverageData.py 
        """
        return _connect.CCoverageStatistic2_getChild(self, idx)

    def getAreaType(self) -> "isys::CCoverageStatistic2::EAreaType":
        r"""
        Returns coverage area type.


        Python example: coverageData.py 
        """
        return _connect.CCoverageStatistic2_getAreaType(self)

    def getAreaName(self) -> "std::string":
        r""" Returns area name, for example source file name, function name, source line text, ..."""
        return _connect.CCoverageStatistic2_getAreaName(self)

    def getLinesAll(self) -> "int":
        r""" Returns the number of all source code lines in area."""
        return _connect.CCoverageStatistic2_getLinesAll(self)

    def getLinesExecuted(self) -> "int":
        r""" Returns the number of executed source code lines in area."""
        return _connect.CCoverageStatistic2_getLinesExecuted(self)

    def getBytesAll(self) -> "int":
        r""" Returns the number of object code bytes in area."""
        return _connect.CCoverageStatistic2_getBytesAll(self)

    def getBytesExecuted(self) -> "int":
        r""" Returns the number of executed object code bytes in area."""
        return _connect.CCoverageStatistic2_getBytesExecuted(self)

    def getConditionsAll(self) -> "int":
        r""" Returns the number of object code conditions in area."""
        return _connect.CCoverageStatistic2_getConditionsAll(self)

    def getConditionsExecuted(self) -> "int":
        r""" Returns the number of object code conditions which executed as ``true``."""
        return _connect.CCoverageStatistic2_getConditionsExecuted(self)

    def getConditionsTrue(self) -> "int":
        r""" Returns the number of object code conditions which executed as ``true``."""
        return _connect.CCoverageStatistic2_getConditionsTrue(self)

    def getConditionsFalse(self) -> "int":
        r""" Returns the number of object code conditions which executed as ``false``."""
        return _connect.CCoverageStatistic2_getConditionsFalse(self)

    def getConditionsBoth(self) -> "int":
        r""" Returns the number of object code conditions which executed both ways."""
        return _connect.CCoverageStatistic2_getConditionsBoth(self)

    def getExecutionCount(self) -> "int":
        r"""
        Returns execution count. For example, if this is coverage statistics for a module,
        this method returns number of functions in module called at least once.
        For function this is number of calls of a function, for lines this
        is number of executions of a line.
        See also: #getItemsCount
        """
        return _connect.CCoverageStatistic2_getExecutionCount(self)

    def getItemsCount(self) -> "int":
        r"""
        Returns items count. For example, if this is coverage statistics for a module,
        this method returns number of all functions in a module. For functions
        this is number of lines in a function.
        See also: #getExecutionCount
        """
        return _connect.CCoverageStatistic2_getItemsCount(self)

    def getCallCount(self) -> "int":
        r"""Returns the number of all calls in a range, function, module, ..."""
        return _connect.CCoverageStatistic2_getCallCount(self)

    def getExecutedCallCount(self) -> "int":
        r"""Returns the number of executed calls in a range, function, module, ..."""
        return _connect.CCoverageStatistic2_getExecutedCallCount(self)

    def getTextOrAbsPath(self) -> "std::string":
        r"""
        Returns source line text for CCoverageStatistic2::ESrcLine areas, and
        absolute path for CCoverageStatistic2::EFolder and
        CCoverageStatistic2::EModule areas. This method is not available for
        areas of other type.

        :raises: IllegalStateException if this is not line, folder or module area.


            Python example: coverageData.py 
        """
        return _connect.CCoverageStatistic2_getTextOrAbsPath(self)

    def getRelPath(self) -> "std::string":
        r"""
        Returns relative path. This method is available only for folder and
        module areas.

        :raises: IllegalStateException if this is not folder or module area.


            Python example: coverageData.py 
        """
        return _connect.CCoverageStatistic2_getRelPath(self)

    def getLineNumber(self) -> "int":
        r"""
        Returns source line number (this method is available only for areas
        of type CCoverageStatistic2::ESrcLine).

        :raises: IllegalStateException if this is not line area.


            Python example: coverageData.py 
        """
        return _connect.CCoverageStatistic2_getLineNumber(self)

    def getNumSourceLines(self) -> "size_t":
        r"""
        This method returns the number of source lines in area of type
        CCoverageStatistic2::EModule.

        :raises: IllegalStateException if this is not module area.


            Python example: coverageData.py 
        """
        return _connect.CCoverageStatistic2_getNumSourceLines(self)

    def getSourceLineInfo(self, idx: "int") -> "CCoverageSource":
        r"""
        This method returns source line coverage info (available
        only for areas of type CCoverageStatistic2::EModule).

        :raises: IllegalStateException if this is not module area.


            Python example: coverageData.py 
        """
        return _connect.CCoverageStatistic2_getSourceLineInfo(self, idx)

    def getNumAsmLines(self) -> "size_t":
        r""" Returns the number of lines with ASM info for this node."""
        return _connect.CCoverageStatistic2_getNumAsmLines(self)

    def getAsmLine(self, idx: "int") -> "CCoverageStatistic2Asm":
        r""" Returns ASM info aththe given index for this node."""
        return _connect.CCoverageStatistic2_getAsmLine(self, idx)

    def addStatItems(self, src: "isys::CCoverageStatistic2SPtr const &") -> "void":
        return _connect.CCoverageStatistic2_addStatItems(self, src)

    @staticmethod
    def areaType2Str(areaType: "isys::CCoverageStatistic2::EAreaType") -> "std::string":
        r"""Returns string representation of the given enum."""
        return _connect.CCoverageStatistic2_areaType2Str(areaType)
    __swig_destroy__ = _connect.delete_CCoverageStatistic2

# Register CCoverageStatistic2 in _connect:
_connect.CCoverageStatistic2_swigregister(CCoverageStatistic2)

def CCoverageStatistic2_areaType2Str(areaType: "isys::CCoverageStatistic2::EAreaType") -> "std::string":
    r"""Returns string representation of the given enum."""
    return _connect.CCoverageStatistic2_areaType2Str(areaType)

class CCoverageStatistic2Asm(object):
    r"""
    This class contains disassembly coverage information for function - op
    codes are sorted by addresses.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CCoverageStatistic2Asm_swiginit(self, _connect.new_CCoverageStatistic2Asm())

    def getLineType(self) -> "char":
        r""" Returns line type (source or assembly)."""
        return _connect.CCoverageStatistic2Asm_getLineType(self)

    def getCoverageMarker(self) -> "isys::CCoverageSource::ESrcLineCoverageMarkers":
        r""" Returns coverage marker for assembly line."""
        return _connect.CCoverageStatistic2Asm_getCoverageMarker(self)

    def getAddress(self) -> "std::string":
        r""" Returns line address."""
        return _connect.CCoverageStatistic2Asm_getAddress(self)

    def getLineText(self) -> "std::string":
        r""" Returns text in line."""
        return _connect.CCoverageStatistic2Asm_getLineText(self)

    def getLineNumber(self) -> "int":
        r""" Returns source line number. Available for source line type only."""
        return _connect.CCoverageStatistic2Asm_getLineNumber(self)

    def getModuleName(self) -> "std::string":
        r""" Returns source module name. Available for source line type only."""
        return _connect.CCoverageStatistic2Asm_getModuleName(self)
    __swig_destroy__ = _connect.delete_CCoverageStatistic2Asm

# Register CCoverageStatistic2Asm in _connect:
_connect.CCoverageStatistic2Asm_swigregister(CCoverageStatistic2Asm)

class CCoverageStatIterator(object):
    r"""
    This class iterates through statistic nodes. Depth-first iteration
    is used. 

    Clients should use CCoverageData2::getIterator() to obtain instances
    of this class.

    See also: CCoverageData2::getIterator()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, coverageData: "isys::CCoverageData2SPtr", areaType: "isys::CCoverageStatistic2::EAreaType", firstStat: "isys::CCoverageStatistic2SPtr"):
        _connect.CCoverageStatIterator_swiginit(self, _connect.new_CCoverageStatIterator(coverageData, areaType, firstStat))

    def hasNext(self) -> "bool":
        r"""
         Returns true, if there is at least one more statistic available.


        Python example: coverageData.py
        """
        return _connect.CCoverageStatIterator_hasNext(self)

    def next(self) -> "CCoverageStatistic2":
        r"""
         Returns the next statistic.


        Python example: coverageData.py
        """
        return _connect.CCoverageStatIterator_next(self)
    __swig_destroy__ = _connect.delete_CCoverageStatIterator

# Register CCoverageStatIterator in _connect:
_connect.CCoverageStatIterator_swigregister(CCoverageStatIterator)

class CCoverageData2(object):
    r"""
    This class provides convenient access to coverage data exported to XML file,
    so that writing XML parser is not required. Use class CCoverageController2
    to record and export the data.


    Instances of this class chould be obtained with one of createInstance()
    static methods.

    Two ways of parsing are provided (see parameter ``isLoadDataInMemory`` in
    methods createInstance()):
    - parse complete coverage file to memory. Use this approach when coverage
      files are small relative to available computer memory. Method getRoot()
      returns root node, which contains children. Iterators are also available.
      Recommended usage:

        createInstance()
        getParserWarnings()
        closeParser()
        use getter methods as needed


    - parse coverage file statistic node by node. Information is available only
      through iterator, nodes do not have children or parents assigned.
      Recommended usage:

        createInstance()
        getParserWarnings()
        then either:
          call getStatistic() if you are interested in coverage
                              statistic of one area only
          call getIterator()  to obtain information about all areas.
                              Once iterator's method hasNext() returns ``false``,
                              this object can no longer be used.
        finally call method closeParser()




    Python example: coverageData.py 

    Python example: coverageToHTML.py 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def createInstance(*args) -> "CCoverageData2":
        r"""
        *Overload 1:*

        This factory method exports data to file,
        and returns initialized object.
        Use it, when you've just recorded data (have CCoverageController2 object
        available), and have not exported it yet. Note also that this method is not
        as flexible as direct export and
        method createInstance(fileName, isLoadDataInMemory).


        **Note**: if ``exportFileName`` is relative, it is saved relative to
        winIDEA working directory, not the script working directory. This method
        tries to do its best to open the saved file, but if winIDEA is on remote
        host, it will fail. In such cases try to export the coverage data with
        CCoverageController2::exportData() and use
        the overloaded method ``createInstance(fileName)`` instead.

        **Important:** To release memory and file, always call closeParser()
                          when done using parser!

        :type coverageCtrl: :py:class:`CCoverageController2`
        :param coverageCtrl: coverage document controller which will be used to obtain data.

        :type exportFileName: string
        :param exportFileName: name of the file to export data to

        :type isLoadDataInMemory: boolean
        :param isLoadDataInMemory: if ``true``, the exported file is immediately parsed
                                      and all data is
                                      loaded into memory.  This provides
                                      faster browsing, but may not be
                                      appropriate for large coverage files. 

                                      If ``false``, use iterator (see getIterator()) to
                                      parse statistic node by node. This approach
                                      is not as flexible as the frst one, but it is very
                                      memory efficient.

        Python example: coverageData.py

        |

        *Overload 2:*

        This factory method parses statistic information from coverage XML
        export file and returns initialized object.

        **Important:** To release memory and file, always call closeParser()
                          when done using parser!

        :type fileName: string
        :param fileName: name of the file with coverage XML export. If you use
                            relative file path, be aware that script working directory is
                            used as a starting point, not winIDEA workspace directory.

        :type isLoadDataInMemory: boolean
        :param isLoadDataInMemory: if ``true``, the exported file is immediately parsed
                                      and all data is loaded into memory. This provides
                                      faster browsing, but may not be
                                      appropriate for large coverage files. 

                                      If ``false``, use iterator (see getIterator()) to
                                      parse statistic node by node. This approach
                                      is not as flexible as the first one, but it is very
                                      memory efficient.

        Python example: coverageData.py
        """
        return _connect.CCoverageData2_createInstance(*args)

    def getParserWarnings(self) -> "std::string":
        r"""
        This method returns warnings related to input XML document. If there
        were no warnings, an empty string is returned. Always call this method
        after createInstance(). If XML document is made with newer version of winIDEA
        than SDK, it will warn you about possible missing info.

        Python example: coverageData.py
        """
        return _connect.CCoverageData2_getParserWarnings(self)

    def closeParser(self) -> "void":
        r"""
        This method releases parser resources and closes XML file. If this method
        is not called, the XML file remains opened and can not be overwritten or
        deleted until the application exits. Furthermore, memory allocated by
        by this object is not released until this method is called!

        Python example: coverageData.py
        """
        return _connect.CCoverageData2_closeParser(self)

    def getCoverageMetaInfo(self) -> "CCoverageMetaInfo":
        r"""
        Returns coverage meta-data as specified by the user in winIDEA
        coverage 'Set information' dialog.


        Python example: coverageData.py 
        """
        return _connect.CCoverageData2_getCoverageMetaInfo(self)

    def getRoot(self) -> "CCoverageStatistic2":
        r"""
        Returns root node of type CCoverageStatistic2, which contains
        all other nodes. This method may be called only if all data is
        loaded into memory (see the second parameter of createInstance()).

        :raises: IllegalStateException if coverage data is not loaded
                   into memory (see the second parameter in
                   createInstance()).


            Python example: coverageData.py 
        """
        return _connect.CCoverageData2_getRoot(self)

    def getStatistic(self, *args) -> "CCoverageStatistic2":
        r"""
        *Overload 1:*

        Returns statistic for the given function. This works only when data is
        loaded into memory.

        |

        *Overload 2:*

        This method searches the coverage data tree and returns the first
        node with the given type and name found. 


        Although this method works also
        when data is not loaded into memory (createInstance() was called with
        parameter ``isLoadDataInMemory`` = ``false)``, the parser has to be closed
        after each call and this class instantiated again, which makes it very
        inefficient. Also, if iterator was used before this method was called,
        results are unpredictable, and calling getIterator() after calling this
        method is forbidden.


        Python example: coverageData.py 
        """
        return _connect.CCoverageData2_getStatistic(self, *args)

    def getIterator(self, areaType: "isys::CCoverageStatistic2::EAreaType") -> "CCoverageStatIterator":
        r"""
        Returns iterator, which iterates all nodes in coverage file sequentially,
        and returns only nodes of the given type. Specify ``areaType`` = ``EAnyArea``
        to get all nodes.


        Python example: coverageData.py 
        """
        return _connect.CCoverageData2_getIterator(self, areaType)
    __swig_destroy__ = _connect.delete_CCoverageData2

# Register CCoverageData2 in _connect:
_connect.CCoverageData2_swigregister(CCoverageData2)

def CCoverageData2_createInstance(*args) -> "CCoverageData2":
    r"""
    *Overload 1:*

    This factory method exports data to file,
    and returns initialized object.
    Use it, when you've just recorded data (have CCoverageController2 object
    available), and have not exported it yet. Note also that this method is not
    as flexible as direct export and
    method createInstance(fileName, isLoadDataInMemory).


    **Note**: if ``exportFileName`` is relative, it is saved relative to
    winIDEA working directory, not the script working directory. This method
    tries to do its best to open the saved file, but if winIDEA is on remote
    host, it will fail. In such cases try to export the coverage data with
    CCoverageController2::exportData() and use
    the overloaded method ``createInstance(fileName)`` instead.

    **Important:** To release memory and file, always call closeParser()
                      when done using parser!

    :type coverageCtrl: :py:class:`CCoverageController2`
    :param coverageCtrl: coverage document controller which will be used to obtain data.

    :type exportFileName: string
    :param exportFileName: name of the file to export data to

    :type isLoadDataInMemory: boolean
    :param isLoadDataInMemory: if ``true``, the exported file is immediately parsed
                                  and all data is
                                  loaded into memory.  This provides
                                  faster browsing, but may not be
                                  appropriate for large coverage files. 

                                  If ``false``, use iterator (see getIterator()) to
                                  parse statistic node by node. This approach
                                  is not as flexible as the frst one, but it is very
                                  memory efficient.

    Python example: coverageData.py

    |

    *Overload 2:*

    This factory method parses statistic information from coverage XML
    export file and returns initialized object.

    **Important:** To release memory and file, always call closeParser()
                      when done using parser!

    :type fileName: string
    :param fileName: name of the file with coverage XML export. If you use
                        relative file path, be aware that script working directory is
                        used as a starting point, not winIDEA workspace directory.

    :type isLoadDataInMemory: boolean
    :param isLoadDataInMemory: if ``true``, the exported file is immediately parsed
                                  and all data is loaded into memory. This provides
                                  faster browsing, but may not be
                                  appropriate for large coverage files. 

                                  If ``false``, use iterator (see getIterator()) to
                                  parse statistic node by node. This approach
                                  is not as flexible as the first one, but it is very
                                  memory efficient.

    Python example: coverageData.py
    """
    return _connect.CCoverageData2_createInstance(*args)

class CProfilerContext(object):
    r"""
    Deprecated: this method will be removed or changed in one of
                future releases.
    This class contains information about profiler context (task, ISR,
    thread, ...). Context IDs are specified in timeline events.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getName(self) -> "std::string":
        return _connect.CProfilerContext_getName(self)

    def getHandle(self) -> "DWORD":
        return _connect.CProfilerContext_getHandle(self)

    def __init__(self):
        _connect.CProfilerContext_swiginit(self, _connect.new_CProfilerContext())
    __swig_destroy__ = _connect.delete_CProfilerContext

# Register CProfilerContext in _connect:
_connect.CProfilerContext_swigregister(CProfilerContext)

class CProfilerArea2(object):
    r"""
    This class contains information about profiler area (function or
    data), which has been profiled. Areas are identified by 64-bit IDs, which
    are composed of area handle and area value.
    Function areas and non-state variable areas have value always set to 0.


    Python example: profilerData.py
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EFunctions = _connect.CProfilerArea2_EFunctions
    r""" function (code) areas"""
    EFunctionLines = _connect.CProfilerArea2_EFunctionLines
    r""" deprecated since 9.17.36, Jan. 2018"""
    EVariables = _connect.CProfilerArea2_EVariables
    r"""
    variable areas for regular (non-state) variables.
    No statistics is recorded for values.
    """
    EStateVariables = _connect.CProfilerArea2_EStateVariables
    r"""
    state variables, which have at most 256 values.
    Statistics (see CProfilerStatistics2) is
    recorded for each value. Examples
    of such variables are task Id and states in
    state machines.
    """
    EAUX = _connect.CProfilerArea2_EAUX
    r""" IO lines as value"""
    EStateAUX = _connect.CProfilerArea2_EStateAUX
    r""" IO lines as state"""
    EInspector = _connect.CProfilerArea2_EInspector
    r""" inspector area, implemented as state machine with other areas as inputs"""
    EStateInspector = _connect.CProfilerArea2_EStateInspector
    r""" state inspector area, implemented as state machine with other areas as inputs"""

    def getAreaType(self) -> "isys::CProfilerArea2::EAreaType":
        r""" Returns area type."""
        return _connect.CProfilerArea2_getAreaType(self)

    def getHandle(self) -> "DWORD":
        r""" Returns area handle."""
        return _connect.CProfilerArea2_getHandle(self)

    def getAreaName(self) -> "std::string":
        r"""
        Returns area name. For function, variable and AUX areas this method
        returns function, variable, or AUX name. For function lines the source
        code of the line is returned. For state variables an empty string is
        returned, unless the variable was added to profiler with
        method CProfilerController2::addStateVariable(). Definition name
        (for example enum constant) is returned in this case.
        """
        return _connect.CProfilerArea2_getAreaName(self)

    def getFileName(self) -> "std::string":
        r"""Returns file name. Available only for function line areas."""
        return _connect.CProfilerArea2_getFileName(self)

    def getPath(self) -> "std::string":
        r"""Returns path from root node. Path consists of node names separated with '/'."""
        return _connect.CProfilerArea2_getPath(self)

    def getAreaId(self) -> "isys::areaHandle_t":
        r"""Returns unique Id for area."""
        return _connect.CProfilerArea2_getAreaId(self)

    def getValue(self) -> "int64_t":
        r"""
        Returns area value for state variables. For functions, function lines,
        and non-state variable areas it returns 0.
        """
        return _connect.CProfilerArea2_getValue(self)

    def getLineNumber(self) -> "DWORD":
        r"""Returns line number for function lines. For other areas it returns 0."""
        return _connect.CProfilerArea2_getLineNumber(self)

    def getParentHandle(self) -> "DWORD":
        r"""
        For state variable areas this method returns handle of variable,
        which was recorded, for function lines function handle is returned.
        For example, if state
        variable 'counter' was recorded with value '3',
        this method returns handle of variable 'counter'.

        Returns 0 for other ares.
        """
        return _connect.CProfilerArea2_getParentHandle(self)

    def getParentAreaName(self) -> "std::string":
        r"""
        For state variable areas this method returns the name of variable,
        which was recorded with this value, for function lines function
        name is returned. For example, if state
        variable 'counter' was recorded with value '3', than state area
        has empty name (method getName() returns empty string), but
        this method returns 'counter' and getValue() returns '3'.
        Returns empty string for other ares.
        """
        return _connect.CProfilerArea2_getParentAreaName(self)

    def getValueUnit(self) -> "std::string":
        r"""Returns physical unit of value, for example V for Volts, A, for Amperes, ..."""
        return _connect.CProfilerArea2_getValueUnit(self)

    def getValueType(self) -> "std::string":
        r"""
        Returns type of value, 'I32' for 32-bit unsigned integers,
        'S32' for 32-bit signed integers, or 'F32' for 32-bit floats.
        """
        return _connect.CProfilerArea2_getValueType(self)

    def hasStates(self) -> "bool":
        r"""
        Returns true, if state areas exist for variable area.

        See also: getStateAreaId()
        """
        return _connect.CProfilerArea2_hasStates(self)

    def getStateAreaId(self, value: "DWORD") -> "isys::areaHandle_t":
        r"""
        Returns ID for state areas if they exist for the variable,
        0 otherwise. For example,
        if variable `mysStateVar` has states `S_ENTER`, and `S_EXIT`,
        method `getStateAreaID()` on area of `myStateVar` will return the
        same ID as `getParentHandle()` method on areas `S_ENTER` and `S_EXIT`. This way
        we can connect state variables and their states.

        :type value: int
        :param value: ignored, no longer used after 9.12.274.
        See also: hasStates()
        """
        return _connect.CProfilerArea2_getStateAreaId(self, value)

    @staticmethod
    def handle2AreaId(handle: "DWORD", value: "int64_t"=0) -> "isys::areaHandle_t":
        r""" Utility method, which returns area type for the given handle."""
        return _connect.CProfilerArea2_handle2AreaId(handle, value)

    def __init__(self):
        _connect.CProfilerArea2_swiginit(self, _connect.new_CProfilerArea2())
    __swig_destroy__ = _connect.delete_CProfilerArea2

# Register CProfilerArea2 in _connect:
_connect.CProfilerArea2_swigregister(CProfilerArea2)

def CProfilerArea2_handle2AreaId(handle: "DWORD", value: "int64_t"=0) -> "isys::areaHandle_t":
    r""" Utility method, which returns area type for the given handle."""
    return _connect.CProfilerArea2_handle2AreaId(handle, value)

class CProfilerContextIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, profilerData: "isys::CProfilerData2SPtr"):
        _connect.CProfilerContextIterator_swiginit(self, _connect.new_CProfilerContextIterator(profilerData))

    def hasNext(self) -> "bool":
        r""" Returns true, if there is at least one more area available."""
        return _connect.CProfilerContextIterator_hasNext(self)

    def next(self) -> "isys::CProfilerContext":
        r""" Returns the next context."""
        return _connect.CProfilerContextIterator_next(self)
    __swig_destroy__ = _connect.delete_CProfilerContextIterator

# Register CProfilerContextIterator in _connect:
_connect.CProfilerContextIterator_swigregister(CProfilerContextIterator)

class CProfilerAreaIterator(object):
    r"""
    This class provides access to profiler areas. Do not
    instantiate this class directly but call
    CProfilerData2::getAreaIterator() to get an instance.


    Python example: profilerData.py
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, profilerData: "isys::CProfilerData2SPtr", areaType: "isys::CProfilerArea2::EAreaType"):
        _connect.CProfilerAreaIterator_swiginit(self, _connect.new_CProfilerAreaIterator(profilerData, areaType))

    def hasNext(self) -> "bool":
        r"""
         Returns true, if there is at least one more area available.


        Python example: profilerData.py
        """
        return _connect.CProfilerAreaIterator_hasNext(self)

    def next(self) -> "isys::CProfilerArea2":
        r"""
         Returns the next area.


        Python example: profilerData.py
        """
        return _connect.CProfilerAreaIterator_next(self)
    __swig_destroy__ = _connect.delete_CProfilerAreaIterator

# Register CProfilerAreaIterator in _connect:
_connect.CProfilerAreaIterator_swigregister(CProfilerAreaIterator)

class CProfilerStatistics2(object):
    r"""
    This class contains profiler statistics information.


    Python example: profilerData.py
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ENetTimes = _connect.CProfilerStatistics2_ENetTimes
    r"""
    Identifies net times for function execution.
    Net time is time spent for code inside function body, without
    sub-functions called from this function.
    """
    EGrossTimes = _connect.CProfilerStatistics2_EGrossTimes
    r"""
    Identifies gross times for function execution.
    Gross time is time spent for code inside function body, AND
    sub-functions called from this function.
    """
    ECallTimes = _connect.CProfilerStatistics2_ECallTimes
    r"""
    Identifies call times for function execution.
    Call time is gross time plus time spent in other contexts
    (tasks, interrupts) between entry/exit of this function.
    """
    EPeriodTimes = _connect.CProfilerStatistics2_EPeriodTimes
    r"""
    Identifies times between function invocation. Total time
    is not defined for this type of time.
    """
    EOutsideTimes = _connect.CProfilerStatistics2_EOutsideTimes
    r""" Deprecated: use EInactiveTimes instead"""
    EInactiveTimes = _connect.CProfilerStatistics2_EInactiveTimes
    r"""
    Identifies inactive time for function execution
    or state variable - the time spent outside the body of
    the function or a state.
    """
    EUnknown = _connect.CProfilerStatistics2_EUnknown

    def getAreaId(self) -> "isys::areaHandle_t":
        r"""
        Returns ID of the profiler area (function, variable, AUX, ...), for which
        this statistics was measured.
        """
        return _connect.CProfilerStatistics2_getAreaId(self)

    def getHandle(self) -> "DWORD":
        r"""
        Deprecated: use getAreaId instead

        Returns handle of the profiler area (function, variable, AUX, ...), for which
        this statistics was measured.
        """
        return _connect.CProfilerStatistics2_getHandle(self)

    def getAreaName(self) -> "std::string":
        r"""
        Returns name of the profiler area (function or variable), for which
        this statistics was measured.
        """
        return _connect.CProfilerStatistics2_getAreaName(self)

    def getParentAreaName(self) -> "std::string":
        r"""
        For state variables areas returns name of parent area (variable).
        Empty for other areas.
        """
        return _connect.CProfilerStatistics2_getParentAreaName(self)

    def getAreaValue(self) -> "int64_t":
        r"""
        Returns value of the state area, for which
        this statistics was measured. If it is not state area, this method
        always returns 0.
        """
        return _connect.CProfilerStatistics2_getAreaValue(self)

    def getNumHits(self) -> "DWORD":
        r"""Returns the number of hits."""
        return _connect.CProfilerStatistics2_getNumHits(self)

    def getTotalTime(self, timeType: "isys::CProfilerStatistics2::ETimeType") -> "int64_t":
        r""" Returns total time for the given time type."""
        return _connect.CProfilerStatistics2_getTotalTime(self, timeType)

    def getMinTime(self, timeType: "isys::CProfilerStatistics2::ETimeType") -> "int64_t":
        r""" Returns min time for the given time type."""
        return _connect.CProfilerStatistics2_getMinTime(self, timeType)

    def getMinStartTime(self, timeType: "isys::CProfilerStatistics2::ETimeType") -> "int64_t":
        r""" Returns min start time for the given time type."""
        return _connect.CProfilerStatistics2_getMinStartTime(self, timeType)

    def getMinEndTime(self, timeType: "isys::CProfilerStatistics2::ETimeType") -> "int64_t":
        r""" Returns min end time for the given time type."""
        return _connect.CProfilerStatistics2_getMinEndTime(self, timeType)

    def getMaxTime(self, timeType: "isys::CProfilerStatistics2::ETimeType") -> "int64_t":
        r""" Returns max time for the given time type."""
        return _connect.CProfilerStatistics2_getMaxTime(self, timeType)

    def getMaxStartTime(self, timeType: "isys::CProfilerStatistics2::ETimeType") -> "int64_t":
        r""" Returns max start time for the given time type."""
        return _connect.CProfilerStatistics2_getMaxStartTime(self, timeType)

    def getMaxEndTime(self, timeType: "isys::CProfilerStatistics2::ETimeType") -> "int64_t":
        r""" Returns max end time for the given time type."""
        return _connect.CProfilerStatistics2_getMaxEndTime(self, timeType)

    def getAverageTime(self, timeType: "isys::CProfilerStatistics2::ETimeType") -> "int64_t":
        r""" Returns average time for the given time type."""
        return _connect.CProfilerStatistics2_getAverageTime(self, timeType)

    def getValueAverage(self) -> "double":
        r""" Returns average value if area is regular variable."""
        return _connect.CProfilerStatistics2_getValueAverage(self)

    def getValueMin(self) -> "double":
        r""" Returns min value if area is regular variable."""
        return _connect.CProfilerStatistics2_getValueMin(self)

    def getValueMax(self) -> "double":
        r""" Returns max value if area is regular variable."""
        return _connect.CProfilerStatistics2_getValueMax(self)

    def getValueTimeOfMin(self) -> "int64_t":
        r""" Returns time when min value appeared for the first time, if area is regular variable."""
        return _connect.CProfilerStatistics2_getValueTimeOfMin(self)

    def getValueTimeOfMax(self) -> "int64_t":
        r""" Returns time when max value appeared for the first time, if area is regular variable."""
        return _connect.CProfilerStatistics2_getValueTimeOfMax(self)

    def getNetTotalTime(self) -> "int64_t":
        r"""
        Deprecated: use getTotalTime(ETimeType) instead.

        Returns the total net time for function execution.
        Net time is time spent for code inside function body, without
        sub-functions called from this function.
        """
        return _connect.CProfilerStatistics2_getNetTotalTime(self)

    def getNetMinTime(self) -> "int64_t":
        r"""
         Deprecated: use getMinTime(ETimeType) instead.
        Returns the min net time for function execution.
        Net time is time spent for code inside function body, without
        sub-functions called from this function.
        """
        return _connect.CProfilerStatistics2_getNetMinTime(self)

    def getNetMaxTime(self) -> "int64_t":
        r"""
         Deprecated: use getMaxTime(ETimeType) instead.
        Returns the max net time for function execution.
        Net time is time spent for code inside function body, without
        sub-functions called from this function.
        """
        return _connect.CProfilerStatistics2_getNetMaxTime(self)

    def getNetAverageTime(self) -> "int64_t":
        r"""
         Deprecated: use getAverageTime(ETimeType) instead.
        Returns the average net time for function execution.
        Net time is time spent for code inside function body, without
        sub-functions called from this function.
        """
        return _connect.CProfilerStatistics2_getNetAverageTime(self)

    def getGrossTotalTime(self) -> "int64_t":
        r"""
         Deprecated: use getTotalTime(ETimeType) instead.
        Returns the total gross time for function execution.
        Gross time is time spent for code inside function body, AND
        sub-functions called from this function.
        """
        return _connect.CProfilerStatistics2_getGrossTotalTime(self)

    def getGrossMinTime(self) -> "int64_t":
        r"""
         Deprecated: use getMinTime(ETimeType) instead.
        Returns the min gross time for function execution.
        Gross time is time spent for code inside function body, AND
        sub-functions called from this function.
        """
        return _connect.CProfilerStatistics2_getGrossMinTime(self)

    def getGrossMaxTime(self) -> "int64_t":
        r"""
         Deprecated: use getMaxTime(ETimeType) instead.
        Returns the max gross time for function execution.
        Gross time is time spent for code inside function body, AND
        sub-functions called from this function.
        """
        return _connect.CProfilerStatistics2_getGrossMaxTime(self)

    def getGrossAverageTime(self) -> "int64_t":
        r"""
         Deprecated: use getAverageTime(ETimeType) instead.
        Returns the average gross time for function execution.
        Gross time is time spent for code inside function body, AND
        sub-functions called from this function.
        """
        return _connect.CProfilerStatistics2_getGrossAverageTime(self)

    def getCallTotalTime(self) -> "int64_t":
        r"""
         Deprecated: use getTotalTime(ETimeType) instead.
        Returns the total call time for function execution.
        Call time is gross time plus time spent in other contexts
        (tasks, interrupts) between entry/exit of this function.
        """
        return _connect.CProfilerStatistics2_getCallTotalTime(self)

    def getCallMinTime(self) -> "int64_t":
        r"""
         Deprecated: use getMinTime(ETimeType) instead.
        Returns the min call time for function execution.
        Call time is gross time plus time spent in other contexts
        (tasks, interrupts) between entry/exit of this function.
        """
        return _connect.CProfilerStatistics2_getCallMinTime(self)

    def getCallMaxTime(self) -> "int64_t":
        r"""
         Deprecated: use getMaxTime(ETimeType) instead.
        Returns the max call time for function execution.
        Call time is gross time plus time spent in other contexts
        (tasks, interrupts) between entry/exit of this function.
        """
        return _connect.CProfilerStatistics2_getCallMaxTime(self)

    def getCallAverageTime(self) -> "int64_t":
        r"""
         Deprecated: use getAverageTime(ETimeType) instead.
        Returns the average call time for function execution.
        Call time is gross time plus time spent in other contexts
        (tasks, interrupts) between entry/exit of this function.
        """
        return _connect.CProfilerStatistics2_getCallAverageTime(self)

    def getPeriodMinTime(self) -> "int64_t":
        r"""
         Deprecated: use getMinTime(ETimeType) instead.
        Returns the minimum time between function invocation.
        """
        return _connect.CProfilerStatistics2_getPeriodMinTime(self)

    def getPeriodMaxTime(self) -> "int64_t":
        r"""
         Deprecated: use getMaxTime(ETimeType) instead.
        Returns the maximum time between function invocation.
        """
        return _connect.CProfilerStatistics2_getPeriodMaxTime(self)

    def getPeriodAverageTime(self) -> "int64_t":
        r"""
         Deprecated: use getAverageTime(ETimeType) instead.
        Returns the average time between function invocation.
        """
        return _connect.CProfilerStatistics2_getPeriodAverageTime(self)

    def getOutsideTotalTime(self) -> "int64_t":
        r"""
         Deprecated: use getTotalTime(ETimeType) instead.
        Returns the total outside time for function execution.
        Outside Time indicates the time spent outside the body of
        the function or a state - where the function state is Inactive.
        """
        return _connect.CProfilerStatistics2_getOutsideTotalTime(self)

    def getOutsideMinTime(self) -> "int64_t":
        r"""
         Deprecated: use getMinTime(ETimeType) instead.
        Returns the min outside time for function execution.
        Outside Time indicates the time spent outside the body of
        the function or a state - where the function state is Inactive.
        """
        return _connect.CProfilerStatistics2_getOutsideMinTime(self)

    def getOutsideMaxTime(self) -> "int64_t":
        r"""
         Deprecated: use getMaxTime(ETimeType) instead.
        Returns the max outside time for function execution.
        Outside Time indicates the time spent outside the body of
        the function or a state - where the function state is Inactive.
        """
        return _connect.CProfilerStatistics2_getOutsideMaxTime(self)

    def getOutsideAverageTime(self) -> "int64_t":
        r"""
         Deprecated: use getAverageTime(ETimeType) instead.
        Returns the average outside time for function execution.
        Outside Time indicates the time spent outside the body of
        the function or a state - where the function state is Inactive.
        """
        return _connect.CProfilerStatistics2_getOutsideAverageTime(self)

    def toString(self) -> "std::string":
        r""" Returns string representation of this object."""
        return _connect.CProfilerStatistics2_toString(self)

    def __init__(self):
        _connect.CProfilerStatistics2_swiginit(self, _connect.new_CProfilerStatistics2())
    __swig_destroy__ = _connect.delete_CProfilerStatistics2

# Register CProfilerStatistics2 in _connect:
_connect.CProfilerStatistics2_swigregister(CProfilerStatistics2)

UNDEF_EVENT_SOURCE = _connect.UNDEF_EVENT_SOURCE
class CProfilerTimeEvent(object):
    r"""
    This class contains information of one profiler time-line event.


    Python example: profilerData.py
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EEvAny = _connect.CProfilerTimeEvent_EEvAny
    r""" any event, this value can be used by iterator to return all events"""
    EEvWrite = _connect.CProfilerTimeEvent_EEvWrite
    r""" variable write events"""
    EEvSuspend = _connect.CProfilerTimeEvent_EEvSuspend
    r""" function/task/interrupt/... execution was suspended, for example function called another function"""
    EEvResume = _connect.CProfilerTimeEvent_EEvResume
    r""" function/task/interrupt/... execution was resumed, for example function call returned to the function which called it"""
    EEvEnter = _connect.CProfilerTimeEvent_EEvEnter
    r""" function/task/interrupt/... execution started"""
    EEvExit = _connect.CProfilerTimeEvent_EEvExit
    r""" function/task/interrupt/... execution ended"""

    def getAreaId(self) -> "isys::areaHandle_t":
        r""" Returns ID of the area, for which event was recorded."""
        return _connect.CProfilerTimeEvent_getAreaId(self)

    def getHandle(self) -> "DWORD":
        r"""
        Deprecated: since 9.12.295 (dec 2016). Use getAreaId()
        Returns ID of the area, for which event was recorded.
        """
        return _connect.CProfilerTimeEvent_getHandle(self)

    def getEventType(self) -> "isys::CProfilerTimeEvent::EEventType":
        r""" Returns event type."""
        return _connect.CProfilerTimeEvent_getEventType(self)

    def getValue(self) -> "int64_t":
        r"""
        Returns value of integer variable or digital AUX port.
        Always check value type of area, to interpret the number correctly, for
        example:


          area = profilerData.getArea(event.getHandle())
          valueType = area.getValueType()[0]
          if valueType == 'I':    # unsigned integer type
              print(timelineEvents[2].getValue() & 0xffffFFFFffffFFFF)
          elif valueType == 'S':  # signed integer type
              print(timelineEvents[2].getValue())
          elif valueType == 'F':  # floating point (double) type
              print(timelineEvents[2].getFloatValue())
        """
        return _connect.CProfilerTimeEvent_getValue(self)

    def getSignedValue(self) -> "int64_t":
        r"""
        Deprecated: use getValue().

        Returns value of integer variable or digital AUX port, 0 for functions.
        """
        return _connect.CProfilerTimeEvent_getSignedValue(self)

    def getFloatValue(self) -> "double":
        r"""
        Returns float value of float variables and analog AUX ports,
        0 for functions.
        """
        return _connect.CProfilerTimeEvent_getFloatValue(self)

    def getUnit(self) -> "std::string":
        r""" Returns unit of analog AUX port, empty string for all other areas."""
        return _connect.CProfilerTimeEvent_getUnit(self)

    def getTime(self) -> "int64_t":
        r""" Returns time of event."""
        return _connect.CProfilerTimeEvent_getTime(self)

    def getEventSource(self) -> "int":
        r""" Returns source of event or -1 if it does not exist for an event."""
        return _connect.CProfilerTimeEvent_getEventSource(self)

    def toString(self) -> "std::string":
        r""" Returns string representation of this object."""
        return _connect.CProfilerTimeEvent_toString(self)

    def __init__(self):
        _connect.CProfilerTimeEvent_swiginit(self, _connect.new_CProfilerTimeEvent())
    __swig_destroy__ = _connect.delete_CProfilerTimeEvent

# Register CProfilerTimeEvent in _connect:
_connect.CProfilerTimeEvent_swigregister(CProfilerTimeEvent)

class CProfilerTimelineIterator(object):
    r"""
    This class implements iterator for profiler time-line events. Only one
    iterator may iterate the events at a time, because the events are
    not stored in memory, but are sequentially parsed from a file.


    Python example: profilerData.py
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def hasNext(self) -> "bool":
        r"""
         Returns true, if there is at least one more time-line item available.


        Python example: profilerData.py
        """
        return _connect.CProfilerTimelineIterator_hasNext(self)

    def next(self) -> "isys::CProfilerTimeEvent":
        r"""
        Returns the next time-line item. Do not call this method if hasNext()
        returned ``false!``


        Python example: profilerData.py
        """
        return _connect.CProfilerTimelineIterator_next(self)
    __swig_destroy__ = _connect.delete_CProfilerTimelineIterator

# Register CProfilerTimelineIterator in _connect:
_connect.CProfilerTimelineIterator_swigregister(CProfilerTimelineIterator)

class CProfilerData2(object):
    r"""
    This class provides access to profiler measurements. It parses XML export
    file and returns the parsed data through method calls. Since profiler export
    files may be very large - hundreds of megabytes or even gigabytes, this
    class parses one time-line item per iterator function call.

    To get instance of this class call one of createInstance() factory methods.


    Profiler data consists of three groups:
    - areas contain information about item, which was profiled:
            function name, variable name, variable value,
            source line, ... Each area also has an identifier value called **handle**.
            Information for area is stored in class CProfilerArea2.
    - statistics group contains statistics (min, max, average) of measurements for areas.
                 In general each area has its statistics item. If there are more
                 execution contexts, statistics is measured for each of them.
                 Information for statistics is stored in class CProfilerStatistics2.
    - time-line group contains events for areas as they have happened during recording.
               Each time-line event contains time stamp and handle, among other data.
               The handle identifies the area, for which the event was recorded.
               Information for time-line events is stored in class CProfilerTimeEvent.

    Items in all groups are identified by handles.


    Python example with recording and simple data retrieval: profiler2Example.py


    Python example with detailed data retrieval: profilerData.py


    Python example converts data to Excel 2007 format: profilerData2XLSX.py
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def createInstance(*args) -> "CProfilerData2":
        r"""
        *Overload 1:*

        This factory method exports data to file, then parses statistics information,
        and returns initialized object.
        Use it, when you've just recorded data (have CProfilerController2 object
        available), and have not exported it yet. Note also that this method is not
        as flexible as direct export and
        method createInstance(fileName, isBinaryTimeline).


        **Note**: if ``exportFileName`` is relative, it is saved relative to
        winIDEA working directory, not the script working directory. This method
        tries to do its best to open the saved file, but if winIDEA is on remote
        host, it will fail. In such cases try to export the profiler data with
        CProfilerController2::exportData() and use
        the overloaded method ``createInstance(fileName)`` instead.

        :type profilerCtrl: :py:class:`CProfilerController2`
        :param profilerCtrl: profiler document controller which will be used to obtain data.

        :type exportFileName: string
        :param exportFileName: name of the file to export data to

        :param isTimeLine: if true, time-line is also exported. Note that this may
                              produce very large files in terms of gigabytes, so use it only
                              when needed.

        :type funcAreaNames: string
        :param funcAreaNames: contains function areas separated by spaces to be
                                 exported. If '*' is specified, all function areas are
                                 exported. If empty, no function areas are exported.

        :type dataAreaNames: string
        :param dataAreaNames: contains data areas separated by spaces to be
                                 exported. If '*' is specified, all data areas are exported.
                                 If empty, no data areas are exported.

        Python example: profilerData.py

        |

        *Overload 2:*

        See also: createInstance(isys::CProfilerController2SPtr, const std::string &, bool,
                            const std::string &, const std::string &) for description.
        :type exportPNameMode: int
        :param exportPNameMode: defines if download file name is appended to area names or not

        |

        *Overload 3:*

        This factory method parses statistic information from profiler XML
        export file and returns initialized object.

        :type fileName: string
        :param fileName: name of the file with profiler XML export. If you use
                            relative file path, be aware that script working directory is
                            used as a starting point, not winIDEA workspace directory.

        :type isBinaryTimeline: boolean, optional
        :param isBinaryTimeline: if true, time-line data is read from binary file.
                                    Set this parameter to true when export file
                                    was created with
                                    CProfilerXMLExportFormat::setTimelineBinary(true).

        Python example: profilerData.py

        |

        *Overload 4:*

        This factory method parses statistic information from profiler XML
        export file and returns initialized object.

        :type fileName: string
        :param fileName: name of the file with profiler XML export. If you use
                            relative file path, be aware that script working directory is
                            used as a starting point, not winIDEA workspace directory.

        :param isBinaryTimeline: if true, time-line data is read from binary file.
                                    Set this parameter to true when export file
                                    was created with
                                    CProfilerXMLExportFormat::setTimelineBinary(true).

        Python example: profilerData.py
        """
        return _connect.CProfilerData2_createInstance(*args)

    def getParserWarnings(self) -> "std::string":
        r"""
        This method returns warnings related to input XML document. If there
        were no warnings, an empty string is returned. Always call this method
        after createInstance(). If XML document is made with newer version of winIDEA
        than SDK, it will warn you about possible missing info.

        Python example: profilerData.py
        """
        return _connect.CProfilerData2_getParserWarnings(self)

    def closeParser(self) -> "void":
        r"""
        This method releases parser resources and closes XML file. It is
        recommended to call this method always after CProfilerTimelineIterator
        is no longer used. It must be called always when there is time-line data
        available, but we didn't fetch all time-line items
        (CProfilerTimelineIterator.hasNext() did not return false). Otherwise the
        XML file remains opened and can not be ovewritten or deleted until the
        application exits.

        Python example: profilerData.py
        """
        return _connect.CProfilerData2_closeParser(self)

    def getBinTimelineEventSize(self) -> "uint64_t":
        r"""
        Returns number of bytes for one event in profiler binary timeline.
        This value can be used to get the number of events in timeline, if
        you know the size of binary timeline file.
        """
        return _connect.CProfilerData2_getBinTimelineEventSize(self)

    def getBinTimelineFileSize(self) -> "size_t":
        r"""
        Returns size of file containing binary timeline. If timeline
        is defined in XML, not in binary file, IllegalStateException is
        thrown.
        """
        return _connect.CProfilerData2_getBinTimelineFileSize(self)

    def getTotalSessionTimeNs(self) -> "int64_t":
        r"""Returns total session time in nanoseconds."""
        return _connect.CProfilerData2_getTotalSessionTimeNs(self)

    def getContextIterator(self) -> "isys::CProfilerContextIterator":
        r"""
        Deprecated: this method will be removed or changed in one of
                    future releases

        Returns iterator for contexts. Use this method to get all recorded
        contexts (tasks, threads, ISRs, ...).

        Python example: profilerData.py
        """
        return _connect.CProfilerData2_getContextIterator(self)

    def getAreaIterator(self, areaType: "isys::CProfilerArea2::EAreaType") -> "isys::CProfilerAreaIterator":
        r"""
        Returns iterator for areas. Use this method to get all recorded areas.

        Python example: profilerData.py
        """
        return _connect.CProfilerData2_getAreaIterator(self, areaType)

    def hasArea(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Returns true, if the given area exists in profiler recording.

        :type areaQName: string
        :param areaQName: qualified area name consisting of path and name.

        Python example: profilerData.py

        |

        *Overload 2:*

        Deprecated: Use hasArea(string areaQName) instead.

        Returns true, if the given area exists in profiler recording.

        :type areaType: int
        :param areaType: area type
        :type areaName: string
        :param areaName: function, variable or AUX name with full path.
                            If area type
                            is EStateVariables, or EStateAUX, then areaName
                            is taken from type definition in recording. If
                            the definition is not set, name of state var
                            is empty and we can not search for it.
                            Use getArea(EAreaType, std::string, DWORD)
                            in such case. See also
                            CProfilerController2::addStateVariable().
        """
        return _connect.CProfilerData2_hasArea(self, *args)

    def getArea(self, *args) -> "isys::CProfilerArea2":
        r"""
        *Overload 1:*

        Returns profiler area for the given id.

        Python example: profilerData.py

        |

        *Overload 2:*

        Returns profiler area for the given qualified area name.

        :type areaQName: string
        :param areaQName: qualified area name consisting of path and name.

        Python example: profilerData.py

        |

        *Overload 3:*

        Deprecated: if there is more than one area with the same name, this
        method returns the first one only. Use getArea(string areaQName) instead.

        Returns area of the given type and with the given name. If
        ``areaType`` is
        EStateVariables or EStateAUX``, then
        area of the first value detected is returned.

        :type areaType: int
        :param areaType: area type
        :type areaName: string
        :param areaName: function, variable or AUX name with full path.
                            If area type
                            is EStateVariables, or EStateAUX, then areaName
                            is taken from type definition in recording. If
                            the definition is not set, name of state var
                            is empty and we can not search for it.
                            Use getArea(EAreaType, std::string, DWORD)
                            in such case. See also
                            CProfilerController2::addStateVariable().

        Python example: profilerData.py

        |

        *Overload 4:*

        Returns profiler state area for the given type, parent
        name and state value.

        :type areaType: int
        :param areaType: may be EStateVariables, or EStateAUX

        :type areaPath: string
        :param areaPath: path to area without area name, for example
                            name of the state variable or function.

        :param value: value of the state variable or function line number

        Python example: profilerData.py

        |

        *Overload 5:*

        Deprecated: if there is more than one area with the same name, this
        method returns the first one only. Use getArea(string areaQName) instead.

        Returns profiler state area for the given type, parent name and state name.

        :type areaType: int
        :param areaType: may be EStateVariables, or EStateAUX

        :type areaPath: string
        :param areaPath: path to area without area name, for example
                            name of the state variable or function.

        :type stateAreaName: string
        :param stateAreaName: name of enum state value or function line number source code

        Python example: profilerData.py

        |

        *Overload 6:*

        Returns state area for the given value.

        :type areaPath: string
        :param areaPath: path to area without area name, for example
                            name of the state variable or function.
        :type valueOrLineNumber: int
        :param valueOrLineNumber: value for state variables, line number for lines

        Python example: profilerData.py
        """
        return _connect.CProfilerData2_getArea(self, *args)

    def hasStatisticsForArea(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Returns true, if statistics for the given area exists.

        Python example: profilerData.py

        |

        *Overload 2:*

        Returns true, if statistics for the given area exists.

        :type areaQName: string
        :param areaQName: qualified area name consisting of path and name.

        Python example: profilerData.py

        |

        *Overload 3:*

        Deprecated: Use hasStatisticsForArea(string areaQName) instead.

        Returns true, if statistics for the given area exists.

        :type areaType: int
        :param areaType: area type
        :type areaName: string
        :param areaName: qualified area name, which includes path
                            and area name (for example name of function or variable).

        Python example: profilerData.py
        """
        return _connect.CProfilerData2_hasStatisticsForArea(self, *args)

    def hasStatisticsForStateArea(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Deprecated: use hasStatisticsForStateArea(const std::string &areaPath,
                                                  int64_t value)

        Returns true, if statistics for the given state area exists.

        :type areaType: int
        :param areaType: type of area
        :type parentAreaName: string
        :param parentAreaName: name of parent area
        :type value: int
        :param value: state value

        Python example: profilerData.py

        |

        *Overload 2:*

        Returns true, if statistics for the given state area exists.

        :type areaPath: string
        :param areaPath: path to area, without area name
        :type value: int
        :param value: state value

        Python example: profilerData.py
        """
        return _connect.CProfilerData2_hasStatisticsForStateArea(self, *args)

    def getStatistics(self, *args) -> "isys::CProfilerStatistics2":
        r"""
        *Overload 1:*

        Returns statistics for the specified area Id. If it is function
        area, then this method returns statistics for context 'Neutral',
        if it exists. If it does not exist, an exception is thrown.
        For other contexts use method getStatistics(id, contextName).

        :type id: int
        :param id: area ID. Use ``getArea(type, funcOrVarName).getAreaId()``
                      to get the ID.

        Python example: profilerData.py

        |

        *Overload 2:*

        Returns statistics for the specified qualified area name.

        :type areaQName: string
        :param areaQName: qualified area name consisting of path and name.

        Python example: profilerData.py

        |

        *Overload 3:*

        Deprecated: if there is more than one area with the same name, this
        method returns stats for the first one only.
        Use getStatistics(string areaQName) instead.

        Returns statistics for the specified function or variable area.
        This is a convenience method - for
        best performance use ``getStatistics(id)``.

        :type areaType: int
        :param areaType: area type
        :type areaName: string
        :param areaName: qualified area name, which includes path
                            and area name (for example name of function or variable).

        Python example: profilerData.py

        |

        *Overload 4:*

        Deprecated: use getStatistics(const std::string &areaPath, int64_t value);
                    instead.
        Returns statistics for the specified state area. This is a
        convenience method - for best performance use
        ``getStatistics(id)``.

        :type areaType: int
        :param areaType: are type may be EStateVariables, or EStateAUX
        :type parentAreaName: string
        :param parentAreaName: path to area without area name
        :type value: int
        :param value: value of the state variable to get statistics for

        Python example: profilerData.py

        |

        *Overload 5:*

        Returns statistics for the specified state area. This is a
        convenience method - for best performance use
        ``getStatistics(id)``.

        :type areaPath: string
        :param areaPath: path to area without area name
        :type value: int
        :param value: value of the state variable to get statistics for

        Python example: profilerData.py
        """
        return _connect.CProfilerData2_getStatistics(self, *args)

    def hasStatisticsForFunction(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Returns true, if the specified area was recorded in
        the specified context.

        :type id: int
        :param id: area ID. Use ``getArea(type, funcOrVarName).getAreaId()``
                      to get the ID.
        :type contextName: string
        :param contextName: name of the context.

        :raises: IllegalArgumentException if area with the given ID does not exist.

        Python example: profilerData.py

        |

        *Overload 2:*

        Returns true, if the specified area was recorded in the specified
        context.

        :type areaType: int
        :param areaType: area type must be EFunctions. EFunctionLines is
                            deprecated since 9.17.36.
        :type areaName: string
        :param areaName: name of function
        :type contextName: string
        :param contextName: name of the context.

        :raises: IllegalArgumentException if area with the given type and name
                                            does not exist.

        Python example: profilerData.py
        """
        return _connect.CProfilerData2_hasStatisticsForFunction(self, *args)

    def getStatisticsForFunction(self, *args) -> "isys::CProfilerStatistics2":
        r"""
        *Overload 1:*

        Returns statistics for the specified function area Id and context.
        Use this method when profiler data was exported with context set
        to 'All' or 'Current' (see CProfilerExportConfig::setContextScope()).
        If profiler data was exported with context 'Neutral', then specify
        'Neutral' as context name or use method getStatistics(id).

        :type id: int
        :param id: area ID. Use ``getArea(type, funcOrVarName).getAreaId()``
                      to get the ID.
        :type contextName: string
        :param contextName: name of the context.

        Python example: profilerData.py

        |

        *Overload 2:*

        Returns statistics for the specified function area and context.
        Use this method when profiler data was exported with context set
        to 'All' or 'Current' (see CProfilerExportConfig::setContextScope()).
        If profiler data was exported with context 'Neutral', then specify
        'Neutral' as context name or use method getStatistics(id).

        :type areaType: int
        :param areaType: area type must be EFunctions. EFunctionLines is
                            deprecated since 9.17.36.
        :type areaName: string
        :param areaName: name of function
        :type contextName: string
        :param contextName: name of the context.

        Python example: profilerData.py
        """
        return _connect.CProfilerData2_getStatisticsForFunction(self, *args)

    def getContexts(self, contexts: "StrVector") -> "void":
        r"""
        Fills the given list with all contexts found in profiler results.

        :type contexts: :py:class:`StrVector`
        :param contexts: vector of strings to receive contexts.

        Python example: profilerData.py
        """
        return _connect.CProfilerData2_getContexts(self, contexts)

    def getTimelineIterator(self, *args) -> "isys::CProfilerTimelineIterator":
        r"""
        *Overload 1:*

        Returns iterator, which will iterate all time-line events of the given type.

        Python example: profilerData.py

        |

        *Overload 2:*

        Returns iterator, which will iterate time-line events for area with the given handle.

        Python example: profilerData.py

        |

        *Overload 3:*

        Returns iterator, which will iterate time-line events for state
        area with the given handle and value.

        Python example: profilerData.py
        """
        return _connect.CProfilerData2_getTimelineIterator(self, *args)

    def getCallStackStatistics(self, *args) -> "void":
        return _connect.CProfilerData2_getCallStackStatistics(self, *args)

    def getCallStackStatisticsForFunction(self, handle: "isys::areaHandle_t", contextName: "std::string const &", callStack: "std::string const &") -> "void":
        return _connect.CProfilerData2_getCallStackStatisticsForFunction(self, handle, contextName, callStack)

    def getCallStackStatisticsIter(self, *args) -> "void":
        return _connect.CProfilerData2_getCallStackStatisticsIter(self, *args)

    def getCallStackStatisticsIterForFunction(self, handle: "isys::areaHandle_t", contextName: "std::string const &") -> "void":
        return _connect.CProfilerData2_getCallStackStatisticsIterForFunction(self, handle, contextName)
    __swig_destroy__ = _connect.delete_CProfilerData2

# Register CProfilerData2 in _connect:
_connect.CProfilerData2_swigregister(CProfilerData2)

def CProfilerData2_createInstance(*args) -> "CProfilerData2":
    r"""
    *Overload 1:*

    This factory method exports data to file, then parses statistics information,
    and returns initialized object.
    Use it, when you've just recorded data (have CProfilerController2 object
    available), and have not exported it yet. Note also that this method is not
    as flexible as direct export and
    method createInstance(fileName, isBinaryTimeline).


    **Note**: if ``exportFileName`` is relative, it is saved relative to
    winIDEA working directory, not the script working directory. This method
    tries to do its best to open the saved file, but if winIDEA is on remote
    host, it will fail. In such cases try to export the profiler data with
    CProfilerController2::exportData() and use
    the overloaded method ``createInstance(fileName)`` instead.

    :type profilerCtrl: :py:class:`CProfilerController2`
    :param profilerCtrl: profiler document controller which will be used to obtain data.

    :type exportFileName: string
    :param exportFileName: name of the file to export data to

    :param isTimeLine: if true, time-line is also exported. Note that this may
                          produce very large files in terms of gigabytes, so use it only
                          when needed.

    :type funcAreaNames: string
    :param funcAreaNames: contains function areas separated by spaces to be
                             exported. If '*' is specified, all function areas are
                             exported. If empty, no function areas are exported.

    :type dataAreaNames: string
    :param dataAreaNames: contains data areas separated by spaces to be
                             exported. If '*' is specified, all data areas are exported.
                             If empty, no data areas are exported.

    Python example: profilerData.py

    |

    *Overload 2:*

    See also: createInstance(isys::CProfilerController2SPtr, const std::string &, bool,
                        const std::string &, const std::string &) for description.
    :type exportPNameMode: int
    :param exportPNameMode: defines if download file name is appended to area names or not

    |

    *Overload 3:*

    This factory method parses statistic information from profiler XML
    export file and returns initialized object.

    :type fileName: string
    :param fileName: name of the file with profiler XML export. If you use
                        relative file path, be aware that script working directory is
                        used as a starting point, not winIDEA workspace directory.

    :type isBinaryTimeline: boolean, optional
    :param isBinaryTimeline: if true, time-line data is read from binary file.
                                Set this parameter to true when export file
                                was created with
                                CProfilerXMLExportFormat::setTimelineBinary(true).

    Python example: profilerData.py

    |

    *Overload 4:*

    This factory method parses statistic information from profiler XML
    export file and returns initialized object.

    :type fileName: string
    :param fileName: name of the file with profiler XML export. If you use
                        relative file path, be aware that script working directory is
                        used as a starting point, not winIDEA workspace directory.

    :param isBinaryTimeline: if true, time-line data is read from binary file.
                                Set this parameter to true when export file
                                was created with
                                CProfilerXMLExportFormat::setTimelineBinary(true).

    Python example: profilerData.py
    """
    return _connect.CProfilerData2_createInstance(*args)

class CProfilerFormatBase(object):
    r"""
    This is abstract base class for profiler export format containers.
    Expand inheritance diagram below and click derived classes to see
    formatting options for each of available formats.

    See also: CProfilerExportConfig::setFormatter()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    EFmtXML = _connect.CProfilerFormatBase_EFmtXML
    r""" export as XML"""
    EFmtText1 = _connect.CProfilerFormatBase_EFmtText1
    r"""
    export as formatted text, see options with
    'ProfilerExport.Export.Text1.*' in URL
    """
    EFmtBTF = _connect.CProfilerFormatBase_EFmtBTF
    r""" export as BTF"""
    EFmtMDF = _connect.CProfilerFormatBase_EFmtMDF
    r""" export as MDF"""

    def getExportFormat(self) -> "isys::CProfilerFormatBase::EExportFormat":
        r""" Returns profiler export format."""
        return _connect.CProfilerFormatBase_getExportFormat(self)

    def getExportFormatAsStr(self) -> "std::string":
        r"""
        Returns string containing export format, which can be used for
        setting of option
        '/Document/<file name>/ProfilerExport.Scope.Type'

        See also: setAreaScope()
        """
        return _connect.CProfilerFormatBase_getExportFormatAsStr(self)

    def setOptions(self, ide: "CIDEController", docFileName: "std::string const &") -> "void":
        r""" Sets export configuration options in winIDEA."""
        return _connect.CProfilerFormatBase_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CProfilerFormatBase

# Register CProfilerFormatBase in _connect:
_connect.CProfilerFormatBase_swigregister(CProfilerFormatBase)

class CProfilerTextExportFormat(CProfilerFormatBase):
    r"""This class configures format of Text export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Creates object with default values."""
        _connect.CProfilerTextExportFormat_swiginit(self, _connect.new_CProfilerTextExportFormat())

    def setOptions(self, ide: "CIDEController", docFileName: "std::string const &") -> "void":
        r"""Writes options to winIDEA."""
        return _connect.CProfilerTextExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CProfilerTextExportFormat

# Register CProfilerTextExportFormat in _connect:
_connect.CProfilerTextExportFormat_swigregister(CProfilerTextExportFormat)

class CProfilerText1ExportFormat(CProfilerFormatBase):
    r"""
    This class configures format of Text1 export. It does not have
    methods for setting specific options, but two generic methods,
    which can be used to set/get ant option at URL
    ``/Document/``<docName>/ProfilerExport.Export.Text1.*

    See winIDEA menu ``Help | Display Option ...``
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Creates object with default values."""
        _connect.CProfilerText1ExportFormat_swiginit(self, _connect.new_CProfilerText1ExportFormat())

    def setOption(self, profiler: "isys::CProfilerController2SPtr &", option: "std::string const &", value: "std::string const &") -> "isys::CProfilerText1ExportFormat &":
        r"""
        Sets option specific to this export format. Option is set
        immediately in this method - there is no need to call method
        setOptions().

        :type profiler: :py:class:`CProfilerController2`
        :param profiler: opened profiler document controller

        :type option: string
        :param option: option URL identifying Text1 export option,
                          for example: 'FileHeader'. The URL prefix is
                          automatically prepended by this method. See
                          winIDEA Help | Display Option ..., document options.
        """
        return _connect.CProfilerText1ExportFormat_setOption(self, profiler, option, value)

    def getOption(self, profiler: "isys::CProfilerController2SPtr &", option: "std::string const &") -> "std::string":
        r""" Returns value of the given option from winIDEA settings."""
        return _connect.CProfilerText1ExportFormat_getOption(self, profiler, option)

    def setOptions(self, ide: "CIDEController", docFileName: "std::string const &") -> "void":
        r"""
        Writes options to winIDEA. This method is automatically called
        by CTraceController::exportData(). This method sets only configuration
        for Text format, but does not set trace export format to Text (modifies
        only options '/Document/<fname>/TraceExport.Text.*').
        """
        return _connect.CProfilerText1ExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CProfilerText1ExportFormat

# Register CProfilerText1ExportFormat in _connect:
_connect.CProfilerText1ExportFormat_swigregister(CProfilerText1ExportFormat)

class CProfilerCSVExportFormat(CProfilerFormatBase):
    r"""This class configures format of CSV export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Creates object with default values."""
        _connect.CProfilerCSVExportFormat_swiginit(self, _connect.new_CProfilerCSVExportFormat())

    def setDelimiter(self, delimiter: "std::string const &") -> "isys::CProfilerCSVExportFormat &":
        r""" Sets CSV field delimiter. Default: ','."""
        return _connect.CProfilerCSVExportFormat_setDelimiter(self, delimiter)

    def getDelimiter(self) -> "std::string":
        r""" Returns CSV field delimiter."""
        return _connect.CProfilerCSVExportFormat_getDelimiter(self)

    def setOptions(self, ide: "CIDEController", docFileName: "std::string const &") -> "void":
        r"""Writes options to winIDEA."""
        return _connect.CProfilerCSVExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CProfilerCSVExportFormat

# Register CProfilerCSVExportFormat in _connect:
_connect.CProfilerCSVExportFormat_swigregister(CProfilerCSVExportFormat)

class CProfilerXMLExportFormat(CProfilerFormatBase):
    r"""This class configures format of XML export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Creates object with default values."""
        _connect.CProfilerXMLExportFormat_swiginit(self, _connect.new_CProfilerXMLExportFormat())

    def setTimelineBinary(self, isTimelineBinary: "bool") -> "isys::CProfilerXMLExportFormat &":
        r"""
        If set to ``true``, and time-line export is enabled (see setSaveTimeline()),
        profiler areas and statistics are exported in
        XML format, while time-line is exported in separate file in
        binary format. For small amounts of data, and when human
        readability or printing is desired, leave this at default
        value (``false)``. For long recordings the binary export is
        much faster and files are much smaller.
        Binary file name is
        <origFileName>.BIN, for example ``myExport.xml.BIN``.
        Default: false.
        """
        return _connect.CProfilerXMLExportFormat_setTimelineBinary(self, isTimelineBinary)

    def setUseIndent(self, isUseIndent: "bool") -> "isys::CProfilerXMLExportFormat &":
        r"""
        If set to true, XML file is produced with indented elements.
        This improves readability, but produces about 20% larger files.
        If files will be processed by tools, leave this setting at the
        default value.
        Default: false.
        """
        return _connect.CProfilerXMLExportFormat_setUseIndent(self, isUseIndent)

    def isTimelineBinary(self) -> "bool":
        r"""
        Returns true, if time-line will be exported in binary format.
        See also: setTimelineBinary()
        """
        return _connect.CProfilerXMLExportFormat_isTimelineBinary(self)

    def isUseIndent(self) -> "bool":
        r"""
        Returns true, if indentation will be used in XML export.
        See also: setUseIndent()
        """
        return _connect.CProfilerXMLExportFormat_isUseIndent(self)

    def setOptions(self, ide: "CIDEController", docFileName: "std::string const &") -> "void":
        r"""Writes options to winIDEA."""
        return _connect.CProfilerXMLExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CProfilerXMLExportFormat

# Register CProfilerXMLExportFormat in _connect:
_connect.CProfilerXMLExportFormat_swigregister(CProfilerXMLExportFormat)

class CProfilerBTFExportFormat(CProfilerFormatBase):
    r"""This class configures format of BTF export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Creates object with default values."""
        _connect.CProfilerBTFExportFormat_swiginit(self, _connect.new_CProfilerBTFExportFormat())

    def setOptions(self, ide: "CIDEController", docFileName: "std::string const &") -> "void":
        r"""Writes options to winIDEA."""
        return _connect.CProfilerBTFExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CProfilerBTFExportFormat

# Register CProfilerBTFExportFormat in _connect:
_connect.CProfilerBTFExportFormat_swigregister(CProfilerBTFExportFormat)

class CProfilerMDFExportFormat(CProfilerFormatBase):
    r"""This class configures format of MDF export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Creates object with default values."""
        _connect.CProfilerMDFExportFormat_swiginit(self, _connect.new_CProfilerMDFExportFormat())

    def setOptions(self, ide: "CIDEController", docFileName: "std::string const &") -> "void":
        r"""Writes options to winIDEA."""
        return _connect.CProfilerMDFExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CProfilerMDFExportFormat

# Register CProfilerMDFExportFormat in _connect:
_connect.CProfilerMDFExportFormat_swigregister(CProfilerMDFExportFormat)

class CProfilerExportConfig(object):
    r"""
    This class contains configuration for export of profiler
    measurements. All setters return reference to ``this``, so
    we can chain calls to set values, for example:


    cfg = CProfilerExportFormat().setFileName('profilerResult.xml')
                                 .setTimeScope(CProfilerExportFormat::ETimeAll)
                                 .setAreaScope(CProfilerExportFormat::EAreaAll);
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EContextAll = _connect.CProfilerExportConfig_EContextAll
    r"""
    functions are exported for all contexts.
    Statistics contains information about time spent
    in each context (IRQ, task).
    """
    EContextNeutral = _connect.CProfilerExportConfig_EContextNeutral
    r"""
    functions are exported without context info,
    times in statistics are sumed for all contexts
    """
    EContextCurrent = _connect.CProfilerExportConfig_EContextCurrent
    r"""
    export only context specified with
    call setContextFilter().
    """
    EAreaAll = _connect.CProfilerExportConfig_EAreaAll
    r""" all areas are exported"""
    EAreaFilter = _connect.CProfilerExportConfig_EAreaFilter
    r"""
    export only areas specified with calls
    to setFunctionsFilter(), setVariablesFilter(),
    and setAUXFilter().
    """
    ETimeAll = _connect.CProfilerExportConfig_ETimeAll
    r""" export recorded samples regardless of timestamp"""
    ETimeBetweenMarkers = _connect.CProfilerExportConfig_ETimeBetweenMarkers
    r"""
    export only samples between times specified
    with call to setTimeFilter()
    """
    EPNameAuto = _connect.CProfilerExportConfig_EPNameAuto
    r"""
    partition name is appended only if there is more than
    one download file (partition) in the project
    """
    EPNameAlways = _connect.CProfilerExportConfig_EPNameAlways
    r""" partition name is appended always"""
    EPNameNever = _connect.CProfilerExportConfig_EPNameNever
    r""" partition name is never appended"""
    EPNameConfigName = _connect.CProfilerExportConfig_EPNameConfigName

    def __init__(self):
        r"""
        Constructs object with default settings, as described with each method.

        Python example: profiler2Example.py
        """
        _connect.CProfilerExportConfig_swiginit(self, _connect.new_CProfilerExportConfig())

    def setFileName(self, fileName: "std::string const &") -> "isys::CProfilerExportConfig &":
        r"""
        Sets the name of the exported file. If this method is not called, or
        ``fileName`` is empty string, then the existing export file name in
        winIDEA is used.

        Python example: profiler2Example.py
        """
        return _connect.CProfilerExportConfig_setFileName(self, fileName)

    def setFormatter(self, formatter: "isys::CProfilerFormatBaseSPtr &") -> "isys::CProfilerExportConfig &":
        r"""
        Sets formatter object, which configures export file format. If this
        method is not called, XML formatter with default settings is used.
        Example:


            formatter = ic.CProfilerXMLExportFormat()
            formatter.setUseIndent(False).setTimelineBinary(False)
            exportCfg.setFormatter(formatter)


        See also: CProfilerFormatBase
        """
        return _connect.CProfilerExportConfig_setFormatter(self, formatter)

    def setAreaScope(self, areaScope: "isys::CProfilerExportConfig::EAreaScope") -> "isys::CProfilerExportConfig &":
        r"""
        Sets the area scope (default: EAreaAll).

        Python example: profiler2Example.py
        """
        return _connect.CProfilerExportConfig_setAreaScope(self, areaScope)

    def setExportActiveAreasOnly(self, isExportActiveAreasOnly: "bool") -> "isys::CProfilerExportConfig &":
        r"""
        Sets areas to export.

        :type isExportActiveAreasOnly: boolean
        :param isExportActiveAreasOnly: if true, only areas with recorded activity are exported,
                                           otherwise all configured areas are exported.
        """
        return _connect.CProfilerExportConfig_setExportActiveAreasOnly(self, isExportActiveAreasOnly)

    def setAreaExportSections(self, *args) -> "isys::CProfilerExportConfig &":
        r"""
        *Overload 1:*

        If area scope is set to ``EAreaAll`` (see method setAreaScope()),
        then this method defines better granularity, so that some
        types of areas are not exported. If this method is not called,
        all flags are set to ``true`` by default.

        :type isExportFunctions: boolean
        :param isExportFunctions: if true, function areas are exported.
        :type isExportData: boolean
        :param isExportData: if true, data areas are exported
        :type isExportAUX: boolean
        :param isExportAUX: if true, AUX data is exported

        |

        *Overload 2:*

        Deprecated: since winIDEA 9.12.36 line information is no longer available. If
        'isExportLines' is set to true, an exception is thrown. Use overload
        setAreaExportSections(bool, bool, bool) instead.
        """
        return _connect.CProfilerExportConfig_setAreaExportSections(self, *args)

    def setTimeScope(self, timeScope: "isys::CProfilerExportConfig::ETimeScope") -> "isys::CProfilerExportConfig &":
        r""" Sets the time scope (default: ETimeAll)."""
        return _connect.CProfilerExportConfig_setTimeScope(self, timeScope)

    def setFunctionsFilter(self, namesOfFunctions: "std::string const &") -> "isys::CProfilerExportConfig &":
        r"""
        Sets names of functions for which profiler measurements should be
        exported (default: empty). This setting is used only if
        ara scope is set to EAreaFilter (see setAreaScope()).

        :type namesOfFunctions: string
        :param namesOfFunctions: names of functions for which profiler measurements should be
                                    exported to file. Functions names should be separated by spaces,
                                    for example ``'func1 func2 func3'``

        Python example: profiler2Example.py
        """
        return _connect.CProfilerExportConfig_setFunctionsFilter(self, namesOfFunctions)

    def setVariablesFilter(self, namesOfVariables: "std::string const &") -> "isys::CProfilerExportConfig &":
        r"""
        Sets names of variables for which profiler measurements should be
        exported  (default: empty). This setting is used only if
        ara scope is set to EAreaFilter (see setAreaScope()).

        :type namesOfVariables: string
        :param namesOfVariables: names of variables for which
                                    profiler measurements should be
                                    exported to file. Names of
                                    variables should be separated by
                                    spaces, for example ``'var1
                                    var2 var3'``
        """
        return _connect.CProfilerExportConfig_setVariablesFilter(self, namesOfVariables)

    def setAUXFilter(self, namesOfIOPorts: "std::string const &") -> "isys::CProfilerExportConfig &":
        r"""
        Sets names of IO ports for which profiler measurements should be
        exported (default: empty). This setting is used only if
        ara scope is set to EAreaFilter (see setAreaScope()).

        :type namesOfIOPorts: string
        :param namesOfIOPorts: names of IO ports from IO module for which
                                  profiler measurements should be
                                  exported to file. Names of
                                  the ports should be separated by
                                  spaces, for example ``'port1
                                  port2 port3'``
        """
        return _connect.CProfilerExportConfig_setAUXFilter(self, namesOfIOPorts)

    def setTimeFilter(self, startTime: "int64_t", endTime: "int64_t") -> "isys::CProfilerExportConfig &":
        r"""
        Sets time-frame for which profiler measurements should be exported
        (default: both times are set to 0, but are not used if
        setTimeScope(ETimeBetweenMarkers) is not called). 

        To export measurements before trigger, times must be negative. Trigger
        has timestamp 0.

        :type startTime: int
        :param startTime: start of measurements to export relative to trigger

        :type endTime: int
        :param endTime: end of measurements to export. If greater than the timestamp
                           of the last sample, all samples from ``startTime`` to the end
                           are exported.
        """
        return _connect.CProfilerExportConfig_setTimeFilter(self, startTime, endTime)

    def setContextFilter(self, contextToExport: "std::string const &") -> "isys::CProfilerExportConfig &":
        r"""
        Sets context for which profiler measurements should be exported
        (default: empty). Only one context may be specified at a time. 


        :type contextToExport: string
        :param contextToExport: name of the context to export, for example
            ``'TSK: InitTask'``, or ``'IRQ: Timer'``. Prefix
            ``TSK`` should be used for tasks, ``IRQ`` for interrupts.
        """
        return _connect.CProfilerExportConfig_setContextFilter(self, contextToExport)

    def setLaunchViewer(self, isLaunchViewer: "bool") -> "isys::CProfilerExportConfig &":
        r"""
        If set to ``true``, launches the system default
        viewer for the specified document type after export, for example
        notepad for text documents (default: false).
        """
        return _connect.CProfilerExportConfig_setLaunchViewer(self, isLaunchViewer)

    def setSaveStatistics(self, isSaveStatistics: "bool") -> "isys::CProfilerExportConfig &":
        r""" If set to ``true``, statistics data is exported to file (default: true)."""
        return _connect.CProfilerExportConfig_setSaveStatistics(self, isSaveStatistics)

    def setSaveInfo(self, isSaveInfo: "bool") -> "isys::CProfilerExportConfig &":
        r""" Deprecated: 9.17.81, Sept. 2018. Had no effect in the past, so there is no replacement."""
        return _connect.CProfilerExportConfig_setSaveInfo(self, isSaveInfo)

    def setSaveTimeline(self, isSaveTimeline: "bool") -> "isys::CProfilerExportConfig &":
        r"""
        If set to ``true``, time-line data is exported (default: false).

        Python example: profiler2Example.py
        """
        return _connect.CProfilerExportConfig_setSaveTimeline(self, isSaveTimeline)

    def setContextScope(self, saveContext: "isys::CProfilerExportConfig::EContextScope") -> "isys::CProfilerExportConfig &":
        r""" Sets context to be exported to file (default: EContextNeutral)."""
        return _connect.CProfilerExportConfig_setContextScope(self, saveContext)

    def setExportPartitionNameMode(self, exportPartNameMode: "isys::CProfilerExportConfig::EExportPartitionNameMode") -> "isys::CProfilerExportConfig &":
        r""" Sets when download file name should be appended to exported area names."""
        return _connect.CProfilerExportConfig_setExportPartitionNameMode(self, exportPartNameMode)

    def getFileName(self) -> "std::string":
        r""" Returns profiler file name."""
        return _connect.CProfilerExportConfig_getFileName(self)

    def getAreaScope(self) -> "isys::CProfilerExportConfig::EAreaScope":
        r""" Returns profiler area scope."""
        return _connect.CProfilerExportConfig_getAreaScope(self)

    def isExportFunctions(self) -> "bool":
        r"""
        Returns export flag for functions area.

        See also: setAreaExportSections()
        """
        return _connect.CProfilerExportConfig_isExportFunctions(self)

    def isExportLines(self) -> "bool":
        r"""
        Deprecated: since 9.12.36 profiler function lines are no longer supported.
        Always returns false.
        """
        return _connect.CProfilerExportConfig_isExportLines(self)

    def isExportData(self) -> "bool":
        r"""
        Returns export flag for data area.

        See also: setAreaExportSections()
        """
        return _connect.CProfilerExportConfig_isExportData(self)

    def isExportAUX(self) -> "bool":
        r"""
        Returns export flag for AUX area.

        See also: setAreaExportSections()
        """
        return _connect.CProfilerExportConfig_isExportAUX(self)

    def isExportActiveAreasOnly(self) -> "bool":
        r"""
        Returns true, if only areas with recorded activity will be exported.
        Returns false, if all configured areas will be exported.

        See also: setExportActiveAreasOnly()
        """
        return _connect.CProfilerExportConfig_isExportActiveAreasOnly(self)

    def getTimeScope(self) -> "isys::CProfilerExportConfig::ETimeScope":
        r""" Returns profiler time scope."""
        return _connect.CProfilerExportConfig_getTimeScope(self)

    def getFunctionsFilter(self) -> "std::string":
        r"""
        Returns a list of functions to be exported. Function names are
        separated by spaces.
        """
        return _connect.CProfilerExportConfig_getFunctionsFilter(self)

    def getVariablesFilter(self) -> "std::string":
        r"""
        Returns a list of variables to be exported. Names of variables are
        separated by spaces.
        """
        return _connect.CProfilerExportConfig_getVariablesFilter(self)

    def getAUXFilter(self) -> "std::string":
        r"""
        Returns a list of IO ports to be exported. Names of ports are
        separated by spaces.
        """
        return _connect.CProfilerExportConfig_getAUXFilter(self)

    def getStartTime(self) -> "int64_t":
        r""" Returns export start time."""
        return _connect.CProfilerExportConfig_getStartTime(self)

    def getEndTime(self) -> "int64_t":
        r""" Returns export and time."""
        return _connect.CProfilerExportConfig_getEndTime(self)

    def getContextFilter(self) -> "std::string":
        r"""
        Returns context filter.

        See also: setContextFilter(), setContextScope()
        """
        return _connect.CProfilerExportConfig_getContextFilter(self)

    def isLaunchViewer(self) -> "bool":
        r""" Returns true, if viewer will be launched after export."""
        return _connect.CProfilerExportConfig_isLaunchViewer(self)

    def isSaveStatistics(self) -> "bool":
        r""" Returns true, if profiler statistics should be exported."""
        return _connect.CProfilerExportConfig_isSaveStatistics(self)

    def isSaveTimeline(self) -> "bool":
        r""" Returns true, if profiler time-line should be exported."""
        return _connect.CProfilerExportConfig_isSaveTimeline(self)

    def isSaveInfo(self) -> "bool":
        r"""
        Deprecated: 9.17.81, Sept. 2018. Had no effect in the past,
        so there is no replacement. Always returns true.
        """
        return _connect.CProfilerExportConfig_isSaveInfo(self)

    def getContextScope(self) -> "isys::CProfilerExportConfig::EContextScope":
        r""" Returns profiler context to be exported."""
        return _connect.CProfilerExportConfig_getContextScope(self)

    def getExportPartitionNameMode(self) -> "isys::CProfilerExportConfig::EExportPartitionNameMode":
        r""" Returns setting, which defines when download file name should be appended to exported area names."""
        return _connect.CProfilerExportConfig_getExportPartitionNameMode(self)

    def getFormatter(self) -> "CProfilerFormatBase":
        r""" Returns formatter object, which configures export file format."""
        return _connect.CProfilerExportConfig_getFormatter(self)

    def getContextScopeAsStr(self) -> "std::string":
        r"""
        Returns string, which can be used for setting of option
        '/Document/<file name>/ProfilerExport.Export.ContextScope'

        See also: setContextScope()
        """
        return _connect.CProfilerExportConfig_getContextScopeAsStr(self)

    def getExportPartitionNameModeAsStr(self) -> "std::string":
        r"""
        Returns string, which can be used for setting of option
        '/Document/<file name>/ProfilerExport.Export.ExportPartitionName'

        See also: setExportPartitionNameMode()
        """
        return _connect.CProfilerExportConfig_getExportPartitionNameModeAsStr(self)

    def getAreaScopeAsStr(self) -> "std::string":
        r"""
        Returns string, which can be used for setting of option
        '/Document/<file name>/ProfilerExport.Scope.AreaScope'

        See also: setAreaScope()
        """
        return _connect.CProfilerExportConfig_getAreaScopeAsStr(self)

    def getTimeScopeAsStr(self) -> "std::string":
        r"""
        Returns string, which can be used for setting of option
        '/Document/<file name>/ProfilerExport.Scope.TimeScope'

        See also: setTimeScope()
        """
        return _connect.CProfilerExportConfig_getTimeScopeAsStr(self)

    def setOptions(self, ide: "CIDEController", docFileName: "std::string const &") -> "void":
        r"""Writes options to winIDEA."""
        return _connect.CProfilerExportConfig_setOptions(self, ide, docFileName)

    def toString(self) -> "std::string":
        r"""Returns contents of this object in human readable form."""
        return _connect.CProfilerExportConfig_toString(self)
    __swig_destroy__ = _connect.delete_CProfilerExportConfig

# Register CProfilerExportConfig in _connect:
_connect.CProfilerExportConfig_swigregister(CProfilerExportConfig)

class CProfilerController2(CAnalyzerDocController):
    r"""
    This class implements profiler functionality with a document
    oriented interface. It replaces the old CProfilerController,
    which is deprecated now. If you need some functionality from the
    old class, which is missing in this one, please contact iSystem
    support, rather than using the old class. If you use the
    old class, your code will no longer work once the deprecated
    class will be removed in the future versions of ``isystem.connect``.


    Portability list

    CProfilerController()  -->  CProfilerController2()
                                File name and open mode are required.

    getCapabilities()      -->  not implemented in CProfilerController2

    startConfiguration()   -->  use setFunctionTrigger()

    All ``get...()`` methods are implemented in **isys::CProfilerData2** class.


    This class can be used to configure profiler, run recording, and export
    the recorded data. However, it has no methods to get recorded information.
    For this purpose a separate class called CProfilerData2 should be used.


    Use only methods documented for this class. If a method from the base class is
    not documented here, do not use it. 

    **Advanced profiler configuration**

    Most settings for profiler are implemented by setting of winIDEA options.
    Since there are many options, and most of them are target dependent,
    this class provides methods for accessing only the most often used options.
    To see all profiler options, open profiler document in winIDEA, then select
    ``Help | Display Option...``. In the opened dialog select all
    check-boxes, and radio button 'Document'. Then select profiler document in
    the combo box next to the radio button. Click the ``Display'`` button to
    see all profiler options as shown in the image below:

    Image: displayOptionsDialog.png

    These options can be set with method CIDEController::setOption().


    Python example with recording and simple data reading: profiler2Example.py


    Python example with detailed data reading  - uses only class CProfilerData2: profilerData.py


    Python example for profiling a single function: profileSingleFunction.py
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ERWRead = _connect.CProfilerController2_ERWRead
    ERWWrite = _connect.CProfilerController2_ERWWrite
    ERWReadOrWrite = _connect.CProfilerController2_ERWReadOrWrite
    EDATState = _connect.CProfilerController2_EDATState
    r"""
    Data area is a state variable. It is supposed to
    have only few values, at most 256. Task ID or state
    in state machine are examples of state variables.
    Statistics will be recoded for each value.
    """
    EDATLsbExitEntry = _connect.CProfilerController2_EDATLsbExitEntry
    EDATZeroExitEntry = _connect.CProfilerController2_EDATZeroExitEntry
    EDATRegular = _connect.CProfilerController2_EDATRegular
    r"""
    Regular variable, can have any number of values,
    but no statistics will be available for each value.
    """
    EStateDefNone = _connect.CProfilerController2_EStateDefNone
    r""" no definition, there will be empty name for state variables"""
    EStateDefDefine = _connect.CProfilerController2_EStateDefDefine
    r""" variable state names will be taken from defines"""
    EStateDefEnum = _connect.CProfilerController2_EStateDefEnum
    r""" variable state names will be taken from enum type"""
    ESingleData = _connect.CProfilerController2_ESingleData
    r""" messages without parameters, for example OTM on PowerPC"""
    ESingleData1 = _connect.CProfilerController2_ESingleData1
    r"""
    messages with parameter, for example ITM on ARM, where
    parameter is channel number.
    """

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >", fileName: "std::string const &", mode: "std::string const &"):
        r"""
        Instantiates object and opens or creates profiler document in
        ``winIDEA``.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        :type mode: string
        :param mode: document open mode. 'u' opens existing file for update (file
                        must exist), 'w' opens existing file and deletes contents,
                        or creates a new file, 'a' opens existing file and keeps
                        contents, or creates a new file if it does not exist.

        :type fileName: string
        :param fileName: if not an empty string, it is used, otherwise
                   the user is prompted for fileName by winIDEA. In the later
                   case this object can not be used, because the file name
                   is known only in winIDEA.

        Python example: profiler2Example.py
        """
        _connect.CProfilerController2_swiginit(self, _connect.new_CProfilerController2(connectionMgr, fileName, mode))
    __swig_destroy__ = _connect.delete_CProfilerController2

    def createTrigger(self, triggerName: "std::string const &") -> "int":
        r"""
        Creates a new profiler trigger. Trigger contains information about
        what profiler should record (which functions, variables, ...)
        and how to record it (when to start, buffer size, ...).

        :type triggerName: string
        :param triggerName: name of the trigger

        :rtype: int
        :return: index of the created trigger

        :raises: IllegalArgumentException if the trigger already exists

        Python example: profiler2Example.py
        """
        return _connect.CProfilerController2_createTrigger(self, triggerName)

    def setProfilingSections(self, triggerIndex: "int", isProfileCode: "bool", isProfileData: "bool", isProfileOSObjects: "bool", isProfileAUX: "bool") -> "void":
        r"""
        Defines, which sections (code, data, AUX) should be recorded by profiler.
        Please note, that the meaning of flags is different for each section.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()

        :type isProfileCode: boolean
        :param isProfileCode: if ``true``, code execution is recorded. If function list
                                 is empty, (method addFunction() was not called or functions
                                 were removed with one of remove() methods), all functions
                                 will be recorded. If the function list is not empty, only
                                 functions in the list will be recorded.
                                 If ``false``, no functions will be recorded.
        :type isProfileData: boolean
        :param isProfileData: if ``true``, variables added with addVariable() or
                                 addStateVariable() will be recorded. If ``false``,
                                 no variables will be recorded.
        :type isProfileOSObjects: boolean
        :param isProfileOSObjects: if ``true``, OS objects will be recorded. If ``false``
                                 OS objects won't be recorded.
        :type isProfileAUX: boolean
        :param isProfileAUX:  if ``true``, AUX ports will be recorded. If ``false``,
                                 AUX ports won't be recorded.

        Python example: profiler2Example.py
        """
        return _connect.CProfilerController2_setProfilingSections(self, triggerIndex, isProfileCode, isProfileData, isProfileOSObjects, isProfileAUX)

    def setFunctionTrigger(self, triggerIndex: "int", functionName: "std::string const &") -> "void":
        r"""
        Sets a function, which will start profiling, when its execution
        starts.
        If trigger is not set, profiling starts immediately when ``start()`` is
        called and target is running.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type functionName: string
        :param functionName: name of the function to use as a profiler trigger. If
                                empty string, trigger start is set to ``Anything``.

        Python example: profiler2Example.py
        """
        return _connect.CProfilerController2_setFunctionTrigger(self, triggerIndex, functionName)

    def addFunction(self, triggerIndex: "int", functionName: "std::string const &", isIncludeFunctionLines: "bool"=False) -> "int":
        r"""
        Adds function to the list of functions to profile. If the function is
        already in the list, it is not added again.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type functionName: string
        :param functionName: name of the function to profile
        :type isIncludeFunctionLines: boolean, optional
        :param isIncludeFunctionLines: since version 9.12.36 this parameter must always be false,
                                          because profiling function lines is no longer supported.

        :rtype: int
        :return: index of profiler option ``ExecArea``, which contains the added function

        Python example: profiler2Example.py
        """
        return _connect.CProfilerController2_addFunction(self, triggerIndex, functionName, isIncludeFunctionLines)

    def addFunctions(self, triggerIndex: "int", functions: "StrVector") -> "void":
        r"""
        Adds functions to the list of functions to profile. If a function is
        already in the list, it is not added.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type functions: :py:class:`StrVector`
        :param functions: list of functions to add
        """
        return _connect.CProfilerController2_addFunctions(self, triggerIndex, functions)

    def addVariable(self, triggerIndex: "int", variableName: "std::string const &", dataAreaType: "isys::CProfilerController2::EDataAreaType") -> "int":
        r"""
        Adds variable to the list of variables to profile. If the variable is
        already in the list, it is not added, only ``dataAreaType`` of the existing
        entry is set. If it is a state variable, and names of states are known,
        consider using addStateVariable().

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type variableName: string
        :param variableName: name of the variable to profile
        :type dataAreaType: int
        :param dataAreaType: type of variable, see CProfilerController2::EDataAreaType

        :rtype: int
        :return: index of DataArea with the added function

        Python example: profiler2Example.py
        """
        return _connect.CProfilerController2_addVariable(self, triggerIndex, variableName, dataAreaType)

    def addTraceMessage(self, triggerIndex: "int", traceMessage: "std::string const &", dataAreaType: "isys::CProfilerController2::EDataAreaType", messageType: "isys::CProfilerController2::ETraceMessageType") -> "int":
        r"""
        Adds trace message to the list of variables to profile. If the message is
        already in the list, it is not added, only ``dataAreaType`` of the existing
        entry is set.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type traceMessage: string
        :param traceMessage: name of the message to record. For PowerPC this should be
                                empty string, for ARM this should be channel number of ITM
                                messages.
        :type dataAreaType: int
        :param dataAreaType: defines the way to analyze the recorded data,
                                see CProfilerController2::EDataAreaType

        :type messageType: int
        :param messageType: type of messages, see CProfilerController2::ETraceMessageType

        :rtype: int
        :return: index of DataArea with the added function

        Python example: profiler2Example.py
        """
        return _connect.CProfilerController2_addTraceMessage(self, triggerIndex, traceMessage, dataAreaType, messageType)

    def addStateVariable(self, triggerIndex: "int", variableName: "std::string const &", stateVarDef: "isys::CProfilerController2::EStateVarDefinition", definitonName: "std::string const") -> "int":
        r"""
        Adds state variable to the list of variables to profile. If the
        variable is already in the list, it is not added, only
        ``stateVarDef`` and ``definitonName`` of the existing entry are set.
        If ``definitonName`` is not available, use addVariable(.., EDATState)
        instead of this function.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type variableName: string
        :param variableName: name of the variable to profile
        :type stateVarDef: int
        :param stateVarDef: how variable states are defined,
                   see CProfilerController2::EStateVarDefinition
        :param definitionName: name of state definition, for example name of
                   enum type

        :rtype: int
        :return: index of DataArea with the added function

        Python example: profiler2Example.py
        """
        return _connect.CProfilerController2_addStateVariable(self, triggerIndex, variableName, stateVarDef, definitonName)

    def addAuxVariable(self, triggerIndex: "int", variableName: "std::string const &", dataAreaType: "isys::CProfilerController2::EDataAreaType") -> "int":
        r"""
        Adds AUX input to the list of variables to profile. If the input is
        already in the list, it is not added, only ``dataAreaType`` of the existing
        entry is set.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type variableName: string
        :param variableName: name of the AUX input to profile
        :type dataAreaType: int
        :param dataAreaType: type of variable, see CProfilerController2::EDataAreaType

        :rtype: int
        :return: index of DataArea with the added function
        """
        return _connect.CProfilerController2_addAuxVariable(self, triggerIndex, variableName, dataAreaType)

    def removeFunction(self, triggerIndex: "int", functionName: "std::string const &") -> "int":
        r"""
        Removes function from the list of functions to profile.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type functionName: string
        :param functionName: name of the function to remove

        :rtype: int
        :return: -1 if no function with the given name was found, 0 if
                    the function was found and removed

        Python example: profiler2Example.py
        """
        return _connect.CProfilerController2_removeFunction(self, triggerIndex, functionName)

    def removeVariable(self, triggerIndex: "int", variableName: "std::string const &") -> "int":
        r"""
        Removes variable from the list of variables to profile.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type variableName: string
        :param variableName: name of the variable to remove

        :rtype: int
        :return: -1 if no variable with the given name was found, 0 if
                    the variable was found and removed

        Python example: profiler2Example.py
        """
        return _connect.CProfilerController2_removeVariable(self, triggerIndex, variableName)

    def removeAllFunctions(self, triggerIndex: "int") -> "void":
        r"""
        Removes all functions from the list of functions to profile.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        """
        return _connect.CProfilerController2_removeAllFunctions(self, triggerIndex)

    def removeAllVariables(self, triggerIndex: "int") -> "void":
        r"""
        Removes all variables from the list of variables to profile.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        """
        return _connect.CProfilerController2_removeAllVariables(self, triggerIndex)

    def getSessionDuration(self, triggerIndex: "int") -> "int":
        r"""
        Returns how long should profiler recording last on next run.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()

        :rtype: int
        :return: session duration in milliseconds if limit is enabled,
                    negative value of session duration if limit is disabled.
        """
        return _connect.CProfilerController2_getSessionDuration(self, triggerIndex)

    def setSessionDuration(self, triggerIndex: "int", sessionDurationInMilliseconds: "int") -> "void":
        r"""
        Sets how long should profiler recording last on next run. Profiler
        will stop after the specified number of milliseconds. If target
        is stopped earlier, profiler session is shorter.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type sessionDurationInMilliseconds: int
        :param sessionDurationInMilliseconds: max duration of next profiler session.
                                                 If greater than 0, session duration limit
                                                 is enabled and set to the specified value,
                                                 otherwise session duration limit is disabled
                                                 and the time is not changed.
        """
        return _connect.CProfilerController2_setSessionDuration(self, triggerIndex, sessionDurationInMilliseconds)

    def exportData(self, exportConfig: "CProfilerExportConfig") -> "void":
        r"""
        Exports profiler data according to the given configuration.
        Example:


        profiler = CProfilerController2(connectionMgr, "profiler.trd", "w");

        ...

        cfg = CProfilerExportConfig().setFileName('profilerResult.xml')
                                     .setExportFormat(CProfilerExportFormat::EXML)
                                     .setAreaScpe(CProfilerExportConfig::EAll);
        profiler.exportData(cfg);


        Python example: profiler2Example.py
        """
        return _connect.CProfilerController2_exportData(self, exportConfig)

    def dataAreaType2Str(self, dataAreaType: "isys::CProfilerController2::EDataAreaType") -> "std::string":
        r"""
        Returns string, which can be used to set option
        ``/Document/<fileName>/Trigger.Items[<idx1>].Profiler.DataArea[<idx2>].Type``.
        """
        return _connect.CProfilerController2_dataAreaType2Str(self, dataAreaType)

    def stateVarDef2Str(self, stateVarDef: "isys::CProfilerController2::EStateVarDefinition") -> "std::string":
        r"""
        Returns string, which can be used to set option
        ``/Document/<fileName>/Trigger.Items[<idx1>].Profiler.DataArea[<idx2>].Definition``.
        """
        return _connect.CProfilerController2_stateVarDef2Str(self, stateVarDef)

    def traceMsgDef2Str(self, traceMsgType: "isys::CProfilerController2::ETraceMessageType") -> "std::string":
        r"""
        Returns string, which can be used to set option
        ``/Document/<fileName>/Trigger.Items[<idx1>].Profiler.DataArea[<idx2>].DataType``.
        """
        return _connect.CProfilerController2_traceMsgDef2Str(self, traceMsgType)

# Register CProfilerController2 in _connect:
_connect.CProfilerController2_swigregister(CProfilerController2)

class CTraceFormatBase(object):
    r"""
    This is base class for trace export format containers. Expand
    **inheritance diagram** below to see all derived formatter classes.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    EFmtText = _connect.CTraceFormatBase_EFmtText
    r""" text export"""
    EFmtCSV = _connect.CTraceFormatBase_EFmtCSV
    r""" CSV export"""
    EFmtBinary = _connect.CTraceFormatBase_EFmtBinary
    r""" binary export"""
    EFmtXML = _connect.CTraceFormatBase_EFmtXML
    r""" XMl export"""

    def getExportFormat(self) -> "isys::CTraceFormatBase::EExportFormat":
        r""" Returns value used for option /TraceExport.Type."""
        return _connect.CTraceFormatBase_getExportFormat(self)

    def getExportFormatAsStr(self) -> "std::string":
        r"""
        Returns string with export format, suitable for setting winIDEA
        trace export format option.
        """
        return _connect.CTraceFormatBase_getExportFormatAsStr(self)

    def setOptions(self, ide: "CIDEController", docFileName: "std::string const &") -> "void":
        r""" Sets option in winIDEA."""
        return _connect.CTraceFormatBase_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CTraceFormatBase

# Register CTraceFormatBase in _connect:
_connect.CTraceFormatBase_swigregister(CTraceFormatBase)

class CTraceTextExportFormat(CTraceFormatBase):
    r"""This class configures format of Text export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Creates object with default values."""
        _connect.CTraceTextExportFormat_swiginit(self, _connect.new_CTraceTextExportFormat())

    def setContentLen(self, contentLen: "int") -> "isys::CTraceTextExportFormat &":
        r""" Sets content length. Default: 30."""
        return _connect.CTraceTextExportFormat_setContentLen(self, contentLen)

    def getContentLen(self) -> "int":
        r""" Returns content length."""
        return _connect.CTraceTextExportFormat_getContentLen(self)

    def setOptions(self, ide: "CIDEController", docFileName: "std::string const &") -> "void":
        r"""
        Writes options to winIDEA. This method is automatically called
        by CTraceController::exportData(). This method sets only configuration
        for Text format, but does not set trace export format to Text (modifies
        only options '/Document/<fname>/TraceExport.Text.*').
        """
        return _connect.CTraceTextExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CTraceTextExportFormat

# Register CTraceTextExportFormat in _connect:
_connect.CTraceTextExportFormat_swigregister(CTraceTextExportFormat)

class CTraceCSVExportFormat(CTraceFormatBase):
    r"""This class configures format of CSV export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Creates object with default values."""
        _connect.CTraceCSVExportFormat_swiginit(self, _connect.new_CTraceCSVExportFormat())

    def setSeparator(self, separator: "std::string const &") -> "isys::CTraceCSVExportFormat &":
        r""" Sets CSV field separator. Default: ','."""
        return _connect.CTraceCSVExportFormat_setSeparator(self, separator)

    def setColumnHeaders(self, isColumnHeaders: "bool") -> "isys::CTraceCSVExportFormat &":
        r""" Defines if column headers should be written to file. Default: true."""
        return _connect.CTraceCSVExportFormat_setColumnHeaders(self, isColumnHeaders)

    def setFunctionTree(self, isFunctionTree: "bool") -> "isys::CTraceCSVExportFormat &":
        r"""
        Deprecated: This option has been removed from trace exports, do not
        call this method, it will be removed in future release
        """
        return _connect.CTraceCSVExportFormat_setFunctionTree(self, isFunctionTree)

    def getSeparator(self) -> "std::string":
        r""" Returns CSV field separator."""
        return _connect.CTraceCSVExportFormat_getSeparator(self)

    def isColumnHeaders(self) -> "int":
        r""" Returns true, if column headers will be present in export file."""
        return _connect.CTraceCSVExportFormat_isColumnHeaders(self)

    def isFunctionTree(self) -> "int":
        r"""
        Deprecated: Always returns `false`. This option has been removed from trace
                    exports, do not call this method, it will be removed in future release.
        """
        return _connect.CTraceCSVExportFormat_isFunctionTree(self)

    def setOptions(self, ide: "CIDEController", docFileName: "std::string const &") -> "void":
        r"""
        Writes options to winIDEA. This method is automatically called
        by CTraceController::exportData(). This method sets only configuration
        for Text format, but does not set trace export format to Text (modifies
        only options '/Document/<fname>/TraceExport.Text.*').
        """
        return _connect.CTraceCSVExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CTraceCSVExportFormat

# Register CTraceCSVExportFormat in _connect:
_connect.CTraceCSVExportFormat_swigregister(CTraceCSVExportFormat)

class CTraceXMLExportFormat(CTraceFormatBase):
    r"""This class configures contents of XML export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Creates object with default values."""
        _connect.CTraceXMLExportFormat_swiginit(self, _connect.new_CTraceXMLExportFormat())

    def setIndex(self, isIndex: "bool") -> "isys::CTraceXMLExportFormat &":
        r""" Export sample index. XML Property = IDX, default: true."""
        return _connect.CTraceXMLExportFormat_setIndex(self, isIndex)

    def setTime(self, isTime: "bool") -> "isys::CTraceXMLExportFormat &":
        r""" Export sample time. XML Property = T, default: true."""
        return _connect.CTraceXMLExportFormat_setTime(self, isTime)

    def setTraceSourceId(self, isTraceSourceId: "bool") -> "isys::CTraceXMLExportFormat &":
        r""" Export trace source ID. XML Property = ID, default: false."""
        return _connect.CTraceXMLExportFormat_setTraceSourceId(self, isTraceSourceId)

    def setAddress(self, isAddress: "bool") -> "isys::CTraceXMLExportFormat &":
        r""" Export address. XML Property = ADR, default: true."""
        return _connect.CTraceXMLExportFormat_setAddress(self, isAddress)

    def setMemArea(self, isMemArea: "bool") -> "isys::CTraceXMLExportFormat &":
        r""" Export memory area. XML Property = AREA, default: false."""
        return _connect.CTraceXMLExportFormat_setMemArea(self, isMemArea)

    def setData(self, isData: "bool") -> "isys::CTraceXMLExportFormat &":
        r""" Export data. XML Property = DATA, default: true."""
        return _connect.CTraceXMLExportFormat_setData(self, isData)

    def setDasm(self, isDasm: "bool") -> "isys::CTraceXMLExportFormat &":
        r""" Export disassembly. XML Property = DASM, default: true."""
        return _connect.CTraceXMLExportFormat_setDasm(self, isDasm)

    def setDasmData(self, isDasmData: "bool") -> "isys::CTraceXMLExportFormat &":
        r""" Includes op-code data in the Disassembly. default: false."""
        return _connect.CTraceXMLExportFormat_setDasmData(self, isDasmData)

    def setDasmAddress(self, isDasmAddress: "bool") -> "isys::CTraceXMLExportFormat &":
        r""" Includes op-code address in the Disassembly. default: false."""
        return _connect.CTraceXMLExportFormat_setDasmAddress(self, isDasmAddress)

    def setFunction(self, isFunction: "bool") -> "isys::CTraceXMLExportFormat &":
        r""" Export function. XML Property = FUNC, default: false."""
        return _connect.CTraceXMLExportFormat_setFunction(self, isFunction)

    def setLabel(self, isLabel: "bool") -> "isys::CTraceXMLExportFormat &":
        r""" Export label. XML Property = LABEL, default: false."""
        return _connect.CTraceXMLExportFormat_setLabel(self, isLabel)

    def setSourceLine(self, isSourceLine: "bool") -> "isys::CTraceXMLExportFormat &":
        r""" Export source line. XML Property = SRC, default: true."""
        return _connect.CTraceXMLExportFormat_setSourceLine(self, isSourceLine)

    def setActivity(self, isActivity: "bool") -> "isys::CTraceXMLExportFormat &":
        r""" Export activity information. XML Property = ACT, default: false."""
        return _connect.CTraceXMLExportFormat_setActivity(self, isActivity)

    def setBusStatus(self, isBusStatus: "bool") -> "isys::CTraceXMLExportFormat &":
        r""" Export bus status. XML Property = BS, default: false."""
        return _connect.CTraceXMLExportFormat_setBusStatus(self, isBusStatus)

    def setAUX(self, isAUX: "bool") -> "isys::CTraceXMLExportFormat &":
        r""" Export AUX signals. XML Property prefix = X, default: false."""
        return _connect.CTraceXMLExportFormat_setAUX(self, isAUX)

    def setOCT(self, isOCT: "bool") -> "isys::CTraceXMLExportFormat &":
        r""" Export OCT data. XML Property prefix = OCT, default: false."""
        return _connect.CTraceXMLExportFormat_setOCT(self, isOCT)

    def setUseIndent(self, isUseIndent: "bool") -> "isys::CTraceXMLExportFormat &":
        r"""
        Use indenting in XML export file. Default: false.
        Set this property to true, if humans will read the exported file.
        If indenting is not used, the file is about 20% smaller.
        """
        return _connect.CTraceXMLExportFormat_setUseIndent(self, isUseIndent)

    def isIndex(self) -> "bool":
        r""" Returns true, if sample index will be exported."""
        return _connect.CTraceXMLExportFormat_isIndex(self)

    def isTime(self) -> "bool":
        r""" Returns true, if time stamp will be exported."""
        return _connect.CTraceXMLExportFormat_isTime(self)

    def isTraceSourceId(self) -> "bool":
        r""" Returns true, if trace source ID will be exported."""
        return _connect.CTraceXMLExportFormat_isTraceSourceId(self)

    def isAddress(self) -> "bool":
        r""" Returns true, if address will be exported."""
        return _connect.CTraceXMLExportFormat_isAddress(self)

    def isMemArea(self) -> "bool":
        r""" Returns true, if memory area will be exported."""
        return _connect.CTraceXMLExportFormat_isMemArea(self)

    def isData(self) -> "bool":
        r""" Returns true, if data will be exported."""
        return _connect.CTraceXMLExportFormat_isData(self)

    def isDasm(self) -> "bool":
        r""" Returns true, if disassembly will be exported."""
        return _connect.CTraceXMLExportFormat_isDasm(self)

    def isDasmData(self) -> "bool":
        r""" Returns true, if disassembly op-code will be exported."""
        return _connect.CTraceXMLExportFormat_isDasmData(self)

    def isDasmAddress(self) -> "bool":
        r""" Returns true, if disassembly op-code address will be exported."""
        return _connect.CTraceXMLExportFormat_isDasmAddress(self)

    def isFunction(self) -> "bool":
        r""" Returns true, if function name will be exported."""
        return _connect.CTraceXMLExportFormat_isFunction(self)

    def isLabel(self) -> "bool":
        r""" Returns true, if label will be exported."""
        return _connect.CTraceXMLExportFormat_isLabel(self)

    def isSourceLine(self) -> "bool":
        r""" Returns true, if source line will be exported."""
        return _connect.CTraceXMLExportFormat_isSourceLine(self)

    def isActivity(self) -> "bool":
        r""" Returns true, if activity will be exported."""
        return _connect.CTraceXMLExportFormat_isActivity(self)

    def isBusStatus(self) -> "bool":
        r""" Returns true, if bus status will be exported."""
        return _connect.CTraceXMLExportFormat_isBusStatus(self)

    def isAUX(self) -> "bool":
        r""" Returns true, if AUX signals will be exported."""
        return _connect.CTraceXMLExportFormat_isAUX(self)

    def isOCT(self) -> "bool":
        r""" Returns true, if OCT signals will be exported."""
        return _connect.CTraceXMLExportFormat_isOCT(self)

    def isUseIndent(self) -> "bool":
        r""" Returns true, if exported XML will be indented."""
        return _connect.CTraceXMLExportFormat_isUseIndent(self)

    def setOptions(self, ide: "CIDEController", docFileName: "std::string const &") -> "void":
        r"""
        Writes options to winIDEA. This method is automatically called
        by CTraceController::exportData(). This method sets only configuration
        for XML format, but does not set trace export format to XML (modifies
        only options '/Document/<fname>/TraceExport.XML.*').
        """
        return _connect.CTraceXMLExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CTraceXMLExportFormat

# Register CTraceXMLExportFormat in _connect:
_connect.CTraceXMLExportFormat_swigregister(CTraceXMLExportFormat)

class CTraceBinExportFormat(CTraceFormatBase):
    r"""
    This class configures contents of Binary export. It is _highly_ recommended to
    set format to header version 2 (EHeaderVer2), and to export also the presence
    flags. This way the file format is self descriptive and can be parsed anytime
    later. In all other cases we have to store the file format separately, but
    even then the file may not be parseable - for example, if addresses and OCD are
    exported, than samples with OCD may not have data for addresses, and there
    is no way to find this out from the information in file. Use
    export without presence flags only when file size is really critical, and
    you know that all exported data is present in each sample.

    winIDEA 9.12.x note: If parsing binary data without header or with header
    version 1, always call `setNumBusStatusBytes(4)` on this object, because
    it is set to 8 by default.

    traceData.py
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EHeaderVer1 = _connect.CTraceBinExportFormat_EHeaderVer1
    r""" the old header, without information about file format"""
    EHeaderVer2 = _connect.CTraceBinExportFormat_EHeaderVer2
    r""" the new header, which contains file format info"""
    EDataItem = _connect.CTraceBinExportFormat_EDataItem
    r""" data is present"""
    EAddressItem = _connect.CTraceBinExportFormat_EAddressItem
    r""" address is present"""
    EMemAreaItem = _connect.CTraceBinExportFormat_EMemAreaItem
    r""" memory area is present"""
    ETimeStampItem = _connect.CTraceBinExportFormat_ETimeStampItem
    r""" timestamp is present"""
    EBusStatusItem = _connect.CTraceBinExportFormat_EBusStatusItem
    r""" bus status is present"""
    ESampleIndexItem = _connect.CTraceBinExportFormat_ESampleIndexItem
    r""" sample and subsample indices are present"""
    EOCDItem = _connect.CTraceBinExportFormat_EOCDItem
    r""" On Chip Data is present"""
    EAUXItem = _connect.CTraceBinExportFormat_EAUXItem
    r""" AUX is present"""
    EPresenceFlagsItem = _connect.CTraceBinExportFormat_EPresenceFlagsItem
    r"""
    presence flags are saved in the file,
    this flag is set only in file header
    """
    ETraceSourceIdItem = _connect.CTraceBinExportFormat_ETraceSourceIdItem
    r""" trace source ID is present"""

    def __init__(self):
        r"""
        Creates object with default values. Most important, header version 2
        and presence flags are saved to file. Change these two settings only
        if the export file size really matters.
        """
        _connect.CTraceBinExportFormat_swiginit(self, _connect.new_CTraceBinExportFormat())

    def setHeader(self, isHeader: "bool") -> "isys::CTraceBinExportFormat &":
        r""" If true, header is saved to binary export. Default: true."""
        return _connect.CTraceBinExportFormat_setHeader(self, isHeader)

    def setHeaderVersion(self, headerVersion: "isys::CTraceBinExportFormat::EHeaderVersion") -> "isys::CTraceBinExportFormat &":
        r""" Sets header version. Default: EHeaderVer2."""
        return _connect.CTraceBinExportFormat_setHeaderVersion(self, headerVersion)

    def setNumOfCpuBuses(self, numberOfCpuBusses: "int") -> "isys::CTraceBinExportFormat &":
        r"""
        Sets the number of CPU buses. This value is not used during export -
        all buses are always exported, but only during parsing.
        Default: 1.
        """
        return _connect.CTraceBinExportFormat_setNumOfCpuBuses(self, numberOfCpuBusses)

    def setNumMAUs(self, numMAUs: "int") -> "isys::CTraceBinExportFormat &":
        r"""
        Sets the number of valid MAUs in the data item.
        Default: 4. Should be set to 4 for winIDEA 9.12.x, and 8 for
        winIDEA 9.17 and newer, if trace header version 2 is not available.
        """
        return _connect.CTraceBinExportFormat_setNumMAUs(self, numMAUs)

    def setNumBusStatusBytes(self, numBusStatusBytes: "int") -> "isys::CTraceBinExportFormat &":
        r"""
        Sets the number of valid bus status bytes in the bus status item.
        Default: 4.
        """
        return _connect.CTraceBinExportFormat_setNumBusStatusBytes(self, numBusStatusBytes)

    def setTraceItemFlags(self, presenceFlags: "unsigned short") -> "isys::CTraceBinExportFormat &":
        r"""
        Sets flags, where each bit defines, which trace items should be
        exported.

        See also: EPresenceFlags
        """
        return _connect.CTraceBinExportFormat_setTraceItemFlags(self, presenceFlags)

    def addTraceItem(self, presenceFlag: "isys::CTraceBinExportFormat::EPresenceFlags") -> "isys::CTraceBinExportFormat &":
        r""" Adds the given trace item to export."""
        return _connect.CTraceBinExportFormat_addTraceItem(self, presenceFlag)

    def removeTraceItem(self, presenceFlag: "isys::CTraceBinExportFormat::EPresenceFlags") -> "isys::CTraceBinExportFormat &":
        r""" Removes the given trace item from export."""
        return _connect.CTraceBinExportFormat_removeTraceItem(self, presenceFlag)

    def isHeader(self) -> "bool":
        r""" Returns true, if header will be exported."""
        return _connect.CTraceBinExportFormat_isHeader(self)

    def getHeaderVersion(self) -> "isys::CTraceBinExportFormat::EHeaderVersion":
        r""" Returns export header version."""
        return _connect.CTraceBinExportFormat_getHeaderVersion(self)

    def getHeaderVersionAsStr(self) -> "std::string":
        r""" Returns export header version as string."""
        return _connect.CTraceBinExportFormat_getHeaderVersionAsStr(self)

    def getNumOfCpuBuses(self) -> "int":
        r"""Returns the number of CPU buses as set by setNumOfCpuBuses()"""
        return _connect.CTraceBinExportFormat_getNumOfCpuBuses(self)

    def getNumMAUs(self) -> "int":
        r"""Returns the number of MAUs as set by setNumMAUs()"""
        return _connect.CTraceBinExportFormat_getNumMAUs(self)

    def getNumBusStatusBytes(self) -> "int":
        r"""Returns the number of valid bus status bytes as set by setNumBusStatusBytes()"""
        return _connect.CTraceBinExportFormat_getNumBusStatusBytes(self)

    def getPresenceFlags(self) -> "unsigned short":
        r"""
        Returns presence flags, which indicate which trace items should
        be exported.

        See also: EPresenceFlags
        See also: setPresenceFlags()
        """
        return _connect.CTraceBinExportFormat_getPresenceFlags(self)

    def isTraceItem(self, itemMask: "isys::CTraceBinExportFormat::EPresenceFlags") -> "bool":
        r"""
        Returns ``true``, if trace item specified in ``itemMask`` is
        available.
        """
        return _connect.CTraceBinExportFormat_isTraceItem(self, itemMask)

    def setOptions(self, ide: "CIDEController", docFileName: "std::string const &") -> "void":
        r"""
        Writes options to winIDEA. This method is automatically called
        by CTraceController::exportData(). This method sets only configuration
        for binary  format, but does not set trace export format to binary (modifies
        only options '/Document/<fname>/TraceExport.Bin.*').
        """
        return _connect.CTraceBinExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CTraceBinExportFormat

# Register CTraceBinExportFormat in _connect:
_connect.CTraceBinExportFormat_swigregister(CTraceBinExportFormat)

class CTraceExportConfig(object):
    r"""
    This class contains configuration for export of trace
    recording. All setters return reference to ``this``, so we can
    chain calls to set values, for example:


    cfg = CTraceExportConfig().setFileName('traceResult.xml')
                              .setTimeScope(CTraceExportConfig::ETimeAll)
                              .setTimeFilter(0, 1000000);
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ETimeAll = _connect.CTraceExportConfig_ETimeAll
    r""" export recorded samples regardless of timestamp"""
    ETimeBetweenMarkers = _connect.CTraceExportConfig_ETimeBetweenMarkers
    r"""
    export only samples between times specified
    with call to setTimeFilter()
    """

    def __init__(self):
        r""" Creates object with default values."""
        _connect.CTraceExportConfig_swiginit(self, _connect.new_CTraceExportConfig())

    def setFileName(self, fileName: "std::string const &") -> "isys::CTraceExportConfig &":
        r"""
        Sets the name of the exported file. If this method is not called, or
        ``fileName`` is empty string, then the existing export file name in
        winIDEA is used.

        Python example: trace2Example.py
        """
        return _connect.CTraceExportConfig_setFileName(self, fileName)

    def setLaunchViewer(self, isLaunchViewer: "bool") -> "isys::CTraceExportConfig &":
        r"""
        If set to true, launches the system default
        viewer for the specified document type after export, for example
        notepad for text documents. Default: false.
        """
        return _connect.CTraceExportConfig_setLaunchViewer(self, isLaunchViewer)

    def setTimeScope(self, timeScope: "isys::CTraceExportConfig::ETimeScope") -> "isys::CTraceExportConfig &":
        r""" Sets the time scope Default: ETimeAll."""
        return _connect.CTraceExportConfig_setTimeScope(self, timeScope)

    def setTimeFilter(self, startTime: "int64_t", endTime: "int64_t") -> "isys::CTraceExportConfig &":
        r"""
        Sets time-frame for which trace should be exported
        Default: both times are set to 0, but are not used if
        setTimeScope(ETimeBetweenMarkers) is not called.


         To export measurements before trigger, times must be
        negative. Trigger has timestamp 0.

        :type startTime: int
        :param startTime: start of measurements to export relative
                             to trigger.

        :type endTime: int
        :param endTime: end of measurements to export. If greater
                           than the timestamp of the last sample, all
                           samples from ``startTime`` to the end are
                           exported.
        """
        return _connect.CTraceExportConfig_setTimeFilter(self, startTime, endTime)

    def setFormatter(self, formatter: "isys::CTraceFormatBaseSPtr &") -> "isys::CTraceExportConfig &":
        r"""
        Sets formatter object, which configures export file format. If this
        method is not called, XML formatter with default settings is used.
        """
        return _connect.CTraceExportConfig_setFormatter(self, formatter)

    def getFileName(self) -> "std::string":
        r""" Returns trace export file name."""
        return _connect.CTraceExportConfig_getFileName(self)

    def isLaunchViewer(self) -> "bool":
        r""" Returns true, if viewer will be launched after export."""
        return _connect.CTraceExportConfig_isLaunchViewer(self)

    def getTimeScope(self) -> "isys::CTraceExportConfig::ETimeScope":
        r""" Returns trace export time scope."""
        return _connect.CTraceExportConfig_getTimeScope(self)

    def getTimeScopeAsStr(self) -> "std::string":
        r"""
        Returns string, which can be used for setting of option
        '/Document/<file name>/TraceExport.SampleRange'
        """
        return _connect.CTraceExportConfig_getTimeScopeAsStr(self)

    def getStartTime(self) -> "int64_t":
        r""" Returns export start time."""
        return _connect.CTraceExportConfig_getStartTime(self)

    def getEndTime(self) -> "int64_t":
        r""" Returns export and time."""
        return _connect.CTraceExportConfig_getEndTime(self)

    def getFormatter(self) -> "CTraceFormatBase":
        r""" Returns formatter object, which configures export file format."""
        return _connect.CTraceExportConfig_getFormatter(self)

    def setOptions(self, ide: "CIDEController", docFileName: "std::string const &") -> "void":
        r"""
        Writes configured options to winIDEA. Only after this call
        the configured options are made active. This method is
        automatically called when CTraceController::exportData() is
        called.
        """
        return _connect.CTraceExportConfig_setOptions(self, ide, docFileName)

    def toString(self) -> "std::string":
        r"""Returns contents of this object in human readable form."""
        return _connect.CTraceExportConfig_toString(self)
    __swig_destroy__ = _connect.delete_CTraceExportConfig

# Register CTraceExportConfig in _connect:
_connect.CTraceExportConfig_swigregister(CTraceExportConfig)

class CTraceController(CAnalyzerDocController):
    r"""
    This class enables recording and export of program trace. It
    extends the existing class CAnalyzerDocController.

    This class can be used to configure trace trigger, run recording, and export
    the recorded data. However, it has no methods for retrieving recorded information.
    For this purpose a separate class called CTraceData should be used.


    **Advanced trace configuration**

    Most settings for trace are implemented by setting of winIDEA options.
    Since there are many options, and most of them are target dependent,
    this class provides methods for accessing only the most often used options.
    To see all trace options, open trace document in winIDEA, then select
    ``Help | Display Option...``. In the opened dialog select all
    check-boxes, and radio button 'Document'. Then select trace document in
    the combo box next to the radio button. Click the ``Display'`` button to
    see all trace options as shown in the image below:

    Image: displayOptionsDialog.png

    These options can be set with method CIDEController::setOption(). This
    approach should be used for advanced configurations, which are
    target dependent. Another possibility is to create and configure a trace
    document manually in winIDEA, and use it as a template in scripts.


    trace2Example.py Python example with recording and simple data reading.

    traceData.py Python example with detailed data reading  -
    uses only class CTraceData.

    traceChart.py Python example with graphical data presentation.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >", fileName: "std::string const &", mode: "std::string const &"):
        r"""
        Instantiates object and opens or creates analyzer document in
        ``winIDEA``.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        :type mode: string
        :param mode: document open mode. 'u' opens existing file for update (file
                        must exist), 'w' opens existing file and deletes contents,
                        or creates a new file, 'a' opens existing file and keeps
                        contents, or creates a new file if it does not exist.

        :type fileName: string
        :param fileName: Absolute or relative path to trd file. If not an
                   empty string, it is used, otherwise
                   the user is prompted for fileName by winIDEA. In the later
                   case this object can not be used, because the file name
                   is known only in winIDEA.

        Python example: trace2Example.py
        """
        _connect.CTraceController_swiginit(self, _connect.new_CTraceController(connectionMgr, fileName, mode))
    __swig_destroy__ = _connect.delete_CTraceController

    def createTrigger(self, triggerName: "std::string const &") -> "int":
        r"""
        Creates a new trace trigger. Trigger contains parameters for
        trace recording (when to start, buffer size, ...). See
        CTraceConfigWizard for simplified trigger configuration.

        :type triggerName: string
        :param triggerName: name of the trigger

        :rtype: int
        :return: index of the created trigger

        :raises: IllegalArgumentException if the trigger already exists

        Python example: trace2Example.py
        """
        return _connect.CTraceController_createTrigger(self, triggerName)

    def applyTriggerWizard(self, traceWizardConfig: "isys::CTraceConfigWizardSPtr &", triggerIdx: "int") -> "void":
        r"""
        This method applies the given trace trigger configuration to
        the actual trigger of this document.

        :type traceWizardConfig: :py:class:`CTraceConfigWizard`
        :param traceWizardConfig: trigger configuration.

        Python example: trace2Example.py
        """
        return _connect.CTraceController_applyTriggerWizard(self, traceWizardConfig, triggerIdx)

    def exportData(self, exportConfig: "CTraceExportConfig") -> "void":
        r"""
        Exports trace data according to the given configuration.
        Example:


        trace = CTraceController(connectionMgr, "trace.trd", "w");

        ...

        cfg = CTraceExportConfig().setFileName('traceResult.xml')
                                  .setExportFormat(CTraceExportConfig::EFmtXML);
        trace.exportData(cfg);


        Python example: trace2Example.py
        """
        return _connect.CTraceController_exportData(self, exportConfig)

# Register CTraceController in _connect:
_connect.CTraceController_swigregister(CTraceController)

class CTraceTimeEvent(object):
    r"""This class contains information of one trace time-line event."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def isTraceItem(self, itemMask: "isys::CTraceBinExportFormat::EPresenceFlags") -> "bool":
        return _connect.CTraceTimeEvent_isTraceItem(self, itemMask)

    def getSampleIndex(self) -> "int64_t":
        r""" Returns sample index."""
        return _connect.CTraceTimeEvent_getSampleIndex(self)

    def getSubSampleIndex(self) -> "int64_t":
        r""" Returns sub-sample index."""
        return _connect.CTraceTimeEvent_getSubSampleIndex(self)

    def getTime(self) -> "int64_t":
        r""" Returns time of event."""
        return _connect.CTraceTimeEvent_getTime(self)

    def getTraceSourceId(self) -> "uint8_t":
        return _connect.CTraceTimeEvent_getTraceSourceId(self)

    def getAddress(self, busIndex: "int") -> "int64_t":
        r"""
        Returns address.

        :type busIndex: int
        :param busIndex: index of the target bus, 0 based.
        """
        return _connect.CTraceTimeEvent_getAddress(self, busIndex)

    def getMemArea(self, busIndex: "int") -> "int":
        r"""
        Returns memory area. See MemArea.h for meaning of values
        returned by this function - make sure to see enum for your
        target architecture.

        :type busIndex: int
        :param busIndex: index of the target bus, 0 based.
        """
        return _connect.CTraceTimeEvent_getMemArea(self, busIndex)

    def getData(self, busIndex: "int") -> "DWORD":
        r"""
        Returns data.

        :type busIndex: int
        :param busIndex: index of the target bus, 0 based.
        """
        return _connect.CTraceTimeEvent_getData(self, busIndex)

    def getBusStatus(self, status: "VectorBYTE") -> "void":
        r"""
        Returns bus status.

        :param busIndex: index of the target bus, 0 based.
        """
        return _connect.CTraceTimeEvent_getBusStatus(self, status)

    def getDasm(self) -> "std::string":
        r""" Returns disassembly (available only in XML export)."""
        return _connect.CTraceTimeEvent_getDasm(self)

    def getFunc(self) -> "std::string":
        r""" Returns function data (available only in XML export)."""
        return _connect.CTraceTimeEvent_getFunc(self)

    def getLabel(self) -> "std::string":
        r""" Returns label (available only in XML export)."""
        return _connect.CTraceTimeEvent_getLabel(self)

    def getSrc(self) -> "std::string":
        r""" Returns source code (available only in XML export)."""
        return _connect.CTraceTimeEvent_getSrc(self)

    def getBusActivity(self) -> "std::string":
        r""" Returns bus activity (available only in XML export)."""
        return _connect.CTraceTimeEvent_getBusActivity(self)

    def getOnChipData(self, data: "VectorOnChipData") -> "void":
        r""" Returns the recorded on chip data."""
        return _connect.CTraceTimeEvent_getOnChipData(self, data)

    def getAuxData(self, channelName: "std::string const &") -> "float":
        r"""
        Returns value on the given AUX channel. Channel names have prefix 'X',
        followed by 'A' for analog channel, 'D' for digital channel, followed
        by 'I' for input, 'O' for output and channel number. 

        Example: ``XAI2`` is value on Analog Input channel 2.


        Values for digital channels are float values 0 or 1.
        """
        return _connect.CTraceTimeEvent_getAuxData(self, channelName)

    def getAuxChannels(self, channels: "StrVector") -> "void":
        r"""
        This method returns the list of channels recorded in the current sample.

        :type channels: :py:class:`StrVector`
        :param channels: list of channel names, cleared before new values are inserted
        """
        return _connect.CTraceTimeEvent_getAuxChannels(self, channels)

    def toString(self) -> "std::string":
        r""" Returns string representation of this object."""
        return _connect.CTraceTimeEvent_toString(self)

    def __init__(self):
        _connect.CTraceTimeEvent_swiginit(self, _connect.new_CTraceTimeEvent())
    __swig_destroy__ = _connect.delete_CTraceTimeEvent

# Register CTraceTimeEvent in _connect:
_connect.CTraceTimeEvent_swigregister(CTraceTimeEvent)

class CTraceTimelineIterator(object):
    r"""
    This class implements iterator for trace time-line events. Only one
    iterator may iterate the events at a time, because the events are
    not stored in memory, but are sequentially parsed from a file.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def hasNext(self) -> "bool":
        r""" Returns true, if there is at least one more time-line item available."""
        return _connect.CTraceTimelineIterator_hasNext(self)

    def next(self) -> "isys::CTraceTimeEvent":
        r"""
        Returns the next time-line item by value. This method is much slower than
        calling nextAsPtr().

        Do not call this method if hasNext() returned ``false!``
        """
        return _connect.CTraceTimelineIterator_next(self)

    def nextAsSPtr(self) -> "CTraceTimeEvent":
        r"""
        Returns the next time-line item. Each call to this method returns the same
        object, but filled with new data. It is faster than calling next().

        Do not call this method if hasNext() returned ``false!``
        """
        return _connect.CTraceTimelineIterator_nextAsSPtr(self)
    __swig_destroy__ = _connect.delete_CTraceTimelineIterator

# Register CTraceTimelineIterator in _connect:
_connect.CTraceTimelineIterator_swigregister(CTraceTimelineIterator)

class CTraceData(object):
    r"""
    This class provides access to trace measurements. It parses XML or binary export
    files, and returns the parsed data through method calls. Since trace export
    files may be very large - hundreds of megabytes or even gigabytes, this
    class parses one sample per iterator function call.

    To get instance of this class call one of createInstance() factory methods.


    Python example with recording and simple data retrieval: trace2Example.py 

    Python example with detailed data retrieval: traceData.py 

    Python example with graphical data presentation: traceChart.py 

    Python example that converts data to Excel 2007 format: traceData2XLSX.py 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def createInstance(*args) -> "CTraceData":
        r"""
        *Overload 1:*

        This factory method exports data to file, and returns initialized object
        for parsing of trace files.
        Use it, when you've just recorded data (have CTraceController2 object
        available), and have not exported it yet. Note also that this method is not
        as flexible as direct export and
        method createInstance(fileName) or createInstance(fileName, exportConfig).


        **Note**: if ``exportFileName`` is relative, it is saved relative to
        winIDEA working directory, not the script working directory. This method
        tries to do its best to open the saved file, but if winIDEA is on remote
        host, it will fail. In such cases try to export the trace data with
        CTraceController2::exportData() and use
        the overloaded method ``createInstance(fileName, isBinaryTimeline)`` instead.

        :type traceCtrl: :py:class:`CTraceController`
        :param traceCtrl: trace document controller which will be used to obtain data.

        :type exportFileName: string
        :param exportFileName: name of the file to export data to

        :type startTime: int
        :param startTime: start time for trace export. If ``startTime`` and ``endTime``
                             are set to 0, then all data is exported.

        :type endTime: int
        :param endTime: end time for trace export. If ``startTime`` and ``endTime``
                           are set to 0, then all data is exported.

        :type isBinaryExport: boolean
        :param isBinaryExport: if ``true``, trace data is exported in binary format. If
                                  ``false``, XML format is used.

        Python example: traceData.py

        |

        *Overload 2:*

        This factory method returns initialized object for parsing of XML
        trace files. Use this method when trace data was exported to XML file.

        :type fileName: string
        :param fileName: name of the file with trace XML export. If you use
                            relative file path, be aware that script working directory is
                            used as a starting point, not winIDEA workspace directory.

        Python example: traceData.py

        |

        *Overload 3:*

        This factory method returns initialized object for parsing of binary trace files.
        Use this method when trace data was exported to binary file.

        :type fileName: string
        :param fileName: name of the file with trace binary export. If you use
                            relative file path, be aware that script working directory is
                            used as a starting point, not winIDEA workspace directory.

        :type exportConfig: :py:class:`CTraceBinExportFormat`
        :param exportConfig: this object is used to obtain information about export
                                format. First the header presence and version are obtained.
                                If there is no header or the version is less than 2, then
                                other flags in this object are used to get the exact file
                                format.
                                If header is present and version is 2, then exact format
                                is retrieved from the file and other settings in this object
                                are ignored.

        Python example: traceData.py
        """
        return _connect.CTraceData_createInstance(*args)

    def getBinaryExportConfig(self) -> "CTraceBinExportFormat":
        r"""
        Returns file format. If header version 2 was specified in
        call to createInstance(file, exportConfig), then this object
        is filled with information form the header. Otherwise it is
        returned unchanged. If binary parser is not active, an exception is
        thrown.

        Python example: trace2Example.py
        """
        return _connect.CTraceData_getBinaryExportConfig(self)

    def getParserWarnings(self) -> "std::string":
        r"""
        This method returns warnings related to input document. If there
        were no warnings, an empty string is returned. Always call this method
        after createInstance().

        Python example: trace2Example.py
        """
        return _connect.CTraceData_getParserWarnings(self)

    def closeParser(self) -> "void":
        r"""
        This method releases parser resources and closes document file. It is
        recommended to call this method always after CTraceTimelineIterator
        is no longer used.

        Python example: trace2Example.py
        """
        return _connect.CTraceData_closeParser(self)

    def getTimelineIterator(self) -> "isys::CTraceTimelineIterator":
        r"""
        Returns iterator, which will iterate trace samples.

        Python example: traceData.py
        """
        return _connect.CTraceData_getTimelineIterator(self)
    __swig_destroy__ = _connect.delete_CTraceData

# Register CTraceData in _connect:
_connect.CTraceData_swigregister(CTraceData)

def CTraceData_createInstance(*args) -> "CTraceData":
    r"""
    *Overload 1:*

    This factory method exports data to file, and returns initialized object
    for parsing of trace files.
    Use it, when you've just recorded data (have CTraceController2 object
    available), and have not exported it yet. Note also that this method is not
    as flexible as direct export and
    method createInstance(fileName) or createInstance(fileName, exportConfig).


    **Note**: if ``exportFileName`` is relative, it is saved relative to
    winIDEA working directory, not the script working directory. This method
    tries to do its best to open the saved file, but if winIDEA is on remote
    host, it will fail. In such cases try to export the trace data with
    CTraceController2::exportData() and use
    the overloaded method ``createInstance(fileName, isBinaryTimeline)`` instead.

    :type traceCtrl: :py:class:`CTraceController`
    :param traceCtrl: trace document controller which will be used to obtain data.

    :type exportFileName: string
    :param exportFileName: name of the file to export data to

    :type startTime: int
    :param startTime: start time for trace export. If ``startTime`` and ``endTime``
                         are set to 0, then all data is exported.

    :type endTime: int
    :param endTime: end time for trace export. If ``startTime`` and ``endTime``
                       are set to 0, then all data is exported.

    :type isBinaryExport: boolean
    :param isBinaryExport: if ``true``, trace data is exported in binary format. If
                              ``false``, XML format is used.

    Python example: traceData.py

    |

    *Overload 2:*

    This factory method returns initialized object for parsing of XML
    trace files. Use this method when trace data was exported to XML file.

    :type fileName: string
    :param fileName: name of the file with trace XML export. If you use
                        relative file path, be aware that script working directory is
                        used as a starting point, not winIDEA workspace directory.

    Python example: traceData.py

    |

    *Overload 3:*

    This factory method returns initialized object for parsing of binary trace files.
    Use this method when trace data was exported to binary file.

    :type fileName: string
    :param fileName: name of the file with trace binary export. If you use
                        relative file path, be aware that script working directory is
                        used as a starting point, not winIDEA workspace directory.

    :type exportConfig: :py:class:`CTraceBinExportFormat`
    :param exportConfig: this object is used to obtain information about export
                            format. First the header presence and version are obtained.
                            If there is no header or the version is less than 2, then
                            other flags in this object are used to get the exact file
                            format.
                            If header is present and version is 2, then exact format
                            is retrieved from the file and other settings in this object
                            are ignored.

    Python example: traceData.py
    """
    return _connect.CTraceData_createInstance(*args)

class CTraceConfigWizard(object):
    r"""
    This class can be used to configure trace in a similar way as it
    is done via GUI wizard. To get instance of this class, use one of the static
    factory methods.

    trace2Example.py Python example
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    ERead = _connect.CTraceConfigWizard_ERead
    r""" read access"""
    EWrite = _connect.CTraceConfigWizard_EWrite
    r""" write access"""
    EReadWrite = _connect.CTraceConfigWizard_EReadWrite
    r""" read-write access"""
    EWidthAny = _connect.CTraceConfigWizard_EWidthAny
    r""" any width"""
    EWidth1 = _connect.CTraceConfigWizard_EWidth1
    r""" width of 1 MAU"""
    EWidth2 = _connect.CTraceConfigWizard_EWidth2
    r""" width of 2 MAUs"""
    EWidth4 = _connect.CTraceConfigWizard_EWidth4
    r""" width of 4 MAUs"""
    ERisingEdge = _connect.CTraceConfigWizard_ERisingEdge
    r""" rising edge"""
    EFallingEdge = _connect.CTraceConfigWizard_EFallingEdge
    r""" falling edge"""
    EAUXState = _connect.CTraceConfigWizard_EAUXState
    ERecordEverything = _connect.CTraceConfigWizard_ERecordEverything
    r""" record everything"""
    ERecordProgramFlow = _connect.CTraceConfigWizard_ERecordProgramFlow
    r""" record program flow"""
    ERecordDataAccess = _connect.CTraceConfigWizard_ERecordDataAccess
    r""" record data access"""
    ERecordInstrumentationMsgs = _connect.CTraceConfigWizard_ERecordInstrumentationMsgs
    r""" record instrumentation messages OTM/ITM"""
    ESamplesBefore = _connect.CTraceConfigWizard_ESamplesBefore
    r""" record few samples before"""
    ESamplesAfter = _connect.CTraceConfigWizard_ESamplesAfter
    r""" record few samples after"""
    ESamplesBeforeAndAfter = _connect.CTraceConfigWizard_ESamplesBeforeAndAfter
    r""" record few samples before and after"""
    EAllTheTime = _connect.CTraceConfigWizard_EAllTheTime
    r""" record all the time"""
    EBetweenTwoEvents = _connect.CTraceConfigWizard_EBetweenTwoEvents
    r""" record between two events"""

    @staticmethod
    def createImmediateTrigger() -> "CTraceConfigWizard":
        r"""
        This method creates trigger configuration equal to selecting
        'Trigger Immediately' radio button in trace wizard GUI.
        """
        return _connect.CTraceConfigWizard_createImmediateTrigger()

    @staticmethod
    def createDataAccessTrigger(*args) -> "CTraceConfigWizard":
        r"""
        *Overload 1:*

        This method creates trigger configuration for data access event.

        :type varName: string
        :param varName: name of a variable or literal address, where access
                           triggers trace recording
        :type isCoverEntireObject: boolean
        :param isCoverEntireObject: if true, access to entire object is monitored
        :type endAddress: string
        :param endAddress: name of variable or literal address, where monitoring
                              for trigger ends
        :type accessType: int
        :param accessType: type of memory access

        |

        *Overload 2:*

        This method creates trigger configuration for data access event.

        :type varName: string
        :param varName: name of a variable or literal address, where access
                           triggers trace recording
        :type isCoverEntireObject: boolean
        :param isCoverEntireObject: if true, access to entire object is monitored
        :type endAddress: string
        :param endAddress: name of variable or literal address, where monitoring
                              for trigger ends
        :type accessType: int
        :param accessType: type of memory access

        :type dataWidth: int
        :param dataWidth: data width type
        """
        return _connect.CTraceConfigWizard_createDataAccessTrigger(*args)

    @staticmethod
    def createCodeExecTrigger(funcName: "std::string const &") -> "CTraceConfigWizard":
        r"""
        This method creates trigger configuration for code execution event.

        :type funcName: string
        :param funcName: name of a function or literal address, where execution
                            triggers trace recording

        trace2Example.py Python example
        """
        return _connect.CTraceConfigWizard_createCodeExecTrigger(funcName)

    @staticmethod
    def createAUXStateTrigger(signalsMask: "DWORD", signalsValue: "DWORD") -> "CTraceConfigWizard":
        r"""This method creates trigger configuration for AUX signals state event."""
        return _connect.CTraceConfigWizard_createAUXStateTrigger(signalsMask, signalsValue)

    @staticmethod
    def createAUXEdgeTrigger(edgeType: "isys::CTraceConfigWizard::EEdgeType", signalNumber: "int") -> "CTraceConfigWizard":
        r"""This method creates trigger configuration for AUX signals edge event."""
        return _connect.CTraceConfigWizard_createAUXEdgeTrigger(edgeType, signalNumber)

    def setRecordingContent(self, *args) -> "void":
        r"""
        If this method is not called, then 'Record Everything' is configured.
        If more detailed configuration is required, call it for each
        ERecordingContent, which you want to record.

        :type recType: int
        :param recType: if set to ERecordEverything, then all other recording
                           settings are reset. Other function parameters are ignored.
        :type identifierOrStartAddr: string, optional
        :param identifierOrStartAddr: name of function or variable (depending on recType),
                                         or literal start address of area to trace
        :type identifierOrEndAddr: string, optional
        :param identifierOrEndAddr: name of function or variable (depending on recType),
                                       or literal end address of area to trace
        :type accessType: int, optional
        :param accessType: memory access type, used only when recType == ERecordDataAccess.
        """
        return _connect.CTraceConfigWizard_setRecordingContent(self, *args)

    def setRecordingAttibutes(self, samplesOffsetType: "isys::CTraceConfigWizard::ESamplesOffset", recordingDuration: "isys::CTraceConfigWizard::ERecordingDuration") -> "void":
        r"""
        This method sets additional recording properties.

        :type samplesOffsetType: int
        :param samplesOffsetType: defines any additional samples to record
        :type recordingDuration: int
        :param recordingDuration: defines the recording duration
        """
        return _connect.CTraceConfigWizard_setRecordingAttibutes(self, samplesOffsetType, recordingDuration)

    def setProcess(self, name: "std::string const &") -> "void":
        r"""
        This method sets process name
         :type name: string
         :param name: process name
        """
        return _connect.CTraceConfigWizard_setProcess(self, name)

    def configureOptions(self, ide: "CIDEController", docFileName: "std::string const &", triggerIdx: "int") -> "void":
        return _connect.CTraceConfigWizard_configureOptions(self, ide, docFileName, triggerIdx)
    __swig_destroy__ = _connect.delete_CTraceConfigWizard

# Register CTraceConfigWizard in _connect:
_connect.CTraceConfigWizard_swigregister(CTraceConfigWizard)

def CTraceConfigWizard_createImmediateTrigger() -> "CTraceConfigWizard":
    r"""
    This method creates trigger configuration equal to selecting
    'Trigger Immediately' radio button in trace wizard GUI.
    """
    return _connect.CTraceConfigWizard_createImmediateTrigger()

def CTraceConfigWizard_createDataAccessTrigger(*args) -> "CTraceConfigWizard":
    r"""
    *Overload 1:*

    This method creates trigger configuration for data access event.

    :type varName: string
    :param varName: name of a variable or literal address, where access
                       triggers trace recording
    :type isCoverEntireObject: boolean
    :param isCoverEntireObject: if true, access to entire object is monitored
    :type endAddress: string
    :param endAddress: name of variable or literal address, where monitoring
                          for trigger ends
    :type accessType: int
    :param accessType: type of memory access

    |

    *Overload 2:*

    This method creates trigger configuration for data access event.

    :type varName: string
    :param varName: name of a variable or literal address, where access
                       triggers trace recording
    :type isCoverEntireObject: boolean
    :param isCoverEntireObject: if true, access to entire object is monitored
    :type endAddress: string
    :param endAddress: name of variable or literal address, where monitoring
                          for trigger ends
    :type accessType: int
    :param accessType: type of memory access

    :type dataWidth: int
    :param dataWidth: data width type
    """
    return _connect.CTraceConfigWizard_createDataAccessTrigger(*args)

def CTraceConfigWizard_createCodeExecTrigger(funcName: "std::string const &") -> "CTraceConfigWizard":
    r"""
    This method creates trigger configuration for code execution event.

    :type funcName: string
    :param funcName: name of a function or literal address, where execution
                        triggers trace recording

    trace2Example.py Python example
    """
    return _connect.CTraceConfigWizard_createCodeExecTrigger(funcName)

def CTraceConfigWizard_createAUXStateTrigger(signalsMask: "DWORD", signalsValue: "DWORD") -> "CTraceConfigWizard":
    r"""This method creates trigger configuration for AUX signals state event."""
    return _connect.CTraceConfigWizard_createAUXStateTrigger(signalsMask, signalsValue)

def CTraceConfigWizard_createAUXEdgeTrigger(edgeType: "isys::CTraceConfigWizard::EEdgeType", signalNumber: "int") -> "CTraceConfigWizard":
    r"""This method creates trigger configuration for AUX signals edge event."""
    return _connect.CTraceConfigWizard_createAUXEdgeTrigger(edgeType, signalNumber)

class CProfilerStatus(object):
    r"""
    This class contains profiler status. It should not be instantiated by
    clients. Call CProfilerController::getStatus() to get instance of this class.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getNoOfSamples(self) -> "int":
        r"""
        Returns the number of recorded or analyzed samples, depending
        on flags of CProfilerController::getStatus() method.
        """
        return _connect.CProfilerStatus_getNoOfSamples(self)

    def isMustInit(self) -> "bool":
        r""" Returns true, if profiler must be initialized."""
        return _connect.CProfilerStatus_isMustInit(self)

    def isIdle(self) -> "bool":
        r""" Returns true, if profiler is idle."""
        return _connect.CProfilerStatus_isIdle(self)

    def isWaiting(self) -> "bool":
        r""" Returns true, if profiler is waiting for trigger."""
        return _connect.CProfilerStatus_isWaiting(self)

    def isActive(self) -> "bool":
        r""" Returns true, if profiler is recording."""
        return _connect.CProfilerStatus_isActive(self)

    def isErrorInBuffer(self) -> "bool":
        r""" Returns true, if there was error in buffer."""
        return _connect.CProfilerStatus_isErrorInBuffer(self)

    def isBufferOverrun(self) -> "bool":
        r""" Returns true, if there was buffer overrun."""
        return _connect.CProfilerStatus_isBufferOverrun(self)

    def isRecordingError(self) -> "bool":
        r""" Returns true, if there was error in recording."""
        return _connect.CProfilerStatus_isRecordingError(self)

    def isError(self) -> "bool":
        r""" Returns true if any of the above errors occurs."""
        return _connect.CProfilerStatus_isError(self)

    def isLoading(self) -> "bool":
        r""" Returns true, if profiler is loading data to PC."""
        return _connect.CProfilerStatus_isLoading(self)

    def getAnalysisError(self) -> "int":
        r""" Returns profiler analysis error code. If there was no error, 0 is returned."""
        return _connect.CProfilerStatus_getAnalysisError(self)

    def toString(self) -> "std::string":
        r""" Returns object data as YAML string."""
        return _connect.CProfilerStatus_toString(self)
    __swig_destroy__ = _connect.delete_CProfilerStatus

# Register CProfilerStatus in _connect:
_connect.CProfilerStatus_swigregister(CProfilerStatus)

class CProfilerStatistic(object):
    r"""
    This class contains statistic results for one profiler area.

    Deprecated: Use CProfilerController2 class instead of CProfilerController.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CProfilerStatistic_swiginit(self, _connect.new_CProfilerStatistic())

    def getHandle(self) -> "DWORD":
        r""" Returns handle of the area, related to these profiler results."""
        return _connect.CProfilerStatistic_getHandle(self)

    def getValue(self) -> "DWORD":
        r"""
        Returns value of the data, related to these profiler results. Valid only for
                   data areas.
        """
        return _connect.CProfilerStatistic_getValue(self)

    def getMinTime(self) -> "int64_t":
        r""" Returns min time spent in function or min duration of the data value."""
        return _connect.CProfilerStatistic_getMinTime(self)

    def getMaxTime(self) -> "int64_t":
        r""" Returns max time spent in function or max duration of the data value."""
        return _connect.CProfilerStatistic_getMaxTime(self)

    def getTotalTime(self) -> "int64_t":
        r""" Returns total time spent in function or total duration of the data value."""
        return _connect.CProfilerStatistic_getTotalTime(self)

    def getNumHits(self) -> "DWORD":
        r""" Returns how many times the function was called or data changed to the value."""
        return _connect.CProfilerStatistic_getNumHits(self)

    def toString(self) -> "std::string":
        r"""
         Returns object's data as YAML string. This method is intended for debugging
        purposes only, do not parse the returned data!
        """
        return _connect.CProfilerStatistic_toString(self)
    __swig_destroy__ = _connect.delete_CProfilerStatistic

# Register CProfilerStatistic in _connect:
_connect.CProfilerStatistic_swigregister(CProfilerStatistic)

class CProfilerHistory(object):
    r"""
    This class contains history results for one profiler area.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CProfilerHistory_swiginit(self, _connect.new_CProfilerHistory(*args))

    def getSProfilerHistory(self) -> "SProfilerHistory &":
        r"""When wrapper class lacks some functionality, use this access."""
        return _connect.CProfilerHistory_getSProfilerHistory(self)

    def getHandle(self) -> "DWORD":
        r""" Returns handle of the area, related to these profiler results."""
        return _connect.CProfilerHistory_getHandle(self)

    def getHitTime(self) -> "int64_t":
        r"""Returns time, when the function started execution or data changed."""
        return _connect.CProfilerHistory_getHitTime(self)

    def getValue(self) -> "DWORD":
        r"""
        Returns data value.
        Use this method only when querying data items, which were
        obtained by getHistoryAll() or getHistoryForHandle().
        Otherwise use methods isActive() and isInactive()
        """
        return _connect.CProfilerHistory_getValue(self)

    def isActive(self) -> "bool":
        r"""
        :rtype: boolean
        :return: For functions: The function is currently executing
                    For data: The value is equal to the filtered one
        """
        return _connect.CProfilerHistory_isActive(self)

    def isInactive(self) -> "bool":
        r"""
        :rtype: boolean
        :return: For functions: The function is currently not executing.
                    Note, that it may be on stack - has called another function.
                    For data: The value is NOT equal to the filtered one
        """
        return _connect.CProfilerHistory_isInactive(self)

    def toString(self) -> "std::string":
        r""" Returns object data as YAML string."""
        return _connect.CProfilerHistory_toString(self)
    __swig_destroy__ = _connect.delete_CProfilerHistory

# Register CProfilerHistory in _connect:
_connect.CProfilerHistory_swigregister(CProfilerHistory)

class CProfilerCapabilities(object):
    r"""
    This class provides information about profiler capabilities.
    Clients should not instantiate this class. Call
    method CProfilerController::getCapabilities() to get instance of this class.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CProfilerCapabilities_swiginit(self, _connect.new_CProfilerCapabilities())

    def getNumExecAreas(self) -> "DWORD":
        r""" Returns the number of execution areas that can be profiled."""
        return _connect.CProfilerCapabilities_getNumExecAreas(self)

    def getNumDataAreas(self) -> "DWORD":
        r""" Returns the number of data areas that can be profiled."""
        return _connect.CProfilerCapabilities_getNumDataAreas(self)

    def getSingleDataWidth(self) -> "int":
        r""" Returns the width of single data in memory addressable units."""
        return _connect.CProfilerCapabilities_getSingleDataWidth(self)

    def isAvailable(self) -> "bool":
        r""" Returns true, if profiler is available."""
        return _connect.CProfilerCapabilities_isAvailable(self)

    def canUseStartingPoint(self) -> "bool":
        r""" Returns true, if profiler can use starting point."""
        return _connect.CProfilerCapabilities_canUseStartingPoint(self)

    def canProfileExec(self) -> "bool":
        r""" Returns true, if profiler can profile execution."""
        return _connect.CProfilerCapabilities_canProfileExec(self)

    def canProfileFuncLines(self) -> "bool":
        r""" Returns true, if profiler can profile functions."""
        return _connect.CProfilerCapabilities_canProfileFuncLines(self)

    def canProfileData(self) -> "bool":
        r""" Returns true, if profiler can profile data."""
        return _connect.CProfilerCapabilities_canProfileData(self)

    def isSingleData(self) -> "bool":
        r""" Returns true, if profiler can profile single data."""
        return _connect.CProfilerCapabilities_isSingleData(self)

    def isSingleDataAddress(self) -> "bool":
        r""" Returns true, if single data requires address specification."""
        return _connect.CProfilerCapabilities_isSingleDataAddress(self)

    def isSingleDataSize(self) -> "bool":
        r""" Returns true, if single data requires size specification."""
        return _connect.CProfilerCapabilities_isSingleDataSize(self)

    def toString(self) -> "std::string":
        r""" Returns object data as YAML string."""
        return _connect.CProfilerCapabilities_toString(self)
    __swig_destroy__ = _connect.delete_CProfilerCapabilities

# Register CProfilerCapabilities in _connect:
_connect.CProfilerCapabilities_swigregister(CProfilerCapabilities)

class CAreaProperties(object):
    r"""This class contains profiler area properties."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, areaName: "std::string const &", handle: "DWORD", address: "ADDRESS"):
        r"""
        Initializes the instance.

        :type areaName: string
        :param areaName: name of the profiler area
        :type handle: int
        :param handle: profiler area handle
        :type address: int
        :param address: profiler area start address
        """
        _connect.CAreaProperties_swiginit(self, _connect.new_CAreaProperties(areaName, handle, address))

    def getName(self) -> "std::string":
        r""" Returns area name."""
        return _connect.CAreaProperties_getName(self)

    def getHandle(self) -> "DWORD":
        r""" Returns area handle."""
        return _connect.CAreaProperties_getHandle(self)

    def getAddress(self) -> "ADDRESS":
        r""" Returns area address."""
        return _connect.CAreaProperties_getAddress(self)

    def toString(self) -> "std::string":
        r""" Returns object data as YAML string."""
        return _connect.CAreaProperties_toString(self)
    __swig_destroy__ = _connect.delete_CAreaProperties

# Register CAreaProperties in _connect:
_connect.CAreaProperties_swigregister(CAreaProperties)

class CProfilerController(object):
    r"""
    *Deprecated* - Use isys::CProfilerController2 instead. 

    This class controls winIDEA profiler.

    Example:


        profiler.startConfiguration(isystem.connect.IConnectProfiler.cfTimeStampTime, "targetInit")
        profiler.addFunction("Type_Simple")
        profiler.start()


    Deprecated: This class is provided for backward compatibility only. Use
    isys::CProfilerController2 instead.




    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        """
        _connect.CProfilerController_swiginit(self, _connect.new_CProfilerController(connectionMgr))
    __swig_destroy__ = _connect.delete_CProfilerController

    def getIConnectProfiler(self) -> "IConnectProfiler2 *":
        r"""
        Returns the **isystem.connect** profiler interface. Use this method only when
        some functionality of the IConnectProfiler2 interface is not accessible
        from this wrapper.
        """
        return _connect.CProfilerController_getIConnectProfiler(self)

    def getCapabilities(self) -> "isys::CProfilerCapabilities":
        r"""
        Returns profiler capabilities.

        :raises: IOException in case of an error
        """
        return _connect.CProfilerController_getCapabilities(self)

    def startConfiguration(self, *args) -> "void":
        r"""
        *Overload 1:*

        Configures profiler for start without waiting for trigger.

        :type startConfigFlags: int
        :param startConfigFlags: define profiler resolution

        |

        *Overload 2:*

        Configures profiler for start when the instruction on the
        specified address will be executed.

        :type startConfigFlags: int
        :param startConfigFlags: define profiler resolution
        :type memArea: BYTE
        :param memArea: memory area of the profiler start address
        :type address: int
        :param address: profiler start address

        |

        *Overload 3:*

        Configures profiler for start when execution of the
        specified function starts.

        :type startConfigFlags: int
        :param startConfigFlags: define profiler resolution
        :type functionName: string
        :param functionName: name of the profiler trigger function

        |

        *Overload 4:*

        Sets the given configuration for profiler. Use this method only if other
        overloaded variants do not support some settings in configuration.

        :type startConfigFlags: int
        :param startConfigFlags: define profiler resolution
        :type pStartingPoint: :py:class:`SProfilerStartingPoint`
        :param pStartingPoint: the starting point
        """
        return _connect.CProfilerController_startConfiguration(self, *args)

    def addFunction(self, functionName: "std::string const &", isIncludeFunctionLines: "bool"=False) -> "void":
        r"""
        Adds function area to the current profiler configuration.

        :type functionName: string
        :param functionName: name of the function to profile
        :type isIncludeFunctionLines: boolean, optional
        :param isIncludeFunctionLines: if true, profiles also each line of a function,
            however accuracy of these results may be low on some systems. Results for each
            line are currently not accessible from isystem.connect interface.
        """
        return _connect.CProfilerController_addFunction(self, functionName, isIncludeFunctionLines)

    def addVariable(self, variableName: "std::string const &", isTaskId: "bool"=False, isSingleData: "bool"=False) -> "void":
        r"""
        Adds variable area to the current profiler configuration.

        :type variableName: string
        :param variableName: name of the variable to profile
        :type isTaskId: boolean, optional
        :param isTaskId: set this to true, if variable is task ID
        :type isSingleData: boolean, optional
        :param isSingleData: set this to true, if variable is the 'single data' (OTM style)
                   object.
        """
        return _connect.CProfilerController_addVariable(self, variableName, isTaskId, isSingleData)

    def addRegion(self, name: "std::string const &", isTaskId: "bool", isSingleData: "bool", byMemArea: "BYTE", aAddress: "DWORD", aSize: "DWORD") -> "void":
        r"""
        Adds memory region to the current profiler configuration.

        :type name: string
        :param name: area name
        :type isTaskId: boolean
        :param isTaskId: set this to true, if area is task ID
        :type isSingleData: boolean
        :param isSingleData: set this to true, if area is the 'single data' (OTM style)
                   object.
        :type byMemArea: BYTE
        :param byMemArea: memory area of the start address
        :type aAddress: int
        :param aAddress: start address of the area
        :param size: size of the area
        """
        return _connect.CProfilerController_addRegion(self, name, isTaskId, isSingleData, byMemArea, aAddress, aSize)

    def addRoutine(self, name: "std::string const &", byMemArea: "BYTE", aAddress: "DWORD", aSize: "DWORD", exits: "AddressVector") -> "void":
        r"""
        Adds profiler area as a low level routine.

        :type name: string
        :param name: area name
        :type byMemArea: BYTE
        :param byMemArea: memory area of the start address
        :type aAddress: int
        :param aAddress: start address of the area
        :param size: size of the area
        :type exits: :py:class:`AddressVector`
        :param exits: points to a vector of ADDRESS_64 type objects, each specifying an exit
                    point from afTypeRoutine object
        """
        return _connect.CProfilerController_addRoutine(self, name, byMemArea, aAddress, aSize, exits)

    def getNumAreas(self) -> "int":
        r"""
        Returns the number of result areas. Area handles have values
        in the range [0, numAreas - 1], so we can easily iterate all areas.
        """
        return _connect.CProfilerController_getNumAreas(self)

    def getAreaProperties(self, *args) -> "isys::CAreaProperties":
        r"""
        *Overload 1:*

        Returns area properties, such as handle and address.

        :type areaName: string
        :param areaName: name of the area, which properties should be returned

        |

        *Overload 2:*

        Returns area properties, such as name and address.

        :type handle: int
        :param handle: handle of the area, which properties should be returned

        |

        *Overload 3:*

        Returns area properties, such as name and handle.

        :type dwResultAreaFlags: int
        :param dwResultAreaFlags: should be IConnectProfiler2::grafTypeExec or
                                     IConnectProfiler2::grafTypeData, depending on address
                                     type
        :param address: address of the area, which properties should be returned
        """
        return _connect.CProfilerController_getAreaProperties(self, *args)

    def start(self) -> "void":
        r"""Starts profiler."""
        return _connect.CProfilerController_start(self)

    def stop(self) -> "bool":
        r"""
        Stops profiler.

        :rtype: boolean
        :return: true, is profiler was running, false if profiler was stopped
        """
        return _connect.CProfilerController_stop(self)

    def getStatus(self, *args) -> "isys::CProfilerStatus":
        r"""
        Polls the profiler status.

        :type statusFlags: int, optional
        :param statusFlags: define the type of information returned in CProfilerStatus.
                   See IConnectProfiler::EGetStatusFlags.
        """
        return _connect.CProfilerController_getStatus(self, *args)

    def getStatisticsAll(self, expectedSize: "size_t", statisticsList: "ProfilerStatisticVector") -> "void":
        r"""
        Retrieves statistic results for all areas. If output vector size equals expectedSize,
        it means that there is more data to retrieve. Increase expected size and call
        this method again to get all data.

        :type expectedSize: int
        :param expectedSize: expected number of statistics items to be returned. If it
            is to small only the specified number of items will be returned. If it is to big,
            to much memory is allocated for local buffer.

        :type statisticsList: :py:class:`StatisticsVector`
        :param statisticsList: the vector, which will contain results on return
        """
        return _connect.CProfilerController_getStatisticsAll(self, expectedSize, statisticsList)

    def getStatisticsForHandle(self, handle: "DWORD", expectedSize: "size_t", statisticsList: "ProfilerStatisticVector") -> "void":
        r"""
        Retrieves statistic results for area with the given handle. If output vector
        size equals expectedSize, it means that there is more data to retrieve.
        Increase expected size and call this method again to get all data.

        :type handle: int
        :param handle: profiler area handle

        :type expectedSize: int
        :param expectedSize: expected number of statistics items to be returned. If it
            is to small only the specified number of items will be returned. If it is to big,
            to much memory is allocated for local buffer.

        :type statisticsList: :py:class:`StatisticsVector`
        :param statisticsList: the vector, which will contain results on return
        """
        return _connect.CProfilerController_getStatisticsForHandle(self, handle, expectedSize, statisticsList)

    def getStatisticsForTask(self, *args) -> "void":
        r"""
        *Overload 1:*

        Retrieves statistic results for task with the given ID, for all areas. If output
        vector size equals expectedSize, it means that there is more data to retrieve.
        Increase expected size and call this method again to get all data.

        :type taskID: int
        :param taskID: ID of the task

        :type expectedSize: int
        :param expectedSize: expected number of statistics items to be returned. If it
            is to small only the specified number of items will be returned. If it is to big,
            to much memory is allocated for local buffer.

        :type statisticsList: :py:class:`StatisticsVector`
        :param statisticsList: the vector, which will contain results on return

        |

        *Overload 2:*

        Retrieves statistic results for task with the given profiler area handle.
        If output vector size equals expectedSize,
        it means that there is more data to retrieve.
        Increase expected size and call this method again to get all data.

        :type handle: int
        :param handle: profiler area handle
        :param taskID: ID of the task

        :type expectedSize: int
        :param expectedSize: expected number of statistics items to be returned. If it
            is to small only the specified number of items will be returned. If it is to big,
            to much memory is allocated for local buffer.

        :type statisticsList: :py:class:`StatisticsVector`
        :param statisticsList: the vector, which will contain results on return
        """
        return _connect.CProfilerController_getStatisticsForTask(self, *args)

    def getStatisticsForValue(self, handle: "DWORD", value: "DWORD", expectedSize: "size_t", statisticsList: "ProfilerStatisticVector") -> "void":
        r"""
        Retrieves statistic results for data area with the given handle and
        value.
        If output vector size equals expectedSize, it means that there is more data to
        retrieve. Increase expected size and call this method again to get all data.

        :type handle: int
        :param handle: profiler area handle
        :param taskID: ID of the task

        :type expectedSize: int
        :param expectedSize: expected number of statistics items to be returned. If it
            is to small only the specified number of items will be returned. If it is to big,
            to much memory is allocated for local buffer.

        :type statisticsList: :py:class:`StatisticsVector`
        :param statisticsList: the vector, which will contain results on return
        """
        return _connect.CProfilerController_getStatisticsForValue(self, handle, value, expectedSize, statisticsList)

    def getHistoryAll(self, startIDx: "DWORD", len: "DWORD", historyList: "ProfilerHistoryVector") -> "void":
        r"""
        Retrieves history of invocations for all areas.

        :param startIdx: start index of array of data to retrieve
        :type len: int
        :param len: number of history items to retrieve
        :type historyList: :py:class:`HistoryVector`
        :param historyList: vector to contain data on return
        """
        return _connect.CProfilerController_getHistoryAll(self, startIDx, len, historyList)

    def getHistoryForHandle(self, handle: "DWORD", startIDx: "DWORD", len: "DWORD", historyList: "ProfilerHistoryVector") -> "void":
        return _connect.CProfilerController_getHistoryForHandle(self, handle, startIDx, len, historyList)

    def getHistoryForTask(self, *args) -> "void":
        return _connect.CProfilerController_getHistoryForTask(self, *args)

    def getHistoryForValue(self, handle: "DWORD", value: "DWORD", startIDx: "DWORD", len: "DWORD", historyList: "ProfilerHistoryVector") -> "void":
        return _connect.CProfilerController_getHistoryForValue(self, handle, value, startIDx, len, historyList)

    def waitUntilLoaded(self, timeout: "int"=0, pollingInterval: "DWORD"=100) -> "bool":
        r"""
        This method polls profiler status with the given polling interval and
        returns when profiler stops loading samples from the hardware, or
        timeout expires.

        :type timeout: int, optional
        :param timeout: timeout in milliseconds. 0 means infinite timeout
        :type pollingInterval: int, optional
        :param pollingInterval: time between two readings of the profiler status
        :rtype: boolean
        :return: true if CPU is in stopped state, false if timeout expired
        """
        return _connect.CProfilerController_waitUntilLoaded(self, timeout, pollingInterval)

# Register CProfilerController in _connect:
_connect.CProfilerController_swigregister(CProfilerController)

class ITestCaseController(object):
    r"""Interface class for test case controllers."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_ITestCaseController

    def init(self) -> "bool":
        return _connect.ITestCaseController_init(self)

    def clean(self) -> "void":
        return _connect.ITestCaseController_clean(self)

    def destroy(self) -> "void":
        return _connect.ITestCaseController_destroy(self)

    def getTestCaseHandle(self) -> "DWORD":
        r"""
        Returns the test case handle. To be used when there is a need for
        other processes to access the test case info.
        """
        return _connect.ITestCaseController_getTestCaseHandle(self)

    def setTestTimeout(self, timeout: "int") -> "void":
        r"""
        Sets timeout in milliseconds for test execution - after this
        timeout the test is terminated.
        """
        return _connect.ITestCaseController_setTestTimeout(self, timeout)

    def createStub(self, *args) -> "CTestStubController":
        return _connect.ITestCaseController_createStub(self, *args)

    def createUserStub(self, functionName: "std::string const &", stubFunctionName: "std::string const &") -> "void":
        return _connect.ITestCaseController_createUserStub(self, functionName, stubFunctionName)

    def getActiveStub(self) -> "CTestStubController":
        return _connect.ITestCaseController_getActiveStub(self)

    def createPersistentVariable(self, variableName: "std::string const &", typeName: "std::string const &") -> "void":
        r"""
        This method creates variable on stack. The variable object
        created with this method is destroyed when the parent
        CSystemTestController object is destroyed. This method may
        *not* be called when unit test is in progress.
        Call initPersistentVars() and modify() to initialize the
        created variable.

        :type variableName: string
        :param variableName: name of the variable to be created

        :type typeName: string
        :param typeName: type of the variable. This should be one of
                            the existing types in the application under
                            test (defined in debug symbol table).

        persistentVars.py Python example. 
        """
        return _connect.ITestCaseController_createPersistentVariable(self, variableName, typeName)

    def deletePersistentVariable(self, variableName: "std::string const &") -> "void":
        r"""
        Deletes variable. Note that method commitDeletedVars() must be called after
        all vars are deleted to apply changes on the target.

        :type variableName: string
        :param variableName: name of the variable to be deleted. The variable
                                had to be created with createVariable() before this call.

        :param flags: see IConnectTest::ECreateVariableExFlags
        """
        return _connect.ITestCaseController_deletePersistentVariable(self, variableName)

    def commitDeletedVars(self) -> "void":
        r"""Deletes variables deleted with deleteVariable() on the target."""
        return _connect.ITestCaseController_commitDeletedVars(self)

    def initPersistentVars(self) -> "void":
        r"""
        Allocates persistent variables, which were created
        with createPersistentVariable(), on the stack. When persistent
        variables are no longer needed, call cleanPersistentVars().
        """
        return _connect.ITestCaseController_initPersistentVars(self)

    def cleanPersistentVars(self) -> "void":
        r"""Cleans persistent variables from the stack."""
        return _connect.ITestCaseController_cleanPersistentVars(self)

    def setTestBatchNS(self, isBatchBegin: "bool") -> "void":
        return _connect.ITestCaseController_setTestBatchNS(self, isBatchBegin)

    def setDebugModeOn(self) -> "void":
        return _connect.ITestCaseController_setDebugModeOn(self)

    def evaluate(self, expression: "std::string const &", dwEvalFlags: "DWORD"=0) -> "std::string":
        return _connect.ITestCaseController_evaluate(self, expression, dwEvalFlags)

    def modify(self, lval: "std::string const &", rval: "std::string const &", dwEvalFlags: "DWORD"=0) -> "std::string":
        return _connect.ITestCaseController_modify(self, lval, rval, dwEvalFlags)

    def modifyAsString(self, lval: "std::string const &", rval: "std::string const &", dwEvalFlags: "DWORD"=0) -> "void":
        return _connect.ITestCaseController_modifyAsString(self, lval, rval, dwEvalFlags)

    def getStatus(self, *args) -> "IConnectTest::EState":
        return _connect.ITestCaseController_getStatus(self, *args)

    def run(self) -> "void":
        return _connect.ITestCaseController_run(self)

    def waitUntilStopped(self, timeout: "int"=0, pollingInterval: "DWORD"=100) -> "bool":
        return _connect.ITestCaseController_waitUntilStopped(self, timeout, pollingInterval)

# Register ITestCaseController in _connect:
_connect.ITestCaseController_swigregister(ITestCaseController)

class CTestCaseController(ITestCaseController):
    r"""
    This class provides low level interface for configuration and
    execution of unit tests. Tests are executed on target without
    code instrumentation.


    Each test case has its life-cycle composed of several possible
    states. The figure below shows available states and events,
    which trigger transition between states. Event names with '()'
    are methods from this class, which trigger the transition.

    Image: IConnectTest-StatechartDiagram.jpg

    The following rules apply for data access:
    - Function parameters may be created and evaluated only in state ``initialized``.
    - Return value is only available in state ``ended``.
    - local variables (created with createVariable())can be accessed in any state except ``offline``.

    Python example: lowLevelAPI.py 

    Python example with script callbacks: scriptCallbackMethods.py 

    Python example for comparison of high and low level APIs: itestSpecVsTestControllerSample.py 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Creates test case for the given function. The test case declaration
        is stored in winIDEA buffer, and does not get on target until it is
        initialized. Only one test case may be in initialized state.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection to winIDEA

        :type functionName: string
        :param functionName: name of the function to test

        :type retValName: string
        :param retValName: name of the variable used to store the
                              function return value, so that it can be
                              used after test for verification. May be empty
                              string if it is not used by test or function
                              is of type void.

        |

        *Overload 2:*

        Creates test case controller for the given handle. When using this ctor,
        test case controller with the given handle must exist, and this instance
        is valid only as long as the original controller exists. The purpose of
        this ctor is to be used from Python, when original controller was created
        in testIDEA. We can not pass pointers to other processes, so we pass a handle
        when Python script functions are being called during test.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection to winIDEA

        :type testCaseHandle: int
        :param testCaseHandle: handle of existing test case
        """
        _connect.CTestCaseController_swiginit(self, _connect.new_CTestCaseController(*args))
    __swig_destroy__ = _connect.delete_CTestCaseController

    def destroy(self) -> "void":
        r"""
        Destroys object on the target. If this method is not called,
        the object is destroyed by destructor.

        Python example: lowLevelAPI.py 

        Python example: itestSpecVsTestControllerSample.py 
        """
        return _connect.CTestCaseController_destroy(self)

    def getTestCaseHandle(self) -> "DWORD":
        r"""
        Returns the test case handle. To be used when there is a need for
        other processes to access the test case info.
        """
        return _connect.CTestCaseController_getTestCaseHandle(self)

    def createParameter(self, *args) -> "void":
        r"""
        Creates function parameter and assignes a name to it, because
        debug information does not provide it.

        :type parameterIndex: int
        :param parameterIndex: 0-based index of parameter in function parameter list

        :type parameterName: string
        :param parameterName: name of parameter to be used when setting it's value.

        Python example: lowLevelAPI.py 

        Python example: itestSpecVsTestControllerSample.py 
        """
        return _connect.CTestCaseController_createParameter(self, *args)

    def createVariable(self, *args) -> "void":
        r"""
        Utility method for variable creation. The variable object created
        with this method is destroyed when the parent CTestCaseController
        object is destroyed.

        :type variableName: string
        :param variableName: name of the variable to be created

        :type typeName: string
        :param typeName: type of the variable. This should be one of
                            the existing types in the application under
                            test (defined in debug symbol table).

        :type flags: int, optional
        :param flags: see IConnectTest::ECreateVariableExFlags

        Python example: testCaseExample2.py 
        """
        return _connect.CTestCaseController_createVariable(self, *args)

    def deletePersistentVariable(self, variableName: "std::string const &") -> "void":
        r"""See also: ITestCaseController::deletePersistentVariable()"""
        return _connect.CTestCaseController_deletePersistentVariable(self, variableName)

    def commitDeletedVars(self) -> "void":
        r"""See also: ITestCaseController::commitDeletedVars()"""
        return _connect.CTestCaseController_commitDeletedVars(self)

    def setTestTimeout(self, timeout: "int") -> "void":
        return _connect.CTestCaseController_setTestTimeout(self, timeout)

    def createStub(self, *args) -> "CTestStubController":
        r"""
        *Overload 1:*

        Utility method for stub creation. The stub object created
        with this method is destroyed when the parent CTestCaseController
        object is destroyed. Breakpoints for stubs created with this method are
        managed automatically by winIDEA.

        :type functionName: string
        :param functionName: name of the stubbed function

        |

        *Overload 2:*

        Utility method for stub creation. The stub object created
        with this method is destroyed when the parent CTestCaseController
        object is destroyed.

        :param functionName: name of the stubbed function
        :type flags: int
        :param flags: see IConnectTest::EStubFlags
        """
        return _connect.CTestCaseController_createStub(self, *args)

    def createUserStub(self, functionName: "std::string const &", stubFunctionName: "std::string const &") -> "void":
        r"""
        This method creates user stub. If ``stubFunctionName`` parameter
        is not empty, then execution continues on stub method on the target,
        when this stub is hit. If the ``stubFunctionName``  parameter is empty string,
        then return instruction is inserted at the start of the stubbed function.

        For the first approach with target function name in ``stubFunctionName``,
        we have to provide additional function on target,
        with the same prototype as stubbed methods.

        The second approach with immediate return should be used only for
        void functions without output parameters.

        :type functionName: string
        :param functionName: name of the stubbed function
        :type stubFunctionName: string
        :param stubFunctionName: name of the function, which should be
                                    called instead of the stubbed function, or
                                    an empty string
        """
        return _connect.CTestCaseController_createUserStub(self, functionName, stubFunctionName)

    def getActiveStub(self) -> "CTestStubController":
        r"""
        When test case execution stops at stub, this method returns
        the stub controller. It can be used to set stub return value
        and other variables. This method should only be called when
        the method getStatus() returns IConnectTest::stateStub.
        """
        return _connect.CTestCaseController_getActiveStub(self)

    def createPersistentVariable(self, variableName: "std::string const &", typeName: "std::string const &") -> "void":
        return _connect.CTestCaseController_createPersistentVariable(self, variableName, typeName)

    def initPersistentVars(self) -> "void":
        return _connect.CTestCaseController_initPersistentVars(self)

    def cleanPersistentVars(self) -> "void":
        return _connect.CTestCaseController_cleanPersistentVars(self)

    def evaluate(self, expression: "std::string const &", dwEvalFlags: "DWORD"=0) -> "std::string":
        r"""
        Evaluates the given expression and returns result as a string.
        This method is similar to IConnectDebug::Evaluate(). The difference is
        in variable scope, since this method takes into account also variables
        created by createVariable() and the test case return value.


        See state descriptions above for data accessibility.

        :type expression: string
        :param expression: the expression to be evaluated
        :type dwEvalFlags: int, optional
        :param dwEvalFlags: see IConnectTest::EEvaluateFlags

        :rtype: string
        :return: evaluation result

        Python example: testCaseExample2.py 

        Python example: lowLevelAPI.py 
        """
        return _connect.CTestCaseController_evaluate(self, expression, dwEvalFlags)

    def modify(self, expression: "std::string const &", value: "std::string const &", dwEvalFlags: "DWORD"=0) -> "std::string":
        r"""
        Modifies expression to the given value. Expression must be an lvalue.


        See state descriptions above for data accessibility.

        :type expression: string
        :param expression: lvalue to be modified
        :type value: string
        :param value: the value to be assigned to 'expression'
        :type dwEvalFlags: int, optional
        :param dwEvalFlags: see IConnectTest::EEvaluateFlags

        :rtype: string
        :return: evaluation result

        Python example: lowLevelAPI.py 

        Python example: itestSpecVsTestControllerSample.py 

        Python example with callback methods: scriptCallbackMethods.py 
        """
        return _connect.CTestCaseController_modify(self, expression, value, dwEvalFlags)

    def modifyAsString(self, lval: "std::string const &", rval: "std::string const &", dwEvalFlags: "DWORD"=0) -> "void":
        r"""
        Sets lval to rval. If rval is double quoted string, then lval
        must be pointer or array. Assignments lval[i] = 'rval[i]' for
        each element in rval are made. Normal assignment (lval = rval)
        is performed if rval does not start and end with double quote.

        :type lval: string
        :param lval: left-value, for example name of variable, register, ...
        :type rval: string
        :param rval: value to assign. Can be "double quoted" string for string
                        array assignments or array of values for array assignment:
                        {0, 1, 2, 3, 4}
        :type dwEvalFlags: int, optional
        :param dwEvalFlags: see IConnectTest::EEvaluateFlags

        Python example: testCaseExample2.py 
        """
        return _connect.CTestCaseController_modifyAsString(self, lval, rval, dwEvalFlags)

    def getStatus(self, *args) -> "IConnectTest::EState":
        r"""
        *Overload 1:*

        Returns the current test case status.

        Python example: targetCallWithTrace.py 


        |

        *Overload 2:*

        Returns the current test case status.

        :type flags: int
        :param flags: use IConnectTest::EStatusFlags
        """
        return _connect.CTestCaseController_getStatus(self, *args)

    def init(self) -> "bool":
        r"""
        Initializes the test case by initializing environment on
        the target according to function under test. Brings the
        test from limbo state or reinitializes an already
        initialized test case.

        :raises: IllegalStateException if there already exists an
            initialized test case. Call clean() on the active test case
            first.

        :rtype: boolean
        :return: false if ret val was specified and function returns void.
                          Returns true otherwise.

        Python example: lowLevelAPI.py 

        Python example: itestSpecVsTestControllerSample.py 
        """
        return _connect.CTestCaseController_init(self)

    def clean(self) -> "void":
        r"""
        Deprecated: call destroy() instead.

        Python example: lowLevelAPI.py 

        Python example: itestSpecVsTestControllerSample.py 
        """
        return _connect.CTestCaseController_clean(self)

    def setTestBatchNS(self, isBatchBegin: "bool") -> "void":
        r"""
        Marks start of test batch. When ``isBatchBegin`` = ``true``, winIDEA
        remembers the batch start and saves
        target state, but it does not restore it at the end of the test, but only
        when this method is called again with ``isBatchBegin`` is ``false``.
        This method can be called several times with ``isBatchBegin`` = ``true``,
        but it must be called the same number of times with ``isBatchBegin`` = ``false``
        to restore the state. Postfix NS stands for non-static. Use ctor
        CTestCaseController(std::shared_ptr<ConnectionMgr> connectionMgr, 0) to
        instantiate object for calling this method.

        :type isBatchBegin: boolean
        :param isBatchBegin: when true, winIDEA saves target state, when false, it is restored.

        See also: setTestBatch(ConnectionMgrSPtr, bool)
        """
        return _connect.CTestCaseController_setTestBatchNS(self, isBatchBegin)

    def setDebugModeOn(self) -> "void":
        r"""
        Turns debug mode on for the next test case. Speed optimizations
        will be disabled, so winIDEA UI will be refreshed. This method must
        be called after method ``init()`` to have effect.
        """
        return _connect.CTestCaseController_setDebugModeOn(self)

    @staticmethod
    def setTestBatch(connectionMgr: "isys::ConnectionMgrSPtr", isBatchBegin: "bool") -> "void":
        r"""
        Static variant of setTestBatchNS(bool) .
        See also: setTestBatchNS(bool)
        """
        return _connect.CTestCaseController_setTestBatch(connectionMgr, isBatchBegin)

    def run(self) -> "void":
        r"""
        Runs an initialized test case; it has no effect if the test
        case is not initialized (i.e. in limbo); valid only if the
        test case is clean initialized (not valid for resume).

        Python example: lowLevelAPI.py 

        Python example: itestSpecVsTestControllerSample.py 
        """
        return _connect.CTestCaseController_run(self)

    def abort(self) -> "void":
        r"""
        Aborts the test case, regardless of it's status. It has no
        effect if the test case is not initialized (i.e. in limbo state).
        """
        return _connect.CTestCaseController_abort(self)

    def pause(self) -> "void":
        r"""
        Pauses a running test case. Valid only if the test case is
        in running state.
        """
        return _connect.CTestCaseController_pause(self)

    @staticmethod
    def clearAllTests(connection: "std::shared_ptr< isys::ConnectionMgr >") -> "void":
        r"""
        Removes all test data from isystem.connect. All existing instances of
        this class should be destroyed, because their handles are no
        longer valid. Use this method when the state of the
        ``iconnect.test`` is not known, for example at application
        startup, to remove any data that remained from the previous run.
        """
        return _connect.CTestCaseController_clearAllTests(connection)

    def waitUntilStopped(self, timeoutMs: "int"=0, pollingIntervalMs: "DWORD"=100) -> "bool":
        r"""
        This method polls test execution status with the given polling interval and
        returns when the test stops or timeout expires. The test may stop for
        several reasons. To get the reason, call the getStatus() method.

        :param timeout: timeout in milliseconds. 0 means infinite timeout
        :param pollingInterval: time in milliseconds between two readings of the test status

        :rtype: boolean
        :return: true if the test is in stopped state, false if timeout expired

        Python example: lowLevelAPI.py 

        Python example: itestSpecVsTestControllerSample.py 
        """
        return _connect.CTestCaseController_waitUntilStopped(self, timeoutMs, pollingIntervalMs)

    @staticmethod
    def testState2str(state: "IConnectTest::EState") -> "std::string":
        r"""
        Converts test state to enum string. This is a utility function for logging
        and error reporting. Program logic should always use enum directly.
        If enum value can't be mapped
        to one of defined values, the return string contains its integer
        representation.
        """
        return _connect.CTestCaseController_testState2str(state)

    def stubState2str(self, state: "IConnectTest::EStubState") -> "std::string":
        r"""
        Converts stub state to enum string. This is a utility function for logging
        and error reporting. Program logic should always use enum directly.
        If enum value can't be mapped
        to one of defined values, the return string contains its integer
        representation.
        """
        return _connect.CTestCaseController_stubState2str(self, state)

    @staticmethod
    def s2i64(numStr: "std::string const &") -> "int64_t":
        r"""
        Utility method for string to number conversion. It accepts numbers
        in decimal, hexadecimal formats and character formats, for
        example: "16", "0x10", and "\xFF".
        No leading spaces are allowed or signs for decimal numbers.

        Python example: itestSpecVsTestControllerSample.py 
        """
        return _connect.CTestCaseController_s2i64(numStr)

    @staticmethod
    def verifyRetVal(icTest: "IConnectTest", retVal: "unsigned long", description: "std::string const &", handle: "DWORD", objectId: "std::string const &") -> "void":
        return _connect.CTestCaseController_verifyRetVal(icTest, retVal, description, handle, objectId)

# Register CTestCaseController in _connect:
_connect.CTestCaseController_swigregister(CTestCaseController)
CTestCaseController.POSITION_PARAM_NAME_PREFIX = _connect.cvar.CTestCaseController_POSITION_PARAM_NAME_PREFIX

def CTestCaseController_setTestBatch(connectionMgr: "isys::ConnectionMgrSPtr", isBatchBegin: "bool") -> "void":
    r"""
    Static variant of setTestBatchNS(bool) .
    See also: setTestBatchNS(bool)
    """
    return _connect.CTestCaseController_setTestBatch(connectionMgr, isBatchBegin)

def CTestCaseController_clearAllTests(connection: "std::shared_ptr< isys::ConnectionMgr >") -> "void":
    r"""
    Removes all test data from isystem.connect. All existing instances of
    this class should be destroyed, because their handles are no
    longer valid. Use this method when the state of the
    ``iconnect.test`` is not known, for example at application
    startup, to remove any data that remained from the previous run.
    """
    return _connect.CTestCaseController_clearAllTests(connection)

def CTestCaseController_testState2str(state: "IConnectTest::EState") -> "std::string":
    r"""
    Converts test state to enum string. This is a utility function for logging
    and error reporting. Program logic should always use enum directly.
    If enum value can't be mapped
    to one of defined values, the return string contains its integer
    representation.
    """
    return _connect.CTestCaseController_testState2str(state)

def CTestCaseController_s2i64(numStr: "std::string const &") -> "int64_t":
    r"""
    Utility method for string to number conversion. It accepts numbers
    in decimal, hexadecimal formats and character formats, for
    example: "16", "0x10", and "\xFF".
    No leading spaces are allowed or signs for decimal numbers.

    Python example: itestSpecVsTestControllerSample.py 
    """
    return _connect.CTestCaseController_s2i64(numStr)

def CTestCaseController_verifyRetVal(icTest: "IConnectTest", retVal: "unsigned long", description: "std::string const &", handle: "DWORD", objectId: "std::string const &") -> "void":
    return _connect.CTestCaseController_verifyRetVal(icTest, retVal, description, handle, objectId)

class CTestStubController(object):
    r"""
    This class wraps test case stubs, which are created, used, and
    destroyed by IControlTest class. Stubs may have lifetime different
    than single test case, for example they may be used by several test cases.


    Stub replaces function called by function under test. Since no
    code instrumentation is allowed, only breakpoint is set at the given
    function. When the function is called, the test case execution stops,
    and then the test framework can define next actions. Usually it will
    simulate desired side effects of a stubbed function (for example set
    return value, local and global variables), and then continue execution of the
    function under test.


    Destructor automatically destroys the stub on the target.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SCRIPT_STUB = _connect.CTestStubController_E_SCRIPT_STUB
    r"""
    stub is implemented as breakpoint at the start of the
    stubbed function. Target stops and program (script) on PC takes control
    """
    E_RT_USER_STUB = _connect.CTestStubController_E_RT_USER_STUB
    r""" user specified function on a target is called instead of the stubbed function"""
    E_RT_EMPTY_STUB = _connect.CTestStubController_E_RT_EMPTY_STUB
    r"""
    the stubbed function is not executed, but ths execution immediately
    returns to the caller
    """

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Creates empty controller, call method create() to actually create
        stub in winIDEA. Use this ctor, when greater flexibility is required
        for stub creation (for example, when  stub breakpoint setting should
        not be managed by winIDEA (for example, when there are not enough HW BPs)).

        |

        *Overload 2:*

        Creates function stub on the target.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection to winIDEA

        :type stubbedFunctionName: string
        :param stubbedFunctionName: name of the function to be stubbed
        """
        _connect.CTestStubController_swiginit(self, _connect.new_CTestStubController(*args))
    __swig_destroy__ = _connect.delete_CTestStubController

    def create(self, flags: "IConnectTest::EStubFlags", stubbedFunctionName: "std::string const &") -> "void":
        r"""
        Creates stub in winIDEA.

        :type flags: int
        :param flags: see IConnectTest::EStubFlags
        :type stubbedFunctionName: string
        :param stubbedFunctionName: name of the function to be stubbed
        """
        return _connect.CTestStubController_create(self, flags, stubbedFunctionName)

    def createParameter(self, parameterIndex: "DWORD", parameterName: "std::string const &") -> "void":
        r"""
         Assigns a name to stub parameter at the given position.
        The assigned name may be used in expressions by
        CTestCaseController::evaluateExpression() and
        CTestCaseController::modifyExpression().

        :type parameterIndex: int
        :param parameterIndex: 0 - based parameter index
        :type parameterName: string
        :param parameterName: name assigned to parameter
        """
        return _connect.CTestStubController_createParameter(self, parameterIndex, parameterName)

    def createReturnValue(self, retValName: "std::string const &") -> "void":
        r"""
        Assigns a name to stub return value.
        The assigned name may be used in expressions by
        CTestCaseController::evaluateExpression() and
        CTestCaseController::modifyExpression() to define value returned
        to the function under test.

        :type retValName: string
        :param retValName: name assigned to return value
        """
        return _connect.CTestStubController_createReturnValue(self, retValName)

    def getStubName(self) -> "std::string":
        r""" Returns stub name."""
        return _connect.CTestStubController_getStubName(self)

    def getRetValName(self) -> "std::string":
        r""" Returns return value name."""
        return _connect.CTestStubController_getRetValName(self)

    def getHandle(self) -> "DWORD":
        r""" Returns handle as used by IConnectTest."""
        return _connect.CTestStubController_getHandle(self)

# Register CTestStubController in _connect:
_connect.CTestStubController_swigregister(CTestStubController)

class CSystemTestController(ITestCaseController):
    r"""
    This class can create and execute tests, which are not limited
    to single function. We can initialize target and start test
    programatically, and then the same way stop the target and
    analyze the target state (registers, variables, ...).

    API implemented by this class is relatively low lever. Python clients are
    advised to use the PTestCase class.

    persistentVars.py Python example. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection to winIDEA
        """
        _connect.CSystemTestController_swiginit(self, _connect.new_CSystemTestController(connectionMgr))
    __swig_destroy__ = _connect.delete_CSystemTestController

    def init(self) -> "bool":
        r"""
        Applies created stubs on the target. Call this method before
        running target.
        """
        return _connect.CSystemTestController_init(self)

    def clean(self) -> "void":
        r"""
        Deprecated: call destroy() instead.

        If this method is not called, objects are destroyed in
        destructor.
        """
        return _connect.CSystemTestController_clean(self)

    def destroy(self) -> "void":
        r"""
        Destroys all items related to test, for example stubs, and persistent
        variables.

        If this method is not called, objects are destroyed in
        destructor.
        """
        return _connect.CSystemTestController_destroy(self)

    def getTestCaseHandle(self) -> "DWORD":
        return _connect.CSystemTestController_getTestCaseHandle(self)

    def createPersistentVariable(self, variableName: "std::string const &", typeName: "std::string const &") -> "void":
        r"""
        This method creates variable on stack. The variable object
        created with this method is destroyed when the parent
        CSystemTestController object is destroyed. This method may
        *not* be called when unit test is in progress.
        Call initPersistentVars() and modify() to initialize the
        created variable.

        :type variableName: string
        :param variableName: name of the variable to be created

        :type typeName: string
        :param typeName: type of the variable. This should be one of
                            the existing types in the application under
                            test (defined in debug symbol table).

        persistentVars.py Python example. 
        """
        return _connect.CSystemTestController_createPersistentVariable(self, variableName, typeName)

    def deletePersistentVariable(self, variableName: "std::string const &") -> "void":
        r"""See also: ITestCaseController::deletePersistentVariable()"""
        return _connect.CSystemTestController_deletePersistentVariable(self, variableName)

    def commitDeletedVars(self) -> "void":
        r"""See also: ITestCaseController::commitDeletedVars()"""
        return _connect.CSystemTestController_commitDeletedVars(self)

    def initPersistentVars(self) -> "void":
        r"""
        Allocates persistent variables, which were created
        with createPersistentVariable(), on the stack. When persistent
        variables are no longer needed, call cleanPersistentVars().
        """
        return _connect.CSystemTestController_initPersistentVars(self)

    def cleanPersistentVars(self) -> "void":
        r"""Cleans persistent variables from the stack."""
        return _connect.CSystemTestController_cleanPersistentVars(self)

    def setTestTimeout(self, timeout: "int") -> "void":
        return _connect.CSystemTestController_setTestTimeout(self, timeout)

    def createStub(self, *args) -> "CTestStubController":
        r"""
        *Overload 1:*

        Utility method for stub creation. The stub object created
        with this method is destroyed when the parent
        CSystemTestController object is destroyed. When this stub is
        hit, control is transferred to script running on PC - it
        can modify parameters, set return value and restart
        execution.

        The stub is implemented as breakpoint at the first method
        instruction.

        :type functionName: string
        :param functionName: name of the stubbed function

        Python example: stubsInSysTests.py 

        Python example: stubsAndUserStubsInSysTests.py 


        |

        *Overload 2:*

        Utility method for stub creation. The stub object created
        with this method is destroyed when the parent
        CSystemTestController object is destroyed. When this stub is
        hit, control is transferred to script running on PC - it
        can modify parameters, set return value and restart
        execution.

        The stub is implemented as breakpoint at the first method
        instruction. Breakpoint handling can be automatic or custom
        controlled - see flags.

        :type flags: int
        :param flags: see IConnectTest::EStubFlags
        :type functionName: string
        :param functionName: name of the stubbed function
        """
        return _connect.CSystemTestController_createStub(self, *args)

    def createUserStub(self, functionName: "std::string const &", stubFunctionName: "std::string const &") -> "void":
        r"""
        Utility method for stub creation. The stub object created
        with this method is destroyed when the parent
        CSystemTestController object is destroyed. When this stub is
        hit, execution continues in stub function on the target,
        which replaces stubbed function. We have to provide
        additional functions with the same prototype as stubbed
        functions to be used as stubs.

        The stub is implemented as replacement of the first
        instruction in the stubbed function with jump to the stub function.

        :type functionName: string
        :param functionName: name of the stubbed function
        :type stubFunctionName: string
        :param stubFunctionName: name of the function, which should be
                                    called instead of the stubbed function

        Python example: stubsAndUserStubsInSysTests.py 
        """
        return _connect.CSystemTestController_createUserStub(self, functionName, stubFunctionName)

    def getActiveStub(self) -> "CTestStubController":
        r"""
        When test case execution stops at stub, this method returns
        the stub controller. It can be used to set stub return value
        and other variables. This method should only be called when
        the method ``getStatus()`` returns ``IConnectTest::stateStub``.
        """
        return _connect.CSystemTestController_getActiveStub(self)

    def setTestBatchNS(self, isBatchBegin: "bool") -> "void":
        return _connect.CSystemTestController_setTestBatchNS(self, isBatchBegin)

    def setDebugModeOn(self) -> "void":
        return _connect.CSystemTestController_setDebugModeOn(self)

    def evaluate(self, expression: "std::string const &", dwEvalFlags: "DWORD"=0) -> "std::string":
        r"""
        Evaluates the given expression and returns result as a string.
        This method is similar to IConnectDebug::Evaluate(). The difference is
        in variable scope, since this method takes into account also variables
        created by createPersistentVariable().


        :type expression: string
        :param expression: the expression to be evaluated
        :type dwEvalFlags: int, optional
        :param dwEvalFlags: see IConnectTest::EEvaluateFlags

        :rtype: string
        :return: evaluation result

        Python example: persistentVars.py 

        Python example: stubsInSysTests.py 
        """
        return _connect.CSystemTestController_evaluate(self, expression, dwEvalFlags)

    def modify(self, expression: "std::string const &", value: "std::string const &", dwEvalFlags: "DWORD"=0) -> "std::string":
        r"""
        Modifies expression to the given value. Expression must be an lvalue.


        :type expression: string
        :param expression: lvalue to be modified
        :type value: string
        :param value: the value to be assigned to 'expression'
        :type dwEvalFlags: int, optional
        :param dwEvalFlags: see IConnectTest::EEvaluateFlags

        :rtype: string
        :return: evaluation result

        Python example: persistentVars.py 
        """
        return _connect.CSystemTestController_modify(self, expression, value, dwEvalFlags)

    def modifyAsString(self, expression: "std::string const &", value: "std::string const &", dwEvalFlags: "DWORD"=0) -> "void":
        r"""
        Sets lval to rval. If rval is double quoted string, then lval
        must be pointer or array. Assignments lval[i] = 'rval[i]' for
        each element in rval are made. Normal assignment (lval = rval)
        is performed if rval does not start and end with double quote.

        :param lval: left-value, for example name of variable, register, ...
        :param rval: value to assign. Can be "double quoted" string for string
                        array assignments or array of values for array assignment:
                        {0, 1, 2, 3, 4}
        :type dwEvalFlags: int, optional
        :param dwEvalFlags: see IConnectTest::EEvaluateFlags
        """
        return _connect.CSystemTestController_modifyAsString(self, expression, value, dwEvalFlags)

    def getStatus(self, *args) -> "IConnectTest::EState":
        r"""
        *Overload 1:*

        Returns the current execution status.

        Python example: stubsInSysTests.py 

        Python example: stubsAndUserStubsInSysTests.py 


        |

        *Overload 2:*

        Returns the current execution status.

        :type flags: int
        :param flags: use IConnectTest::EStatusFlags
        """
        return _connect.CSystemTestController_getStatus(self, *args)

    def run(self) -> "void":
        r"""
        Runs the target.

        Python example: stubsInSysTests.py 

        Python example: stubsAndUserStubsInSysTests.py 
        """
        return _connect.CSystemTestController_run(self)

    def stop(self) -> "void":
        r"""
        Stops the target.

        Python example: stubsInSysTests.py 

        Python example: stubsAndUserStubsInSysTests.py 
        """
        return _connect.CSystemTestController_stop(self)

    def waitUntilStopped(self, timeoutMs: "int"=0, pollingIntervalMs: "DWORD"=100) -> "bool":
        r"""
        This method polls test execution status with the given polling interval and
        returns when the target stops or timeout expires. The execution may stop for
        several reasons. To get the reason, call the getStatus() method.

        :param timeout: timeout in milliseconds. 0 means infinite timeout
        :param pollingInterval: time in milliseconds between two readings of the test status

        :rtype: boolean
        :return: true if the test is in stopped state, false if timeout expired

        Python example: stubsInSysTests.py 
        """
        return _connect.CSystemTestController_waitUntilStopped(self, timeoutMs, pollingIntervalMs)

# Register CSystemTestController in _connect:
_connect.CSystemTestController_swigregister(CSystemTestController)

class CDebugFacade(object):
    r"""
    This class is a facade for few other classes. It adds no new
    functionality, but provides all-in-one interface for the most common
    isystem.connect operations. It contains most of the functionality of
    the following classes:
    - CAddressController
    - CBreakpointController
    - CDataController
    - CExecutionController
    - CLoaderController




    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        """
        _connect.CDebugFacade_swiginit(self, _connect.new_CDebugFacade(connectionMgr))
    __swig_destroy__ = _connect.delete_CDebugFacade

    def getAddressController(self) -> "isys::CAddressController &":
        r""" Returns reference to address controller."""
        return _connect.CDebugFacade_getAddressController(self)

    def getBreakpointController(self) -> "isys::CBreakpointController &":
        r""" Returns reference to breakpoint controller."""
        return _connect.CDebugFacade_getBreakpointController(self)

    def getDataController(self) -> "isys::CDataController &":
        r""" Returns reference to data controller."""
        return _connect.CDebugFacade_getDataController(self)

    def getExecutionController(self) -> "isys::CExecutionController &":
        r""" Returns reference to execution controller."""
        return _connect.CDebugFacade_getExecutionController(self)

    def getLoaderController(self) -> "isys::CLoaderController &":
        r""" Returns reference to loader controller."""
        return _connect.CDebugFacade_getLoaderController(self)

    def getCodeArea(self, bPhysical: "bool") -> "int":
        r""" See documentation of CAddressController::getCodeArea(bool)  ."""
        return _connect.CDebugFacade_getCodeArea(self, bPhysical)

    def getFunctionAddress(self, functionName: "std::string const &") -> "isys::CMemAddress":
        r""" See documentation of CAddressController::getFunctionAddress(const std::string &)  ."""
        return _connect.CDebugFacade_getFunctionAddress(self, functionName)

    def getVariableAddress(self, variableName: "std::string const &") -> "isys::CMemAddress":
        r""" See documentation of CAddressController#getVariableAddress(const std::string &) ."""
        return _connect.CDebugFacade_getVariableAddress(self, variableName)

    def getExpressionAddress(self, expression: "std::string const &") -> "isys::CMemAddress":
        r""" See documentation of CAddressController#getExpressionAddress(const std::string &) ."""
        return _connect.CDebugFacade_getExpressionAddress(self, expression)

    def getLabelAddress(self, labelName: "std::string const &") -> "isys::CMemAddress":
        r""" See documentation of CAddressController#getLabelAddress(const std::string &) ."""
        return _connect.CDebugFacade_getLabelAddress(self, labelName)

    def getSymbolInfo(self, flags: "DWORD", expression: "std::string const &") -> "isys::CSymbolInfo":
        r""" See documentation of CAddressController#getSymbolInfo(DWORD,const std::string &) ."""
        return _connect.CDebugFacade_getSymbolInfo(self, flags, expression)

    def getSymbolAtAddress(self, *args) -> "std::string":
        r""" See documentation of CAddressController#getSymbolAtAddress(IConnectDebug::ESymbolFlags, BYTE, ADDRESS_64, IConnectDebug::ESymbolFlags) ."""
        return _connect.CDebugFacade_getSymbolAtAddress(self, *args)

    def getAddressOfSourceLine(self, fileName: "std::string const &", line: "int", isReportSize: "bool"=False) -> "iconnect::AddressVector":
        r""" See documentation of CAddressController#getAddressOfSourceLine(const std::string &,int,bool) ."""
        return _connect.CDebugFacade_getAddressOfSourceLine(self, fileName, line, isReportSize)

    def getSourceLineAtAddress(self, *args) -> "isys::CLineLocation":
        r"""
        *Overload 1:*
        See documentation of CAddressController#getSourceLineAtAddress(ADDRESS_64) .

        |

        *Overload 2:*
        See documentation of CAddressController#getSourceLineAtAddress(ADDRESS_64, bool, bool) .
        """
        return _connect.CDebugFacade_getSourceLineAtAddress(self, *args)

    def setBP(self, *args) -> "int":
        r"""
        *Overload 1:*
        See documentation of CBreakpointController#setBP(const std::string &, int, const std::string &) .

        |

        *Overload 2:*
        See documentation of CBreakpointController#setBP(int, const std::string &, int, const std::string &) .

        |

        *Overload 3:*
        See documentation of CBreakpointController#setBP(int, const std::string &, int, const std::string &) .

        |

        *Overload 4:*
        See documentation of CBreakpointController#setBP(int, const std::string &, int, const std::string &) .

        |

        *Overload 5:*
        See documentation of CBreakpointController#setBP(int, ADDRESS_64, int, const std::string &) .

        |

        *Overload 6:*
        See documentation of CBreakpointController#setBP(int, ADDRESS_64, int, const std::string &) .

        |

        *Overload 7:*
        See documentation of CBreakpointController#setBP(int, ADDRESS_64, int, const std::string &) .
        """
        return _connect.CDebugFacade_setBP(self, *args)

    def setHWBP(self, *args) -> "int":
        r"""
        *Overload 1:*
        See documentation of CBreakpointController#setHWBP(DWORD, DWORD, DWORD, bool, const std::string &, DWORD) .

        |

        *Overload 2:*
        See documentation of CBreakpointController#setHWBP(DWORD, DWORD, DWORD, int, ADDRESS_64, DWORD) .
        """
        return _connect.CDebugFacade_setHWBP(self, *args)

    def deleteBP(self, *args) -> "int":
        r"""
        *Overload 1:*
        See documentation of CBreakpointController#deleteBP(const std::string &) .

        |

        *Overload 2:*
        See documentation of CBreakpointController#deleteBP(const std::string &, int) .

        |

        *Overload 3:*
        See documentation of CBreakpointController#deleteBP(int, ADDRESS_64) .
        """
        return _connect.CDebugFacade_deleteBP(self, *args)

    def deleteHWBP(self, *args) -> "int":
        r"""
        *Overload 1:*
        See documentation of CBreakpointController#deleteHWBP(const std::string &) .

        |

        *Overload 2:*
        See documentation of CBreakpointController#deleteHWBP(int, ADDRESS_64) .
        """
        return _connect.CDebugFacade_deleteHWBP(self, *args)

    def deleteAll(self) -> "int":
        r""" See documentation of CBreakpointController#deleteAll() ."""
        return _connect.CDebugFacade_deleteAll(self)

    def deleteAllHWBP(self) -> "int":
        r""" See documentation of CBreakpointController#deleteAllHWBP() ."""
        return _connect.CDebugFacade_deleteAllHWBP(self)

    def setEnabled(self, *args) -> "int":
        r"""
        *Overload 1:*
        See documentation of CBreakpointController#setEnabled(bool, const std::string &) .

        |

        *Overload 2:*
        See documentation of CBreakpointController#setEnabled(bool, const std::string &, int) .

        |

        *Overload 3:*
        See documentation of CBreakpointController#setEnabled(bool, int, ADDRESS_64) .
        """
        return _connect.CDebugFacade_setEnabled(self, *args)

    def setHWEnabled(self, *args) -> "int":
        r"""
        *Overload 1:*
        See documentation of CBreakpointController#setHWEnabled(bool, const std::string &) .

        |

        *Overload 2:*
        See documentation of CBreakpointController#setHWEnabled(bool, int, ADDRESS_64) .
        """
        return _connect.CDebugFacade_setHWEnabled(self, *args)

    def setHWEnabledAll(self, isEnabled: "bool") -> "int":
        r""" See documentation of CBreakpointController#setHWEnabledAll(bool) ."""
        return _connect.CDebugFacade_setHWEnabledAll(self, isEnabled)

    def setEnabledAll(self, isEnabled: "bool") -> "int":
        r""" See documentation of CBreakpointController#setEnabledAll(bool) ."""
        return _connect.CDebugFacade_setEnabledAll(self, isEnabled)

    def reapplyAll(self) -> "int":
        r""" See documentation of CBreakpointController#reapplyAll() ."""
        return _connect.CDebugFacade_reapplyAll(self)

    def getCPUInfo(self) -> "CCPUInfo":
        r""" See documentation of CDataController#getCPUInfo() ."""
        return _connect.CDebugFacade_getCPUInfo(self)

    def getMemoryAreaBytesPerMAU(self, memArea: "int") -> "int":
        r""" See documentation of CDataController#getMemoryAreaBytesPerMAU(int) ."""
        return _connect.CDebugFacade_getMemoryAreaBytesPerMAU(self, memArea)

    def readMemory(self, accessFlags: "IConnectDebug::EAccessFlags", memArea: "BYTE", aAddress: "ADDRESS_64", aNumMAUs: "ADDRESS_64", bytesPerMAU: "BYTE") -> "std::vector< BYTE,std::allocator< BYTE > >":
        r"""
        See documentation
        of CDataController#readMemory(IConnectDebug::EAccessFlags, BYTE, ADDRESS_64, ADDRESS_64, BYTE)  .
        """
        return _connect.CDebugFacade_readMemory(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU)

    def writeMemory(self, accessFlags: "IConnectDebug::EAccessFlags", memArea: "BYTE", aAddress: "ADDRESS_64", aNumMAUs: "ADDRESS_64", bytesPerMAU: "BYTE", buff: "VectorBYTE") -> "std::vector< BYTE,std::allocator< BYTE > >":
        r"""
        See documentation
        of CDataController#writeMemory(IConnectDebug::EAccessFlags, BYTE, ADDRESS_64, ADDRESS_64, BYTE, std::vector<BYTE> &) .
        """
        return _connect.CDebugFacade_writeMemory(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU, buff)

    def readRegister(self, accessFlags: "IConnectDebug::EAccessFlags", registerName: "std::string const &") -> "isys::CValueType":
        r""" See documentation of CDataController#readRegister(IConnectDebug::EAccessFlags, const std::string &) ."""
        return _connect.CDebugFacade_readRegister(self, accessFlags, registerName)

    def writeRegister(self, accessFlags: "IConnectDebug::EAccessFlags", registerName: "std::string const &", registerInfo: "CValueType") -> "void":
        r""" See documentation of CDataController#writeRegister(IConnectDebug::EAccessFlags, const std::string &, const CValueType &) ."""
        return _connect.CDebugFacade_writeRegister(self, accessFlags, registerName, registerInfo)

    def readValue(self, accessFlags: "IConnectDebug::EAccessFlags", memArea: "BYTE", aAddress: "ADDRESS_64", type: "SType") -> "isys::CValueType":
        r""" See documentation of CDataController#readValue(IConnectDebug::EAccessFlags, BYTE, ADDRESS_64, const SType &) ."""
        return _connect.CDebugFacade_readValue(self, accessFlags, memArea, aAddress, type)

    def writeValue(self, *args) -> "void":
        r"""
        *Overload 1:*
        See documentation of CDataController#writeValue(IConnectDebug::EAccessFlags, BYTE, ADDRESS_64, const CValueType &) .

        |

        *Overload 2:*
        See documentation of CDataController#writeValue(IConnectDebug::EAccessFlags, bool, BYTE, ADDRESS_64, const CValueType &) .
        """
        return _connect.CDebugFacade_writeValue(self, *args)

    def evaluate(self, *args) -> "isys::CValueType":
        r"""
        *Overload 1:*
        See documentation of CDataController#evaluate(IConnectDebug#EAccessFlags, const std::string &) .

        |

        *Overload 2:*
        See documentation of CDataController#evaluate(IConnectDebug::EAccessFlags, IConnectDebug::EEvaluate, const std::string &) .
        """
        return _connect.CDebugFacade_evaluate(self, *args)

    def modify(self, *args) -> "std::string":
        r"""
        *Overload 1:*
        See documentation of CDataController#modify(IConnectDebug::EAccessFlags, const std::string &, const CValueType &, bool) .

        |

        *Overload 2:*
        See documentation of CDataController#modify(IConnectDebug::EAccessFlags, const std::string &, const std::string &, bool) .

        |

        *Overload 3:*
        See documentation of CDataController#modify(IConnectDebug::EAccessFlags, IConnectDebug::EEvaluate, const std::string &, const CValueType &, bool) .

        |

        *Overload 4:*
        See documentation of CDataController#modify(IConnectDebug::EAccessFlags, IConnectDebug::EEvaluate, const std::string &, const std::string &, bool) .
        """
        return _connect.CDebugFacade_modify(self, *args)

    def run(self, *args) -> "int":
        r"""
        *Overload 1:*
        See documentation of CExecutionController#run() .

        |

        *Overload 2:*
        See documentation of CExecutionController#run(CExecutionController::ETimeoutMode, bool) .
        """
        return _connect.CDebugFacade_run(self, *args)

    def runUntilReturn(self, *args) -> "int":
        r"""
        *Overload 1:*
        See documentation of CExecutionController#runUntilReturn() .

        |

        *Overload 2:*
        See documentation of CExecutionController#runUntilReturn(isys::CExecutionController::ETimeoutMode, bool) .
        """
        return _connect.CDebugFacade_runUntilReturn(self, *args)

    def runUntilAddress(self, *args) -> "int":
        r"""
        *Overload 1:*
        See documentation of CExecutionController#runUntilAddress(BYTE, ADDRESS_64) .

        |

        *Overload 2:*
        See documentation of CExecutionController#runUntilAddress(BYTE, ADDRESS_64, CExecutionController::ETimeoutMode, bool) .
        """
        return _connect.CDebugFacade_runUntilAddress(self, *args)

    def runUntilFunction(self, *args) -> "int":
        r"""
        *Overload 1:*
        See documentation of CExecutionController#runUntilFunction(const std::string &) .

        |

        *Overload 2:*
        See documentation of CExecutionController#runUntilFunction(const std::string &, CExecutionController::ETimeoutMode, bool) .
        """
        return _connect.CDebugFacade_runUntilFunction(self, *args)

    def setSlowRun(self, isSlowRun: "bool") -> "int":
        r""" See documentation of CExecutionController#setSlowRun(bool) ."""
        return _connect.CDebugFacade_setSlowRun(self, isSlowRun)

    def gotoAddress(self, memArea: "BYTE", address: "ADDRESS_64") -> "void":
        r""" See documentation of CExecutionController#gotoAddress(BYTE, ADDRESS_64) ."""
        return _connect.CDebugFacade_gotoAddress(self, memArea, address)

    def gotoFunction(self, functionName: "std::string const &") -> "void":
        r""" See documentation of CExecutionController#gotoFunction(const std::string &) ."""
        return _connect.CDebugFacade_gotoFunction(self, functionName)

    def reset(self) -> "void":
        r""" See documentation of CExecutionController#reset() ."""
        return _connect.CDebugFacade_reset(self)

    def stop(self) -> "void":
        r""" See documentation of CExecutionController#stop() ."""
        return _connect.CDebugFacade_stop(self)

    def stepHigh(self, *args) -> "void":
        r""" See documentation of CExecutionController#stepHigh() ."""
        return _connect.CDebugFacade_stepHigh(self, *args)

    def stepOverHigh(self, *args) -> "void":
        r""" See documentation of CExecutionController#stepOverHigh(CExecutionController::ETimeoutMode, bool) ."""
        return _connect.CDebugFacade_stepOverHigh(self, *args)

    def stepInst(self, *args) -> "void":
        r""" See documentation of CExecutionController#stepInst() ."""
        return _connect.CDebugFacade_stepInst(self, *args)

    def stepOverInst(self, *args) -> "void":
        r""" See documentation of CExecutionController#stepOverInst(CExecutionController::ETimeoutMode, bool) ."""
        return _connect.CDebugFacade_stepOverInst(self, *args)

    def call(self, functionName: "std::string const &") -> "std::string":
        r"""
         See documentation of CExecutionController#call(const std::string &) . If you need
        to specify function parameters, use overloads of this method in
        CExecutionController .
        """
        return _connect.CDebugFacade_call(self, functionName)

    def getCPUStatus(self, wantStopReason: "bool"=True) -> "isys::CPUStatus":
        r""" See documentation of CExecutionController#getCPUStatus(bool) ."""
        return _connect.CDebugFacade_getCPUStatus(self, wantStopReason)

    def setPollingEnabled(self, isEnabled: "bool") -> "void":
        r""" See documentation of CExecutionController#setPollingEnabled(bool) ."""
        return _connect.CDebugFacade_setPollingEnabled(self, isEnabled)

    def waitUntilStopped(self, timeoutMs: "int"=0, pollingIntervalMs: "DWORD"=100) -> "bool":
        r""" See documentation of CExecutionController#waitUntilStopped(int, DWORD, bool) ."""
        return _connect.CDebugFacade_waitUntilStopped(self, timeoutMs, pollingIntervalMs)

    def waitWhileRunning(self, timeoutMs: "int", pollingIntervalMs: "DWORD"=100) -> "bool":
        r""" See documentation of CExecutionController#waitWhileRunning(int, DWORD, bool) ."""
        return _connect.CDebugFacade_waitWhileRunning(self, timeoutMs, pollingIntervalMs)

    def download(self) -> "int":
        r""" See documentation of CLoaderController#download() ."""
        return _connect.CDebugFacade_download(self)

    def runUntilExpression(self, *args) -> "int":
        r"""
        *Overload 1:*

        This method evaluates the given expression, which must evaluate to address.
        Then it runs the target with runUntilAddress .
        This method aggregates calls to CDataController#evaluate  and
        CExecutionController#runUntilAddress  and does not have
        equivalent in CExecutionController. This method returns immediately - the
        target may still be in running mode after return!

        :type expression: string
        :param expression: expression, which evaluates to address. This can be one of
                   - function name, for example 'main'
                   - label, for example 'calc_speed_EXIT'
                   - literal value, for example '0x40004356'
                   - expression, for example: '&main + 0x42'. Note the '&' before main!

        |

        *Overload 2:*

        This method evaluates the given expression, which must evaluate to address.
        Then it runs the target with runUntilAddress .
        This method aggregates calls to CDataController#evaluate  and
        CExecutionController#runUntilAddress  and does not have
        equivalent in CExecutionController.

        :type expression: string
        :param expression: expression, which evaluates to address. This can be one of
                   - function name, for example 'main'
                   - label, for example 'calc_speed_EXIT'
                   - literal value, for example '0x40004356'
                   - expression, for example: '&main + 0x42'. Note the '&' before main!
        :type timeoutMode: int
        :param timeoutMode: timeout mode
        """
        return _connect.CDebugFacade_runUntilExpression(self, *args)

    def adjustAddressExpression(self, expression: "std::string const &") -> "std::string":
        return _connect.CDebugFacade_adjustAddressExpression(self, expression)

# Register CDebugFacade in _connect:
_connect.CDebugFacade_swigregister(CDebugFacade)

class CIncubatorController(object):
    r"""
    This class provides new _isystem.connect_ calls, which are still evolving.
    Use methods from this class with care, and be prepared for change.
    Once stable, these methods will be moved to other _isystem.connect_ classes.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        _connect.CIncubatorController_swiginit(self, _connect.new_CIncubatorController(connectionMgr))
    __swig_destroy__ = _connect.delete_CIncubatorController

    def getWinIDEAVersion(self) -> "isys_sdk::SVersion":
        r""" This method is just proof of concept. Use CIDEController::getWinIDEAVersion() instead."""
        return _connect.CIncubatorController_getWinIDEAVersion(self)

    def prepareToAttach(self) -> "bool":
        r"""
        Returns ``true`` if attach is successfully performed, ``false`` otherwise.

        :raises: IOException if core initialization can not be performed.

        Python example: prepareToAttach.py
        """
        return _connect.CIncubatorController_prepareToAttach(self)

# Register CIncubatorController in _connect:
_connect.CIncubatorController_swigregister(CIncubatorController)

class CPluginController(object):
    r"""
    This class is used to control winIDEA plugins.


    Python example: pluginController.py 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >", pluginName: "std::string const &"):
        r"""
        This class provides winIDEA plugin control.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection object
        :type pluginName: string
        :param pluginName: as defined in winIDEA
        """
        _connect.CPluginController_swiginit(self, _connect.new_CPluginController(connectionMgr, pluginName))
    __swig_destroy__ = _connect.delete_CPluginController

    def open(self, viewName: "std::string const &") -> "void":
        r"""
        Opens a view.

        :raises: IOException if operation fails.

        :type viewName: string
        :param viewName: specifies view name
        """
        return _connect.CPluginController_open(self, viewName)

    def close(self, viewName: "std::string const &") -> "void":
        r"""
        Closes a view.

        :raises: IOException if operation fails.

        :type viewName: string
        :param viewName: specifies view name
        """
        return _connect.CPluginController_close(self, viewName)

    def isOpen(self, viewName: "std::string const &") -> "bool":
        r"""
        Returns true if view is open.

        :raises: IOException if operation fails.

        :type viewName: string
        :param viewName: specifies view name

        :rtype: boolean
        :return: true if view open, false otherwise
        """
        return _connect.CPluginController_isOpen(self, viewName)

    def refresh(self, viewName: "std::string const &") -> "void":
        r"""
        Refreshes a view.

        :raises: IOException if operation fails.

        :type viewName: string
        :param viewName: specifies view name
        """
        return _connect.CPluginController_refresh(self, viewName)

    def call(self, *args) -> "std::string":
        r"""
        *Overload 1:*

        Service call for plugin specific commands (non generic).

        :raises: IOException if operation fails.

        :type command: string
        :param command: command name
        :type parameters: string
        :param parameters: command parameters separated by colon

        :rtype: string
        :return: command operation results

        |

        *Overload 2:*

        Service call for plugin specific commands (non generic).

        :raises: IOException if operation fails.

        :type viewName: string
        :param viewName: specifies view name
        :type command: string
        :param command: command
        :type parameters: string
        :param parameters: command parameters separated by colon

        :rtype: string
        :return: command operation results
        """
        return _connect.CPluginController_call(self, *args)

    def getContent(self, viewName: "std::string const &", itemPath: "std::string const &", columns: "IntVector") -> "iconnect::StrStrVectorMap":
        r"""
        Returns view content.

        :raises: IOException if operation fails.

        :type viewName: string
        :param viewName: view name
        :type itemPath: string
        :param itemPath: item path
        :type columns: :py:class:`IntVector`
        :param columns: column indexes (0, 2, 3,...), if empty all columns will be returned

        :rtype: :py:class:`StrStrVectorMap`
        :return: view content as map - key is item path, vector represent column values, header is also included
        """
        return _connect.CPluginController_getContent(self, viewName, itemPath, columns)

# Register CPluginController in _connect:
_connect.CPluginController_swigregister(CPluginController)

class CInstruction(object):
    r"""
    This class contains additional information to IInstruction, and provides
    convenient wrapper methods.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, sInstr: "IInstruction"):
        _connect.CInstruction_swiginit(self, _connect.new_CInstruction(sInstr))

    def getAddress(self) -> "ADDRESS_64":
        r""" Returns location of the current instruction."""
        return _connect.CInstruction_getAddress(self)

    def getJumpTarget(self) -> "ADDRESS_64":
        r"""
        When isFlowDirectJump() returns true, this method returns absolute
        target address.
        """
        return _connect.CInstruction_getJumpTarget(self)

    def getFlags(self) -> "DWORD":
        return _connect.CInstruction_getFlags(self)

    def getSize(self) -> "int":
        return _connect.CInstruction_getSize(self)

    def getMemAccessSize(self) -> "int":
        return _connect.CInstruction_getMemAccessSize(self)

    def getOpCode(self) -> "std::string":
        return _connect.CInstruction_getOpCode(self)

    def isFlowSequential(self) -> "bool":
        r""" Returns true, if this is sequential instruction."""
        return _connect.CInstruction_isFlowSequential(self)

    def isFlowDirectJump(self) -> "bool":
        r"""
        Returns true, if this is a direct change of flow. Method
        getJumpTarget() returns valid value.
        """
        return _connect.CInstruction_isFlowDirectJump(self)

    def isFlowIndirectJump(self) -> "bool":
        r"""Returns true, if this is an indirect change of flow."""
        return _connect.CInstruction_isFlowIndirectJump(self)

    def isConditional(self) -> "bool":
        r""" Returns true, if this is conditional instruction."""
        return _connect.CInstruction_isConditional(self)

    def isCall(self) -> "bool":
        r"""
        This instruction is a call to a routine which will return and resume
        execution after this instruction.
        """
        return _connect.CInstruction_isCall(self)

    def isRelative(self) -> "bool":
        r"""This call is valid when method isFlowDirectJump() returns true."""
        return _connect.CInstruction_isRelative(self)

    def isWriteAccess(self) -> "bool":
        r""" Execution of instruction will generate a write access."""
        return _connect.CInstruction_isWriteAccess(self)

    def isReadAccess(self) -> "bool":
        r""" Execution of instruction  will generate a read access."""
        return _connect.CInstruction_isReadAccess(self)

    def incExecCounter(self) -> "void":
        r"""Increments execution counter."""
        return _connect.CInstruction_incExecCounter(self)

    def setExecCounter(self, n: "int64_t") -> "void":
        r"""Sets execution counter."""
        return _connect.CInstruction_setExecCounter(self, n)

    def getExecCounter(self) -> "int64_t":
        r"""Returns execution counter."""
        return _connect.CInstruction_getExecCounter(self)

    def toString(self) -> "std::string":
        return _connect.CInstruction_toString(self)
    __swig_destroy__ = _connect.delete_CInstruction

# Register CInstruction in _connect:
_connect.CInstruction_swigregister(CInstruction)

class CPartitionCodeInfo(object):
    r"""This class handles instructions for one application domain."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, instructions: "iEclipse::IInstructions *"):
        _connect.CPartitionCodeInfo_swiginit(self, _connect.new_CPartitionCodeInfo(instructions))

    def getInstructionAtAddress(self, address: "uint64_t") -> "isys::CInstruction":
        r"""
        Reads instructions. To release memory occupied by these data, call
        method release().
        """
        return _connect.CPartitionCodeInfo_getInstructionAtAddress(self, address)

    def getInstructionAtIndex(self, index: "int64_t") -> "isys::CInstruction":
        return _connect.CPartitionCodeInfo_getInstructionAtIndex(self, index)

    def getIndexForAddress(self, address: "uint64_t") -> "size_t":
        return _connect.CPartitionCodeInfo_getIndexForAddress(self, address)

    def getFunction(self, address: "uint64_t") -> "std::string":
        return _connect.CPartitionCodeInfo_getFunction(self, address)

    def getFile(self, address: "uint64_t") -> "std::string":
        return _connect.CPartitionCodeInfo_getFile(self, address)

    def getLine(self, address: "uint64_t") -> "int":
        return _connect.CPartitionCodeInfo_getLine(self, address)

    def getSrcCode(self, address: "uint64_t") -> "std::string":
        return _connect.CPartitionCodeInfo_getSrcCode(self, address)

    def getCalledFunctions(self, funcName: "std::string", level: "int", calledFunctions: "StrVector") -> "void":
        return _connect.CPartitionCodeInfo_getCalledFunctions(self, funcName, level, calledFunctions)
    __swig_destroy__ = _connect.delete_CPartitionCodeInfo

# Register CPartitionCodeInfo in _connect:
_connect.CPartitionCodeInfo_swigregister(CPartitionCodeInfo)

class CPartitionExecInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CPartitionExecInfo_swiginit(self, _connect.new_CPartitionExecInfo())
    __swig_destroy__ = _connect.delete_CPartitionExecInfo

# Register CPartitionExecInfo in _connect:
_connect.CPartitionExecInfo_swigregister(CPartitionExecInfo)

class CInstructionIter(object):
    r"""
    This class should be used to access instructions from other languages
    than C++, otherwise garbage collector may release objects to early and
    application will crash.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CInstructionIter_swiginit(self, _connect.new_CInstructionIter(*args))

    def hasNext(self) -> "bool":
        r""" Returns true, if iterator has not reached range end."""
        return _connect.CInstructionIter_hasNext(self)

    def next(self) -> "isys::CInstruction":
        r""" Returns next element from iterator range."""
        return _connect.CInstructionIter_next(self)

    def peek(self) -> "isys::CInstruction":
        r""" Returns current element."""
        return _connect.CInstructionIter_peek(self)

    def branch(self, address: "int64_t") -> "bool":
        r"""
        Returns true for forward jump, false if branch is made to same
        address or backward.
        """
        return _connect.CInstructionIter_branch(self, address)

    def isAddressInRange(self, address: "int64_t") -> "bool":
        r"""Returns true, if the given adress is in range of this iterator."""
        return _connect.CInstructionIter_isAddressInRange(self, address)
    __swig_destroy__ = _connect.delete_CInstructionIter

# Register CInstructionIter in _connect:
_connect.CInstructionIter_swigregister(CInstructionIter)

class CSOCCodeInfo(object):
    r"""Contains inctructions for complete SOC."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_CSOCCodeInfo

    def release(self) -> "void":
        return _connect.CSOCCodeInfo_release(self)

    def getCodeInfo(self, partition: "std::string const &") -> "CPartitionCodeInfo":
        return _connect.CSOCCodeInfo_getCodeInfo(self, partition)

    def loadCodeInfo(self, dataCtrl2: "isys::CDataController2SPtr &", partition: "std::string const &") -> "CPartitionCodeInfo":
        return _connect.CSOCCodeInfo_loadCodeInfo(self, dataCtrl2, partition)

    def __init__(self):
        _connect.CSOCCodeInfo_swiginit(self, _connect.new_CSOCCodeInfo())

# Register CSOCCodeInfo in _connect:
_connect.CSOCCodeInfo_swigregister(CSOCCodeInfo)

class CLogger(object):
    r"""
    This class can be used to add logging to all controller classes. The result
    is program file, which contains only calls to isystem.connect. This is
    useful, when we would like to quickly reproduce the problem or simply
    for readable overview of what is going on between our application and
    target hardware. 


    However, although the log file is a runnable program, the functionality
    will usually NOT be the same as that of original program. For example,
    if the original program calls ``getStatus()`` in a loop until condition is met,
    the log file will contain on the number of ``getStatus()`` calls, without
    loop or condition. The log file is intended as debugging help, not as
    full substitute of the original program.

    **NOTE**: This class is not intended to be used directly by end users. It
    is used internally, when the user code makes ``isystem.connect`` calls. See
    ConnectionMgr::initLogger() for initialization of internal logger.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    JAVA = _connect.CLogger_JAVA
    r""" write log statements in Java language (limited support)"""
    PYTHON = _connect.CLogger_PYTHON
    r""" write log statements in Python language"""

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Opens log file and initializes it. Logging is ON by default.

        :type fileName: string
        :param fileName: name of the logFile
        :type language: int
        :param language: defines syntax used for command logging
        :type isLogToStdOut: boolean
        :param isLogToStdOut: NOT IMPLEMENTED! (if true, output will be also printed to std out)
        :type timeDiffToIgnore: float
        :param timeDiffToIgnore: time delays shorter than this value are not logged.
            This value should be specified in seconds. Use large value to disable logging
            of delays.
        :type header: string
        :param header: string containing header of the log file. It may include
            imports, class and method declarations, so that the generated log file is
            compilable Java or Python source file. It may as well be empty or include
            comment only.

        |

        *Overload 2:*

        Opens log file and initializes it. Logging is ON by default. Time difference
        to be ignored is set to 1 second by default.

        :type fileName: string
        :param fileName: name of the logFile
        :type language: int
        :param language: defines syntax used for command logging
        """
        _connect.CLogger_swiginit(self, _connect.new_CLogger(*args))

    def writeHeader(self, header: "std::string const &") -> "bool":
        return _connect.CLogger_writeHeader(self, header)

    def setIgnorableTimeDiff(self, timeDiff: "double") -> "void":
        return _connect.CLogger_setIgnorableTimeDiff(self, timeDiff)
    __swig_destroy__ = _connect.delete_CLogger

    def closeLog(self, footer: "std::string const &") -> "void":
        r"""
        Closes log file and turns off the logging. No logging will be done after
        this call. Log file

        :type footer: string
        :param footer: end of Java or Python program, for example closing parantheses
            in Java. May also be empty or contain comment.
        """
        return _connect.CLogger_closeLog(self, footer)

    def resetStartTime(self) -> "void":
        r"""
        Resets start time so that it will start counting from 0 when the first method is
        executed. Useful, when we want to repeat script without restarting.
        """
        return _connect.CLogger_resetStartTime(self)

    def setIndent(self, indent: "int") -> "void":
        r"""
        Sets indentation for the following logged statements. Call with
        argument 0 to disable indentation.

        :type indent: int
        :param indent: the number of spaces used for indentation
        """
        return _connect.CLogger_setIndent(self, indent)

    def loggingOn(self) -> "void":
        r"""
        Turns logging on.

        See also: #loggingOff
        """
        return _connect.CLogger_loggingOn(self)

    def loggingOff(self) -> "void":
        r"""
        Turns logging off. Calls to ``log()`` methods will produce no
        output after this call.

        See also: #loggingOn
        """
        return _connect.CLogger_loggingOff(self)

    def isLoggingOn(self) -> "bool":
        r"""
        Returns if logging is turned on

        :rtype: boolean
        :return: true if logging is enabled, otherwise false
        """
        return _connect.CLogger_isLoggingOn(self)

    def logc(self, comment: "std::string const &") -> "void":
        r"""
        This method may be called from client code to insert user specific comments.
        The language specific comment character is automatically prepended.
        """
        return _connect.CLogger_logc(self, comment)

    def logf(self, objName: "std::string const &", methodName: "std::string const &", format: "char const *") -> "void":
        r"""
        Logging of function call with variable arguments.

        :type format: string
        :param format: format string, may contain:
                   - i - int
                   - s - std::string
                   - b - bool
                   - l - int64_t
                   - u - unsigned
                   - D - DWORD
                   - E - enum, followed by conversion function pointer. If the
                         pointer == NULL, enum is logged as integer
        """
        return _connect.CLogger_logf(self, objName, methodName, format)

    def log(self, *args) -> "void":
        r"""
        *Overload 1:*

        This method may be called from client code to insert user specific script code.

        |

        *Overload 2:*
         Logs call of method with no parameter.

        |

        *Overload 3:*
         Logs call of method with DWORD parameter.

        |

        *Overload 4:*

        Logs call of method with Logs call with string parameter.
        """
        return _connect.CLogger_log(self, *args)

    def createVar(self, varName: "std::string const &", varType: "std::string const &") -> "void":
        r"""
        Logs declaration and assignment statement, for example
        SProfilerStartingPoint sp = SProfilerStartingPoint();
        """
        return _connect.CLogger_createVar(self, varName, varType)

    def fillVectorBYTE(self, varName: "std::string const &", buff: "VectorBYTE") -> "void":
        r"""Creates vector of bytes in script language and assigns is values from buff."""
        return _connect.CLogger_fillVectorBYTE(self, varName, buff)

    def createSType(self, valueName: "std::string const &", sType: "SType") -> "void":
        r"""
        Creates and fills CValueType object.
                void createCValueType(const std::string &valueName, const CValueType &value);

        Creates and fills SType object.
        """
        return _connect.CLogger_createSType(self, valueName, sType)

    @staticmethod
    def icDebugAccessFlags2str(flags: "int") -> "std::string":
        r""" Returns string corresponding to value of flags to IConnectDebug::EAccessFlags"""
        return _connect.CLogger_icDebugAccessFlags2str(flags)

    @staticmethod
    def icDebugSymbolFlags2str(flags: "int") -> "std::string":
        r""" Returns string corresponding to value of flags to IConnectDebug::ESymbolFlags."""
        return _connect.CLogger_icDebugSymbolFlags2str(flags)

    @staticmethod
    def icDebugAddressFlags2str(flags: "int") -> "std::string":
        r"""
         Returns string corresponding to value of flags to IConnectDebug::EGetAddressFlags.
        Converts only the most often used values.
        Useful for logging, but not for generating program code.
        """
        return _connect.CLogger_icDebugAddressFlags2str(flags)

    @staticmethod
    def icDebugEvaluateFlags2str(flags: "int") -> "std::string":
        r""" Returns string corresponding to value of flags to IConnectDebug::EEvaluateFlags."""
        return _connect.CLogger_icDebugEvaluateFlags2str(flags)

    @staticmethod
    def icSTypeType2str(flags: "int") -> "std::string":
        r""" Returns string corresponding to enum in STYpe."""
        return _connect.CLogger_icSTypeType2str(flags)

    @staticmethod
    def lang2str(flags: "isys::CLogger::LogFileLanguage") -> "std::string":
        r""" Returns string corresponding to CCoverageController::ERangeItem.  Returns string corresponding to IConnectCoverage::ECoverageRangesTypes.  Returns string corresponding to IConnectCoverage::ECoverageStatisticsFlags.  Returns string corresponding to IConnectCoverage::EConfigFlags.  Returns string corresponding to IConnectCoverage::EGetStatusFlags.  Returns string corresponding to logger language settings."""
        return _connect.CLogger_lang2str(flags)

# Register CLogger in _connect:
_connect.CLogger_swigregister(CLogger)

def CLogger_icDebugAccessFlags2str(flags: "int") -> "std::string":
    r""" Returns string corresponding to value of flags to IConnectDebug::EAccessFlags"""
    return _connect.CLogger_icDebugAccessFlags2str(flags)

def CLogger_icDebugSymbolFlags2str(flags: "int") -> "std::string":
    r""" Returns string corresponding to value of flags to IConnectDebug::ESymbolFlags."""
    return _connect.CLogger_icDebugSymbolFlags2str(flags)

def CLogger_icDebugAddressFlags2str(flags: "int") -> "std::string":
    r"""
     Returns string corresponding to value of flags to IConnectDebug::EGetAddressFlags.
    Converts only the most often used values.
    Useful for logging, but not for generating program code.
    """
    return _connect.CLogger_icDebugAddressFlags2str(flags)

def CLogger_icDebugEvaluateFlags2str(flags: "int") -> "std::string":
    r""" Returns string corresponding to value of flags to IConnectDebug::EEvaluateFlags."""
    return _connect.CLogger_icDebugEvaluateFlags2str(flags)

def CLogger_icSTypeType2str(flags: "int") -> "std::string":
    r""" Returns string corresponding to enum in STYpe."""
    return _connect.CLogger_icSTypeType2str(flags)

def CLogger_lang2str(flags: "isys::CLogger::LogFileLanguage") -> "std::string":
    r""" Returns string corresponding to CCoverageController::ERangeItem.  Returns string corresponding to IConnectCoverage::ECoverageRangesTypes.  Returns string corresponding to IConnectCoverage::ECoverageStatisticsFlags.  Returns string corresponding to IConnectCoverage::EConfigFlags.  Returns string corresponding to IConnectCoverage::EGetStatusFlags.  Returns string corresponding to logger language settings."""
    return _connect.CLogger_lang2str(flags)

class CWinIDEAVersion(object):
    r"""
    This class contains version number. This class is not intended to be
    instantiated by clients. Use method for obtaining versions, for example
    isys::CIDEData::getWinIDEAVersion() or isys::ConnectionMgr::getIConnectDllVersion().
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :type version: string
        :param version: must be in <major>.<minor>.<build>[.<subbuild>] format,
                   for example: 9.12.209, or 9.12.209.4302
        """
        _connect.CWinIDEAVersion_swiginit(self, _connect.new_CWinIDEAVersion(*args))

    @staticmethod
    def getFileVersion(fileName: "std::string const &") -> "isys::CWinIDEAVersion":
        return _connect.CWinIDEAVersion_getFileVersion(fileName)

    def getMajor(self) -> "int":
        r""" Returns the major winIDEA version."""
        return _connect.CWinIDEAVersion_getMajor(self)

    def getMinor(self) -> "int":
        r""" Returns the minor winIDEA version."""
        return _connect.CWinIDEAVersion_getMinor(self)

    def getBuild(self) -> "int":
        r""" Returns the winIDEA build number."""
        return _connect.CWinIDEAVersion_getBuild(self)

    def getSubbuild(self) -> "int":
        r"""
         Returns the winIDEA sub-build number. Returns 0xffff if sub-build version
        was not set.
        """
        return _connect.CWinIDEAVersion_getSubbuild(self)

    def getSccRevision(self) -> "uint32_t":
        r"""
         Returns the winIDEA source control revision number. Returns 0xffff'ffff if this version
        was not set.
        """
        return _connect.CWinIDEAVersion_getSccRevision(self)

    def getBuildYear(self) -> "uint16_t":
        r""" Returns winIDEA build year. Returns 0 if build year was not set."""
        return _connect.CWinIDEAVersion_getBuildYear(self)

    def getBuildMonth(self) -> "uint8_t":
        r""" Returns winIDEA build month in range [1..12]. Returns 0 if build month was not set."""
        return _connect.CWinIDEAVersion_getBuildMonth(self)

    def getBuildDay(self) -> "uint8_t":
        r""" Returns winIDEA build day in range [1..31]. Returns 0 if build day was not set."""
        return _connect.CWinIDEAVersion_getBuildDay(self)

    def compare(self, other: "CWinIDEAVersion") -> "int":
        r"""
        Returns -1 if this version is smaller than other, 0 if equal,
        and 1 if greater.
        """
        return _connect.CWinIDEAVersion_compare(self, other)

    def toString(self) -> "std::string":
        r"""
        Returns version number as string. Format: <major>.<minor>.<build>.
        If sub-build number was also set, the return string is <major>.<minor>.<build>.<sub-build>.
        Example: 9.10.115
        """
        return _connect.CWinIDEAVersion_toString(self)
    __swig_destroy__ = _connect.delete_CWinIDEAVersion

# Register CWinIDEAVersion in _connect:
_connect.CWinIDEAVersion_swigregister(CWinIDEAVersion)

def CWinIDEAVersion_getFileVersion(fileName: "std::string const &") -> "isys::CWinIDEAVersion":
    return _connect.CWinIDEAVersion_getFileVersion(fileName)


def getSdkVersion() -> "isys::CWinIDEAVersion":
    r"""
    This function returns version of current isystem.connect module. It returns
    the same version as getModuleVersion(), but source control version is also set.
    """
    return _connect.getSdkVersion()
class CUMIController(object):
    r"""This class provides UMI storage device manipulation methods."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        _connect.CUMIController_swiginit(self, _connect.new_CUMIController(connectionMgr))
    __swig_destroy__ = _connect.delete_CUMIController

    def write(self, *args) -> "void":
        r"""
        *Overload 1:*

        Writes contents of pre-configured files to device.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.

        |

        *Overload 2:*

        Writes contents of file to device.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.
        :type fileFormat: int
        :param fileFormat: should be one of ``wFile...`` flags from IConnectUMI::EOperationFlags,
                              for example IConnectUMI::wFileFormatAuto, IConnectUMI::wFileFormatBin,
                              IConnectUMI::wFileFormatS, IConnectUMI::wFileFormatHex.
        :type offset: int
        :param offset: offset to add to the address in the file
        :type fileName: string
        :param fileName: path to the file to program

        |

        *Overload 3:*

        Writes data to device.
        :param dwDevice: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.
        :type address: int
        :param address: address to write to
        :type size: int
        :param size: size of the data to write
        :type data: std::vector< BYTE,std::allocator< BYTE > >
        :param data: vector of data to be written
        """
        return _connect.CUMIController_write(self, *args)

    def read(self, deviceIndex: "DWORD", address: "ADDRESS", size: "ADDRESS", data: "VectorBYTE") -> "void":
        r"""
        Reads data from device.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type address: int
        :param address: address to read from
        :type size: int
        :param size: size of the data to read
        :type data: std::vector< BYTE,std::allocator< BYTE > >
        :param data: vector to contain read data on return
        """
        return _connect.CUMIController_read(self, deviceIndex, address, size, data)

    def flush(self, deviceIndex: "DWORD") -> "void":
        r"""
        Programs the device from the intermediate cache.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        """
        return _connect.CUMIController_flush(self, deviceIndex)

    def erase(self, *args) -> "void":
        r"""
        *Overload 1:*

        Erases complete device.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or IConnectUMI::wProgCache.

        |

        *Overload 2:*

        Erases the specified region.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.
        :type address: int
        :param address: address to erase from
        :type size: int
        :param size: size of the data to be erased
        """
        return _connect.CUMIController_erase(self, *args)

    def verify(self, *args) -> "void":
        r"""
        *Overload 1:*

        Compares device contents to cache. Throws `CUMIException` in case of verification
        error (contents do not match), throws `IOException` in case of any
        other _isystem.connect_ error.

        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.

        |

        *Overload 2:*

        Compares device contents to cache. Throws `CUMIException` in case of verification
        error (contents do not match), throws `IOException` in case of any
        other _isystem.connect_ error.

        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type address: int
        :param address: address to verify from
        :type size: int
        :param size: size of the data to be verified
        """
        return _connect.CUMIController_verify(self, *args)

    def blankCheck(self, *args) -> "void":
        r"""
        *Overload 1:*

        Compares device contents to the empty value.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :raises: CUMIException if device is not empty
        Deprecated: Call isDeviceEmpty(DWORD deviceIndex) instead.

        |

        *Overload 2:*

        Compares device contents to the empty value at given address.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type address: int
        :param address: address to verify from
        :type size: int
        :param size: size of the data to be verified
        :raises: CUMIException if device is not empty
        Deprecated: Call isDeviceEmpty(DWORD deviceIndex, ADDRESS address, ADDRESS size) instead.
        """
        return _connect.CUMIController_blankCheck(self, *args)

    def fill(self, deviceIndex: "DWORD") -> "void":
        r"""
        Fills device with preconfigured value
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :raises: CUMIException if device is not empty
        """
        return _connect.CUMIController_fill(self, deviceIndex)

    def isDeviceEmpty(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Compares device contents to the empty value.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :rtype: boolean
        :return: true if the device is empty, false otherwise

        |

        *Overload 2:*

        Compares device contents to the empty value at given address.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type address: int
        :param address: address to verify from
        :type size: int
        :param size: size of the data to be verified
        :rtype: boolean
        :return: true if the device is empty, false otherwise
        """
        return _connect.CUMIController_isDeviceEmpty(self, *args)

    def secure(self, *args) -> "void":
        r"""
        *Overload 1:*

        Secures the device.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.

        |

        *Overload 2:*

        Secures the sector.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type address: int
        :param address: address of the sector to be secured
        :type size: int
        :param size: size of the sector to be secured
        """
        return _connect.CUMIController_secure(self, *args)

    def unsecure(self, *args) -> "void":
        r"""
        *Overload 1:*

        Unsecures the device.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.

        |

        *Overload 2:*

        Unsecures the sector.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type address: int
        :param address: address of the sector to be unsecured
        :type size: int
        :param size: size of the sector to be unsecured
        """
        return _connect.CUMIController_unsecure(self, *args)

    def secureCheck(self, *args) -> "void":
        r"""
        *Overload 1:*

        Checks if security is set on device.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.

        |

        *Overload 2:*

        Checks if security is set on sector.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type address: int
        :param address: address of the sector to be unsecured
        :type size: int
        :param size: size of the sector to be unsecured
        """
        return _connect.CUMIController_secureCheck(self, *args)

    def readState(self, deviceIndex: "DWORD", programMode: "IConnectUMI::EOperationFlags", address: "ADDRESS", size: "ADDRESS", stateResult: "VectorBYTE") -> "void":
        r"""
        Reads the device program state.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or IConnectUMI::wProgCache.
        :type address: int
        :param address: starting address
        :type size: int
        :param size: size of the data to be examined
        :type stateResult: std::vector< BYTE,std::allocator< BYTE > >
        :param stateResult: Program state as vector of bytes, returned as an unpacked byte array (1 MAU per byte).
                   Vector size must be the size of the data to be examined. Value equals to 1 if MAU programmed and 0 if not.
        """
        return _connect.CUMIController_readState(self, deviceIndex, programMode, address, size, stateResult)

    def readHash(self, *args) -> "void":
        r"""
        *Overload 1:*

        Reads target device data MURMUR2 hash.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type hashResult: std::vector< BYTE,std::allocator< BYTE > >
        :param hashResult: Hash result as vector of bytes. LSB is returned first.
                   Vector capacity should be at least 4 BYTES.

        |

        *Overload 2:*

        Reads target device data MURMUR2 hash.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.
        :type address: int
        :param address: starting address for hash calculation
        :type size: int
        :param size: size of the data to be hashed
        :type hashResult: std::vector< BYTE,std::allocator< BYTE > >
        :param hashResult: Hash result as vector of bytes. LSB is returned first.
                   Vector capacity should be at least 4 bytes, since hash is 4-bytes long.
        """
        return _connect.CUMIController_readHash(self, *args)

    def getDeviceIndex(self, deviceName: "std::string const &", isThrowOnNotFound: "bool"=True) -> "int32_t":
        r"""
        Gets device index for the given device name. It is highly recommended to use this
        method for obtaining device index when calling other methods of this class.
        This way you code will be more robust and will work also if device order changes.
        :type deviceName: string
        :param deviceName: UMI device name
        :type isThrowOnNotFound: boolean, optional
        :param isThrowOnNotFound: if true IllegalStateException is raised in case device not found
        :rtype: int
        :return: index of device, or -1 if device was not found
        :raises: IllegalStateException if device index for the given name can't be retrieved.
        """
        return _connect.CUMIController_getDeviceIndex(self, deviceName, isThrowOnNotFound)

    def getLastError(self) -> "std::string":
        r"""
        This function returns error description, after UMI isystem.connect call fails.
        If there is no error message available, an empty string is returned.
        """
        return _connect.CUMIController_getLastError(self)

# Register CUMIController in _connect:
_connect.CUMIController_swigregister(CUMIController)

class CEMMCPartitionInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, bootStatus: "bool", bootModifyStatus: "bool", nameModifyStatus: "bool", offsetModifyStatus: "bool", sizeModifyStatus: "bool", removeStatus: "bool", enhancedOffset: "uint64_t", enhancedSize: "uint64_t", offset: "uint64_t", size: "uint64_t", extended: "std::string const &", type: "std::string const &", name: "std::string const &"):
        _connect.CEMMCPartitionInfo_swiginit(self, _connect.new_CEMMCPartitionInfo(bootStatus, bootModifyStatus, nameModifyStatus, offsetModifyStatus, sizeModifyStatus, removeStatus, enhancedOffset, enhancedSize, offset, size, extended, type, name))
    __swig_destroy__ = _connect.delete_CEMMCPartitionInfo

    def isBootable(self) -> "bool":
        r"""Returns ``true`` if partition is bootable, ``false`` otherwise."""
        return _connect.CEMMCPartitionInfo_isBootable(self)

    def canModifyBoot(self) -> "bool":
        r"""Returns ``true`` if partition boot status can be changed, ``false`` otherwise."""
        return _connect.CEMMCPartitionInfo_canModifyBoot(self)

    def canModifyName(self) -> "bool":
        r"""Returns ``true`` if partition name can be changed, ``false`` otherwise."""
        return _connect.CEMMCPartitionInfo_canModifyName(self)

    def canModifyOffset(self) -> "bool":
        r"""Returns ``true`` if partition offset can be changed, ``false`` otherwise."""
        return _connect.CEMMCPartitionInfo_canModifyOffset(self)

    def canModifySize(self) -> "bool":
        r"""Returns ``true`` if partition size can be changed, ``false`` otherwise."""
        return _connect.CEMMCPartitionInfo_canModifySize(self)

    def canRemove(self) -> "bool":
        r"""Returns ``true`` if partition can be removed, ``false`` otherwise."""
        return _connect.CEMMCPartitionInfo_canRemove(self)

    def getEnhancedOffset(self) -> "uint64_t":
        r"""Returns partition enhanced offset."""
        return _connect.CEMMCPartitionInfo_getEnhancedOffset(self)

    def getEnhancedSize(self) -> "uint64_t":
        r"""Returns partition enhanced size."""
        return _connect.CEMMCPartitionInfo_getEnhancedSize(self)

    def getOffset(self) -> "uint64_t":
        r"""Returns partition offset."""
        return _connect.CEMMCPartitionInfo_getOffset(self)

    def getSize(self) -> "uint64_t":
        r"""Returns partition size."""
        return _connect.CEMMCPartitionInfo_getSize(self)

    def getExtended(self) -> "std::string":
        r"""Returns partition extended status."""
        return _connect.CEMMCPartitionInfo_getExtended(self)

    def getType(self) -> "std::string":
        r"""Returns partition type."""
        return _connect.CEMMCPartitionInfo_getType(self)

    def getName(self) -> "std::string":
        r"""Returns partition name."""
        return _connect.CEMMCPartitionInfo_getName(self)

# Register CEMMCPartitionInfo in _connect:
_connect.CEMMCPartitionInfo_swigregister(CEMMCPartitionInfo)

class CEMMCDeviceInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name: "std::string const &", configurationApplyStatus: "bool", partitionCreateStatus: "bool", type: "std::string const &", busWidth: "std::string const &", partitionNames: "StrVector"):
        _connect.CEMMCDeviceInfo_swiginit(self, _connect.new_CEMMCDeviceInfo(name, configurationApplyStatus, partitionCreateStatus, type, busWidth, partitionNames))

    def getName(self) -> "std::string":
        r"""Returns device name."""
        return _connect.CEMMCDeviceInfo_getName(self)

    def canApplyConfiguration(self) -> "bool":
        r"""Returns configuration apply status."""
        return _connect.CEMMCDeviceInfo_canApplyConfiguration(self)

    def canCreatePartition(self) -> "bool":
        r"""Returns partition creation status."""
        return _connect.CEMMCDeviceInfo_canCreatePartition(self)

    def getType(self) -> "std::string":
        r"""Returns device type."""
        return _connect.CEMMCDeviceInfo_getType(self)

    def getBusWidth(self) -> "std::string":
        r"""Returns device bus width."""
        return _connect.CEMMCDeviceInfo_getBusWidth(self)

    def getPartitionNames(self) -> "iconnect::StrVector":
        r"""Returns vector of partition names."""
        return _connect.CEMMCDeviceInfo_getPartitionNames(self)
    __swig_destroy__ = _connect.delete_CEMMCDeviceInfo

# Register CEMMCDeviceInfo in _connect:
_connect.CEMMCDeviceInfo_swigregister(CEMMCDeviceInfo)

class CEMMCController(object):
    r"""This class provides EMMC storage device manipulation methods."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CEMMCController_swiginit(self, _connect.new_CEMMCController(*args))
    __swig_destroy__ = _connect.delete_CEMMCController
    textFile = _connect.CEMMCController_textFile
    r""" text file"""
    binFile = _connect.CEMMCController_binFile
    r""" binary file"""

    def initialize(self, deviceName: "std::string const &") -> "void":
        r"""
        Initialize environment. Needs to be called once before any class method is executed,
        except getDevicesNumber() and getDevicesNames() class methods.

        :type deviceName: string
        :param deviceName: storage device name
        :raises: IllegalStateException in case if operation fails.
        """
        return _connect.CEMMCController_initialize(self, deviceName)

    def terminate(self) -> "void":
        r"""
        Terminate environment. Needs to be called after the last class method is executed.

        :raises: IllegalStateException in case of monitor unload fails.
        """
        return _connect.CEMMCController_terminate(self)

    def getDevicesNumber(self) -> "uint32_t":
        r"""
        Returns number of available emmc storage devices.

        :rtype: int
        :return: number of available emmc storage devices.

        :raises: IllegalStateException if number of emmc storage devices can't be retrieved.
        """
        return _connect.CEMMCController_getDevicesNumber(self)

    def getDevicesNames(self, deviceNames: "StrVector") -> "void":
        r"""
        Returns vector of available emmc storage device names.

        :rtype: void
        :return: vector of available emmc storage device names.

        :raises: IllegalStateException if vector of emmc storage device names can't be retrieved.
        """
        return _connect.CEMMCController_getDevicesNames(self, deviceNames)

    def getDeviceInfo(self) -> "isys::CEMMCDeviceInfo":
        r"""
        Returns device information.

        :rtype: :py:class:`CEMMCDeviceInfo`
        :return: CEMMCDeviceInfo

        :raises: IllegalStateException if device information can't be retrieved.
        """
        return _connect.CEMMCController_getDeviceInfo(self)

    def getPartitionInfo(self, partitionName: "std::string const &") -> "CEMMCPartitionInfo":
        r"""
        Returns device's partition information.

        :type partitionName: string
        :param partitionName: partition name
        :rtype: :py:class:`CEMMCPartitionInfo`
        :return: CEMMCPartitionInfoSPtr
        """
        return _connect.CEMMCController_getPartitionInfo(self, partitionName)

    def read(self, partitionName: "std::string const &", offset: "uint64_t", sizeInBytes: "uint64_t", data: "VectorBYTE") -> "void":
        r"""
        Reads data from the storage device.

        :type partitionName: string
        :param partitionName: name of partition
        :type offset: int
        :param offset: to add to the address of the selected partition
        :type sizeInBytes: int
        :param sizeInBytes: number of bytes to read
        :type data: std::vector< uint8_t,std::allocator< uint8_t > >
        :param data: vector to contain read data on return
        """
        return _connect.CEMMCController_read(self, partitionName, offset, sizeInBytes, data)

    def write(self, *args) -> "void":
        r"""
        *Overload 1:*

        Writes data to the storage device from the input vector.

        :type partitionName: string
        :param partitionName: name of partition
        :type offset: int
        :param offset: to add to the address of the selected partition
        :type sizeInBytes: int
        :param sizeInBytes: number of bytes to write
        :type data: std::vector< uint8_t,std::allocator< uint8_t > >
        :param data: vector of data to be written

        |

        *Overload 2:*

        Writes contents of file to the storage device offset.

        :type partitionName: string
        :param partitionName: name of partition
        :type offset: int
        :param offset: to add to the address of the selected partition
        :type filePath: string
        :param filePath: path to the file
        """
        return _connect.CEMMCController_write(self, *args)

    def erase(self, *args) -> "void":
        r"""
        *Overload 1:*

        Erases content of selected partition.

        :type partitionName: string
        :param partitionName: name of partition
        :type sizeInBytes: int
        :param sizeInBytes: number of bytes to be erased from the start of partition

        |

        *Overload 2:*

        Erases content of selected partition.

        :type partitionName: string
        :param partitionName: name of partition
        :type offset: int
        :param offset: to add to the address of the selected partition
        :type sizeInBytes: int
        :param sizeInBytes: number of bytes to be erased from the start of partition
        """
        return _connect.CEMMCController_erase(self, *args)

    def modify(self, partitionName: "std::string const &", offset: "uint64_t", sizeInBytes: "uint64_t", isBoot: "bool") -> "void":
        r"""
        Modifies parameters of the selected partition.

        :type partitionName: string
        :param partitionName: name of partition
        :type offset: int
        :param offset: to add to the address of the selected partition
        :type sizeInBytes: int
        :param sizeInBytes: number of bytes reserved for selected partition
        :type isBoot: boolean
        :param isBoot: bootable partition flag
        """
        return _connect.CEMMCController_modify(self, partitionName, offset, sizeInBytes, isBoot)

    def isDeviceEmpty(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Compares device contents to the empty value.
        :type partitionName: string
        :param partitionName: name of partition
        :rtype: boolean
        :return: true if the device is empty, false otherwise

        |

        *Overload 2:*

        Compares device contents to the empty value at given address.
        :type offset: int
        :param offset: to add to the address of the selected partition
        :type sizeInBytes: int
        :param sizeInBytes: number of bytes to be compared with
        :rtype: boolean
        :return: true if the device is empty, false otherwise
        """
        return _connect.CEMMCController_isDeviceEmpty(self, *args)

# Register CEMMCController in _connect:
_connect.CEMMCController_swigregister(CEMMCController)

class CStorageDeviceController(object):
    r"""This class presents a common API for all storage devices."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_CStorageDeviceController

    def read(self, address: "ADDRESS_64", size: "ADDRESS_64", data: "VectorBYTE") -> "void":
        r"""
        Reads data from device.
        :type address: int
        :param address: address to read from
        :type size: int
        :param size: size of the data to read
        :type data: std::vector< BYTE,std::allocator< BYTE > >
        :param data: vector to contain read data on return
        """
        return _connect.CStorageDeviceController_read(self, address, size, data)

    def write(self, *args) -> "void":
        r"""
        *Overload 1:*

        Writes contents of pre-configured files to device.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.
        :raises: IllegalStateException if operation not supported.

        |

        *Overload 2:*

        Writes contents of file to device.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.
        :type fileFormat: int
        :param fileFormat: should be one of ``wFile...`` flags from IConnectUMI::EOperationFlags,
                              for example IConnectUMI::wFileFormatAuto, IConnectUMI::wFileFormatBin,
                              IConnectUMI::wFileFormatS, IConnectUMI::wFileFormatHex.
        :type offset: int
        :param offset: offset to add to the address in the file
        :type fileName: string
        :param fileName: path to the file to program

        |

        *Overload 3:*

        Writes data to device.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.
        :type address: int
        :param address: address to write to
        :type size: int
        :param size: size of the data to write
        :type data: std::vector< BYTE,std::allocator< BYTE > >
        :param data: vector of data to be written
        """
        return _connect.CStorageDeviceController_write(self, *args)

    def erase(self, *args) -> "void":
        r"""
        *Overload 1:*

        Erases complete device.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or IConnectUMI::wProgCache.

        |

        *Overload 2:*

        Erases the specified region (sector, partition,...).
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.
        :type address: int
        :param address: address to erase from
        :type size: int
        :param size: size of the data to be erased
        """
        return _connect.CStorageDeviceController_erase(self, *args)

    def flush(self) -> "void":
        r"""
        Programs the device from the intermediate cache.
        :raises: IllegalStateException if operation not supported.
        """
        return _connect.CStorageDeviceController_flush(self)

    def verify(self, *args) -> "void":
        r"""
        *Overload 1:*

        Compares device contents to cache. Throws `CUMIException` in case of verification
        error (contents do not match), throws `IOException` in case of any
        other _isystem.connect_ error.
        :raises: IllegalStateException if operation not supported.

        |

        *Overload 2:*

        Compares device contents to cache. Throws `CUMIException` in case of verification
        error (contents do not match), throws `IOException` in case of any
        other _isystem.connect_ error.

        :type address: int
        :param address: address to verify from
        :type size: int
        :param size: size of the data to be verified
        :raises: IllegalStateException if operation not supported.
        """
        return _connect.CStorageDeviceController_verify(self, *args)

    def isDeviceEmpty(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Compares device contents to the empty value.
        :rtype: boolean
        :return: true if the device is empty, false otherwise
        :raises: IllegalStateException if operation not supported.

        |

        *Overload 2:*

        Compares device contents to the empty value at given address.
        :type address: int
        :param address: address to verify from
        :type size: int
        :param size: size of the data to be verified
        :rtype: boolean
        :return: true if the device is empty, false otherwise
        :raises: IllegalStateException if operation not supported.
        """
        return _connect.CStorageDeviceController_isDeviceEmpty(self, *args)

    def fill(self) -> "void":
        r"""
        Fills device with preconfigured value
        :raises: CUMIException if device is not empty
        :raises: IllegalStateException if operation not supported.
        """
        return _connect.CStorageDeviceController_fill(self)

    def readState(self, programMode: "IConnectUMI::EOperationFlags", address: "ADDRESS_64", size: "ADDRESS_64", stateResult: "VectorBYTE") -> "void":
        r"""
        Reads the device program state.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or IConnectUMI::wProgCache.
        :type address: int
        :param address: starting address
        :type size: int
        :param size: size of the data to be examined
        :type stateResult: std::vector< BYTE,std::allocator< BYTE > >
        :param stateResult: Program state as vector of bytes, returned as an unpacked byte array (1 MAU per byte).
                   Vector size must be the size of the data to be examined. Value equals to 1 if MAU programmed and 0 if not.
        :raises: IllegalStateException if operation not supported.
        """
        return _connect.CStorageDeviceController_readState(self, programMode, address, size, stateResult)

    def readHash(self, *args) -> "void":
        r"""
        *Overload 1:*

        Reads target device data MURMUR2 hash.
        :type hashResult: std::vector< BYTE,std::allocator< BYTE > >
        :param hashResult: Hash result as vector of bytes. LSB is returned first.
                   Vector capacity should be at least 4 BYTES.
        :raises: IllegalStateException if operation not supported.

        |

        *Overload 2:*

        Reads target device data MURMUR2 hash.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.
        :type address: int
        :param address: starting address for hash calculation
        :type size: int
        :param size: size of the data to be hashed
        :type hashResult: std::vector< BYTE,std::allocator< BYTE > >
        :param hashResult: Hash result as vector of bytes. LSB is returned first.
                   Vector capacity should be at least 4 bytes, since hash is 4-bytes long.
        :raises: IllegalStateException if operation not supported.
        """
        return _connect.CStorageDeviceController_readHash(self, *args)

    def getLastError(self) -> "std::string":
        r"""
        This function returns error description, after call fails.
        If there is no error message available, an empty string is returned.
        :rtype: string
        :return: error description string
        """
        return _connect.CStorageDeviceController_getLastError(self)

    def getSecurityModule(self) -> "CSecurityStorageDeviceModule":
        r"""
        Returns security storage device module.
        :rtype: :py:class:`CStorageDeviceSecurityModule`
        :return: security storage device module if available, otherwise return nullptr
        """
        return _connect.CStorageDeviceController_getSecurityModule(self)

    def getPartitionConfigurationModule(self) -> "CPartitionConfigurationModule":
        r"""
        Returns configuration module for partition based devices.
        :rtype: isys::CPartitionConfigurationModuleSPtr
        :return: configuration module for partition based devices if available, otherwise return nullptr
        """
        return _connect.CStorageDeviceController_getPartitionConfigurationModule(self)

    def getPerformanceModule(self) -> "CStorageDevicePerformanceModule":
        return _connect.CStorageDeviceController_getPerformanceModule(self)

# Register CStorageDeviceController in _connect:
_connect.CStorageDeviceController_swigregister(CStorageDeviceController)

EStorageDevice_EmbeddedFlashDevice = _connect.EStorageDevice_EmbeddedFlashDevice
r""" internal storage device type"""
EStorageDevice_EMMCDevice = _connect.EStorageDevice_EMMCDevice
r""" emmc storage device type"""
EStorageDevice_SPIDevice = _connect.EStorageDevice_SPIDevice
r""" spi storage device type"""
EStorageDevice_HyperFlash = _connect.EStorageDevice_HyperFlash
r""" hyper flash storage device"""
class CStorageDeviceFactory(object):
    r"""This class presents a storage devices factory methods."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def makeDevice(*args) -> "std::shared_ptr< isys::CStorageDeviceController >":
        r"""
        *Overload 1:*

        Creates pointer to specified device type by device name.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection manager
        :type type: int
        :param type: storage device type
        :type deviceName: string
        :param deviceName: device name
        :rtype: :py:class:`CStorageDeviceController`
        :return: pointer to specified device type

        |

        *Overload 2:*

        Creates pointer to specified device type by device and partition name.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection manager
        :type type: int
        :param type: storage device type
        :type deviceName: string
        :param deviceName: device name
        :type partitionName: string
        :param partitionName: partition name
        :rtype: :py:class:`CStorageDeviceController`
        :return: pointer to specified device type

        |

        *Overload 3:*

        Creates pointer to specified device type by device index.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection manager
        :type type: int
        :param type: storage device type
        :type deviceIndex: int
        :param deviceIndex: device index
        :rtype: :py:class:`CStorageDeviceController`
        :return: pointer to specified device type

        |

        *Overload 4:*

        Creates pointer to specified device type by device index and partition name.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection manager
        :type type: int
        :param type: storage device type
        :type deviceIndex: int
        :param deviceIndex: device index
        :type partitionName: string
        :param partitionName: partition name
        :rtype: :py:class:`CStorageDeviceController`
        :return: pointer to specified device type
        """
        return _connect.CStorageDeviceFactory_makeDevice(*args)

    @staticmethod
    def terminateDevice(*args) -> "void":
        r"""
        *Overload 1:*

        Terminates device connection by name. Valid only for partition based devices (emmc).
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection manager
        :type type: int
        :param type: storage device type
        :type deviceName: string
        :param deviceName: device name

        |

        *Overload 2:*

        Terminates device connection by index. Valid only for partition based devices (emmc).
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection manager
        :type type: int
        :param type: storage device type
        :type deviceIndex: int
        :param deviceIndex: device index
        """
        return _connect.CStorageDeviceFactory_terminateDevice(*args)

    @staticmethod
    def getDeviceNames(connectionMgr: "isys::ConnectionMgrSPtr", deviceNames: "StrVector") -> "void":
        r"""
        Collects all available storage device names.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection manager
        :type deviceNames: std::vector< std::string,std::allocator< std::string > >
        :param deviceNames: vector of all available storage device names
        """
        return _connect.CStorageDeviceFactory_getDeviceNames(connectionMgr, deviceNames)

    @staticmethod
    def getDeviceInfo(connectionMgr: "isys::ConnectionMgrSPtr", deviceName: "std::string", elements: "StrStrMap") -> "void":
        r"""
        Provides device info - internal device structure. Valid only for partition based devices (emmc).
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection manager
        :type deviceName: string
        :param deviceName: storage device name
        :type elements: :py:class:`StrStrMap`
        :param elements: device parameters as mapping
        :raises: IOException if no device by deviceName exists.
        """
        return _connect.CStorageDeviceFactory_getDeviceInfo(connectionMgr, deviceName, elements)

    def __init__(self):
        _connect.CStorageDeviceFactory_swiginit(self, _connect.new_CStorageDeviceFactory())
    __swig_destroy__ = _connect.delete_CStorageDeviceFactory

# Register CStorageDeviceFactory in _connect:
_connect.CStorageDeviceFactory_swigregister(CStorageDeviceFactory)

def CStorageDeviceFactory_makeDevice(*args) -> "std::shared_ptr< isys::CStorageDeviceController >":
    r"""
    *Overload 1:*

    Creates pointer to specified device type by device name.
    :type connectionMgr: :py:class:`ConnectionMgr`
    :param connectionMgr: connection manager
    :type type: int
    :param type: storage device type
    :type deviceName: string
    :param deviceName: device name
    :rtype: :py:class:`CStorageDeviceController`
    :return: pointer to specified device type

    |

    *Overload 2:*

    Creates pointer to specified device type by device and partition name.
    :type connectionMgr: :py:class:`ConnectionMgr`
    :param connectionMgr: connection manager
    :type type: int
    :param type: storage device type
    :type deviceName: string
    :param deviceName: device name
    :type partitionName: string
    :param partitionName: partition name
    :rtype: :py:class:`CStorageDeviceController`
    :return: pointer to specified device type

    |

    *Overload 3:*

    Creates pointer to specified device type by device index.
    :type connectionMgr: :py:class:`ConnectionMgr`
    :param connectionMgr: connection manager
    :type type: int
    :param type: storage device type
    :type deviceIndex: int
    :param deviceIndex: device index
    :rtype: :py:class:`CStorageDeviceController`
    :return: pointer to specified device type

    |

    *Overload 4:*

    Creates pointer to specified device type by device index and partition name.
    :type connectionMgr: :py:class:`ConnectionMgr`
    :param connectionMgr: connection manager
    :type type: int
    :param type: storage device type
    :type deviceIndex: int
    :param deviceIndex: device index
    :type partitionName: string
    :param partitionName: partition name
    :rtype: :py:class:`CStorageDeviceController`
    :return: pointer to specified device type
    """
    return _connect.CStorageDeviceFactory_makeDevice(*args)

def CStorageDeviceFactory_terminateDevice(*args) -> "void":
    r"""
    *Overload 1:*

    Terminates device connection by name. Valid only for partition based devices (emmc).
    :type connectionMgr: :py:class:`ConnectionMgr`
    :param connectionMgr: connection manager
    :type type: int
    :param type: storage device type
    :type deviceName: string
    :param deviceName: device name

    |

    *Overload 2:*

    Terminates device connection by index. Valid only for partition based devices (emmc).
    :type connectionMgr: :py:class:`ConnectionMgr`
    :param connectionMgr: connection manager
    :type type: int
    :param type: storage device type
    :type deviceIndex: int
    :param deviceIndex: device index
    """
    return _connect.CStorageDeviceFactory_terminateDevice(*args)

def CStorageDeviceFactory_getDeviceNames(connectionMgr: "isys::ConnectionMgrSPtr", deviceNames: "StrVector") -> "void":
    r"""
    Collects all available storage device names.
    :type connectionMgr: :py:class:`ConnectionMgr`
    :param connectionMgr: connection manager
    :type deviceNames: std::vector< std::string,std::allocator< std::string > >
    :param deviceNames: vector of all available storage device names
    """
    return _connect.CStorageDeviceFactory_getDeviceNames(connectionMgr, deviceNames)

def CStorageDeviceFactory_getDeviceInfo(connectionMgr: "isys::ConnectionMgrSPtr", deviceName: "std::string", elements: "StrStrMap") -> "void":
    r"""
    Provides device info - internal device structure. Valid only for partition based devices (emmc).
    :type connectionMgr: :py:class:`ConnectionMgr`
    :param connectionMgr: connection manager
    :type deviceName: string
    :param deviceName: storage device name
    :type elements: :py:class:`StrStrMap`
    :param elements: device parameters as mapping
    :raises: IOException if no device by deviceName exists.
    """
    return _connect.CStorageDeviceFactory_getDeviceInfo(connectionMgr, deviceName, elements)

class CStorageDeviceSecurityModule(object):
    r"""This class presents a common API for storage devices security module."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_CStorageDeviceSecurityModule

    def secure(self, *args) -> "void":
        r"""
        *Overload 1:*

        Secures the device.

        |

        *Overload 2:*

        Secures the sector.
        :type address: int
        :param address: address of the sector to be secured
        :type size: int
        :param size: size of the sector to be secured
        """
        return _connect.CStorageDeviceSecurityModule_secure(self, *args)

    def unsecure(self, *args) -> "void":
        r"""
        *Overload 1:*

        Unsecures the device.

        |

        *Overload 2:*

        Unsecures the sector.
        :type address: int
        :param address: address of the sector to be unsecured
        :type size: int
        :param size: size of the sector to be unsecured
        """
        return _connect.CStorageDeviceSecurityModule_unsecure(self, *args)

    def secureCheck(self, *args) -> "void":
        r"""
        *Overload 1:*

        Checks if security is set on device.

        |

        *Overload 2:*

        Checks if security is set on sector.
        :type address: int
        :param address: address of the sector to be unsecured
        :type size: int
        :param size: size of the sector to be unsecured
        """
        return _connect.CStorageDeviceSecurityModule_secureCheck(self, *args)

# Register CStorageDeviceSecurityModule in _connect:
_connect.CStorageDeviceSecurityModule_swigregister(CStorageDeviceSecurityModule)

class CBasicFlashSecurityModule(CStorageDeviceSecurityModule):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, umiCtrl: "CUMIController", deviceIndex: "uint32_t const"):
        _connect.CBasicFlashSecurityModule_swiginit(self, _connect.new_CBasicFlashSecurityModule(umiCtrl, deviceIndex))
    __swig_destroy__ = _connect.delete_CBasicFlashSecurityModule

    def secure(self, *args) -> "void":
        return _connect.CBasicFlashSecurityModule_secure(self, *args)

    def unsecure(self, *args) -> "void":
        return _connect.CBasicFlashSecurityModule_unsecure(self, *args)

    def secureCheck(self, *args) -> "void":
        return _connect.CBasicFlashSecurityModule_secureCheck(self, *args)

# Register CBasicFlashSecurityModule in _connect:
_connect.CBasicFlashSecurityModule_swigregister(CBasicFlashSecurityModule)

class CBasicFlashStorageDevice(CStorageDeviceController):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CBasicFlashStorageDevice_swiginit(self, _connect.new_CBasicFlashStorageDevice(*args))
    __swig_destroy__ = _connect.delete_CBasicFlashStorageDevice

    def read(self, address: "ADDRESS_64", size: "ADDRESS_64", data: "VectorBYTE") -> "void":
        return _connect.CBasicFlashStorageDevice_read(self, address, size, data)

    def write(self, *args) -> "void":
        return _connect.CBasicFlashStorageDevice_write(self, *args)

    def erase(self, *args) -> "void":
        return _connect.CBasicFlashStorageDevice_erase(self, *args)

    def flush(self) -> "void":
        return _connect.CBasicFlashStorageDevice_flush(self)

    def verify(self, *args) -> "void":
        return _connect.CBasicFlashStorageDevice_verify(self, *args)

    def isDeviceEmpty(self, *args) -> "bool":
        return _connect.CBasicFlashStorageDevice_isDeviceEmpty(self, *args)

    def fill(self) -> "void":
        return _connect.CBasicFlashStorageDevice_fill(self)

    def readState(self, programMode: "IConnectUMI::EOperationFlags", address: "ADDRESS_64", size: "ADDRESS_64", stateResult: "VectorBYTE") -> "void":
        return _connect.CBasicFlashStorageDevice_readState(self, programMode, address, size, stateResult)

    def readHash(self, *args) -> "void":
        return _connect.CBasicFlashStorageDevice_readHash(self, *args)

    def getLastError(self) -> "std::string":
        return _connect.CBasicFlashStorageDevice_getLastError(self)

    def getSecurityModule(self) -> "CSecurityStorageDeviceModule":
        return _connect.CBasicFlashStorageDevice_getSecurityModule(self)

    def getPartitionConfigurationModule(self) -> "CPartitionConfigurationModule":
        return _connect.CBasicFlashStorageDevice_getPartitionConfigurationModule(self)

    def getPerformanceModule(self) -> "CStorageDevicePerformanceModule":
        return _connect.CBasicFlashStorageDevice_getPerformanceModule(self)

# Register CBasicFlashStorageDevice in _connect:
_connect.CBasicFlashStorageDevice_swigregister(CBasicFlashStorageDevice)

class CEMMCStorageDevice(CStorageDeviceController):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CEMMCStorageDevice_swiginit(self, _connect.new_CEMMCStorageDevice(*args))
    __swig_destroy__ = _connect.delete_CEMMCStorageDevice

    def read(self, address: "ADDRESS_64", size: "ADDRESS_64", data: "VectorBYTE") -> "void":
        return _connect.CEMMCStorageDevice_read(self, address, size, data)

    def write(self, *args) -> "void":
        return _connect.CEMMCStorageDevice_write(self, *args)

    def erase(self, *args) -> "void":
        return _connect.CEMMCStorageDevice_erase(self, *args)

    def flush(self) -> "void":
        return _connect.CEMMCStorageDevice_flush(self)

    def verify(self, *args) -> "void":
        return _connect.CEMMCStorageDevice_verify(self, *args)

    def isDeviceEmpty(self, *args) -> "bool":
        return _connect.CEMMCStorageDevice_isDeviceEmpty(self, *args)

    def fill(self) -> "void":
        return _connect.CEMMCStorageDevice_fill(self)

    def readState(self, programMode: "IConnectUMI::EOperationFlags", address: "ADDRESS_64", size: "ADDRESS_64", stateResult: "VectorBYTE") -> "void":
        return _connect.CEMMCStorageDevice_readState(self, programMode, address, size, stateResult)

    def readHash(self, *args) -> "void":
        return _connect.CEMMCStorageDevice_readHash(self, *args)

    def getLastError(self) -> "std::string":
        return _connect.CEMMCStorageDevice_getLastError(self)

    @staticmethod
    def terminate(*args) -> "void":
        return _connect.CEMMCStorageDevice_terminate(*args)

    def getSecurityModule(self) -> "CSecurityStorageDeviceModule":
        return _connect.CEMMCStorageDevice_getSecurityModule(self)

    def getPartitionConfigurationModule(self) -> "CPartitionConfigurationModule":
        return _connect.CEMMCStorageDevice_getPartitionConfigurationModule(self)

    def getPerformanceModule(self) -> "CStorageDevicePerformanceModule":
        return _connect.CEMMCStorageDevice_getPerformanceModule(self)

# Register CEMMCStorageDevice in _connect:
_connect.CEMMCStorageDevice_swigregister(CEMMCStorageDevice)

def CEMMCStorageDevice_terminate(*args) -> "void":
    return _connect.CEMMCStorageDevice_terminate(*args)

class CEMMCPartitionConfigurationModule(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, emmcCtrl: "CEMMCController", partitionName: "std::string const"):
        _connect.CEMMCPartitionConfigurationModule_swiginit(self, _connect.new_CEMMCPartitionConfigurationModule(emmcCtrl, partitionName))
    __swig_destroy__ = _connect.delete_CEMMCPartitionConfigurationModule

    def modify(self, offset: "ADDRESS_64", sizeInBytes: "ADDRESS_64", isBoot: "bool") -> "void":
        return _connect.CEMMCPartitionConfigurationModule_modify(self, offset, sizeInBytes, isBoot)

    def getPartitionInfo(self) -> "CPartitionInfo":
        return _connect.CEMMCPartitionConfigurationModule_getPartitionInfo(self)

# Register CEMMCPartitionConfigurationModule in _connect:
_connect.CEMMCPartitionConfigurationModule_swigregister(CEMMCPartitionConfigurationModule)

class SSingleOperationDiagnostics(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_downloadTimeInUs = property(_connect.SSingleOperationDiagnostics_m_downloadTimeInUs_get, _connect.SSingleOperationDiagnostics_m_downloadTimeInUs_set)
    m_downloadSize = property(_connect.SSingleOperationDiagnostics_m_downloadSize_get, _connect.SSingleOperationDiagnostics_m_downloadSize_set)
    m_executionTimeInUs = property(_connect.SSingleOperationDiagnostics_m_executionTimeInUs_get, _connect.SSingleOperationDiagnostics_m_executionTimeInUs_set)
    m_affectedSize = property(_connect.SSingleOperationDiagnostics_m_affectedSize_get, _connect.SSingleOperationDiagnostics_m_affectedSize_set)

    def __init__(self):
        _connect.SSingleOperationDiagnostics_swiginit(self, _connect.new_SSingleOperationDiagnostics())
    __swig_destroy__ = _connect.delete_SSingleOperationDiagnostics

# Register SSingleOperationDiagnostics in _connect:
_connect.SSingleOperationDiagnostics_swigregister(SSingleOperationDiagnostics)

class SAtomicOperationsDiagnostics(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_operationName = property(_connect.SAtomicOperationsDiagnostics_m_operationName_get, _connect.SAtomicOperationsDiagnostics_m_operationName_set)
    m_operationAddress = property(_connect.SAtomicOperationsDiagnostics_m_operationAddress_get, _connect.SAtomicOperationsDiagnostics_m_operationAddress_set)
    m_operationDataSize = property(_connect.SAtomicOperationsDiagnostics_m_operationDataSize_get, _connect.SAtomicOperationsDiagnostics_m_operationDataSize_set)
    m_operationTimeInUs = property(_connect.SAtomicOperationsDiagnostics_m_operationTimeInUs_get, _connect.SAtomicOperationsDiagnostics_m_operationTimeInUs_set)
    m_sumSingleDownloadTimeInUs = property(_connect.SAtomicOperationsDiagnostics_m_sumSingleDownloadTimeInUs_get, _connect.SAtomicOperationsDiagnostics_m_sumSingleDownloadTimeInUs_set)
    m_sumSingleDownloadSize = property(_connect.SAtomicOperationsDiagnostics_m_sumSingleDownloadSize_get, _connect.SAtomicOperationsDiagnostics_m_sumSingleDownloadSize_set)
    m_sumSingleExecutionTimeInUs = property(_connect.SAtomicOperationsDiagnostics_m_sumSingleExecutionTimeInUs_get, _connect.SAtomicOperationsDiagnostics_m_sumSingleExecutionTimeInUs_set)
    m_singleOperations = property(_connect.SAtomicOperationsDiagnostics_m_singleOperations_get, _connect.SAtomicOperationsDiagnostics_m_singleOperations_set)

    def __init__(self):
        _connect.SAtomicOperationsDiagnostics_swiginit(self, _connect.new_SAtomicOperationsDiagnostics())
    __swig_destroy__ = _connect.delete_SAtomicOperationsDiagnostics

# Register SAtomicOperationsDiagnostics in _connect:
_connect.SAtomicOperationsDiagnostics_swigregister(SAtomicOperationsDiagnostics)

class SAtomicSumOperationsDiagnostics(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_operationName = property(_connect.SAtomicSumOperationsDiagnostics_m_operationName_get, _connect.SAtomicSumOperationsDiagnostics_m_operationName_set)
    m_sumOperationTimeInUs = property(_connect.SAtomicSumOperationsDiagnostics_m_sumOperationTimeInUs_get, _connect.SAtomicSumOperationsDiagnostics_m_sumOperationTimeInUs_set)
    m_sumExecutionTimeInUs = property(_connect.SAtomicSumOperationsDiagnostics_m_sumExecutionTimeInUs_get, _connect.SAtomicSumOperationsDiagnostics_m_sumExecutionTimeInUs_set)

    def __init__(self):
        _connect.SAtomicSumOperationsDiagnostics_swiginit(self, _connect.new_SAtomicSumOperationsDiagnostics())
    __swig_destroy__ = _connect.delete_SAtomicSumOperationsDiagnostics

# Register SAtomicSumOperationsDiagnostics in _connect:
_connect.SAtomicSumOperationsDiagnostics_swigregister(SAtomicSumOperationsDiagnostics)

class CStorageDeviceDiagnostics(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, results: "StrStrMap"):
        _connect.CStorageDeviceDiagnostics_swiginit(self, _connect.new_CStorageDeviceDiagnostics(results))
    __swig_destroy__ = _connect.delete_CStorageDeviceDiagnostics
    m_monitorLoadTimeInUs = property(_connect.CStorageDeviceDiagnostics_m_monitorLoadTimeInUs_get, _connect.CStorageDeviceDiagnostics_m_monitorLoadTimeInUs_set)
    m_monitorUnloadTimeInUs = property(_connect.CStorageDeviceDiagnostics_m_monitorUnloadTimeInUs_get, _connect.CStorageDeviceDiagnostics_m_monitorUnloadTimeInUs_set)
    m_totalOperationTimeInUs = property(_connect.CStorageDeviceDiagnostics_m_totalOperationTimeInUs_get, _connect.CStorageDeviceDiagnostics_m_totalOperationTimeInUs_set)
    m_atomicSumOperations = property(_connect.CStorageDeviceDiagnostics_m_atomicSumOperations_get, _connect.CStorageDeviceDiagnostics_m_atomicSumOperations_set)
    m_atomicOperations = property(_connect.CStorageDeviceDiagnostics_m_atomicOperations_get, _connect.CStorageDeviceDiagnostics_m_atomicOperations_set)

# Register CStorageDeviceDiagnostics in _connect:
_connect.CStorageDeviceDiagnostics_swigregister(CStorageDeviceDiagnostics)

class CStorageDevicePerformanceModule(object):
    r"""This class presents a common API for storage devices performance module."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, ideCtrl: "CIDEController"):
        _connect.CStorageDevicePerformanceModule_swiginit(self, _connect.new_CStorageDevicePerformanceModule(ideCtrl))
    __swig_destroy__ = _connect.delete_CStorageDevicePerformanceModule

    def getDiagnostic(self) -> "isys::CStorageDeviceDiagnostics":
        r"""
        Provides time performances for executed UMI operations.
        :rtype: :py:class:`CStorageDeviceDiagnostics`
        :return: CStorageDeviceDiagnostics object of diagnostic results
        """
        return _connect.CStorageDevicePerformanceModule_getDiagnostic(self)

    def setBufferSize(self, size: "uint32_t const") -> "void":
        r"""
        Set internal buffer size for data received from winIDEA.
        :type size: int
        :param size: buffer size in bytes; 16KB by default
        """
        return _connect.CStorageDevicePerformanceModule_setBufferSize(self, size)

    def clearDiagnostic(self, status: "bool const") -> "void":
        r"""
        Clears diagnostic for each UMI operation execution. Otherwise diagnostic is accumulated.
        :type status: boolean
        :param status: if true diagnostic is cleared for each UMI operation; true by default
        """
        return _connect.CStorageDevicePerformanceModule_clearDiagnostic(self, status)

    def setTestMode(self, status: "bool const") -> "void":
        r"""
        Test mode modifies default monitor behavior as: disable double buffering, disable multiple
        sector erase before download, executes init, deinit, erase and program operation immediately,
        disables on the fly verify
        :type status: boolean
        :param status: if true test mode is enabled; false by default
        """
        return _connect.CStorageDevicePerformanceModule_setTestMode(self, status)

# Register CStorageDevicePerformanceModule in _connect:
_connect.CStorageDevicePerformanceModule_swigregister(CStorageDevicePerformanceModule)

E_FALSE = _connect.E_FALSE
E_TRUE = _connect.E_TRUE
E_DEFAULT = _connect.E_DEFAULT

def putStrStrMap(container: "StrStrMap", key: "std::string const &", value: "std::string const &") -> "void":
    r"""
    Deprecated: SWIG generates wrappers for C++ std containers, so new
    items can be added with Python syntax, for example: `smap['x'] = 'y'`

    Utility method for adding (key, value) pairs to StrStrMap. Intended to be
    used from Python and Java code.
    """
    return _connect.putStrStrMap(container, key, value)

def getModuleVersion() -> "std::string":
    r"""
    This function returns version of current isystem.connect module in
    format: ``<major>.<minor>.<build>.<sub_build>``,
    for example '9.12.184.0'. Use this function if you want to print version only,
    otherwise usage of getSdkVersion() is preferred.

    See also: getSDKVersion()
    """
    return _connect.getModuleVersion()

def readChar() -> "int":
    r"""
    Reads a single character from stdin, if available. If
    the character is not available, 0 is returned.
    """
    return _connect.readChar()

def getUID() -> "std::string":
    r"""
    Returns string unique for this process. This function is not reentrant.
    The string may contain numbers and letters.
    """
    return _connect.getUID()
class CUtil(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CUtil_swiginit(self, _connect.new_CUtil())
    __swig_destroy__ = _connect.delete_CUtil

# Register CUtil in _connect:
_connect.CUtil_swigregister(CUtil)
CUtil.g_qualifiedFuncNamePattern = _connect.cvar.CUtil_g_qualifiedFuncNamePattern
CUtil.g_qualifiedVarNamePattern = _connect.cvar.CUtil_g_qualifiedVarNamePattern
CUtil.MODULE_GRP_IDX = _connect.cvar.CUtil_MODULE_GRP_IDX
CUtil.SYM_NAME_GRP_IDX = _connect.cvar.CUtil_SYM_NAME_GRP_IDX
CUtil.SIGNATURE_GRP_IDX = _connect.cvar.CUtil_SIGNATURE_GRP_IDX
CUtil.DOWNLOAD_FILE_GRP_IDX = _connect.cvar.CUtil_DOWNLOAD_FILE_GRP_IDX

class CTestObject(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    EYAMLScalar = _connect.CTestObject_EYAMLScalar
    EYAMLBool = _connect.CTestObject_EYAMLBool
    EYAMLEnum = _connect.CTestObject_EYAMLEnum
    EYAMLSeqence = _connect.CTestObject_EYAMLSeqence
    EYAMLMap = _connect.CTestObject_EYAMLMap
    ETestBase = _connect.CTestObject_ETestBase
    ETestBaseList = _connect.CTestObject_ETestBaseList
    __swig_destroy__ = _connect.delete_CTestObject

    def setConst(self, isConst: "bool") -> "void":
        r"""
        Sets object state to const. Only getters may called, setters throw an
        exception.
        """
        return _connect.CTestObject_setConst(self, isConst)

    def assign(self, ptr: "isys::CTestObjectSPtr const &") -> "void":
        return _connect.CTestObject_assign(self, ptr)

    def getTestObjType(self) -> "isys::CTestObject::ETestObjType":
        r"""
        If the object is one of CYAMLObject descendants, this method returns
        a reference to it. Otherwise an exception is thrown.

        If the object is one of CTestBase descendants, this method returns
        a reference to it. Otherwise an exception is thrown.
                   Returns object type.
        """
        return _connect.CTestObject_getTestObjType(self)

    def copy(self) -> "CTestObject":
        r"""Returns deep copy of an object."""
        return _connect.CTestObject_copy(self)

    def isEmpty(self) -> "bool":
        r"""
        Returns contents as string in YAML flow style.
        Sequences and Maps are returned without enclosing [] or {}.
                  This value is given to YAML parser which then sets the data.  Returns true if object contains no data.
        """
        return _connect.CTestObject_isEmpty(self)

    def toString(self) -> "std::string":
        r""" Returns string representation of object, usually in YAML format."""
        return _connect.CTestObject_toString(self)

# Register CTestObject in _connect:
_connect.CTestObject_swigregister(CTestObject)

class CTestBase(CTestObject):
    r"""
    This is a base class for all data objects in itest. It may contain
    other objects of derived types, lists of derived types, scalars,
    mappings and lists.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    NEW_LINE_COMMENT = _connect.CTestBase_NEW_LINE_COMMENT
    END_OF_LINE_COMMENT = _connect.CTestBase_END_OF_LINE_COMMENT
    KEY = _connect.CTestBase_KEY
    VALUE = _connect.CTestBase_VALUE
    LIST_ITEM = _connect.CTestBase_LIST_ITEM
    EMayBeEmpty = _connect.CTestBase_EMayBeEmpty
    EMandatory = _connect.CTestBase_EMandatory
    __swig_destroy__ = _connect.delete_CTestBase

    def getClassName(self) -> "std::string":
        return _connect.CTestBase_getClassName(self)

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestBase_createInstance(self, parent)

    def setParent(self, parent: "isys::CTestBaseSPtr") -> "void":
        return _connect.CTestBase_setParent(self, parent)

    def getParent(self) -> "CTestBase":
        return _connect.CTestBase_getParent(self)

    def copy(self) -> "CTestObject":
        return _connect.CTestBase_copy(self)

    @staticmethod
    def cast(obj: "isys::CTestObjectSPtr const &") -> "CTestBase":
        return _connect.CTestBase_cast(obj)

    def assign(self, base: "isys::CTestObjectSPtr const &") -> "void":
        return _connect.CTestBase_assign(self, base)

    def containsSection(self, section: "int") -> "bool":
        return _connect.CTestBase_containsSection(self, section)

    def isSectionEmpty(self, sectionId: "int") -> "bool":
        return _connect.CTestBase_isSectionEmpty(self, sectionId)

    def getNonNullEmptySections(self, emptySections: "IntVector") -> "void":
        return _connect.CTestBase_getNonNullEmptySections(self, emptySections)

    def equalsData(self, other: "isys::CTestBaseSPtr const &") -> "bool":
        return _connect.CTestBase_equalsData(self, other)

    def getContainerTestNode(self) -> "CTestTreeNode":
        return _connect.CTestBase_getContainerTestNode(self)

    def getHierarchyLevel(self) -> "int":
        return _connect.CTestBase_getHierarchyLevel(self)

    def isMerged(self) -> "bool":
        return _connect.CTestBase_isMerged(self)

    def isEmpty(self) -> "bool":
        r""" This method returns true, if the object contains no data."""
        return _connect.CTestBase_isEmpty(self)

    def isTestSpecification(self) -> "bool":
        return _connect.CTestBase_isTestSpecification(self)

    def getCachedMergedTestSpec(self, sectionId: "int") -> "CTestBase":
        return _connect.CTestBase_getCachedMergedTestSpec(self, sectionId)

    def isSectionSet(self, section: "int") -> "bool":
        return _connect.CTestBase_isSectionSet(self, section)

    def serialize(self, emitter: "isys::IEmitterSPtr const &") -> "void":
        r""" Sends contents of this class to emitter."""
        return _connect.CTestBase_serialize(self, emitter)

    def validate(self) -> "std::string":
        return _connect.CTestBase_validate(self)

    def toString(self) -> "std::string":
        r"""Returns object data as YAML string."""
        return _connect.CTestBase_toString(self)

    def setMainMapStyle(self, mappingStyle: "isys::IEmitter::EYamlStyle") -> "void":
        return _connect.CTestBase_setMainMapStyle(self, mappingStyle)

    def getSectionId(self, sectionName: "std::string const &") -> "int":
        return _connect.CTestBase_getSectionId(self, sectionName)

    def getSectionType(self, section: "int") -> "isys::CTestObject::ETestObjType":
        return _connect.CTestBase_getSectionType(self, section)

    def setSectionValue(self, section: "int", objPtr: "isys::CTestObjectSPtr const &") -> "void":
        return _connect.CTestBase_setSectionValue(self, section, objPtr)

    def getTestBase(self, section: "int", isConst: "bool") -> "CTestBase":
        return _connect.CTestBase_getTestBase(self, section, isConst)

    def getTestBaseList(self, section: "int", isConst: "bool") -> "CTestBaseList":
        return _connect.CTestBase_getTestBaseList(self, section, isConst)

    def createTestBase(self, *args) -> "CTestBase":
        return _connect.CTestBase_createTestBase(self, *args)

    def getTestObjType(self) -> "isys::CTestObject::ETestObjType":
        return _connect.CTestBase_getTestObjType(self)

    def getSectionIds(self, sectionIds: "IntVector") -> "void":
        return _connect.CTestBase_getSectionIds(self, sectionIds)

    def getDeprecatedSectionIds(self, sectionIds: "IntVector") -> "void":
        return _connect.CTestBase_getDeprecatedSectionIds(self, sectionIds)

    def getTagName(self, section: "int") -> "std::string":
        return _connect.CTestBase_getTagName(self, section)

    def getIntValue(self, section: "int") -> "int64_t":
        return _connect.CTestBase_getIntValue(self, section)

    def getTagValue(self, *args) -> "std::string":
        return _connect.CTestBase_getTagValue(self, *args)

    def getTagValueOrDefault(self, section: "int", key: "std::string const &") -> "std::string":
        return _connect.CTestBase_getTagValueOrDefault(self, section, key)

    def getBoolTagValue(self, section: "int") -> "iconnect::ETristate":
        return _connect.CTestBase_getBoolTagValue(self, section)

    def getBoolValueAsBool(self, section: "int") -> "bool":
        return _connect.CTestBase_getBoolValueAsBool(self, section)

    def getEnumTagValue(self, section: "int") -> "int":
        return _connect.CTestBase_getEnumTagValue(self, section)

    def getSectionValue(self, section: "int", isConst: "bool") -> "CTestObject":
        return _connect.CTestBase_getSectionValue(self, section, isConst)

    def containsMapEntry(self, section: "int", key: "std::string const &") -> "bool":
        return _connect.CTestBase_containsMapEntry(self, section, key)

    def removeMapEntry(self, section: "int", key: "std::string const &") -> "bool":
        return _connect.CTestBase_removeMapEntry(self, section, key)

    def removeValue(self, section: "int") -> "bool":
        return _connect.CTestBase_removeValue(self, section)

    def setTagValue(self, *args) -> "void":
        return _connect.CTestBase_setTagValue(self, *args)

    def setBoolTagValue(self, section: "int", value: "iconnect::ETristate") -> "void":
        return _connect.CTestBase_setBoolTagValue(self, section, value)

    def setEnumTagValue(self, section: "int", enumValue: "int") -> "void":
        return _connect.CTestBase_setEnumTagValue(self, section, enumValue)

    def setComment(self, *args) -> "void":
        return _connect.CTestBase_setComment(self, *args)

    def getComment(self, *args) -> "std::string":
        return _connect.CTestBase_getComment(self, *args)

    def getCommentForSeqElement(self, section: "int", idx: "int", commentType: "isys::CTestBase::CommentType") -> "std::string":
        return _connect.CTestBase_getCommentForSeqElement(self, section, idx, commentType)

    def getDefaultValue(self, sectionId: "int") -> "int":
        return _connect.CTestBase_getDefaultValue(self, sectionId)

    def getEnumValues(self, sectionId: "int", values: "StrVector") -> "std::string":
        return _connect.CTestBase_getEnumValues(self, sectionId, values)

    def enum2Str(self, sectionId: "int", enumValue: "int") -> "std::string":
        return _connect.CTestBase_enum2Str(self, sectionId, enumValue)

    def isSerializedAsList(self, isParsing: "bool") -> "bool":
        return _connect.CTestBase_isSerializedAsList(self, isParsing)

# Register CTestBase in _connect:
_connect.CTestBase_swigregister(CTestBase)

def CTestBase_cast(obj: "isys::CTestObjectSPtr const &") -> "CTestBase":
    return _connect.CTestBase_cast(obj)

class CTestBaseList(CTestObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CTestBaseList_swiginit(self, _connect.new_CTestBaseList(*args))
    __swig_destroy__ = _connect.delete_CTestBaseList

    def assign(self, ptr: "isys::CTestObjectSPtr const &") -> "void":
        r"""
        Assigns copies of elements from the given list to this object. Original
        contents of this list is cleared.

        :type ptr: :py:class:`CTestObject`
        :param ptr: reference to instance of CTestBaseList
        """
        return _connect.CTestBaseList_assign(self, ptr)

    @staticmethod
    def cast(obj: "isys::CTestObjectSPtr const &") -> "CTestBaseList":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestBaseList_cast(obj)

    def getParent(self) -> "CTestBase":
        r""" Returns parent."""
        return _connect.CTestBaseList_getParent(self)

    def setParent(self, parent: "isys::CTestBaseSPtr &") -> "void":
        r""" Sets parent."""
        return _connect.CTestBaseList_setParent(self, parent)

    def moveElements(self, src: "isys::CTestBaseListSPtr") -> "void":
        r"""
        Moves elements from source list to this list. The source list is cleared
        after move. This is much faster than assign, since assign makes deep copy,
        while this method copies only references.
        """
        return _connect.CTestBaseList_moveElements(self, src)

    def copy(self) -> "CTestObject":
        r"""Returns deep copy of an object."""
        return _connect.CTestBaseList_copy(self)

    def equalsData(self, other: "isys::CTestBaseListSPtr const &") -> "bool":
        r"""
        Returns true, if the two objects have equal data, including comments.
        Formatting is not compared. The order of elements in the list is
        important.
        """
        return _connect.CTestBaseList_equalsData(self, other)

    def clearEmptySections(self) -> "void":
        r"""
        This method releases all sections, which contain no data (only
        empty strings). It can save some memory this way - it exists for
        optimization purposes, not functionality.

        Not implemented yet. Will call method ``clearEmptySections()`` on all elements.
        """
        return _connect.CTestBaseList_clearEmptySections(self)

    def setParentToElements(self, parent: "isys::CTestBaseSPtr") -> "void":
        r"""Sets the given parent to all elements in the list."""
        return _connect.CTestBaseList_setParentToElements(self, parent)

    def add(self, idx: "int", testBase: "isys::CTestBaseSPtr") -> "void":
        r"""
        Adds element to the list at the given index.

        :type idx: int
        :param idx: where to insert the element. If out of range,
                       the element is appended to the list.
        """
        return _connect.CTestBaseList_add(self, idx, testBase)

    def get(self, idx: "int") -> "CTestBase":
        r"""
        Returns element at the given index.

        :param index: index of element to return. If negative, elements
                         from the end are returned (for example, -1 returns
                         the last element).
        """
        return _connect.CTestBaseList_get(self, idx)

    def size(self) -> "size_t":
        r""" Returns the number of elements in the list."""
        return _connect.CTestBaseList_size(self)

    def find(self, item: "isys::CTestBaseSPtr const &") -> "int":
        r"""
        Returns index of item in the child list by comparing pointer equality.

        :rtype: int
        :return: index of item, or -1 if item was not found
        """
        return _connect.CTestBaseList_find(self, item)

    def remove(self, idx: "int") -> "void":
        r"""
        Removes element at the given index.

        :param index: index of element to remove.
        """
        return _connect.CTestBaseList_remove(self, idx)

    def clear(self) -> "void":
        r"""Removes all elements from the list."""
        return _connect.CTestBaseList_clear(self)

    def serialize(self, emitter: "isys::IEmitterSPtr const &") -> "void":
        r"""Serializes all members to the given emitter."""
        return _connect.CTestBaseList_serialize(self, emitter)

    def getTestObjType(self) -> "isys::CTestObject::ETestObjType":
        r""" Returns object type."""
        return _connect.CTestBaseList_getTestObjType(self)

    def isEmpty(self) -> "bool":
        r""" Returns true if object contains no data."""
        return _connect.CTestBaseList_isEmpty(self)

    def toString(self) -> "std::string":
        r""" Returns string representation of object, usually in YAML format."""
        return _connect.CTestBaseList_toString(self)

# Register CTestBaseList in _connect:
_connect.CTestBaseList_swigregister(CTestBaseList)

def CTestBaseList_cast(obj: "isys::CTestObjectSPtr const &") -> "CTestBaseList":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestBaseList_cast(obj)

class CScalarAdapter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, obj: "isys::CTestBaseSPtr const &", section: "int", isConst: "bool"):
        _connect.CScalarAdapter_swiginit(self, _connect.new_CScalarAdapter(obj, section, isConst))

    def getValue(self) -> "std::string":
        return _connect.CScalarAdapter_getValue(self)

    def getBoolValue(self) -> "bool":
        return _connect.CScalarAdapter_getBoolValue(self)

    def getComment(self, commentType: "isys::CTestBase::CommentType") -> "std::string":
        r"""
        :type commentType: int
        :param commentType: specifies whether it is end of line or new line comment
        """
        return _connect.CScalarAdapter_getComment(self, commentType)

    def setValue(self, value: "std::string const &") -> "void":
        return _connect.CScalarAdapter_setValue(self, value)

    def setComment(self, commentType: "isys::CTestBase::CommentType", comment: "std::string const &") -> "void":
        return _connect.CScalarAdapter_setComment(self, commentType, comment)

    def toString(self) -> "std::string":
        return _connect.CScalarAdapter_toString(self)
    __swig_destroy__ = _connect.delete_CScalarAdapter

# Register CScalarAdapter in _connect:
_connect.CScalarAdapter_swigregister(CScalarAdapter)

class CSequenceAdapter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CSequenceAdapter_swiginit(self, _connect.new_CSequenceAdapter(*args))

    def assign(self, src: "isys::CSequenceAdapterSPtr &") -> "void":
        return _connect.CSequenceAdapter_assign(self, src)

    def equalsData(self, other: "isys::CSequenceAdapterSPtr &") -> "bool":
        return _connect.CSequenceAdapter_equalsData(self, other)

    def size(self) -> "size_t":
        return _connect.CSequenceAdapter_size(self)

    def getValue(self, idx: "int") -> "std::string":
        return _connect.CSequenceAdapter_getValue(self, idx)

    def getComment(self, commentType: "isys::CTestBase::CommentType", idx: "int") -> "std::string":
        return _connect.CSequenceAdapter_getComment(self, commentType, idx)

    def getStrVector(self, strVector: "StrVector") -> "void":
        return _connect.CSequenceAdapter_getStrVector(self, strVector)

    def getMapAdapter(self, idx: "int") -> "CMapAdapter":
        return _connect.CSequenceAdapter_getMapAdapter(self, idx)

    def getSeqAdapter(self, idx: "int") -> "CSequenceAdapter":
        return _connect.CSequenceAdapter_getSeqAdapter(self, idx)

    def resize(self, newSize: "int") -> "void":
        return _connect.CSequenceAdapter_resize(self, newSize)

    def add(self, *args) -> "void":
        r"""
        *Overload 1:*
        Inserts value at idx or appends if idx < 0.

        |

        *Overload 2:*
        Inserts value at idx or appends if idx < 0.
        """
        return _connect.CSequenceAdapter_add(self, *args)

    def setValue(self, *args) -> "void":
        return _connect.CSequenceAdapter_setValue(self, *args)

    def setComment(self, idx: "int", nlComment: "std::string const &", eolComment: "std::string const &") -> "void":
        return _connect.CSequenceAdapter_setComment(self, idx, nlComment, eolComment)

    def remove(self, idx: "int") -> "void":
        return _connect.CSequenceAdapter_remove(self, idx)

    def toString(self) -> "std::string":
        return _connect.CSequenceAdapter_toString(self)
    __swig_destroy__ = _connect.delete_CSequenceAdapter

# Register CSequenceAdapter in _connect:
_connect.CSequenceAdapter_swigregister(CSequenceAdapter)

class CMapAdapter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CMapAdapter_swiginit(self, _connect.new_CMapAdapter(*args))

    def assign(self, src: "isys::CMapAdapterSPtr &") -> "void":
        return _connect.CMapAdapter_assign(self, src)

    def equalsData(self, src: "isys::CMapAdapterSPtr &") -> "bool":
        return _connect.CMapAdapter_equalsData(self, src)

    def contains(self, key: "std::string const &") -> "bool":
        return _connect.CMapAdapter_contains(self, key)

    def size(self) -> "size_t":
        return _connect.CMapAdapter_size(self)

    def getValue(self, key: "std::string const &") -> "std::string":
        return _connect.CMapAdapter_getValue(self, key)

    def getComment(self, commentType: "isys::CTestBase::CommentType", key: "std::string const &") -> "std::string":
        r"""
        :type commentType: int
        :param commentType: specifies whether it is end of line or new line comment
        """
        return _connect.CMapAdapter_getComment(self, commentType, key)

    def getStrStrMap(self, strMap: "StrStrMap") -> "void":
        return _connect.CMapAdapter_getStrStrMap(self, strMap)

    def getKeys(self, strVector: "StrVector") -> "void":
        return _connect.CMapAdapter_getKeys(self, strVector)

    def getKey(self, index: "size_t") -> "std::string":
        r"""Returns key at the given index. Throws exception if index is out of range."""
        return _connect.CMapAdapter_getKey(self, index)

    def getKeyIndex(self, key: "std::string const &") -> "int":
        r""" Returns index of the given key in ordered map."""
        return _connect.CMapAdapter_getKeyIndex(self, key)

    def getMapAdapter(self, key: "std::string const &") -> "CMapAdapter":
        return _connect.CMapAdapter_getMapAdapter(self, key)

    def getSeqAdapter(self, key: "std::string const &") -> "CSequenceAdapter":
        return _connect.CMapAdapter_getSeqAdapter(self, key)

    def setValue(self, *args) -> "void":
        return _connect.CMapAdapter_setValue(self, *args)

    def setComment(self, key: "std::string const &", nlComment: "std::string const &", eolComment: "std::string const &") -> "void":
        return _connect.CMapAdapter_setComment(self, key, nlComment, eolComment)

    def renameKey(self, oldKey: "std::string const &", newKey: "std::string const &") -> "void":
        r"""
        Replaces ``oldKey`` with ``newKey``, while value, comments, and order
        are preserved.
        """
        return _connect.CMapAdapter_renameKey(self, oldKey, newKey)

    def removeEntry(self, key: "std::string const &") -> "bool":
        r"""
        Removes entry with the existing key.

        :rtype: boolean
        :return: true, if entry existed, false if there was no such key in the map.
        """
        return _connect.CMapAdapter_removeEntry(self, key)

    def removeAll(self) -> "void":
        r""" Removes all entries, formatting is left unchanged."""
        return _connect.CMapAdapter_removeAll(self)

    def insertKey(self, key: "std::string const &", predecessors: "StrVector") -> "bool":
        r"""
        Inserts the given key and empty scalar value after any key found
        in ``predecessors``.

        :rtype: boolean
        :return: false if the key was not inserted - it already existed in the map
                    true otherwise
        """
        return _connect.CMapAdapter_insertKey(self, key, predecessors)

    def moveKey(self, key: "std::string const &", predecessors: "StrVector") -> "bool":
        return _connect.CMapAdapter_moveKey(self, key, predecessors)

    def serialize(self) -> "std::string":
        return _connect.CMapAdapter_serialize(self)

    def parse(self, yamlStr: "std::string const &") -> "void":
        r""" Sets content of this object according to the given YAML spec."""
        return _connect.CMapAdapter_parse(self, yamlStr)

    def toString(self) -> "std::string":
        return _connect.CMapAdapter_toString(self)
    __swig_destroy__ = _connect.delete_CMapAdapter

# Register CMapAdapter in _connect:
_connect.CMapAdapter_swigregister(CMapAdapter)

class CTestFilter(CTestBase):
    r"""
    This class defies conditions, which test case must satisfy to be
    executed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BUILT_IN_FILTER = _connect.CTestFilter_BUILT_IN_FILTER
    r""" filter algorithm implemented in this class is used"""
    SCRIPT_FILTER = _connect.CTestFilter_SCRIPT_FILTER
    r""" filter algorithm implemented in user provided script is used"""

    def filterQualifier(self, filterRegExs: "StrVector", testCaseQualifier: "std::string const &") -> "bool":
        return _connect.CTestFilter_filterQualifier(self, filterRegExs, testCaseQualifier)
    E_SECTION_FILTER_ID = _connect.CTestFilter_E_SECTION_FILTER_ID
    E_SECTION_FILTER_TYPE = _connect.CTestFilter_E_SECTION_FILTER_TYPE
    E_SECTION_CORE_ID = _connect.CTestFilter_E_SECTION_CORE_ID
    E_SECTION_PARTITIONS = _connect.CTestFilter_E_SECTION_PARTITIONS
    E_SECTION_MODULES = _connect.CTestFilter_E_SECTION_MODULES
    E_SECTION_INCLUDED_IDS = _connect.CTestFilter_E_SECTION_INCLUDED_IDS
    E_SECTION_EXCLUDED_IDS = _connect.CTestFilter_E_SECTION_EXCLUDED_IDS
    E_SECTION_INCLUDED_FUNCTIONS = _connect.CTestFilter_E_SECTION_INCLUDED_FUNCTIONS
    E_SECTION_EXCLUDED_FUNCTIONS = _connect.CTestFilter_E_SECTION_EXCLUDED_FUNCTIONS
    E_SECTION_MUST_HAVE_ALL_TAGS = _connect.CTestFilter_E_SECTION_MUST_HAVE_ALL_TAGS
    E_SECTION_MUST_HAVE_ONE_OF_TAGS = _connect.CTestFilter_E_SECTION_MUST_HAVE_ONE_OF_TAGS
    E_SECTION_MUST_NOT_HAVE_ALL_TAGS = _connect.CTestFilter_E_SECTION_MUST_NOT_HAVE_ALL_TAGS
    E_SECTION_MUST_NOT_HAVE_ONE_OF_TAGS = _connect.CTestFilter_E_SECTION_MUST_NOT_HAVE_ONE_OF_TAGS
    E_SECTION_IS_OR_TAGS_1 = _connect.CTestFilter_E_SECTION_IS_OR_TAGS_1
    E_SECTION_IS_OR_TAGS_2 = _connect.CTestFilter_E_SECTION_IS_OR_TAGS_2
    E_SECTION_IS_OR_TAGS_3 = _connect.CTestFilter_E_SECTION_IS_OR_TAGS_3
    E_SECTION_SCRIPT_FUNCTION = _connect.CTestFilter_E_SECTION_SCRIPT_FUNCTION
    E_SECTION_SCRIPT_FUNCTION_PARAMS = _connect.CTestFilter_E_SECTION_SCRIPT_FUNCTION_PARAMS

    def __init__(self, parent: "isys::CTestBaseSPtr const &"):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestBench class. Used
            only when parsing YAML declaration. Can be specified as
            NULL if the object is not initialized by parser.
        """
        _connect.CTestFilter_swiginit(self, _connect.new_CTestFilter(parent))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestFilter_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestFilter":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestFilter_cast(testBase)

    def getFilterType(self) -> "isys::CTestFilter::EFilterTypes":
        r""" Returns true, if script function is set."""
        return _connect.CTestFilter_getFilterType(self)

    def getFilterId(self) -> "std::string":
        r""" Returns the ID of this filter."""
        return _connect.CTestFilter_getFilterId(self)

    def getCoreId(self) -> "std::string":
        r"""Returns core or application ID."""
        return _connect.CTestFilter_getCoreId(self)

    def getPartitions(self, partitions: "StrVector") -> "void":
        r"""
        Returns regex for partition names (download file) where symbols are located. If this item is
        empty string, symbols from all partitions in winIDEA project are used as filter input.
        """
        return _connect.CTestFilter_getPartitions(self, partitions)

    def getModules(self, modules: "StrVector") -> "void":
        r"""
        Returns regex for module names (source files), which should be used as
        a source for symbols. If this string is empty, all symbols from partition
        are used as filter input.
        """
        return _connect.CTestFilter_getModules(self, modules)

    def getMustHaveAllTags(self, tags: "StrVector") -> "void":
        r""" Returns tags, which must be present in test specification to be executed."""
        return _connect.CTestFilter_getMustHaveAllTags(self, tags)

    def getMustHaveOneOfTags(self, tags: "StrVector") -> "void":
        r""" Returns tags, of which at least one must be present in test specification to be executed."""
        return _connect.CTestFilter_getMustHaveOneOfTags(self, tags)

    def getMustNotHaveAllTags(self, tags: "StrVector") -> "void":
        r""" Returns tags, which must NOT be present in test specification to be executed."""
        return _connect.CTestFilter_getMustNotHaveAllTags(self, tags)

    def getMustNotHaveOneOfTags(self, tags: "StrVector") -> "void":
        r""" Returns tags, of which at least one must NOT be present in test specification to be executed."""
        return _connect.CTestFilter_getMustNotHaveOneOfTags(self, tags)

    def isOrTags1(self) -> "bool":
        r"""
        Returns true, if the result of test for ``must have all tags`` is
        ANDed with other tests.
        """
        return _connect.CTestFilter_isOrTags1(self)

    def isOrTags2(self) -> "bool":
        r"""
        Returns true, if the result of test for ``must have any of tags`` is
        ANDed with other tests.
        """
        return _connect.CTestFilter_isOrTags2(self)

    def isOrTags3(self) -> "bool":
        r"""
        Returns true, if the result of test for ``must not have all tags`` is
        ANDed with other tests.
        """
        return _connect.CTestFilter_isOrTags3(self)

    def getIncludedIds(self, ids: "StrVector") -> "void":
        r"""
        Returns the list of exception IDs.

        See also: setIncludedIds
        """
        return _connect.CTestFilter_getIncludedIds(self, ids)

    def getExcludedIds(self, ids: "StrVector") -> "void":
        r"""
        Returns the list of exception IDs.

        See also: setExcludedIds
        """
        return _connect.CTestFilter_getExcludedIds(self, ids)

    def getIncludedFunctions(self, functions: "StrVector") -> "void":
        r"""
        Returns the list of exception function names.

        See also: setIncludedFunctions
        """
        return _connect.CTestFilter_getIncludedFunctions(self, functions)

    def getExcludedFunctions(self, functions: "StrVector") -> "void":
        r"""
        Returns the list of exception function names.

        See also: setExcludedFunctions
        """
        return _connect.CTestFilter_getExcludedFunctions(self, functions)

    def getScriptFunction(self) -> "std::string":
        r"""
         Returns script function, which performs filtering.
        If the function returns null, test spec. is executed. If the
        function returns string, it is printed into test report, why the
        test spec. was not executed.
        """
        return _connect.CTestFilter_getScriptFunction(self)

    def getScriptFunctionParams(self, params: "StrVector") -> "void":
        r"""Returns the list of script function parameters."""
        return _connect.CTestFilter_getScriptFunctionParams(self, params)

    def setFilterId(self, filterId: "std::string const &") -> "void":
        r""" Sets id of this filter."""
        return _connect.CTestFilter_setFilterId(self, filterId)

    def setFilterType(self, filterType: "isys::CTestFilter::EFilterTypes") -> "void":
        r""" Sets type of filter performed."""
        return _connect.CTestFilter_setFilterType(self, filterType)

    def setMustHaveAllTags(self, tags: "std::string const &") -> "void":
        r"""
         Test specification must have all tags set with this method.

        :type tags: string
        :param tags: YAML list of strings, for example: "[myName1, myName2]"
        """
        return _connect.CTestFilter_setMustHaveAllTags(self, tags)

    def setMustHaveOneOfTags(self, tags: "std::string const &") -> "void":
        r"""
         Test specification must have at least one of tags set with this method.

        :type tags: string
        :param tags: YAML list of strings, for example: "[myName1, myName2]"
        """
        return _connect.CTestFilter_setMustHaveOneOfTags(self, tags)

    def setMustNotHaveAllTags(self, tags: "std::string const &") -> "void":
        r"""
         Test specification must not have any of tags set with this method.

        :type tags: string
        :param tags: YAML list of strings, for example: "[myName1, myName2]"
        """
        return _connect.CTestFilter_setMustNotHaveAllTags(self, tags)

    def setMustNotHaveOneOfTags(self, tags: "std::string const &") -> "void":
        r"""
         Test specification must not have at least one of tags set with this method.

        :type tags: string
        :param tags: YAML list of strings, for example: "[myName1, myName2]"
        """
        return _connect.CTestFilter_setMustNotHaveOneOfTags(self, tags)

    def setOrTags1(self, isOr1: "bool") -> "void":
        r"""
        :type isOr1: boolean
        :param isOr1: if true, AND logical operation is applied between test for
            must have all tags and other tags tests.
        """
        return _connect.CTestFilter_setOrTags1(self, isOr1)

    def setOrTags2(self, isOr2: "bool") -> "void":
        r"""
        :param isOr1: if true, AND logical operation is applied between test for
            must have any of tags and other tags tests.
        """
        return _connect.CTestFilter_setOrTags2(self, isOr2)

    def setOrTags3(self, isOr3: "bool") -> "void":
        r"""
        :param isOr1: if true, AND logical operation is applied between test for
            must not have all tags and other tags tests.
        """
        return _connect.CTestFilter_setOrTags3(self, isOr3)

    def setIncludedIds(self, ids: "std::string const &") -> "void":
        r"""
        Test specification, which have test ID equal to one of the ids specified
        with this method, are added as an exception to the pool of executed test
        specifications. Note that test for function name is executed BEFORE the
        test for test ID.

        :type ids: string
        :param ids: YAML list of strings, for example: "[myName1, myName2]"
        """
        return _connect.CTestFilter_setIncludedIds(self, ids)

    def setExcludedIds(self, ids: "std::string const &") -> "void":
        r"""
        Test specification, which have test ID equal to one of the ids specified
        with this method, are removed as an exception from the pool of executed test
        specifications. If the same ID is in set also with the method
        ``setIncludedIds()``, the
        inclusion takes precedence - test spec. is executed.

        :type ids: string
        :param ids: YAML list of strings, for example: "[myName1, myName2]"
        """
        return _connect.CTestFilter_setExcludedIds(self, ids)

    def setIncludedFunctions(self, functions: "std::string const &") -> "void":
        r"""
        Test specification, which have function name equal to one of the ids specified
        with this method, are added as an exception to the pool of executed test
        specifications.

        :type functions: string
        :param functions: YAML list of strings, for example: "[myName1, myName2]"
        """
        return _connect.CTestFilter_setIncludedFunctions(self, functions)

    def setExcludedFunctions(self, functions: "std::string const &") -> "void":
        r"""
        Test specification, which have function name equal to one of the ids specified
        with this method, are removed as an exception from the pool of executed test
        specifications. If the same function name is in set also with the method
        ``setIncludedFunctions()``, the
        inclusion takes precedence - test spec. is executed.

        :type functions: string
        :param functions: YAML list of strings, for example: "[myName1, myName2]"
        """
        return _connect.CTestFilter_setExcludedFunctions(self, functions)

    def setScriptFunction(self, functionName: "std::string const &") -> "void":
        r""" Sets parameters for the script function."""
        return _connect.CTestFilter_setScriptFunction(self, functionName)

    def setScriptFunctionParams(self, params: "std::string const &") -> "void":
        r"""Returns the list of script function parameters."""
        return _connect.CTestFilter_setScriptFunctionParams(self, params)
    __swig_destroy__ = _connect.delete_CTestFilter

# Register CTestFilter in _connect:
_connect.CTestFilter_swigregister(CTestFilter)

def CTestFilter_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestFilter":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestFilter_cast(testBase)

class CTestFilterController(object):
    r"""
    This class maintains all data required for test case filtering, and
    contains methods, which perform the filtering.

    It maintains the following structure of symbols:
    coreInfo --> partition1 --> module1 --> func1
                                            func2
                                            ...
                                module2
                                ...
                 partition2 --> moduleN

                 partition3
                 ...
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def isEmpty(self) -> "bool":
        r""" Returns true, if there are no symbols stored in this object."""
        return _connect.CTestFilterController_isEmpty(self)

    def clear(self) -> "void":
        r""" Clears symbols. Can be used to indicate that refresh is needed."""
        return _connect.CTestFilterController_clear(self)

    def countExecutableTests(self, testSpec: "isys::CTestSpecificationSPtr const &", derivedLevel: "int", testFilter: "isys::CTestFilterSPtr const &") -> "int":
        r"""
        Returns the number of tests which are executable (have 'run' flag set
        and are note excluded by the given filter.

        :type testSpec: :py:class:`CTestSpecification`
        :param testSpec: the test spec. and it's derived test specs to be counted
        :type derivedLevel: int
        :param derivedLevel: how deep to test derived test specifications
        :type testFilter: :py:class:`CTestFilter`
        :param testFilter: filter to be used for test inclusion/exclusion. If
                   the filter specifies script function, an IllegalStateException is thrown,
                   since scripts can't be called from native code.
        """
        return _connect.CTestFilterController_countExecutableTests(self, testSpec, derivedLevel, testFilter)

    def isTestExecutable(self, testSpec: "isys::CTestSpecificationSPtr const &", testFilter: "isys::CTestFilterSPtr const &") -> "bool":
        r"""
        Returns true, if the test will be executed. This method is similar to
        filterTestSpec(), but always performs merging.

        :type testSpec: :py:class:`CTestSpecification`
        :param testSpec: the test spec. to be tested for execution
        :type testFilter: :py:class:`CTestFilter`
        :param testFilter: filter to be used for test inclusion/exclusion. If
                   the filter specifies script function, an IllegalStateException is thrown,
                   since scripts can't be called from native code.
        """
        return _connect.CTestFilterController_isTestExecutable(self, testSpec, testFilter)

    def refreshSymbols(self, envConfig: "isys::CTestEnvironmentConfigSPtr const &", globalsContainer: "isys::CTestGlobalsContainerSPtr const &") -> "void":
        return _connect.CTestFilterController_refreshSymbols(self, envConfig, globalsContainer)

    def setDefaultCoreId(self, coreId: "std::string const &") -> "void":
        r"""Sets list of core IDs."""
        return _connect.CTestFilterController_setDefaultCoreId(self, coreId)

    def setDefaultPartition(self, coreId: "std::string const &", defaultPartition: "std::string const &") -> "void":
        r"""
        Used for assigning test cases to groups. You can use CIDEController::getDefaultDownloadFile()
        to obtain this value.

        :type defaultPartition: string
        :param defaultPartition: name of default download file as set in winIDEA.
        """
        return _connect.CTestFilterController_setDefaultPartition(self, coreId, defaultPartition)

    def setFunctionToModuleMap(self, coreId: "std::string const &", functionToModuleMap: "StrStrMap") -> "void":
        r"""
        Sets map with keys containing function name with partition, and modules as values.
        You can use CDataController::getFunctionToModuleMap() to obtain this information.

        :type functionToModuleMap: :py:class:`StrStrMap`
        :param functionToModuleMap: function name to module name, for example: main,,sample.elf: main.c
        """
        return _connect.CTestFilterController_setFunctionToModuleMap(self, coreId, functionToModuleMap)

    def filterTestSpec(self, testSpec: "isys::CTestSpecificationSPtr const &", isTestSpecMerged: "bool", filter: "isys::CTestFilterSPtr const &") -> "bool":
        r"""
        Returns true, if testSpec passes filter, false otherwise.

        :type testSpec: :py:class:`CTestSpecification`
        :param testSpec: test specification to be filtered
        :type isTestSpecMerged: boolean
        :param isTestSpecMerged: if the given test spec is already merged,
                                    then specifying this flag as True saves
                                    some time. If false, the given test spec is
                                    merged before filter is applied.
        :type filter: :py:class:`CTestFilter`
        :param filter: contains data to be used for filtering
        """
        return _connect.CTestFilterController_filterTestSpec(self, testSpec, isTestSpecMerged, filter)

    def getTestItemsForFilter(self, testGroup: "isys::CTestGroupSPtr const &", partitions: "StrVector", modules: "StrVector", qualFuncNames: "StrVector") -> "std::string":
        r"""
        Returns all partitions, modules, and functions for coreID from filter,
        which pass filter.

        :param filter: contains filtering criteria
        :type qualFuncNames: :py:class:`StrVector`
        :param qualFuncNames: vector to receive qualified function names with module paths.

        :rtype: string
        :return: empty string if everything OK, warning or error otherwise (for example
                          core ID not found, not all partitions in filter exist in core).
        """
        return _connect.CTestFilterController_getTestItemsForFilter(self, testGroup, partitions, modules, qualFuncNames)

    def countTestCasesInGroup(self, group: "isys::CTestGroupSPtr const &", partitionsWTestInGroup: "StrSet", modulesWTestInGroup: "StrSet", functionsWTestInGroup: "StrSet") -> "void":
        r"""
        Based on filter from the given group, this m. returns all partitions,
        modules, and functions, which are tested by at least one test case in a group.
        """
        return _connect.CTestFilterController_countTestCasesInGroup(self, group, partitionsWTestInGroup, modulesWTestInGroup, functionsWTestInGroup)

    def toString(self) -> "std::string":
        r"""Prints stored symbol information."""
        return _connect.CTestFilterController_toString(self)

    def __init__(self):
        _connect.CTestFilterController_swiginit(self, _connect.new_CTestFilterController())
    __swig_destroy__ = _connect.delete_CTestFilterController

# Register CTestFilterController in _connect:
_connect.CTestFilterController_swigregister(CTestFilterController)

class CTestGlobalsContainer(object):
    r"""
    IMPORTANT: Do not use this class as an intermediate between iconnect IGlobals
    data and Java, because is ti much faster to call CDataController2:getGlobals()
    directly from Java and then perform copying of data to Java only once. This class
    copies data to intermediate C++ data structures.

    This class contains all global symbols. It returns references
    to internal data for performance reasons, and is therefore intended for
    iSystem internal use only.
    IMPORTANT:
    Never use reference returned by this class outside of scope where it
    was obtained, especially in other languages!
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def refresh(self, mccmgr: "isys::CMulticoreConnectionMgrSPtr const &", isRefreshTypes: "bool") -> "void":
        r"""
        Reads globals from winIDEA and copies them to local structures.

        :type isRefreshTypes: boolean
        :param isRefreshTypes: if true types and typedefs are also
                   read. In some cases this may degrade performance (for example in
                   a project with 550_000 types and 150_000 typedefs), but is needed
                   only for code proposals and not for test execution. On the mentioned
                   project the time difference was 0.5s vs 9.5 s with types.
                   Retrieval from winIDEA took 2.3s, so 7.2 seconds were used for data
                   copying to std::strings.
                   For performance optimization consider custom std::string allocator,
                   or keep references to data returned by iconnect in this class and
                   avoid conversion to std::string.
        """
        return _connect.CTestGlobalsContainer_refresh(self, mccmgr, isRefreshTypes)

    def getCores(self, coreIds: "StrVector") -> "void":
        r""" Returns IDs of all cores."""
        return _connect.CTestGlobalsContainer_getCores(self, coreIds)

    def getPartitions(self, coreId: "std::string const &", isGetPaths: "bool", partitions: "StrVector") -> "void":
        r""" Returns partitions for the given core."""
        return _connect.CTestGlobalsContainer_getPartitions(self, coreId, isGetPaths, partitions)

    def getModules(self, coreId: "std::string const &", partitionIdx: "int", isGetPaths: "bool", modules: "StrVector") -> "void":
        r""" Returns modules for the given partition."""
        return _connect.CTestGlobalsContainer_getModules(self, coreId, partitionIdx, isGetPaths, modules)

    def getFunctionsForModule(self, coreId: "std::string const &", partitionIdx: "int", moduleIdx: "int", functions: "StrVector") -> "void":
        return _connect.CTestGlobalsContainer_getFunctionsForModule(self, coreId, partitionIdx, moduleIdx, functions)

    def getFunctionToModulesMap(self, coreId: "std::string const &", functionsToModulesMap: "StrStrMap") -> "void":
        return _connect.CTestGlobalsContainer_getFunctionToModulesMap(self, coreId, functionsToModulesMap)

    def toString(self) -> "std::string":
        r""" Returns some statistics about symbols in this class."""
        return _connect.CTestGlobalsContainer_toString(self)

    def __init__(self):
        _connect.CTestGlobalsContainer_swiginit(self, _connect.new_CTestGlobalsContainer())
    __swig_destroy__ = _connect.delete_CTestGlobalsContainer

# Register CTestGlobalsContainer in _connect:
_connect.CTestGlobalsContainer_swigregister(CTestGlobalsContainer)

class CTestBench(CTestBase):
    r"""
    This class encapsulates all data required to run isystem unit tests.
    Use one of static methods to get instances of this class.

    Python example (from ``filterTests.py)``:


    Another useful example is ``loadRunReport.py``.



    filterTests.py Python example. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_ENV_CONFIG = _connect.CTestBench_E_SECTION_ENV_CONFIG
    E_SECTION_REPORT_CONFIG = _connect.CTestBench_E_SECTION_REPORT_CONFIG
    E_SECTION_FILTERS = _connect.CTestBench_E_SECTION_FILTERS
    E_SECTION_GROUPS = _connect.CTestBench_E_SECTION_GROUPS
    E_SECTION_TESTS = _connect.CTestBench_E_SECTION_TESTS
    E_SECTION_TEST_CASES = _connect.CTestBench_E_SECTION_TEST_CASES

    def __init__(self):
        _connect.CTestBench_swiginit(self, _connect.new_CTestBench())

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestBench_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestBench":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestBench_cast(testBase)

    def getTestEnvironmentConfig(self, isConst: "bool") -> "CTestEnvironmentConfig":
        r""" Returns test environment configuration."""
        return _connect.CTestBench_getTestEnvironmentConfig(self, isConst)

    def getTestReportConfig(self, isConst: "bool") -> "CTestReportConfig":
        r""" Returns test report configuration."""
        return _connect.CTestBench_getTestReportConfig(self, isConst)

    def getTestFilters(self, isConst: "bool") -> "CTestBaseList":
        r""" Returns test filters."""
        return _connect.CTestBench_getTestFilters(self, isConst)

    def getTestFilter(self, filterId: "std::string const &") -> "CTestFilter":
        r""" Returns test filter with the given ID, or NULL if the filter is not found."""
        return _connect.CTestBench_getTestFilter(self, filterId)

    def getGroup(self, isConst: "bool") -> "CTestGroup":
        r""" Returns root group."""
        return _connect.CTestBench_getGroup(self, isConst)

    def getTestSpecification(self, isConst: "bool") -> "CTestSpecification":
        r"""
        Returns root test case. This test case is a container only - it has no data set,
        but contains derived test cases (as they were defined in testIDEA, for example).
        """
        return _connect.CTestBench_getTestSpecification(self, isConst)

    def getWarnings(self) -> "std::string":
        r"""
        If there were any warnings detected during parsing, this method returns
        non-empty string with description of warnings. It is recommended to
        call this method always after parsing. This method calls getWarning() on all
        aggregated classes, so it is not necessary to call getWarning() on each
        of them.
        """
        return _connect.CTestBench_getWarnings(self)

    def getFileName(self) -> "std::string":
        r"""Returns file from which this test bench data was loaded, or saved to."""
        return _connect.CTestBench_getFileName(self)

    def setFileName(self, fileName: "std::string const &") -> "void":
        r"""
        Sets name of the file this test bench is related to. It should be
        always absolute, as this directory is considered as working directory, when
        relative path names are specified for other files in test spec (reports,
        diagrams, ...).
        """
        return _connect.CTestBench_setFileName(self, fileName)

    def getModelDirectory(self) -> "std::string":
        r"""Returns directory of the model file."""
        return _connect.CTestBench_getModelDirectory(self)

    def setTestSpecification(self, testSpec: "isys::CTestSpecificationSPtr &") -> "void":
        return _connect.CTestBench_setTestSpecification(self, testSpec)

    @staticmethod
    def load(fileName: "std::string const &", filePos: "size_t"=0) -> "CTestBench":
        r""" Loads test environment configuration and test specifications from the given file."""
        return _connect.CTestBench_load(fileName, filePos)

    @staticmethod
    def parse(yamlSpec: "std::string const &") -> "CTestBench":
        r""" Parses test environment configuration and test specifications from the given string."""
        return _connect.CTestBench_parse(yamlSpec)

    def save(self, fileName: "std::string const &", isAppend: "bool"=False, isSaveLineNumbers: "bool"=False) -> "void":
        r"""
        Saves test bench configuration into the given file.

        :type fileName: string
        :param fileName: file to save to
        :type isAppend: boolean, optional
        :param isAppend: if true, new data is appended to the end of the file,
                            otherwise any previous contents is erased.
        :type isSaveLineNumbers: boolean, optional
        :param isSaveLineNumbers: if true, line numbers are assigned to test specifications when saved
        """
        return _connect.CTestBench_save(self, fileName, isAppend, isSaveLineNumbers)

    @staticmethod
    def addUserInfoToReportConfig(reportConfig: "isys::CTestReportConfigSPtr const &", testSpecificationFile: "std::string const &", winIDEAWorkspace: "std::string const &", winIDEAWorkspaceFile: "std::string const &", defaultDlFile: "std::string const &") -> "void":
        r"""
        This method adds the following info to report config:
        - path to test spec. file given as parameter
        - path to winIDEA workspace file given as parameter
        - SDK (testIDEA) version (automatically obtained)
        - current date and time if specified in 'reportConfig'.
        """
        return _connect.CTestBench_addUserInfoToReportConfig(reportConfig, testSpecificationFile, winIDEAWorkspace, winIDEAWorkspaceFile, defaultDlFile)

    def getTestReportContainer(self) -> "CTestReportContainer":
        r"""Returns instance of class containing information for test reports."""
        return _connect.CTestBench_getTestReportContainer(self)

    def getFilterController(self) -> "CTestFilterController":
        r"""Returns reference to filter controller."""
        return _connect.CTestBench_getFilterController(self)

    @staticmethod
    def createDirIfNotExists(filePath: "std::string const") -> "void":
        r"""
        Creates directory for the given file path, if it does not exist.
        If path does not contain file name, it must end with path separator.
        """
        return _connect.CTestBench_createDirIfNotExists(filePath)

    @staticmethod
    def saveTestResults(testResults: "isys::CTestReportContainerSPtr const &", reportConfig: "isys::CTestReportConfigSPtr &") -> "void":
        r"""
        This method saves test results into file in the specified format.
        Only XML, YAML and CSV files are supported by this function.
        XLS and XLSX (Excel) formats are available only from testIDEA,
        but CSV format can be easily imported to Excel.

        Note for CSV format: Because there are three different tables
        stored (configuration, statistics, and results), three files are
        created for CSV format. File name specified in reportConfig gets
        appended '-config' and '-statistics' strings for configuration and
        statistics tables respectively.

        createTestReport.py Python example. 
        """
        return _connect.CTestBench_saveTestResults(testResults, reportConfig)

    @staticmethod
    def saveCSV(testResults: "isys::CTestReportContainerSPtr const &", newReportConfig: "isys::CTestReportConfigSPtr const &") -> "void":
        return _connect.CTestBench_saveCSV(testResults, newReportConfig)

    @staticmethod
    def saveYAML(testResults: "isys::CTestReportContainerSPtr const &", newReportConfig: "isys::CTestReportConfigSPtr const &") -> "void":
        return _connect.CTestBench_saveYAML(testResults, newReportConfig)

    @staticmethod
    def saveXML(testResults: "isys::CTestReportContainerSPtr const &", newReportConfig: "isys::CTestReportConfigSPtr const &") -> "void":
        return _connect.CTestBench_saveXML(testResults, newReportConfig)

    @staticmethod
    def initTargetForTest(config: "isys::CTestEnvironmentConfigSPtr &", debug: "isys::CDebugFacadeSPtr &", ideCtrl: "isys::CIDEControllerSPtr &", targetStopTimeout: "int") -> "void":
        r"""
        Deprecated since 9.12.188, 2014-09-05, it works for old style
        init sequences only (download, reset, run, and runUntil actions are
        supported only and only in this order, no multicore support).
        Call 'executeInitAction' for all init actions in CTestEnvironmentConfig
        instead. Python has method PTestCase.executeInitSequence(), which
        replaces this method.

        Initializes target according to settings in 'config' to be ready for unit tests.

        :type config: :py:class:`CTestEnvironmentConfig`
        :param config: initialization configuration
        :type debug: :py:class:`CDebugFacade`
        :param debug: debug facade
        :type ideCtrl: :py:class:`CIDEController`
        :param ideCtrl: ide controller
        :type targetStopTimeout: int
        :param targetStopTimeout: timeout in milliseconds to wait for target
                                     to stop on the given function, address or breakpoint.
                                     TimeoutException is thrown in case of timeout.
        """
        return _connect.CTestBench_initTargetForTest(config, debug, ideCtrl, targetStopTimeout)

    @staticmethod
    def executeInitAction(envConfig: "isys::CTestEnvironmentConfigSPtr &", mccMgr: "isys::CMulticoreConnectionMgrSPtr &", action: "isys::CInitSequenceActionSPtr &", stepIdx: "int", isWaitUntilStopped: "bool", targetStopTimeout: "int") -> "void":
        return _connect.CTestBench_executeInitAction(envConfig, mccMgr, action, stepIdx, isWaitUntilStopped, targetStopTimeout)

    @staticmethod
    def restoreTargetAfterTest(config: "CTestEnvironmentConfig", debug: "isys::CDebugFacadeSPtr &", ideCtrl: "isys::CIDEControllerSPtr &", targetStopTimeout: "int") -> "void":
        return _connect.CTestBench_restoreTargetAfterTest(config, debug, ideCtrl, targetStopTimeout)

    @staticmethod
    def configureInterrupts(envConfig: "CTestEnvironmentConfig", mccMgr: "isys::CMulticoreConnectionMgrSPtr", interruptStates: "StrStrMap") -> "void":
        return _connect.CTestBench_configureInterrupts(envConfig, mccMgr, interruptStates)

    @staticmethod
    def restoreInterrupts(envConfig: "CTestEnvironmentConfig", mccMgr: "isys::CMulticoreConnectionMgrSPtr", interruptStates: "StrStrMap") -> "void":
        return _connect.CTestBench_restoreInterrupts(envConfig, mccMgr, interruptStates)

    @staticmethod
    def execTestCaseInitSequence(testCaseInitConfig: "isys::CTestCaseTargetInitConfigSPtr &", connectionMgr: "isys::ConnectionMgrSPtr &", debug: "isys::CDebugFacadeSPtr &", targetStopTimeout: "int", isTestBatchOn: "bool") -> "bool":
        r"""
        This function initializes target before execution of each test case.

        :type testCaseInitConfig: :py:class:`CTestCaseTargetInitConfig`
        :param testCaseInitConfig: initialization configuration
        :type debug: :py:class:`CDebugFacade`
        :param debug: debug facade
        :type targetStopTimeout: int
        :param targetStopTimeout: timeout in milliseconds to wait for target
                                     to stop on the given function, address or breakpoint.
                                     TimeoutException is thrown in case of timeout.
        """
        return _connect.CTestBench_execTestCaseInitSequence(testCaseInitConfig, connectionMgr, debug, targetStopTimeout, isTestBatchOn)

    @staticmethod
    def configureBreakpointsMode(ideCtrl: "isys::CIDEControllerSPtr &", bpType: "isys::CTestEnvironmentConfig::EBreakpointsType", coreIdx: "int", isBeforeInit: "bool") -> "void":
        r"""
        This method configures type of breakpoints (software of hardware)
        as needed for target initialization.

        :type ideCtrl: :py:class:`CIDEController`
        :param ideCtrl: controller object needed to access winIDEA
        :type bpType: int
        :param bpType: type of breakpoints
        :type coreIdx: int
        :param coreIdx: index of core for BP configuration
        :type isBeforeInit: boolean
        :param isBeforeInit: should be true, when this method is called before init sequence,
                                false when it is called for the second time after init seq.
        """
        return _connect.CTestBench_configureBreakpointsMode(ideCtrl, bpType, coreIdx, isBeforeInit)

    @staticmethod
    def configureStackUsage(dataCtrl: "isys::CDataController2SPtr &", runConfiguration: "isys::CTestEnvironmentConfigSPtr &", coreIdParam: "std::string const &") -> "void":
        r"""
        This method configures stack usage.

        :param ideCtrl: controller object needed to access winIDEA
        :type runConfiguration: :py:class:`CTestEnvironmentConfig`
        :param runConfiguration: object containing stack measurement configurations
        :param coreId: id of core for which stack usage measurement should be configured.
        """
        return _connect.CTestBench_configureStackUsage(dataCtrl, runConfiguration, coreIdParam)

    @staticmethod
    def isTestWithScripts(testSpec: "isys::CTestSpecificationSPtr const &") -> "bool":
        r"""
        Returns true, if test contains scripts.

        :type testSpec: :py:class:`CTestSpecification`
        :param testSpec: the test spec. to be tested for usage of scripts
        """
        return _connect.CTestBench_isTestWithScripts(testSpec)

    def refreshSymbolsAndGroupsIfEmpty(self, mccmgr: "isys::CMulticoreConnectionMgrSPtr const &", customEnvConfig: "isys::CTestEnvironmentConfigSPtr const &") -> "void":
        r"""
        Refreshes symbols and assigns test cases to groups, if none are initialized.
        To refresh possibly existing symbols in this object, first call:
           testBench.getFilterController().clear();
        and then this method.

        :type mccmgr: :py:class:`CMulticoreConnectionMgr`
        :param mccmgr: connection object
        :type customEnvConfig: :py:class:`CTestEnvironmentConfig`
        :param customEnvConfig: if you want to specify custom coreIds. If null, then
                                   object returned by call to getTestEnvironmentConfig(true)
                                   is used.
        """
        return _connect.CTestBench_refreshSymbolsAndGroupsIfEmpty(self, mccmgr, customEnvConfig)

    @staticmethod
    def getCvrgFilterCandidates(mergedTestSpec: "isys::CTestSpecificationSPtr &") -> "CTestSpecification":
        return _connect.CTestBench_getCvrgFilterCandidates(mergedTestSpec)

    def calculateGroupResults(self, mcmgr: "isys::CMulticoreConnectionMgrSPtr const &", envConfig: "isys::CTestEnvironmentConfigSPtr const &") -> "void":
        return _connect.CTestBench_calculateGroupResults(self, mcmgr, envConfig)

    def assignTestCasesToGroups(self, filterCtrl: "isys::CTestFilterControllerSPtr const &") -> "void":
        return _connect.CTestBench_assignTestCasesToGroups(self, filterCtrl)

    def createTestBase(self, *args) -> "CTestBase":
        return _connect.CTestBench_createTestBase(self, *args)
    __swig_destroy__ = _connect.delete_CTestBench

# Register CTestBench in _connect:
_connect.CTestBench_swigregister(CTestBench)
TMP_XSLT_CSS_EXTENSION = cvar.TMP_XSLT_CSS_EXTENSION

def CTestBench_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestBench":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestBench_cast(testBase)

def CTestBench_load(fileName: "std::string const &", filePos: "size_t"=0) -> "CTestBench":
    r""" Loads test environment configuration and test specifications from the given file."""
    return _connect.CTestBench_load(fileName, filePos)

def CTestBench_parse(yamlSpec: "std::string const &") -> "CTestBench":
    r""" Parses test environment configuration and test specifications from the given string."""
    return _connect.CTestBench_parse(yamlSpec)

def CTestBench_addUserInfoToReportConfig(reportConfig: "isys::CTestReportConfigSPtr const &", testSpecificationFile: "std::string const &", winIDEAWorkspace: "std::string const &", winIDEAWorkspaceFile: "std::string const &", defaultDlFile: "std::string const &") -> "void":
    r"""
    This method adds the following info to report config:
    - path to test spec. file given as parameter
    - path to winIDEA workspace file given as parameter
    - SDK (testIDEA) version (automatically obtained)
    - current date and time if specified in 'reportConfig'.
    """
    return _connect.CTestBench_addUserInfoToReportConfig(reportConfig, testSpecificationFile, winIDEAWorkspace, winIDEAWorkspaceFile, defaultDlFile)

def CTestBench_createDirIfNotExists(filePath: "std::string const") -> "void":
    r"""
    Creates directory for the given file path, if it does not exist.
    If path does not contain file name, it must end with path separator.
    """
    return _connect.CTestBench_createDirIfNotExists(filePath)

def CTestBench_saveTestResults(testResults: "isys::CTestReportContainerSPtr const &", reportConfig: "isys::CTestReportConfigSPtr &") -> "void":
    r"""
    This method saves test results into file in the specified format.
    Only XML, YAML and CSV files are supported by this function.
    XLS and XLSX (Excel) formats are available only from testIDEA,
    but CSV format can be easily imported to Excel.

    Note for CSV format: Because there are three different tables
    stored (configuration, statistics, and results), three files are
    created for CSV format. File name specified in reportConfig gets
    appended '-config' and '-statistics' strings for configuration and
    statistics tables respectively.

    createTestReport.py Python example. 
    """
    return _connect.CTestBench_saveTestResults(testResults, reportConfig)

def CTestBench_saveCSV(testResults: "isys::CTestReportContainerSPtr const &", newReportConfig: "isys::CTestReportConfigSPtr const &") -> "void":
    return _connect.CTestBench_saveCSV(testResults, newReportConfig)

def CTestBench_saveYAML(testResults: "isys::CTestReportContainerSPtr const &", newReportConfig: "isys::CTestReportConfigSPtr const &") -> "void":
    return _connect.CTestBench_saveYAML(testResults, newReportConfig)

def CTestBench_saveXML(testResults: "isys::CTestReportContainerSPtr const &", newReportConfig: "isys::CTestReportConfigSPtr const &") -> "void":
    return _connect.CTestBench_saveXML(testResults, newReportConfig)

def CTestBench_initTargetForTest(config: "isys::CTestEnvironmentConfigSPtr &", debug: "isys::CDebugFacadeSPtr &", ideCtrl: "isys::CIDEControllerSPtr &", targetStopTimeout: "int") -> "void":
    r"""
    Deprecated since 9.12.188, 2014-09-05, it works for old style
    init sequences only (download, reset, run, and runUntil actions are
    supported only and only in this order, no multicore support).
    Call 'executeInitAction' for all init actions in CTestEnvironmentConfig
    instead. Python has method PTestCase.executeInitSequence(), which
    replaces this method.

    Initializes target according to settings in 'config' to be ready for unit tests.

    :type config: :py:class:`CTestEnvironmentConfig`
    :param config: initialization configuration
    :type debug: :py:class:`CDebugFacade`
    :param debug: debug facade
    :type ideCtrl: :py:class:`CIDEController`
    :param ideCtrl: ide controller
    :type targetStopTimeout: int
    :param targetStopTimeout: timeout in milliseconds to wait for target
                                 to stop on the given function, address or breakpoint.
                                 TimeoutException is thrown in case of timeout.
    """
    return _connect.CTestBench_initTargetForTest(config, debug, ideCtrl, targetStopTimeout)

def CTestBench_executeInitAction(envConfig: "isys::CTestEnvironmentConfigSPtr &", mccMgr: "isys::CMulticoreConnectionMgrSPtr &", action: "isys::CInitSequenceActionSPtr &", stepIdx: "int", isWaitUntilStopped: "bool", targetStopTimeout: "int") -> "void":
    return _connect.CTestBench_executeInitAction(envConfig, mccMgr, action, stepIdx, isWaitUntilStopped, targetStopTimeout)

def CTestBench_restoreTargetAfterTest(config: "CTestEnvironmentConfig", debug: "isys::CDebugFacadeSPtr &", ideCtrl: "isys::CIDEControllerSPtr &", targetStopTimeout: "int") -> "void":
    return _connect.CTestBench_restoreTargetAfterTest(config, debug, ideCtrl, targetStopTimeout)

def CTestBench_configureInterrupts(envConfig: "CTestEnvironmentConfig", mccMgr: "isys::CMulticoreConnectionMgrSPtr", interruptStates: "StrStrMap") -> "void":
    return _connect.CTestBench_configureInterrupts(envConfig, mccMgr, interruptStates)

def CTestBench_restoreInterrupts(envConfig: "CTestEnvironmentConfig", mccMgr: "isys::CMulticoreConnectionMgrSPtr", interruptStates: "StrStrMap") -> "void":
    return _connect.CTestBench_restoreInterrupts(envConfig, mccMgr, interruptStates)

def CTestBench_execTestCaseInitSequence(testCaseInitConfig: "isys::CTestCaseTargetInitConfigSPtr &", connectionMgr: "isys::ConnectionMgrSPtr &", debug: "isys::CDebugFacadeSPtr &", targetStopTimeout: "int", isTestBatchOn: "bool") -> "bool":
    r"""
    This function initializes target before execution of each test case.

    :type testCaseInitConfig: :py:class:`CTestCaseTargetInitConfig`
    :param testCaseInitConfig: initialization configuration
    :type debug: :py:class:`CDebugFacade`
    :param debug: debug facade
    :type targetStopTimeout: int
    :param targetStopTimeout: timeout in milliseconds to wait for target
                                 to stop on the given function, address or breakpoint.
                                 TimeoutException is thrown in case of timeout.
    """
    return _connect.CTestBench_execTestCaseInitSequence(testCaseInitConfig, connectionMgr, debug, targetStopTimeout, isTestBatchOn)

def CTestBench_configureBreakpointsMode(ideCtrl: "isys::CIDEControllerSPtr &", bpType: "isys::CTestEnvironmentConfig::EBreakpointsType", coreIdx: "int", isBeforeInit: "bool") -> "void":
    r"""
    This method configures type of breakpoints (software of hardware)
    as needed for target initialization.

    :type ideCtrl: :py:class:`CIDEController`
    :param ideCtrl: controller object needed to access winIDEA
    :type bpType: int
    :param bpType: type of breakpoints
    :type coreIdx: int
    :param coreIdx: index of core for BP configuration
    :type isBeforeInit: boolean
    :param isBeforeInit: should be true, when this method is called before init sequence,
                            false when it is called for the second time after init seq.
    """
    return _connect.CTestBench_configureBreakpointsMode(ideCtrl, bpType, coreIdx, isBeforeInit)

def CTestBench_configureStackUsage(dataCtrl: "isys::CDataController2SPtr &", runConfiguration: "isys::CTestEnvironmentConfigSPtr &", coreIdParam: "std::string const &") -> "void":
    r"""
    This method configures stack usage.

    :param ideCtrl: controller object needed to access winIDEA
    :type runConfiguration: :py:class:`CTestEnvironmentConfig`
    :param runConfiguration: object containing stack measurement configurations
    :param coreId: id of core for which stack usage measurement should be configured.
    """
    return _connect.CTestBench_configureStackUsage(dataCtrl, runConfiguration, coreIdParam)

def CTestBench_isTestWithScripts(testSpec: "isys::CTestSpecificationSPtr const &") -> "bool":
    r"""
    Returns true, if test contains scripts.

    :type testSpec: :py:class:`CTestSpecification`
    :param testSpec: the test spec. to be tested for usage of scripts
    """
    return _connect.CTestBench_isTestWithScripts(testSpec)

def CTestBench_getCvrgFilterCandidates(mergedTestSpec: "isys::CTestSpecificationSPtr &") -> "CTestSpecification":
    return _connect.CTestBench_getCvrgFilterCandidates(mergedTestSpec)

class CScriptConfig(CTestBase):
    r"""
    This class contains configuration for calling script functions from testIDEA.

    Default operator =() can be used.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SCRIPT_SECTION_WORKING_DIR = _connect.CScriptConfig_E_SCRIPT_SECTION_WORKING_DIR
    E_SCRIPT_SECTION_MODULES = _connect.CScriptConfig_E_SCRIPT_SECTION_MODULES
    E_SCRIPT_SECTION_SYS_PATH = _connect.CScriptConfig_E_SCRIPT_SECTION_SYS_PATH
    E_SCRIPT_SECTION_TIMEOUT = _connect.CScriptConfig_E_SCRIPT_SECTION_TIMEOUT
    E_SCRIPT_SECTION_EXTENSION_CLASS = _connect.CScriptConfig_E_SCRIPT_SECTION_EXTENSION_CLASS

    def __init__(self, parent: "isys::CTestBaseSPtr const &"):
        _connect.CScriptConfig_swiginit(self, _connect.new_CScriptConfig(parent))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        r""" Creates a new empty instance of this class."""
        return _connect.CScriptConfig_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CScriptConfig":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CScriptConfig_cast(testBase)

    def getWorkingDir(self) -> "std::string":
        r""" Returns script working directory."""
        return _connect.CScriptConfig_getWorkingDir(self)

    def getModules(self, modules: "StrVector") -> "void":
        r"""
        Returns vector of modules/libraries to import/load by script interpreter
        before execution of tests.
        """
        return _connect.CScriptConfig_getModules(self, modules)

    def getSysPaths(self, paths: "StrVector") -> "void":
        r""" Returns the module/library search path for script interpreter."""
        return _connect.CScriptConfig_getSysPaths(self, paths)

    def getExtensionClass(self) -> "std::string":
        r""" Returns class to use as a extension object during tests."""
        return _connect.CScriptConfig_getExtensionClass(self)

    def getTimeout(self) -> "int":
        r"""
        Returns how long in seconds caller should wait for script calls to return.
        If it does not return in this time, the test is considered as failed!
        """
        return _connect.CScriptConfig_getTimeout(self)

    def setWorkingDir(self, workingDir: "std::string const &") -> "void":
        r""" Sets script working directory."""
        return _connect.CScriptConfig_setWorkingDir(self, workingDir)

    def setModules(self, modules: "StrVector") -> "void":
        r"""
        Setss vector of modules/libraries to import/load by script interpreter
        before execution of tests.
        """
        return _connect.CScriptConfig_setModules(self, modules)

    def setSysPaths(self, sysPaths: "StrVector") -> "void":
        r"""
        Sets modules/libraries to import/load by script interpreter
        before execution of tests.
        """
        return _connect.CScriptConfig_setSysPaths(self, sysPaths)

    def setExtensionClass(self, extensionClass: "std::string const &") -> "void":
        r""" Sets class to use as a callback object during tests."""
        return _connect.CScriptConfig_setExtensionClass(self, extensionClass)

    def setTimeout(self, timeout: "int") -> "void":
        r"""
        Sets how long in seconds caller should wait for script calls to return.
        If it does not return in this time, the test is considered as failed!
        """
        return _connect.CScriptConfig_setTimeout(self, timeout)
    __swig_destroy__ = _connect.delete_CScriptConfig

# Register CScriptConfig in _connect:
_connect.CScriptConfig_swigregister(CScriptConfig)
CScriptConfig.EXT_METHOD_BEFORE_TESTS = _connect.cvar.CScriptConfig_EXT_METHOD_BEFORE_TESTS
CScriptConfig.EXT_METHOD_GET_TEST_REPORT_CUSTOM_DATA = _connect.cvar.CScriptConfig_EXT_METHOD_GET_TEST_REPORT_CUSTOM_DATA
CScriptConfig.EXT_METHOD_AFTER_REPORT_SAVE = _connect.cvar.CScriptConfig_EXT_METHOD_AFTER_REPORT_SAVE
CScriptConfig.EXT_METHOD_CUSTOM_PREFIX = _connect.cvar.CScriptConfig_EXT_METHOD_CUSTOM_PREFIX
CScriptConfig.EXT_METHOD_TABLE_PREFIX = _connect.cvar.CScriptConfig_EXT_METHOD_TABLE_PREFIX
CScriptConfig.EXT_METHOD_TABLE_TYPE = _connect.cvar.CScriptConfig_EXT_METHOD_TABLE_TYPE
CScriptConfig.EXT_METHOD_TYPE = _connect.cvar.CScriptConfig_EXT_METHOD_TYPE

def CScriptConfig_cast(testBase: "isys::CTestBaseSPtr const &") -> "CScriptConfig":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CScriptConfig_cast(testBase)

class CEvaluatorConfig(CTestBase):
    r"""
    This class contains configuration for calling script functions from testIDEA.

    Default operator =() can be used.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ECDAscii = _connect.CEvaluatorConfig_ECDAscii
    ECDInteger = _connect.CEvaluatorConfig_ECDInteger
    ECDBoth = _connect.CEvaluatorConfig_ECDBoth
    EBDBlanks = _connect.CEvaluatorConfig_EBDBlanks
    EBDNoBlanksTrailingB = _connect.CEvaluatorConfig_EBDNoBlanksTrailingB
    EADHexNoPrefix = _connect.CEvaluatorConfig_EADHexNoPrefix
    EADHexPrefix = _connect.CEvaluatorConfig_EADHexPrefix
    EEDEnum = _connect.CEvaluatorConfig_EEDEnum
    EEDInteger = _connect.CEvaluatorConfig_EEDInteger
    EEDBoth = _connect.CEvaluatorConfig_EEDBoth
    E_EVALUATOR_SECTION_IS_OVERRIDE_WINIDEA_SETTINGS = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_IS_OVERRIDE_WINIDEA_SETTINGS
    E_EVALUATOR_SECTION_CHAR_DISPLAY = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_CHAR_DISPLAY
    E_EVALUATOR_SECTION_ANSI = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_ANSI
    E_EVALUATOR_SECTION_HEX = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_HEX
    E_EVALUATOR_SECTION_BINARY_DISPLAY = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_BINARY_DISPLAY
    E_EVALUATOR_SECTION_DISPLAY_POINTER_MEM_AREA = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_DISPLAY_POINTER_MEM_AREA
    E_EVALUATOR_SECTION_CHAR_ARRAY_AS_STRING = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_CHAR_ARRAY_AS_STRING
    E_EVALUATOR_SECTION_DEREFERENCE_STRING_POINTERS = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_DEREFERENCE_STRING_POINTERS
    E_EVALUATOR_SECTION_ADDRESS_DISPLAY = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_ADDRESS_DISPLAY
    E_EVALUATOR_SECTION_ENUM_DISPLAY = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_ENUM_DISPLAY
    E_EVALUATOR_SECTION_DISPLAY_COLLAPSED_ARRAY_STRUCT = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_DISPLAY_COLLAPSED_ARRAY_STRUCT
    E_EVALUATOR_SECTION_VAGUE_FLOAT_PRECISION = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_VAGUE_FLOAT_PRECISION
    E_EVALUATOR_SECTION_IS_USE_DEFAULT_WI_SETTINGS = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_IS_USE_DEFAULT_WI_SETTINGS
    r""" deprecated item"""

    def __init__(self, parent: "isys::CTestBaseSPtr const &"):
        _connect.CEvaluatorConfig_swiginit(self, _connect.new_CEvaluatorConfig(parent))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        r""" Creates a new empty instance of this class."""
        return _connect.CEvaluatorConfig_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CEvaluatorConfig":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CEvaluatorConfig_cast(testBase)

    def applySettingsToWinIDEA(self, ideSPtr: "isys::CIDEControllerSPtr &") -> "void":
        r"""
        This methods sets evaluator options for displaying values in winIDEA
        Watch window. These settings are also used by isystem.connect's
        CDataController::evaluate() method and testIDEA. This method applies
        current settings regardless of value returned by isOverrideWinIDEASettings().

        :param charDisplay: defines how values of type character are displayed
        :param isAnsi:
        :param isHex: if true, integers are displayed in hex format
        :param binaryDisplay: defines how values are displayed in binary format
        :param isDisplayPointerMemArea: if true, memory are is displayed for pointers
        :param isCharArrayAsString: if true, character arrays are displayed as zero terminated strings
        :param isDereferenceStringPointers: if true, ``char *`` is automatically dereferenced
        :param addressDisplay: defines how addresses are displayed
        :param enumDisplay: defines how enums are displayed
        :param isDisplayCollapsedArrayStruct: if true, array and structure values are displayed
        :param vagueFloatPrecision: defines precision for floating point comparison. Numbers,
                                       which differ less than this value are considered equal.
        """
        return _connect.CEvaluatorConfig_applySettingsToWinIDEA(self, ideSPtr)

    def getCharDisplay(self) -> "isys::CEvaluatorConfig::ECharDisplay":
        r""" Returns type of format for char values."""
        return _connect.CEvaluatorConfig_getCharDisplay(self)

    def isOverrideWinIDEASettings(self) -> "bool":
        r"""
        Returns E_TRUE, if winIDEA evaluator setting should be overridden with
        settings in this object. Default value (E_DEFAULT) means false.
        """
        return _connect.CEvaluatorConfig_isOverrideWinIDEASettings(self)

    def isAnsi(self) -> "bool":
        r"""
        Returns E_TRUE, if chars should be displayed in ANSI format.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CEvaluatorConfig_isAnsi(self)

    def isHex(self) -> "bool":
        r"""
        Returns E_TRUE, if integers should be displayed in hex format.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CEvaluatorConfig_isHex(self)

    def getBinaryDisplay(self) -> "isys::CEvaluatorConfig::EBinaryDisplay":
        r""" Returns type of format for binary values."""
        return _connect.CEvaluatorConfig_getBinaryDisplay(self)

    def isDisplayPointerMemArea(self) -> "bool":
        r"""
        Returns E_TRUE, if mem area should be displayed with pointers.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CEvaluatorConfig_isDisplayPointerMemArea(self)

    def isCharArrayAsString(self) -> "bool":
        r"""
        Returns E_TRUE, if char arrays should be displayed as strings.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CEvaluatorConfig_isCharArrayAsString(self)

    def isDereferenceStringPointers(self) -> "bool":
        r"""
        Returns E_TRUE, if pointers to 'char' should be dereferenced automatically.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CEvaluatorConfig_isDereferenceStringPointers(self)

    def getAddressDisplay(self) -> "isys::CEvaluatorConfig::EAddressDisplay":
        r""" Returns type of format for addresses."""
        return _connect.CEvaluatorConfig_getAddressDisplay(self)

    def getEnumDisplay(self) -> "isys::CEvaluatorConfig::EEnumDisplay":
        r""" Returns type of format for enums."""
        return _connect.CEvaluatorConfig_getEnumDisplay(self)

    def isDisplayCollapsedArrayStruct(self) -> "bool":
        r"""
        Returns E_TRUE, if array and structure values are displayed.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CEvaluatorConfig_isDisplayCollapsedArrayStruct(self)

    def getVagueFloatPrecision(self) -> "double":
        r"""
         Returns precision for floating point comparison. Numbers,
        which differ less than this value are considered equal.
        """
        return _connect.CEvaluatorConfig_getVagueFloatPrecision(self)

    def setOverrideWinIDEASettings(self, isOverrideWinIDEASettings: "iconnect::ETristate") -> "void":
        r"""
        If set to true, existing winIDEA evaluator settings will be overridden
        with settings from this object.
        """
        return _connect.CEvaluatorConfig_setOverrideWinIDEASettings(self, isOverrideWinIDEASettings)

    def setCharDisplay(self, charDisplay: "isys::CEvaluatorConfig::ECharDisplay") -> "void":
        r""" Sets type of format for char values."""
        return _connect.CEvaluatorConfig_setCharDisplay(self, charDisplay)

    def setAnsi(self, isAnsi: "iconnect::ETristate") -> "void":
        r""" If set to true, chars are displayed in ANSI format."""
        return _connect.CEvaluatorConfig_setAnsi(self, isAnsi)

    def setHex(self, isHex: "iconnect::ETristate") -> "void":
        r""" If set to true, integers are displayed in HEX format."""
        return _connect.CEvaluatorConfig_setHex(self, isHex)

    def setBinaryDisplay(self, binaryDisplay: "isys::CEvaluatorConfig::EBinaryDisplay") -> "void":
        r""" Sets format for binary numbers."""
        return _connect.CEvaluatorConfig_setBinaryDisplay(self, binaryDisplay)

    def setDisplayPointerMemArea(self, isDisplayPointerMemArea: "iconnect::ETristate") -> "void":
        r""" If set to true, mem area is displayed with pointers."""
        return _connect.CEvaluatorConfig_setDisplayPointerMemArea(self, isDisplayPointerMemArea)

    def setCharArrayAsString(self, isCharArrayAsString: "iconnect::ETristate") -> "void":
        r""" If set to true, char arrays are displayed as null terminated strings."""
        return _connect.CEvaluatorConfig_setCharArrayAsString(self, isCharArrayAsString)

    def setDereferenceStringPointers(self, isDereferenceStringPointers: "iconnect::ETristate") -> "void":
        r""" If set to true, pointers to 'char *' are automatically dereferenced."""
        return _connect.CEvaluatorConfig_setDereferenceStringPointers(self, isDereferenceStringPointers)

    def setAddressDisplay(self, addrDisplay: "isys::CEvaluatorConfig::EAddressDisplay") -> "void":
        r""" Sets format for addresses."""
        return _connect.CEvaluatorConfig_setAddressDisplay(self, addrDisplay)

    def setEnumDisplay(self, enumDisplay: "isys::CEvaluatorConfig::EEnumDisplay") -> "void":
        r""" Sets format for enums."""
        return _connect.CEvaluatorConfig_setEnumDisplay(self, enumDisplay)

    def setDisplayCollapsedArrayStruct(self, isDisplayCollapsedArrayStruct: "iconnect::ETristate") -> "void":
        r""" If set to true, array and struct values are displayed."""
        return _connect.CEvaluatorConfig_setDisplayCollapsedArrayStruct(self, isDisplayCollapsedArrayStruct)

    def setVagueFloatPrecision(self, precision: "double") -> "void":
        r"""
         Sets precision for floating point comparison. Numbers,
        which differ less than this value are considered equal.
        """
        return _connect.CEvaluatorConfig_setVagueFloatPrecision(self, precision)

    @staticmethod
    def charDisplayEnum2Str(val: "isys::CEvaluatorConfig::ECharDisplay") -> "std::string":
        r""" Returns string representation of enum."""
        return _connect.CEvaluatorConfig_charDisplayEnum2Str(val)

    @staticmethod
    def binaryDisplayEnum2Str(val: "isys::CEvaluatorConfig::EBinaryDisplay") -> "std::string":
        return _connect.CEvaluatorConfig_binaryDisplayEnum2Str(val)

    @staticmethod
    def addressDisplayEnum2Str(val: "isys::CEvaluatorConfig::EAddressDisplay") -> "std::string":
        return _connect.CEvaluatorConfig_addressDisplayEnum2Str(val)

    @staticmethod
    def enumDisplayEnum2Str(val: "isys::CEvaluatorConfig::EEnumDisplay") -> "std::string":
        return _connect.CEvaluatorConfig_enumDisplayEnum2Str(val)
    __swig_destroy__ = _connect.delete_CEvaluatorConfig

# Register CEvaluatorConfig in _connect:
_connect.CEvaluatorConfig_swigregister(CEvaluatorConfig)

def CEvaluatorConfig_cast(testBase: "isys::CTestBaseSPtr const &") -> "CEvaluatorConfig":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CEvaluatorConfig_cast(testBase)

def CEvaluatorConfig_charDisplayEnum2Str(val: "isys::CEvaluatorConfig::ECharDisplay") -> "std::string":
    r""" Returns string representation of enum."""
    return _connect.CEvaluatorConfig_charDisplayEnum2Str(val)

def CEvaluatorConfig_binaryDisplayEnum2Str(val: "isys::CEvaluatorConfig::EBinaryDisplay") -> "std::string":
    return _connect.CEvaluatorConfig_binaryDisplayEnum2Str(val)

def CEvaluatorConfig_addressDisplayEnum2Str(val: "isys::CEvaluatorConfig::EAddressDisplay") -> "std::string":
    return _connect.CEvaluatorConfig_addressDisplayEnum2Str(val)

def CEvaluatorConfig_enumDisplayEnum2Str(val: "isys::CEvaluatorConfig::EEnumDisplay") -> "std::string":
    return _connect.CEvaluatorConfig_enumDisplayEnum2Str(val)

class CInitSequenceAction(CTestBase):
    r"""
    This class defines target initialization steps to be performed
    before running tests. It supports initialization of multiple cores.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_INIT_SEQ_CORE_ID = _connect.CInitSequenceAction_E_INIT_SEQ_CORE_ID
    E_INIT_SEQ_ACTION = _connect.CInitSequenceAction_E_INIT_SEQ_ACTION
    E_INIT_SEQ_PARAMS = _connect.CInitSequenceAction_E_INIT_SEQ_PARAMS
    EIAConnectToCore = _connect.CInitSequenceAction_EIAConnectToCore
    r"""
    establish connection to secondary core(s). Normally
    primary winIDEA has to perform download before
    launching winIDEAs for other cores. Mandatory
    parameter is core index.
    """
    EIADownload = _connect.CInitSequenceAction_EIADownload
    r""" Downloads executable."""
    EIAReset = _connect.CInitSequenceAction_EIAReset
    r""" Resets target."""
    EIARun = _connect.CInitSequenceAction_EIARun
    r""" Runs target, optional parameter is stop function"""
    EIADeleteAllBreakpoints = _connect.CInitSequenceAction_EIADeleteAllBreakpoints
    r""" Deletes all breakpoints on core."""
    EIACallTargetFunction = _connect.CInitSequenceAction_EIACallTargetFunction
    r"""
    Calls function on target. Requires function name as first
    parameter, other parameters are passed as function parameters.
    """
    EIACallScriptFunction = _connect.CInitSequenceAction_EIACallScriptFunction
    r"""
    Calls script function. Requires function name as first parameter
    other parameters are passed as function parameters
    """
    EIALoadSymbolsOnly = _connect.CInitSequenceAction_EIALoadSymbolsOnly
    r"""
    If the code is already downloaded to the target, this
    action initializes emulator and loads symbols to winDEA.
    """
    EIAWaitUntilStopped = _connect.CInitSequenceAction_EIAWaitUntilStopped
    r"""
    Waits until core stops execution. Should be used after
    core is started from another core.
    """

    def __init__(self, parent: "isys::CTestBaseSPtr const &"):
        _connect.CInitSequenceAction_swiginit(self, _connect.new_CInitSequenceAction(parent))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        r""" Creates a new empty instance of this class."""
        return _connect.CInitSequenceAction_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CInitSequenceAction":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CInitSequenceAction_cast(testBase)

    def getCoreId(self) -> "std::string":
        r"""Returns ID of the core where action should be performed."""
        return _connect.CInitSequenceAction_getCoreId(self)

    def getAction(self) -> "isys::CInitSequenceAction::EInitAction":
        r""" Returns action to be performed. Use CSequenceAdapter to get parameters."""
        return _connect.CInitSequenceAction_getAction(self)

    def getActionName(self) -> "std::string":
        r"""
        Returns action name as human readable string - may be used for
        logging and debugging.
        """
        return _connect.CInitSequenceAction_getActionName(self)

    def setCoreId(self, coreId: "std::string const &") -> "void":
        r""" See also: getCoreId."""
        return _connect.CInitSequenceAction_setCoreId(self, coreId)

    def setAction(self, action: "isys::CInitSequenceAction::EInitAction") -> "void":
        r""" See also: getAction."""
        return _connect.CInitSequenceAction_setAction(self, action)
    __swig_destroy__ = _connect.delete_CInitSequenceAction

# Register CInitSequenceAction in _connect:
_connect.CInitSequenceAction_swigregister(CInitSequenceAction)

def CInitSequenceAction_cast(testBase: "isys::CTestBaseSPtr const &") -> "CInitSequenceAction":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CInitSequenceAction_cast(testBase)

class CTestCaseTargetInitConfig(CTestBase):
    r"""
    This class defines target initialization steps to be performed
    before each test case.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_TEST_CASE_SECTION_IS_DL_ON_TC_INIT = _connect.CTestCaseTargetInitConfig_E_TEST_CASE_SECTION_IS_DL_ON_TC_INIT
    E_TEST_CASE_SECTION_IS_RESET_ON_TC_INIT = _connect.CTestCaseTargetInitConfig_E_TEST_CASE_SECTION_IS_RESET_ON_TC_INIT
    E_TEST_CASE_SECTION_IS_RUN_ON_TC_INIT = _connect.CTestCaseTargetInitConfig_E_TEST_CASE_SECTION_IS_RUN_ON_TC_INIT
    E_TEST_CASE_SECTION_STOP_FUNC_ON_TC_INIT = _connect.CTestCaseTargetInitConfig_E_TEST_CASE_SECTION_STOP_FUNC_ON_TC_INIT

    def __init__(self, parent: "isys::CTestBaseSPtr const &"):
        _connect.CTestCaseTargetInitConfig_swiginit(self, _connect.new_CTestCaseTargetInitConfig(parent))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        r""" Creates a new empty instance of this class."""
        return _connect.CTestCaseTargetInitConfig_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestCaseTargetInitConfig":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestCaseTargetInitConfig_cast(testBase)

    def isDownloadOnTCInit(self) -> "bool":
        r"""
        If E_TRUE is returned, download is performed before each test case.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestCaseTargetInitConfig_isDownloadOnTCInit(self)

    def isResetOnTCInit(self) -> "bool":
        r"""
        If E_TRUE is returned, reset is performed before each test case.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestCaseTargetInitConfig_isResetOnTCInit(self)

    def isRunOnTCInit(self) -> "bool":
        r"""
        If E_TRUE is returned, target is started before each test case.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestCaseTargetInitConfig_isRunOnTCInit(self)

    def getStopFunctionOnTCInit(self) -> "std::string":
        r"""
         Returns the name of the function to stop on in init sequence
        before each test case.
        Has no effect if isRunOnTCInit() returns false.
        """
        return _connect.CTestCaseTargetInitConfig_getStopFunctionOnTCInit(self)

    def setDownloadOnTCInit(self, isDownload: "iconnect::ETristate") -> "void":
        r""" See also: isDownloadOnTCInit"""
        return _connect.CTestCaseTargetInitConfig_setDownloadOnTCInit(self, isDownload)

    def setResetOnTCInit(self, isReset: "iconnect::ETristate") -> "void":
        r""" See also: isResetOnTCInit"""
        return _connect.CTestCaseTargetInitConfig_setResetOnTCInit(self, isReset)

    def setRunOnTCInit(self, isRun: "iconnect::ETristate") -> "void":
        r""" See also: isRunOnTCInit"""
        return _connect.CTestCaseTargetInitConfig_setRunOnTCInit(self, isRun)

    def setStopFunctionOnTCInit(self, stopFunction: "std::string const &") -> "void":
        r""" See also: getStopFunctionOnTCInit"""
        return _connect.CTestCaseTargetInitConfig_setStopFunctionOnTCInit(self, stopFunction)
    __swig_destroy__ = _connect.delete_CTestCaseTargetInitConfig

# Register CTestCaseTargetInitConfig in _connect:
_connect.CTestCaseTargetInitConfig_swigregister(CTestCaseTargetInitConfig)

def CTestCaseTargetInitConfig_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestCaseTargetInitConfig":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestCaseTargetInitConfig_cast(testBase)

class CStackUsageConfig(CTestBase):
    r"""This class defines values for stack usage measurements."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_CORE_ID = _connect.CStackUsageConfig_E_SECTION_CORE_ID
    E_SECTION_IS_ACTIVE = _connect.CStackUsageConfig_E_SECTION_IS_ACTIVE
    E_SECTION_BASE = _connect.CStackUsageConfig_E_SECTION_BASE
    E_SECTION_END = _connect.CStackUsageConfig_E_SECTION_END
    E_SECTION_PATTERN = _connect.CStackUsageConfig_E_SECTION_PATTERN

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default ctor.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestBase.
        """
        _connect.CStackUsageConfig_swiginit(self, _connect.new_CStackUsageConfig(*args))
    __swig_destroy__ = _connect.delete_CStackUsageConfig

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CStackUsageConfig_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CStackUsageConfig":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CStackUsageConfig_cast(testBase)

    def getCoreId(self) -> "std::string":
        r"""
        Returns ID of the core, which stack usage has to be measured. Core IDs
        are set in CTestEnvironmentConfig, tag 'coreIds'.
        """
        return _connect.CStackUsageConfig_getCoreId(self)

    def isActive(self) -> "bool":
        r"""
        Returns E_TRUE, if stack usage measurement should be initialized.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CStackUsageConfig_isActive(self)

    def getBase(self) -> "DWORD":
        r"""
        Deprecated: use getBaseExpr(), because it can return expressions
        Returns low address of stack area.
        """
        return _connect.CStackUsageConfig_getBase(self)

    def getEnd(self) -> "DWORD":
        r"""
        Deprecated: use getBaseExpr(), because it can return expressions
        Returns high address of stack area.
        """
        return _connect.CStackUsageConfig_getEnd(self)

    def getBaseExpr(self) -> "std::string":
        r"""Returns low address of stack area."""
        return _connect.CStackUsageConfig_getBaseExpr(self)

    def getEndExpr(self) -> "std::string":
        r"""Returns high address of stack area."""
        return _connect.CStackUsageConfig_getEndExpr(self)

    def getPattern(self) -> "int":
        r"""Returns pattern for stack seed."""
        return _connect.CStackUsageConfig_getPattern(self)

    def setCoreId(self, coreId: "std::string const &") -> "void":
        r"""
        Sets ID of the core, which stack usage has to be measured. Core IDs
        are set in CTestEnvironmentConfig, tag 'coreIds'.
        """
        return _connect.CStackUsageConfig_setCoreId(self, coreId)

    def setActive(self, isActive: "iconnect::ETristate") -> "void":
        r""" Sets stack usage measurement status. E_DEFAULT means not active."""
        return _connect.CStackUsageConfig_setActive(self, isActive)

    def setBase(self, minSize: "DWORD") -> "void":
        r"""Sets low address of stack area."""
        return _connect.CStackUsageConfig_setBase(self, minSize)

    def setEnd(self, maxSize: "DWORD") -> "void":
        r"""Sets high address of stack area."""
        return _connect.CStackUsageConfig_setEnd(self, maxSize)

    def setPattern(self, pattern: "unsigned char") -> "void":
        r"""Sets pattern for stack seed."""
        return _connect.CStackUsageConfig_setPattern(self, pattern)

# Register CStackUsageConfig in _connect:
_connect.CStackUsageConfig_swigregister(CStackUsageConfig)

def CStackUsageConfig_cast(testBase: "isys::CTestBaseSPtr const &") -> "CStackUsageConfig":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CStackUsageConfig_cast(testBase)

class CToolsConfig(CTestBase):
    r"""This class defines settings used by commands in iTools menu and wizards."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_IS_AUTO_SET_ANALYZER_FNAME = _connect.CToolsConfig_E_SECTION_IS_AUTO_SET_ANALYZER_FNAME
    r"""
    if true, analyzer file name is
    set if empty when analyzer is activated.
    """
    E_SECTION_ANALYZER_FNAME = _connect.CToolsConfig_E_SECTION_ANALYZER_FNAME
    E_SECTION_IS_SET_TEST_ID_ON_PASTE = _connect.CToolsConfig_E_SECTION_IS_SET_TEST_ID_ON_PASTE

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default ctor.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestBase.
        """
        _connect.CToolsConfig_swiginit(self, _connect.new_CToolsConfig(*args))
    __swig_destroy__ = _connect.delete_CToolsConfig

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CToolsConfig_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CToolsConfig":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CToolsConfig_cast(testBase)

    def isAutoSetAnalyzerFName(self) -> "bool":
        r"""
        Returns E_TRUE, if analyzer file name should be set if empty and pattern is specified.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CToolsConfig_isAutoSetAnalyzerFName(self)

    def getAnalyzerFName(self) -> "std::string":
        r"""
        Returns default analyzer file name, which is used in testIDEA when analyzer
        is activated, if ``isAutoSetAnalyzerFName()`` returns true.
        """
        return _connect.CToolsConfig_getAnalyzerFName(self)

    def isSetTestIdOnPaste(self) -> "bool":
        r""" Returns true, if testIDEA should set test IDs on paste."""
        return _connect.CToolsConfig_isSetTestIdOnPaste(self)

    def setAnalyzerFName(self, fName: "std::string const &") -> "void":
        r"""
        Sets default analyzer file name, which is used in testIDEA when analyzer
        is activated, if ``isAutoSetAnalyzerFName()`` returns true.
        """
        return _connect.CToolsConfig_setAnalyzerFName(self, fName)

    def setAutoSetAnalyzerFName(self, isActive: "iconnect::ETristate") -> "void":
        r"""
        Set to E_TRUE, if analyzer file name should be set if empty and pattern is specified.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CToolsConfig_setAutoSetAnalyzerFName(self, isActive)

# Register CToolsConfig in _connect:
_connect.CToolsConfig_swigregister(CToolsConfig)

def CToolsConfig_cast(testBase: "isys::CTestBaseSPtr const &") -> "CToolsConfig":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CToolsConfig_cast(testBase)

class CTestEnvironmentConfig(CTestBase):
    r"""
    This class contains configuration for winIDEA connection and logging
    parameters.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EKeepWinIDEASetting = _connect.CTestEnvironmentConfig_EKeepWinIDEASetting
    r""" testIDEA does not change setting in winIDEA"""
    EUseHWBPs = _connect.CTestEnvironmentConfig_EUseHWBPs
    r""" testIDEA configures winIDEA to use hardware breakpoints"""
    EUseSWBPs = _connect.CTestEnvironmentConfig_EUseSWBPs
    r""" testIDEA configures winIDEA to use software breakpoints"""
    EUseHWBPsForInitThenSWBPs = _connect.CTestEnvironmentConfig_EUseHWBPsForInitThenSWBPs
    r"""
    testIDEA configures winIDEA to use hardware
    breakpoints during target initialization phase,
    and software breakpoints during testing. This
    setting is useful, when target init involves
    for example CRC verification of code, which fails
    in case of software breakpoints.
    """
    E_SECTION_VERSION = _connect.CTestEnvironmentConfig_E_SECTION_VERSION
    E_SECTION_WINIDEA_WORKSPACE_FILE_NAME = _connect.CTestEnvironmentConfig_E_SECTION_WINIDEA_WORKSPACE_FILE_NAME
    E_SECTION_USE_QUALIFIED_FUNC_NAME = _connect.CTestEnvironmentConfig_E_SECTION_USE_QUALIFIED_FUNC_NAME
    E_SECTION_WINIDEA_ADDRESS = _connect.CTestEnvironmentConfig_E_SECTION_WINIDEA_ADDRESS
    E_SECTION_WINIDEA_PORT = _connect.CTestEnvironmentConfig_E_SECTION_WINIDEA_PORT
    E_SECTION_CORE_IDS = _connect.CTestEnvironmentConfig_E_SECTION_CORE_IDS
    E_SECTION_IS_AUTO_CONNECT = _connect.CTestEnvironmentConfig_E_SECTION_IS_AUTO_CONNECT
    E_SECTION_AUTO_ID_FORMAT_STRING = _connect.CTestEnvironmentConfig_E_SECTION_AUTO_ID_FORMAT_STRING
    E_SECTION_DEFAULT_RET_VAL_NAME = _connect.CTestEnvironmentConfig_E_SECTION_DEFAULT_RET_VAL_NAME
    E_SECTION_LOG_PARAMETERS = _connect.CTestEnvironmentConfig_E_SECTION_LOG_PARAMETERS
    E_SECTION_ALWAYS_RUN_INIT_SEQ = _connect.CTestEnvironmentConfig_E_SECTION_ALWAYS_RUN_INIT_SEQ
    E_SECTION_DISABLE_INTERRUPTS = _connect.CTestEnvironmentConfig_E_SECTION_DISABLE_INTERRUPTS
    E_SECTION_TEST_TIMEOUT = _connect.CTestEnvironmentConfig_E_SECTION_TEST_TIMEOUT
    E_SECTION_BREAKPOINTS_TYPE = _connect.CTestEnvironmentConfig_E_SECTION_BREAKPOINTS_TYPE
    E_SECTION_INIT_SEQUENCE = _connect.CTestEnvironmentConfig_E_SECTION_INIT_SEQUENCE
    E_SECTION_SCRIPT = _connect.CTestEnvironmentConfig_E_SECTION_SCRIPT
    E_SECTION_TOOLS_CONFIG = _connect.CTestEnvironmentConfig_E_SECTION_TOOLS_CONFIG
    E_SECTION_EVALUATOR = _connect.CTestEnvironmentConfig_E_SECTION_EVALUATOR
    E_SECTION_TARGET_INIT = _connect.CTestEnvironmentConfig_E_SECTION_TARGET_INIT
    E_SECTION_STACK_USAGE = _connect.CTestEnvironmentConfig_E_SECTION_STACK_USAGE
    E_SECTION_CHECK_TARGET_STATE_BEFORE_RUN = _connect.CTestEnvironmentConfig_E_SECTION_CHECK_TARGET_STATE_BEFORE_RUN
    E_SECTION_VERIFY_SYMBOLS_BEFORE_RUN = _connect.CTestEnvironmentConfig_E_SECTION_VERIFY_SYMBOLS_BEFORE_RUN
    E_SECTION_STACK_USAGE_DEPR = _connect.CTestEnvironmentConfig_E_SECTION_STACK_USAGE_DEPR
    E_SECTION_IS_DOWNLOAD_ON_INIT = _connect.CTestEnvironmentConfig_E_SECTION_IS_DOWNLOAD_ON_INIT
    E_SECTION_IS_RESET_ON_INIT = _connect.CTestEnvironmentConfig_E_SECTION_IS_RESET_ON_INIT
    E_SECTION_IS_RUN_ON_INIT = _connect.CTestEnvironmentConfig_E_SECTION_IS_RUN_ON_INIT
    E_SECTION_STOP_FUNCTION = _connect.CTestEnvironmentConfig_E_SECTION_STOP_FUNCTION
    E_SECTION_DELETE_BPS = _connect.CTestEnvironmentConfig_E_SECTION_DELETE_BPS

    def __init__(self, parent: "isys::CTestBaseSPtr const &"):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class. Used
            only when parsing YAML declaration. Can be specified as
            NULL if the object is not initialized by parser.
        """
        _connect.CTestEnvironmentConfig_swiginit(self, _connect.new_CTestEnvironmentConfig(parent))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        r""" Creates a new empty instance of this class."""
        return _connect.CTestEnvironmentConfig_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestEnvironmentConfig":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestEnvironmentConfig_cast(testBase)

    def serialize(self, emitter: "isys::IEmitterSPtr const &") -> "void":
        r""" Overrides base class method to change file version."""
        return _connect.CTestEnvironmentConfig_serialize(self, emitter)

    def getVersion(self) -> "std::string":
        r""" Returns version of testIDEA which saved the test specification file."""
        return _connect.CTestEnvironmentConfig_getVersion(self)

    @staticmethod
    def getStaticVersion() -> "std::string":
        r"""
        This method may be used by other classes during parsing to obtain
        version of currently parsed iyaml file. If the version was not parsed,
        empty string is returned.
        """
        return _connect.CTestEnvironmentConfig_getStaticVersion()

    def getWorkspace(self) -> "std::string":
        r""" Returns workspace file path and name."""
        return _connect.CTestEnvironmentConfig_getWorkspace(self)

    def getPrimaryCoreId(self) -> "std::string":
        r"""
        Returns core ID of the primary core (the first item from the list),
        or empty string is there are no core IDs specified.
        """
        return _connect.CTestEnvironmentConfig_getPrimaryCoreId(self)

    def getCoreIds(self, coreIds: "StrVector") -> "void":
        r"""
        Returns vector of core IDs. If empty, single core is used with empty
        string as its ID.
        """
        return _connect.CTestEnvironmentConfig_getCoreIds(self, coreIds)

    def getCoreIdIndex(self, coreId: "std::string const &", isThrow: "bool") -> "int":
        r""" Returns index of the given coreId."""
        return _connect.CTestEnvironmentConfig_getCoreIdIndex(self, coreId, isThrow)

    def isUseQualifiedFuncNames(self) -> "bool":
        r"""
        Returns true, if qualified function names should be presented as
        content proposals in testIDEA.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestEnvironmentConfig_isUseQualifiedFuncNames(self)

    def getAddress(self) -> "std::string":
        r"""
        Returns address of remote host running winIDEA. If empty string is returned
        and port is 0, then local host is used.
        """
        return _connect.CTestEnvironmentConfig_getAddress(self)

    def getPort(self) -> "int":
        r"""
        Returns port of remote host running winIDEA. If 0 is returned
        and address is empty string, then local host is used.
        """
        return _connect.CTestEnvironmentConfig_getPort(self)

    def isAutoConnectToWinIDEA(self) -> "bool":
        r"""
        If true is returned, then Test Bench will connect automatically to winIDEA,
        when names of functions or global vars are required.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestEnvironmentConfig_isAutoConnectToWinIDEA(self)

    def isAlwaysRunInitSeqBeforeRun(self) -> "bool":
        r"""
        If true, init sequence is executed before test specifications are executed.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestEnvironmentConfig_isAlwaysRunInitSeqBeforeRun(self)

    def isDownloadOnInit(self) -> "bool":
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        get action from CInitSequence.

        If true, download is performed in init sequence.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestEnvironmentConfig_isDownloadOnInit(self)

    def isResetOnInit(self) -> "bool":
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        get action from CInitSequence.

        If true, reset is performed in init sequence.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestEnvironmentConfig_isResetOnInit(self)

    def isRunOnInit(self) -> "bool":
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        get action from CInitSequence.

        If true, target is started in init sequence.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestEnvironmentConfig_isRunOnInit(self)

    def getStopFunction(self) -> "std::string":
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        get action from CInitSequence.

        Returns the name of the function to stop on in init sequence.
        Has no effect if isRunOnInit() returns false.
        """
        return _connect.CTestEnvironmentConfig_getStopFunction(self)

    def isDeleteAllBPsOnInit(self) -> "bool":
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        get action from CInitSequence.

        Returns true, if all breakpoints should be deleted in init sequence.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestEnvironmentConfig_isDeleteAllBPsOnInit(self)

    def isCheckTargetStateBeforeRun(self) -> "bool":
        r"""
        Returns true, if testIDEA should check target state before
        running tests and warn user if it does not match state defined in
        this class, for example the target is not stopped on function 'main'.
        """
        return _connect.CTestEnvironmentConfig_isCheckTargetStateBeforeRun(self)

    def isVerifySymbolsBeforeRun(self) -> "bool":
        r"""
        Returns true, if testIDEA should verify that functions exist on target
        before test run. If non-existent functions are found in test cases,
        pop-up dialog appears in testIDEA.
        """
        return _connect.CTestEnvironmentConfig_isVerifySymbolsBeforeRun(self)

    def isDisableInterrupts(self) -> "bool":
        r"""
        Returns true, if interrupts should be disabled in init sequence.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestEnvironmentConfig_isDisableInterrupts(self)

    def getTestTimeout(self) -> "int":
        r"""
        Returns timeout (in milliseconds), after which test execution is terminated.
        Value 0 means infinite timeout. This timeout value is overridden, if timeout
        is specified in test case.
        """
        return _connect.CTestEnvironmentConfig_getTestTimeout(self)

    def getBreakpointType(self) -> "isys::CTestEnvironmentConfig::EBreakpointsType":
        r""" Returns the type of breakpoints to be used during testing."""
        return _connect.CTestEnvironmentConfig_getBreakpointType(self)

    def getDefaultReturnValueName(self) -> "std::string":
        r""" Returns the default name for variable, where function return value is stored."""
        return _connect.CTestEnvironmentConfig_getDefaultReturnValueName(self)

    def getAutoIdFormatString(self) -> "std::string":
        r"""
         Returns string, which defines format of automatically assigned IDs.

        See also: setAutoIdFormatString
        """
        return _connect.CTestEnvironmentConfig_getAutoIdFormatString(self)

    def getScriptConfig(self, isConst: "bool") -> "CScriptConfig":
        r""" Returns script configuration."""
        return _connect.CTestEnvironmentConfig_getScriptConfig(self, isConst)

    def getToolsConfig(self, isConst: "bool") -> "CToolsConfig":
        r""" Returns tools configuration."""
        return _connect.CTestEnvironmentConfig_getToolsConfig(self, isConst)

    def getEvaluatorConfig(self, isConst: "bool") -> "CEvaluatorConfig":
        r""" Returns evaluator configuration."""
        return _connect.CTestEnvironmentConfig_getEvaluatorConfig(self, isConst)

    def getTestCaseTargetInitConfig(self, isConst: "bool") -> "CTestCaseTargetInitConfig":
        r""" Returns target initialization before each test case configuration."""
        return _connect.CTestEnvironmentConfig_getTestCaseTargetInitConfig(self, isConst)

    def getStackUsageConfig(self, isConst: "bool") -> "CStackUsageConfig":
        r"""
        Deprecated: use getStackUsageOptions() instead

        Returns configuration for stack usage measurements.
        """
        return _connect.CTestEnvironmentConfig_getStackUsageConfig(self, isConst)

    def getStackUsageOptions(self, isConst: "bool") -> "CTestBaseList":
        r""" Returns list of stack usage options for all cores for which it is defined."""
        return _connect.CTestEnvironmentConfig_getStackUsageOptions(self, isConst)

    def getLoggingParameters(self, params: "StrVector") -> "void":
        r"""
        Returns vector of logging parameters. Parameters are stored in the list
        in the following order: ``logFileName``, ``logObjPrefix``. All parameters are
        optional. If none of them is specified, logging is off.
        """
        return _connect.CTestEnvironmentConfig_getLoggingParameters(self, params)

    def getWarnings(self) -> "std::string":
        r"""
        If there were any warnings detected during parsing, this method returns
        non-empty string with description of warnings. It is recommended to
        call this method always after parsing.

        See also: CTestBench::getWarnings()
        """
        return _connect.CTestEnvironmentConfig_getWarnings(self)

    def setVersion(self, version: "std::string const &") -> "void":
        r""" Outputs contents of this class to emitter.  See also: getVersion"""
        return _connect.CTestEnvironmentConfig_setVersion(self, version)

    def setWorkspace(self, workspace: "std::string const &") -> "void":
        r""" See also: getWorkspace"""
        return _connect.CTestEnvironmentConfig_setWorkspace(self, workspace)

    def setAddress(self, address: "std::string const &") -> "void":
        r""" See also: getAddress"""
        return _connect.CTestEnvironmentConfig_setAddress(self, address)

    def setPort(self, port: "int") -> "void":
        r""" See also: getPort"""
        return _connect.CTestEnvironmentConfig_setPort(self, port)

    def setAutoConnectToWinIDEA(self, autoConnect: "iconnect::ETristate") -> "void":
        r"""
        If set to true, then Test Bench will connect automatically to winIDEA,
               when names of functions or global vars are required.
        """
        return _connect.CTestEnvironmentConfig_setAutoConnectToWinIDEA(self, autoConnect)

    def setAlwaysRunInitSeqBeforeRun(self, isAlwaysRunInitSeq: "iconnect::ETristate") -> "void":
        r""" If set to true, init sequence is run before each test start."""
        return _connect.CTestEnvironmentConfig_setAlwaysRunInitSeqBeforeRun(self, isAlwaysRunInitSeq)

    def setDownloadOnInit(self, isDownload: "iconnect::ETristate") -> "void":
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        set action in CInitSequence. This function should not be used
        for multicore init sequences, because order of actions can not be
        specified.

        See also: isDownloadOnInit
        """
        return _connect.CTestEnvironmentConfig_setDownloadOnInit(self, isDownload)

    def setResetOnInit(self, isReset: "iconnect::ETristate") -> "void":
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        set action in CInitSequence.

        See also: isResetOnInit
        """
        return _connect.CTestEnvironmentConfig_setResetOnInit(self, isReset)

    def setRunOnInit(self, isRun: "iconnect::ETristate") -> "void":
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        set action in CInitSequence.

        See also: isRunOnInit
        """
        return _connect.CTestEnvironmentConfig_setRunOnInit(self, isRun)

    def setStopFunction(self, stopFunction: "std::string const &") -> "void":
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        set action in CInitSequence.

        See also: getStopFunction
        """
        return _connect.CTestEnvironmentConfig_setStopFunction(self, stopFunction)

    def setDeleteAllBPsOnInit(self, isDeleteAllBPs: "iconnect::ETristate") -> "void":
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        set action in CInitSequence.

        See also: isDeleteAllBPsOnInit
        """
        return _connect.CTestEnvironmentConfig_setDeleteAllBPsOnInit(self, isDeleteAllBPs)

    def setCheckTargetStateBeforeRun(self, isCheckTargetState: "iconnect::ETristate") -> "void":
        r"""
        Defines, if testIDEA should check target state before running tests.
        For example, if run until function is specified in init sequence, testIDEA
        checks if target is stopped there.

        See also: isCheckTargetStateBeforeRun
        """
        return _connect.CTestEnvironmentConfig_setCheckTargetStateBeforeRun(self, isCheckTargetState)

    def setVerifySymbolsBeforeRun(self, isVerifySymbols: "iconnect::ETristate") -> "void":
        r"""
        Defines, if testIDEA should verify symbols before test run. It checks if
        all functions (tested, stubs, ...) exist on target.
        """
        return _connect.CTestEnvironmentConfig_setVerifySymbolsBeforeRun(self, isVerifySymbols)

    def setDisableInterrupts(self, isDisableInterrupts: "iconnect::ETristate") -> "void":
        r""" See also: isDisableInterrupts"""
        return _connect.CTestEnvironmentConfig_setDisableInterrupts(self, isDisableInterrupts)

    def setTestTimeout(self, timeout: "int") -> "void":
        r"""
        Sets timeout (in milliseconds), after which test execution is terminated.
        Value 0 means infinite timeout. This timeout value is overridden, if timeout
        is specified in test case.
        """
        return _connect.CTestEnvironmentConfig_setTestTimeout(self, timeout)

    def setBreakpointsType(self, breakpointsType: "isys::CTestEnvironmentConfig::EBreakpointsType") -> "void":
        r""" Sets type of breakpoints to be used in testing."""
        return _connect.CTestEnvironmentConfig_setBreakpointsType(self, breakpointsType)

    def setDefaultReturnValueName(self, defaultRetValName: "std::string const &") -> "void":
        r""" Sets default name for variable, where function return value is stored."""
        return _connect.CTestEnvironmentConfig_setDefaultReturnValueName(self, defaultRetValName)

    def setAutoIdFormatString(self, format: "std::string const &") -> "void":
        r"""
        Sets format of automatically assigned IDs. The string format is
        specific to the tool, which applies IDs. See testIDEA help for
        testIDEA rules. Users may write their own scripts, which may specify
        custom formats.

        The string can be composed of
        variables and plain text between them. Variables have the following
        format: ``${*}``. The following variables are available:

        - ${id[,n[,m]]} - generates unique string ID.
                          Optional value ``n`` defines the
                          number of characters for the ID. Optional value ``m`` defines the
                          number of characters for the ID extension of derived tests. If ``m``
                          is specified, IDs of derived tests are formed as
                          [base test ID].[derived test id].
                          Letters, numbers and '.' are used in the
                          ID string.
        - ${seq[,n[,m]]} - generates IDs, which are the same as test case sequence number.
                          The first test gets number 0, the next one number 1, ...
                          Optional value ``n`` defines the
                          number of characters for the ID. Optional value ``m`` defines the
                          number of characters for the ID extension of derived tests. If ``m``
                          is specified, IDs of derived tests are formed as
                          [base test ID].[derived test id].
                          Only numbers and '.' are used in the
                          ID string.
        - ${function} - name of the function under test.
        - ${params} - values of parameters. Values of parameters are separated by '-' sign,
                      all characters, which are not allowed for test ID are replaced with '_'
        - ${tags} - test tags separated by '-'.

        Example format string:

        "/{$id,4}/${function}-${params}-${tags}
        </pre>
        """
        return _connect.CTestEnvironmentConfig_setAutoIdFormatString(self, format)

    def setLoggingParameters(self, params: "std::string const &") -> "void":
        r"""
        Sets logging parameters. Parameters are stored in the list
        in the following order: [``logFileName``, ``logObjPrefix]``. All parameters are
        optional. If none of them is specified, logging is off.
        """
        return _connect.CTestEnvironmentConfig_setLoggingParameters(self, params)

    def getConfiguredCoreID(self, testCaseCoreId: "std::string const &") -> "std::string":
        r"""
        Returns the given ``testCaseCoreId``, if it is not empty. If it is empty,
        the first item from ``envConfig`` core IDs is returned. If no
        core IDs are defined there, an empty string is returned.
        """
        return _connect.CTestEnvironmentConfig_getConfiguredCoreID(self, testCaseCoreId)
    __swig_destroy__ = _connect.delete_CTestEnvironmentConfig

# Register CTestEnvironmentConfig in _connect:
_connect.CTestEnvironmentConfig_swigregister(CTestEnvironmentConfig)

def CTestEnvironmentConfig_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestEnvironmentConfig":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestEnvironmentConfig_cast(testBase)

def CTestEnvironmentConfig_getStaticVersion() -> "std::string":
    r"""
    This method may be used by other classes during parsing to obtain
    version of currently parsed iyaml file. If the version was not parsed,
    empty string is returned.
    """
    return _connect.CTestEnvironmentConfig_getStaticVersion()

class CTestReportConfig(CTestBase):
    r"""
    This class contains information about test report, which is implicitly
    contained in the report, for example report format, and user info
    about test.


    emitterDemo.py Python example. 

    createTestReport.py Python example. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DYNAMIC_PREFIX = _connect.CTestReportConfig_DYNAMIC_PREFIX
    RCONFIG_FULL = _connect.CTestReportConfig_RCONFIG_FULL
    r""" all measured values are in the report"""
    RCONFIG_ERRORS_ONLY = _connect.CTestReportConfig_RCONFIG_ERRORS_ONLY
    r""" only values which do not match expected are saved into report"""
    FMT_XML = _connect.CTestReportConfig_FMT_XML
    r""" XML format"""
    FMT_YAML = _connect.CTestReportConfig_FMT_YAML
    r""" YAML format"""
    FMT_CSV = _connect.CTestReportConfig_FMT_CSV
    r""" Comma Separated Values format"""
    FMT_XLS = _connect.CTestReportConfig_FMT_XLS
    r""" the old Excel binary format"""
    FMT_XLSX = _connect.CTestReportConfig_FMT_XLSX
    r""" the new Excel XML format"""
    HTML_VIEW_ALL = _connect.CTestReportConfig_HTML_VIEW_ALL
    HTML_VIEW_ERROS_ONLY = _connect.CTestReportConfig_HTML_VIEW_ERROS_ONLY
    E_SECTION_TEST_IDEA_VERSION = _connect.CTestReportConfig_E_SECTION_TEST_IDEA_VERSION
    E_SECTION_WIN_IDEA_VERSION = _connect.CTestReportConfig_E_SECTION_WIN_IDEA_VERSION
    E_SECTION_REPORT_CONTENTS = _connect.CTestReportConfig_E_SECTION_REPORT_CONTENTS
    E_SECTION_OUTPUT_FORMAT = _connect.CTestReportConfig_E_SECTION_OUTPUT_FORMAT
    E_SECTION_FILE_NAME = _connect.CTestReportConfig_E_SECTION_FILE_NAME
    E_SECTION_IYAML_FILE_NAME = _connect.CTestReportConfig_E_SECTION_IYAML_FILE_NAME
    E_SECTION_XML_XSLT_FOR_FULL_REPORT = _connect.CTestReportConfig_E_SECTION_XML_XSLT_FOR_FULL_REPORT
    E_SECTION_XML_XSLT_FOR_ERRORS = _connect.CTestReportConfig_E_SECTION_XML_XSLT_FOR_ERRORS
    E_SECTION_XML_LOGO_IMAGE = _connect.CTestReportConfig_E_SECTION_XML_LOGO_IMAGE
    E_SECTION_XML_REPORT_HEADER = _connect.CTestReportConfig_E_SECTION_XML_REPORT_HEADER
    E_SECTION_CSS_FILE = _connect.CTestReportConfig_E_SECTION_CSS_FILE
    E_SECTION_IS_EMBED_XML_XSLT_CSS = _connect.CTestReportConfig_E_SECTION_IS_EMBED_XML_XSLT_CSS
    E_SECTION_IS_CREATE_HTML = _connect.CTestReportConfig_E_SECTION_IS_CREATE_HTML
    E_SECTION_CSV_SEPARATOR = _connect.CTestReportConfig_E_SECTION_CSV_SEPARATOR
    E_SECTION_CSV_IS_HEADER_LINE = _connect.CTestReportConfig_E_SECTION_CSV_IS_HEADER_LINE
    E_SECTION_XLS_IS_VERTICAL_HEADER = _connect.CTestReportConfig_E_SECTION_XLS_IS_VERTICAL_HEADER
    E_SECTION_IS_INCLUDE_TEST_SPEC = _connect.CTestReportConfig_E_SECTION_IS_INCLUDE_TEST_SPEC
    E_SECTION_IS_ABS_PATHS_FOR_LINK_TYPO = _connect.CTestReportConfig_E_SECTION_IS_ABS_PATHS_FOR_LINK_TYPO
    E_SECTION_IS_ABS_PATHS_FOR_LINK = _connect.CTestReportConfig_E_SECTION_IS_ABS_PATHS_FOR_LINK
    E_SECTION_HTML_VIEW_MODE = _connect.CTestReportConfig_E_SECTION_HTML_VIEW_MODE
    E_SECTION_TEST_INFO = _connect.CTestReportConfig_E_SECTION_TEST_INFO
    E_SECTION_IS_USE_CUSTOM_TIME = _connect.CTestReportConfig_E_SECTION_IS_USE_CUSTOM_TIME

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new instance with NULL parent.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class. Used
            only when parsing YAML declaration. Can be specified as
            NULL if the object is not initialized by parser.
        """
        _connect.CTestReportConfig_swiginit(self, _connect.new_CTestReportConfig(*args))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestReportConfig_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestReportConfig":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestReportConfig_cast(testBase)

    def getReportContents(self) -> "isys::CTestReportConfig::EReportContents":
        r""" Returns the type of contents in the report."""
        return _connect.CTestReportConfig_getReportContents(self)

    def getTestIDEAVersion(self) -> "std::string":
        r""" Returns version of testIDEA used for running tests as set by client."""
        return _connect.CTestReportConfig_getTestIDEAVersion(self)

    def getWinIDEAVersion(self) -> "std::string":
        return _connect.CTestReportConfig_getWinIDEAVersion(self)

    def getOutputFormat(self) -> "isys::CTestReportConfig::EOutputFormat":
        r""" Returns the output format of the report."""
        return _connect.CTestReportConfig_getOutputFormat(self)

    def getFileName(self) -> "std::string":
        r""" Returns the name of the file to save report to."""
        return _connect.CTestReportConfig_getFileName(self)

    def getIYamlFileName(self) -> "std::string":
        r""" Returns name of iyaml file, which was used to generate this report."""
        return _connect.CTestReportConfig_getIYamlFileName(self)

    def getAbsReportFileName(self) -> "std::string":
        r"""
        Returns the absolute name of the file to save report to. If report file
        name is already an absolute path, it is returned unchanged. If it is
        a relative path, then path of iyaml file is added to it.
        """
        return _connect.CTestReportConfig_getAbsReportFileName(self)

    def getXsltForFullReport(self) -> "std::string":
        r""" Returns the name of the file to use as XML Stylesheet for the full report."""
        return _connect.CTestReportConfig_getXsltForFullReport(self)

    def getXsltForErrors(self) -> "std::string":
        r"""
        Deprecated: only one xslt may be specified, call getXsltForFullReport().
        Returns the name of the file to use as XML Stylesheet for report, which contains errors only.
        """
        return _connect.CTestReportConfig_getXsltForErrors(self)

    def getLogoImageFileName(self) -> "std::string":
        r""" Returns file name for logo image in report."""
        return _connect.CTestReportConfig_getLogoImageFileName(self)

    def getCssFile(self) -> "std::string":
        r""" Returns the name of the file to use as CSS for report."""
        return _connect.CTestReportConfig_getCssFile(self)

    def isEmbedXsltCss(self) -> "bool":
        r""" Returns true, if XSLT and CSS files should be embedded into XML report."""
        return _connect.CTestReportConfig_isEmbedXsltCss(self)

    def isCreateHtml(self) -> "bool":
        r"""
        Returns true, if HTML file should also be created by processing created XML and XSLT.
        Has effect only if report is generated in XML format.
        """
        return _connect.CTestReportConfig_isCreateHtml(self)

    def getSelectedXsltFileName(self) -> "std::string":
        r"""
        Returns XSLT file name for full report or for errors only
        report, depending on the value of output format.
        """
        return _connect.CTestReportConfig_getSelectedXsltFileName(self)

    def getCSVSeparator(self) -> "std::string":
        r""" Returns separator to be used in CSV report files."""
        return _connect.CTestReportConfig_getCSVSeparator(self)

    def isCSVHeaderLine(self) -> "bool":
        r""" Returns true, if header line in CSV report format should contain names of columns."""
        return _connect.CTestReportConfig_isCSVHeaderLine(self)

    def isXLSVerticalHeader(self) -> "bool":
        r""" Returns true, if column headers in XLS tables should be written vertically."""
        return _connect.CTestReportConfig_isXLSVerticalHeader(self)

    def isIncludeTestSpec(self) -> "bool":
        r""" Returns true, is test specification should be included into test report."""
        return _connect.CTestReportConfig_isIncludeTestSpec(self)

    def isAbsPathForLinks(self) -> "bool":
        r"""
        If true is returned, then links in report (for example to export files)
        will be written with absolute path.
        """
        return _connect.CTestReportConfig_isAbsPathForLinks(self)

    def getUserInfo(self, userInfoMap: "StrStrMap") -> "void":
        r"""
        Returns a map of key-value pairs to be stored into report,
        for example HW used for testing.
        """
        return _connect.CTestReportConfig_getUserInfo(self, userInfoMap)

    def hasUserInfo(self, key: "std::string const &") -> "bool":
        r"""
        Returns true, if a user info for the given key exists in mapping.

        :type key: string
        :param key: mapping key.
        """
        return _connect.CTestReportConfig_hasUserInfo(self, key)

    def getXmlReportHeader(self) -> "std::string":
        r"""Returns XML report header."""
        return _connect.CTestReportConfig_getXmlReportHeader(self)

    def getWarnings(self) -> "std::string":
        r"""
        If there were any warnings detected during parsing, this method returns
        non-empty string with description of warnings. It is recommended to
        call this method always after parsing.

        See also: CTestBench::getWarnings()
        """
        return _connect.CTestReportConfig_getWarnings(self)

    def setReportContents(self, reportContents: "isys::CTestReportConfig::EReportContents") -> "void":
        r""" Sets the type of information to be stored in the report."""
        return _connect.CTestReportConfig_setReportContents(self, reportContents)

    def setTestIDEAVersion(self, testIDEAVersion: "std::string const &") -> "void":
        r""" Sets version of testIDEA used for running tests."""
        return _connect.CTestReportConfig_setTestIDEAVersion(self, testIDEAVersion)

    def setWinIDEAVersion(self, winIDEAVersion: "std::string const &") -> "void":
        return _connect.CTestReportConfig_setWinIDEAVersion(self, winIDEAVersion)

    def setOutputFormat(self, outFormat: "isys::CTestReportConfig::EOutputFormat") -> "void":
        r""" Sets report output format."""
        return _connect.CTestReportConfig_setOutputFormat(self, outFormat)

    def setFileName(self, fileName: "std::string const &") -> "void":
        r""" Sets the name of the report file."""
        return _connect.CTestReportConfig_setFileName(self, fileName)

    def setIYamlFileName(self, fileName: "std::string const &") -> "void":
        r""" Sets the name of the iyaml file, which generated this report."""
        return _connect.CTestReportConfig_setIYamlFileName(self, fileName)

    def setXsltForFullReport(self, xsltFileName: "std::string const &") -> "void":
        r""" Sets file name for XSLT for full reports."""
        return _connect.CTestReportConfig_setXsltForFullReport(self, xsltFileName)

    def setXsltForErrors(self, xsltFileName: "std::string const &") -> "void":
        r""" Sets file name for XSLT for reports, which contains errors only."""
        return _connect.CTestReportConfig_setXsltForErrors(self, xsltFileName)

    def setLogoImageFileName(self, logoImageFileName: "std::string const &") -> "void":
        r""" Returns file name for logo image in report."""
        return _connect.CTestReportConfig_setLogoImageFileName(self, logoImageFileName)

    def setCssFile(self, cssFileName: "std::string const &") -> "void":
        r""" Sets file to be used as a style-sheet for HTML rendering."""
        return _connect.CTestReportConfig_setCssFile(self, cssFileName)

    def setCsvSeparator(self, csvSeparator: "std::string const &") -> "void":
        r""" Sets CSV separator."""
        return _connect.CTestReportConfig_setCsvSeparator(self, csvSeparator)

    def setCsvHeaderLine(self, isCsvHeaderLine: "bool") -> "void":
        r"""
        If ``isCsvHeaderLine`` is set to ``true``, then header line with
        names of columns is added to CSV test report file.
        """
        return _connect.CTestReportConfig_setCsvHeaderLine(self, isCsvHeaderLine)

    def setXLSVerticalHeader(self, isXLSVerticalHeader: "bool") -> "void":
        r""" Sets XLS columns headers orientation."""
        return _connect.CTestReportConfig_setXLSVerticalHeader(self, isXLSVerticalHeader)

    def setIncludeTestSpec(self, isIncTestSpec: "bool") -> "void":
        r""" Sets flag ."""
        return _connect.CTestReportConfig_setIncludeTestSpec(self, isIncTestSpec)

    def setXmlReportHeader(self, header: "std::string const &") -> "void":
        r"""Sets header for XML reports."""
        return _connect.CTestReportConfig_setXmlReportHeader(self, header)

    def setUserInfo(self, yamlSpec: "std::string const &") -> "void":
        r"""
        Deprecated: (dec 2015) set/clear tags in user info with
        value ${_time} and ${_date} instead

        Sets flag for writing custom time into the report.

        :param isUseCurrentTime: if ``false``, then date/time of test execution will
            be automatically added to test report. If ``true``, then caller can
            define test execution time with call to addUserInfo().
                  Sets mapping of user info, given in yaml format.
        """
        return _connect.CTestReportConfig_setUserInfo(self, yamlSpec)

    def clearDynamicUserItems(self) -> "void":
        r"""
        Removes all items with key prefix '_'. These items are normally
        added by script called before report is saved, and are not supposed
        to be saved to iyaml file, for example subversion revision number
        of sources tested. It is up to user which items assigned by script
        should be preserved between sessions and saved to yaml file, and
        which not. The user defines this behavior by using prefix '_'
        """
        return _connect.CTestReportConfig_clearDynamicUserItems(self)

    def setAbsPathForLinks(self, iaAbsPathsForLinks: "bool") -> "void":
        r"""
        If set to true, then links in report (for example to export files)
        will be written with absolute path.
        """
        return _connect.CTestReportConfig_setAbsPathForLinks(self, iaAbsPathsForLinks)

    def addUserInfo(self, key: "std::string const &", value: "std::string const &") -> "void":
        r"""
         Adds key/value pair to user info.

        :type key: string
        :param key: must be alphanumeric string
        :type value: string
        :param value: any string
        """
        return _connect.CTestReportConfig_addUserInfo(self, key, value)
    __swig_destroy__ = _connect.delete_CTestReportConfig

# Register CTestReportConfig in _connect:
_connect.CTestReportConfig_swigregister(CTestReportConfig)
BUILT_IN_XSLT_PREFIX = cvar.BUILT_IN_XSLT_PREFIX
DEFAULT_XSLT_NAME = cvar.DEFAULT_XSLT_NAME
DEFAULT_CSS_NAME = cvar.DEFAULT_CSS_NAME
CVRG_TO_COBERTURA_XSLT_FNAME = cvar.CVRG_TO_COBERTURA_XSLT_FNAME

def CTestReportConfig_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestReportConfig":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestReportConfig_cast(testBase)

class CTestReportContainer(object):
    r"""
    This class contains test results in ordered map, which means
    that insertion order is preserved.

    createTestReport.py Python example. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CTestReportContainer_swiginit(self, _connect.new_CTestReportContainer())

    def assign(self, src: "isys::CTestReportContainerSPtr const &") -> "void":
        return _connect.CTestReportContainer_assign(self, src)

    def clearResults(self) -> "void":
        r""" Clears all stored test results."""
        return _connect.CTestReportContainer_clearResults(self)

    def putTestResult(self, testSpec: "isys::CTestTreeNodeSPtr const &", result: "isys::CTestResultBaseSPtr const &") -> "void":
        r""" Saves test result for the given test case."""
        return _connect.CTestReportContainer_putTestResult(self, testSpec, result)

    def getNoOfTestResults(self) -> "int":
        r""" Returns the number of test results stored in this container."""
        return _connect.CTestReportContainer_getNoOfTestResults(self)

    def resetTestResultIterator(self) -> "void":
        r""" Resets test result iterator."""
        return _connect.CTestReportContainer_resetTestResultIterator(self)

    def hasNextTestResult(self) -> "bool":
        r""" Returns true, if internal iterator has not reached the last test result yet."""
        return _connect.CTestReportContainer_hasNextTestResult(self)

    def nextTestResult(self) -> "CTestResult":
        r""" Returns the next test result in container."""
        return _connect.CTestReportContainer_nextTestResult(self)

    def getTestResult(self, testSpec: "isys::CTestTreeNodeSPtr const &") -> "CTestResult":
        r""" Returns test result for the given test case."""
        return _connect.CTestReportContainer_getTestResult(self, testSpec)

    def getNoOfTestGroupResults(self) -> "int":
        r""" Returns the number of test group results stored in this container."""
        return _connect.CTestReportContainer_getNoOfTestGroupResults(self)

    def resetGroupResultIterator(self) -> "void":
        r""" Resets test group result iterator."""
        return _connect.CTestReportContainer_resetGroupResultIterator(self)

    def hasNextGroupResult(self) -> "bool":
        r""" Returns true, if internal iterator has not reached the last test group result yet."""
        return _connect.CTestReportContainer_hasNextGroupResult(self)

    def nextGroupResult(self) -> "CTestGroupResult":
        r""" Returns the next test group result in container."""
        return _connect.CTestReportContainer_nextGroupResult(self)

    def getGroupResult(self, testGroup: "isys::CTestTreeNodeSPtr const &") -> "CTestGroupResult":
        r""" Returns test group result for the given test group."""
        return _connect.CTestReportContainer_getGroupResult(self, testGroup)

    def createGroupResults(self, mcmgr: "isys::CMulticoreConnectionMgrSPtr const &", filterCtrl: "isys::CTestFilterControllerSPtr const &", hostVars: "isys::CTestHostVarsSPtr const &", group: "isys::CTestGroupSPtr const &") -> "void":
        r""" Creates group results."""
        return _connect.CTestReportContainer_createGroupResults(self, mcmgr, filterCtrl, hostVars, group)

    def toString(self) -> "std::string":
        return _connect.CTestReportContainer_toString(self)
    __swig_destroy__ = _connect.delete_CTestReportContainer

# Register CTestReportContainer in _connect:
_connect.CTestReportContainer_swigregister(CTestReportContainer)

class CTestReportStatistic(object):
    r"""This class calculates and stores statistics for test results."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CTestReportStatistic_swiginit(self, _connect.new_CTestReportStatistic())

    def analyzeResult(self, testResult: "isys::CTestResultSPtr const &") -> "void":
        r"""
        Call this method with all instances of CTestResult produced during
        test run.
        """
        return _connect.CTestReportStatistic_analyzeResult(self, testResult)

    def getErrors(self) -> "int32_t":
        r"""
        Returns the number of test cases that did not execute because of an
        error in test. For example: function name is misspelled, wrong
        parameter type, timeout occurred, ...
        """
        return _connect.CTestReportStatistic_getErrors(self)

    def getFailures(self) -> "int32_t":
        r"""
        Returns the number of tests, that executed, but their results
        do not match expected ones.
        """
        return _connect.CTestReportStatistic_getFailures(self)

    def serialize(self, emitter: "isys::IEmitterSPtr const &") -> "void":
        r""" Writes collected data to the given emitter."""
        return _connect.CTestReportStatistic_serialize(self, emitter)
    __swig_destroy__ = _connect.delete_CTestReportStatistic

# Register CTestReportStatistic in _connect:
_connect.CTestReportStatistic_swigregister(CTestReportStatistic)

class CTestFunction(CTestBase):
    r"""
    This class encapsulates information required
    for function call, such as function name and
    parameters. Parameters can be specified either as named
    parameters, or position parameters. Named parameters are stored
    in map as [parameter name, parameter value] pairs, while
    position parameters are stored in vector as a list of
    values. Only one of these two groups of parameters
    may be specified in one specification.

    Default copy ctor may be used.



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_FUNC_NAME = _connect.CTestFunction_E_SECTION_FUNC_NAME
    E_SECTION_PARAMS = _connect.CTestFunction_E_SECTION_PARAMS
    E_SECTION_RET_VAL_NAME = _connect.CTestFunction_E_SECTION_RET_VAL_NAME

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Initializes new instance.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestBase class. May
            be specified as NULL if the object is not initialized by parser.
        """
        _connect.CTestFunction_swiginit(self, _connect.new_CTestFunction(*args))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestFunction_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestFunction":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestFunction_cast(testBase)

    def assign(self, src: "isys::CTestObjectSPtr const &") -> "void":
        return _connect.CTestFunction_assign(self, src)

    def assignYAMLStyle(self, testFunc: "isys::CTestFunctionSPtr &") -> "void":
        return _connect.CTestFunction_assignYAMLStyle(self, testFunc)

    def getName(self) -> "std::string":
        r"""Returns name of the function to be executed."""
        return _connect.CTestFunction_getName(self)

    def hasPositionParams(self) -> "bool":
        r""" Returns true, if function has parameters specified."""
        return _connect.CTestFunction_hasPositionParams(self)

    def getPositionParams(self, positionParams: "StrVector") -> "void":
        r"""
        The given vector is filled with values of positional parameters.

        :type positionParams: :py:class:`StrVector`
        :param positionParams: vector to receive parameters
        """
        return _connect.CTestFunction_getPositionParams(self, positionParams)

    def getRetValueName(self) -> "std::string":
        r"""
        Returns the name of the variable, which will be used to store the
          function return value.
        """
        return _connect.CTestFunction_getRetValueName(self)

    def isSerializedAsList(self, isParsing: "bool") -> "bool":
        return _connect.CTestFunction_isSerializedAsList(self, isParsing)

    def setName(self, functionName: "std::string const &") -> "void":
        r""" Sets function name."""
        return _connect.CTestFunction_setName(self, functionName)

    def setPositionParameters(self, parameters: "StrVector") -> "void":
        r"""
        Sets positional parameters.

        :type parameters: :py:class:`StrVector`
        :param parameters:

        See also: getNamedParameters()
        """
        return _connect.CTestFunction_setPositionParameters(self, parameters)

    def setRetValueName(self, retValName: "std::string const &") -> "void":
        r"""
         Sets return value name.
        See also: getRetValueName
        """
        return _connect.CTestFunction_setRetValueName(self, retValName)
    __swig_destroy__ = _connect.delete_CTestFunction

# Register CTestFunction in _connect:
_connect.CTestFunction_swigregister(CTestFunction)

def CTestFunction_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestFunction":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestFunction_cast(testBase)

class CTestAssert(CTestBase):
    r"""This class defines assertions for test result."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_ASSERT_IS_EXPECT_EXCEPTION = _connect.CTestAssert_E_SECTION_ASSERT_IS_EXPECT_EXCEPTION
    E_SECTION_ASSERT_EXPRESSIONS = _connect.CTestAssert_E_SECTION_ASSERT_EXPRESSIONS

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new instance.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class.
        """
        _connect.CTestAssert_swiginit(self, _connect.new_CTestAssert(*args))
    __swig_destroy__ = _connect.delete_CTestAssert

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestAssert_createInstance(self, parent)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestAssert_isMerged(self)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestAssert":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestAssert_cast(testBase)

    def isExpectException(self) -> "iconnect::ETristate":
        r"""
        Returns true, if exception is expected to be thrown from function under test.
        Throws exception if this class is used to store test pre-condition.
        """
        return _connect.CTestAssert_isExpectException(self)

    def setExpectException(self, isExpectException: "iconnect::ETristate") -> "void":
        r"""
        Sets whether exception is expected as test result.
        Throws exception if this class is used to store test pre-condition.
        """
        return _connect.CTestAssert_setExpectException(self, isExpectException)

    def getExpressions(self, expressions: "StrVector") -> "void":
        r"""
        Returns expressions, which are expected to evaluate to
        **true** after test ends.
        """
        return _connect.CTestAssert_getExpressions(self, expressions)

    def setExpressions(self, expressions: "StrVector") -> "void":
        r"""
        Sets expressions, which are expected to evaluate to
        **true** after test ends.
        """
        return _connect.CTestAssert_setExpressions(self, expressions)

# Register CTestAssert in _connect:
_connect.CTestAssert_swigregister(CTestAssert)

def CTestAssert_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestAssert":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestAssert_cast(testBase)

class CTestCase(object):
    r"""
    This class is the main class of the ``isystem.test
    `` framework. It connects together classes with test
    specification and target controllers by providing methods for test
    execution.


    Methods is itestCpp(), and runTest() execute test
    case, while method getTestResults() returns result.


    **Note:** Wrappers for other languages, for example Python and Java, contain
    their replacement of this class.



    itestSample.py Python example for class PTestCase, which replaces this class in Python. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes object with the given connection to winIDEA,
        and host variables.

        |

        *Overload 2:*

        Deprecated: use CTestCase(ConnectionMgrSPtr, CTestHostVarsSPtr) instead
        Initializes object with the given connection to winIDEA.
        """
        _connect.CTestCase_swiginit(self, _connect.new_CTestCase(*args))
    __swig_destroy__ = _connect.delete_CTestCase

    def getTestResults(self, *args) -> "CTestResult":
        r"""
        *Overload 1:*

        This method returns test result based on data stored internally in this class,
        including test specification.

        |

        *Overload 2:*

        **Deprecated.**
        Deprecated: call getTestResults() without parameter instead

        This method returns test result based on data stored internally in this class,
        including test specification.
        """
        return _connect.CTestCase_getTestResults(self, *args)

    def itestCpp(self, *args) -> "void":
        r"""
        *Overload 1:*

        This method parses test specification given in YAML format, and then calls
        method runTest().

        See also: runTest()

        :type yamlSpec: string
        :param yamlSpec: test specification in YAML format. See
                            User's guide for details.

        :type isDebug: boolean, optional
        :param isDebug: if true, then test is not reset in case of error.
                           If execution stops at user breakpoint, it is then
                           possible to check variables and step through the code.

        |

        *Overload 2:*

        **Deprecated.**
        Deprecated: use itestCpp(yamlSpec, isDebug) instead.

        Return parameter differences contains only the most basic test
        results. Call getTestResult() to get complete information, including
        expression differences.

        :type differences: :py:class:`StrVector`
        :param differences: after return this vector contains a
                               human readable evaluations of expressions from
                               section assert, which evaluated to false, and
                               values of variables used in the expressions.

        |

        *Overload 3:*

        **Deprecated.**
        Deprecated: use itestCpp(yamlSpec, isDebug) instead.

        Return parameter differences contains only the most basic test
        results. Call getTestResult() to get complete information, including
        expression differences.

        :type differences: :py:class:`StrVector`
        :param differences: after return this vector contains a
                               human readable evaluations of expressions from
                               section assert, which evaluated to false, and
                               values of variables used in the expressions.
        """
        return _connect.CTestCase_itestCpp(self, *args)

    def runTest(self, *args) -> "void":
        r"""
        *Overload 1:*

        Runs single test specification. It sets the environment on the target, calls the
        function to be tested, handles stubs, and finally verifies
        the result. Because of callbacks for ``init, end,
        `` and ``stub`` function, it can be used only
        if callbacks are implemented in C++. If any of these
        methods is specified in test specification (tags
        ``initFunc, endFunc, stub [func]``), method
        setCallbackObject() must be called
        with non-NULL argument before this method.

        :type testSpec: :py:class:`CTestSpecification`
        :param testSpec: test specification to be executed

        :type testTimeout: int
        :param testTimeout: test execution timeout in milliseconds. Value 0
                               means infinite timeout.

        :type isDebug: boolean
        :param isDebug: if true, then test is not reset in case of error.
                           If execution stops at user breakpoint, it is then
                           possible to check variables and step through the code.

        :type testFilter: :py:class:`CTestFilter`
        :param testFilter: if not empty, test specification must match the
                              condition specified by the filter to be executed. If
                              empty, no filtering is performed and test spec is executed
                              if not empty or abstract. Empty filter can be created with
                              default ctor CTestFilter().
                              Note: Partition and module are not used for filtering. Call
                              overload with CTestFilterController for complete filtering.

        |

        *Overload 2:*

        Runs single test specification. It sets the environment on the target, calls the
        function to be tested, handles stubs, and finally verifies
        the result. Because of callbacks for ``init, end,
        `` and ``stub`` function, it can be used only
        if callbacks are implemented in C++. If any of these
        methods is specified in test specification (tags
        ``initFunc, endFunc, stub [func]``), method
        setCallbackObject() must be called
        with non-NULL argument before this method.

        Call getTestResults() after this method returns to get test results.

        :type testSpec: :py:class:`CTestSpecification`
        :param testSpec: test specification to be executed

        :type testTimeout: int
        :param testTimeout: test execution timeout in milliseconds. Value 0
                               means infinite timeout.

        :type isDebug: boolean
        :param isDebug: if true, then test is not reset in case of error.
                           If execution stops at user breakpoint, it is then
                           possible to check variables and step through the code.

        :type testFilter: :py:class:`CTestFilter`
        :param testFilter: if not empty, test specification must match the
                              condition specified by the filter to be executed. If
                              empty, no filtering is performed and test spec is executed
                              if not empty or abstract. Empty filter can be created with
                              default ctor CTestFilter().
        :type filterCtrl: :py:class:`CTestFilterController`
        :param filterCtrl: class used for performing filtering. If null, no filtering
                              is performed.

        |

        *Overload 3:*

        **Deprecated.**
        Deprecated: use runTest(testCase, testTimeout, isDebug, testFilter, filterCtrl) instead,
                    create empty instance of testFilter with default ctor. CTestFilter().

        Calls runTest()  with empty test filter, which means the
        given test specification is not filtered - if not empty or abstract,
        it is executed.

        |

        *Overload 4:*

        **Deprecated.**
        Deprecated: use runTest(testCase, testTimeout, isDebug, testFilter, filterCtrl) instead,
                    create empty instance of testFilter with default ctor. CTestFilter().

        Calls runTest()  with empty test filter, which means the
        given test specification is not filtered - if not empty or abstract,
        it is executed.

        |

        *Overload 5:*

        **Deprecated.**
        Deprecated: use runTest(testCase, testTimeout, isDebug, testFilter, filterCtrl) instead,
                    create empty instance of testFilter with default ctor. CTestFilter().

        Calls runTest()  with infinite timeout.

        |

        *Overload 6:*

        **Deprecated.**
        Deprecated: use runTest(testCase, testTimeout, isDebug, testFilter, filterCtrl) instead,
                    create empty instance of testFilter with default ctor. CTestFilter().

        Return parameter differences contains only the most basic test
        results. Call getTestResult() to get complete information, including
        expression differences.

        :type differences: :py:class:`StrVector`
        :param differences: after return this vector contains a
                               human readable evaluations of expressions from
                               section assert, which evaluated to false, and
                               values of variables used in the expressions.

        |

        *Overload 7:*

        **Deprecated.**
        Deprecated: use runTest(testCase, testTimeout, isDebug, testFilter, filterCtrl) instead
        """
        return _connect.CTestCase_runTest(self, *args)

    @staticmethod
    def getISystemRetValName() -> "std::string":
        return _connect.CTestCase_getISystemRetValName()

    def runTest_init_target(self, testSpec: "isys::CTestSpecificationSPtr &", isDebug: "bool", isTestBatchOn: "bool") -> "bool":
        return _connect.CTestCase_runTest_init_target(self, testSpec, isDebug, isTestBatchOn)

    def runTest_init_test(self, isInitAnalyzers: "bool", isMeasureStackUsage: "bool", testTimeout: "int") -> "void":
        return _connect.CTestCase_runTest_init_test(self, isInitAnalyzers, isMeasureStackUsage, testTimeout)

    def runTest_exec_begin(self) -> "void":
        return _connect.CTestCase_runTest_exec_begin(self)

    def runTest_exec_loopStart(self, testSpec: "isys::CTestSpecificationSPtr &", isResumeCoverage: "bool", isStubOrTestPoint: "bool") -> "void":
        return _connect.CTestCase_runTest_exec_loopStart(self, testSpec, isResumeCoverage, isStubOrTestPoint)

    def runTest_exec_waitForStop(self, testSpec: "isys::CTestSpecificationSPtr &", unitTestTimeout: "int") -> "bool":
        return _connect.CTestCase_runTest_exec_waitForStop(self, testSpec, unitTestTimeout)

    def runTest_exec_langSpecific(self) -> "bool":
        return _connect.CTestCase_runTest_exec_langSpecific(self)

    def setTargetException(self, isTargetException: "bool") -> "void":
        return _connect.CTestCase_setTargetException(self, isTargetException)

    def runTest_exec_end(self) -> "void":
        return _connect.CTestCase_runTest_exec_end(self)

    def runTest_finalize(self, differences: "StrVector", isDryRun: "bool", analyzerFilesToMerge: "StrVector") -> "void":
        return _connect.CTestCase_runTest_finalize(self, differences, isDryRun, analyzerFilesToMerge)

    def handleException(self) -> "void":
        return _connect.CTestCase_handleException(self)

    def clearTest(self) -> "void":
        return _connect.CTestCase_clearTest(self)

    def stopTest(self) -> "void":
        return _connect.CTestCase_stopTest(self)

    def setStopConditionForSysTest(self, testSpec: "isys::CTestSpecificationSPtr const &") -> "void":
        return _connect.CTestCase_setStopConditionForSysTest(self, testSpec)

    def isSystemTestStopOnBP(self) -> "bool":
        return _connect.CTestCase_isSystemTestStopOnBP(self)

    def setStopConditionBP(self, stopCondition: "isys::CTestStopConditionSPtr &", testPointOrTestCaseId: "std::string const &") -> "void":
        return _connect.CTestCase_setStopConditionBP(self, stopCondition, testPointOrTestCaseId)

    def deleteStopConditionBP(self, stopCondition: "isys::CTestStopConditionSPtr &", testPointOrTestCaseId: "std::string const &") -> "void":
        return _connect.CTestCase_deleteStopConditionBP(self, stopCondition, testPointOrTestCaseId)

    def checkStopConditionStop(self, stopCondition: "isys::CTestStopConditionSPtr &") -> "void":
        return _connect.CTestCase_checkStopConditionStop(self, stopCondition)

    def checkStopConditionExpr(self, stopCondition: "isys::CTestStopConditionSPtr &") -> "void":
        return _connect.CTestCase_checkStopConditionExpr(self, stopCondition)

    def getTestController(self) -> "isys::ITestCaseControllerSPtr":
        return _connect.CTestCase_getTestController(self)

    def getDebugFacade(self) -> "CDebugFacade":
        return _connect.CTestCase_getDebugFacade(self)

    def getHostVars(self) -> "CTestHostVars":
        return _connect.CTestCase_getHostVars(self)

    def callStubs(self, isRunNativeCustomFunc: "bool", scriptParams: "StrVector", tpResult: "isys::CTestPointResultSPtr") -> "CTestStub":
        return _connect.CTestCase_callStubs(self, isRunNativeCustomFunc, scriptParams, tpResult)

    def execTestPointEvalAssign(self, testCaseCtrl: "isys::ITestCaseControllerSPtr", scriptParams: "StrVector", tpResult: "isys::CTestPointResultSPtr &") -> "CTestPoint":
        return _connect.CTestCase_execTestPointEvalAssign(self, testCaseCtrl, scriptParams, tpResult)

    def waitForAnalyzerToDownloadData(self, timeout: "int"=0) -> "void":
        return _connect.CTestCase_waitForAnalyzerToDownloadData(self, timeout)

    def logStatus(self, testCaseCtrl: "isys::ITestCaseControllerSPtr", logConfig: "isys::CTestLogSPtr &", section: "int", logResult: "isys::CLogResultSPtr &") -> "void":
        return _connect.CTestCase_logStatus(self, testCaseCtrl, logConfig, section, logResult)

    def replaceHostVariables(self, expression: "std::string const &") -> "std::string":
        return _connect.CTestCase_replaceHostVariables(self, expression)

    def runUntilStopPoint(self, stopCondition: "isys::CTestStopConditionSPtr const &", testPointOrTestCaseId: "std::string const &") -> "void":
        return _connect.CTestCase_runUntilStopPoint(self, stopCondition, testPointOrTestCaseId)

    @staticmethod
    def applyDryRun(testSpec: "isys::CTestSpecificationSPtr &", mergedTestSpec: "isys::CTestSpecificationSPtr &", result: "isys::CTestResultSPtr &") -> "bool":
        return _connect.CTestCase_applyDryRun(testSpec, mergedTestSpec, result)

    def setEnableStub(self, testSpec: "isys::CTestSpecificationSPtr &", stubbedFunction: "std::string const &", isEnabled: "bool") -> "void":
        return _connect.CTestCase_setEnableStub(self, testSpec, stubbedFunction, isEnabled)

    def setEnableTestPoint(self, testSpec: "isys::CTestSpecificationSPtr &", tpId: "std::string const &", isEnabled: "bool") -> "void":
        return _connect.CTestCase_setEnableTestPoint(self, testSpec, tpId, isEnabled)

    def deletePersistentVars(self, persistentVars: "isys::CTestPersistentVarsSPtr") -> "void":
        return _connect.CTestCase_deletePersistentVars(self, persistentVars)

# Register CTestCase in _connect:
_connect.CTestCase_swigregister(CTestCase)

def CTestCase_getISystemRetValName() -> "std::string":
    return _connect.CTestCase_getISystemRetValName()

def CTestCase_applyDryRun(testSpec: "isys::CTestSpecificationSPtr &", mergedTestSpec: "isys::CTestSpecificationSPtr &", result: "isys::CTestResultSPtr &") -> "bool":
    return _connect.CTestCase_applyDryRun(testSpec, mergedTestSpec, result)

class CTestAnalyzer(CTestBase):
    r"""
    This class contains specification for analyzer document.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    M_OFF = _connect.CTestAnalyzer_M_OFF
    r""" analyzer will not be configured or started"""
    M_START = _connect.CTestAnalyzer_M_START
    r""" start analyzer"""
    EUpdate = _connect.CTestAnalyzer_EUpdate
    r"""
    When document is opened, data is not erased.
    The document must exist.
    """
    EWrite = _connect.CTestAnalyzer_EWrite
    r"""
    When document is opened, data is erased,
    configuration is kept. If the doc. does not
    exist, it is created.
    """
    EAppend = _connect.CTestAnalyzer_EAppend
    r"""
    When document is opened, data is preserved,
    start will append new recording to existing
    data. Currently available only for coverage,
    and only when profiler analysis is not performed.
    """
    E_SECTION_RUN_MODE = _connect.CTestAnalyzer_E_SECTION_RUN_MODE
    E_SECTION_DOC_FILE_NAME = _connect.CTestAnalyzer_E_SECTION_DOC_FILE_NAME
    E_SECTION_OPEN_MODE = _connect.CTestAnalyzer_E_SECTION_OPEN_MODE
    E_SECTION_IS_SLOW_RUN = _connect.CTestAnalyzer_E_SECTION_IS_SLOW_RUN
    E_SECTION_TRIGGER = _connect.CTestAnalyzer_E_SECTION_TRIGGER
    E_SECTION_IS_PREDEF_TRIGGER = _connect.CTestAnalyzer_E_SECTION_IS_PREDEF_TRIGGER
    E_SECTION_IS_SAVE_AFTER_TEST = _connect.CTestAnalyzer_E_SECTION_IS_SAVE_AFTER_TEST
    E_SECTION_IS_CLOSE_AFTER_TEST = _connect.CTestAnalyzer_E_SECTION_IS_CLOSE_AFTER_TEST
    E_SECTION_TRACE = _connect.CTestAnalyzer_E_SECTION_TRACE
    E_SECTION_COVERAGE = _connect.CTestAnalyzer_E_SECTION_COVERAGE
    E_SECTION_PROFILER = _connect.CTestAnalyzer_E_SECTION_PROFILER

    def __init__(self, parent: "isys::CTestBaseSPtr const &"):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class. Used
                          only when parsing YAML declaration. Can be
                          specified as NULL if the object is not
                          initialized by parser.
        """
        _connect.CTestAnalyzer_swiginit(self, _connect.new_CTestAnalyzer(parent))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestAnalyzer_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestAnalyzer":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestAnalyzer_cast(testBase)

    def getRunMode(self) -> "isys::CTestAnalyzer::ERunMode":
        r""" Returns run mode."""
        return _connect.CTestAnalyzer_getRunMode(self)

    def isPredefinedTrigger(self) -> "iconnect::ETristate":
        r"""
        Returns E_TRUE, if existing trigger from trd file should be used.
        testIDEA does not modify trigger settings in such case.
        """
        return _connect.CTestAnalyzer_isPredefinedTrigger(self)

    def isSlowRun(self) -> "iconnect::ETristate":
        r""" Returns E_TRUE, if slow run should be used for analyzer."""
        return _connect.CTestAnalyzer_isSlowRun(self)

    def getDocumentFileName(self) -> "std::string":
        r""" Returns name of the document to contain trace results."""
        return _connect.CTestAnalyzer_getDocumentFileName(self)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestAnalyzer_isMerged(self)

    def getOpenMode(self) -> "isys::CTestAnalyzer::EOpenMode":
        r"""Returns open mode."""
        return _connect.CTestAnalyzer_getOpenMode(self)

    def getTriggerName(self) -> "std::string":
        r"""
        Returns the name of the trigger to be used for trace
        start. The trigger should be defined in winIDEA GUI.
        """
        return _connect.CTestAnalyzer_getTriggerName(self)

    def isSaveAfterTest(self) -> "iconnect::ETristate":
        r""" Returns true, if the document should be saved after test."""
        return _connect.CTestAnalyzer_isSaveAfterTest(self)

    def isCloseAfterTest(self) -> "iconnect::ETristate":
        r""" Returns true, if the document should be closed after test."""
        return _connect.CTestAnalyzer_isCloseAfterTest(self)

    def getTrace(self, isConst: "bool") -> "CTestAnalyzerTrace":
        r""" Returns trace configuration."""
        return _connect.CTestAnalyzer_getTrace(self, isConst)

    def getCoverage(self, isConst: "bool") -> "CTestAnalyzerCoverage":
        r""" Returns coverage configuration."""
        return _connect.CTestAnalyzer_getCoverage(self, isConst)

    def getProfiler(self, isConst: "bool") -> "CTestAnalyzerProfiler":
        r""" Returns profiler configuration."""
        return _connect.CTestAnalyzer_getProfiler(self, isConst)

    def setPredefinedTrigger(self, isPredefinedTrigger: "iconnect::ETristate") -> "void":
        r"""
        If isPredefinedTrigger == E_TRUE, then analyzer trigger is
        not modified by testIDEA. User has to define it in trd file in advance.
        """
        return _connect.CTestAnalyzer_setPredefinedTrigger(self, isPredefinedTrigger)

    def setRunMode(self, mode: "isys::CTestAnalyzer::ERunMode") -> "void":
        r"""Sets run mode."""
        return _connect.CTestAnalyzer_setRunMode(self, mode)

    def setSlowRun(self, isSlowRun: "iconnect::ETristate") -> "void":
        r"""If parameter is ``true``, then slow run is used for analyzer."""
        return _connect.CTestAnalyzer_setSlowRun(self, isSlowRun)

    def setDocumentFileName(self, docFileName: "std::string const &") -> "void":
        r""" Sets the name of the trace document."""
        return _connect.CTestAnalyzer_setDocumentFileName(self, docFileName)

    def setOpenMode(self, openMode: "isys::CTestAnalyzer::EOpenMode") -> "void":
        r"""Sets open mode for document."""
        return _connect.CTestAnalyzer_setOpenMode(self, openMode)

    def setTriggerName(self, triggerName: "std::string const &") -> "void":
        r"""
        Sets name of the trigger to be used for trace start. The trigger
        must be defined in winIDEA GUI.
        """
        return _connect.CTestAnalyzer_setTriggerName(self, triggerName)

    def setSaveAfterTest(self, isSave: "iconnect::ETristate") -> "void":
        r""" Sets save operation for trace document after test."""
        return _connect.CTestAnalyzer_setSaveAfterTest(self, isSave)

    def setCloseAfterTest(self, isClose: "iconnect::ETristate") -> "void":
        r""" Sets close  operation for trace document after test."""
        return _connect.CTestAnalyzer_setCloseAfterTest(self, isClose)
    __swig_destroy__ = _connect.delete_CTestAnalyzer

# Register CTestAnalyzer in _connect:
_connect.CTestAnalyzer_swigregister(CTestAnalyzer)

def CTestAnalyzer_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestAnalyzer":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestAnalyzer_cast(testBase)

class CTestAnalyzerTrace(CTestBase):
    r"""
    This class contains specification for trace recording during
    test execution.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EX_TrcAsText = _connect.CTestAnalyzerTrace_EX_TrcAsText
    EX_TrcAsCSV = _connect.CTestAnalyzerTrace_EX_TrcAsCSV
    EX_TrcAsBinary = _connect.CTestAnalyzerTrace_EX_TrcAsBinary
    EX_TrcAsXML = _connect.CTestAnalyzerTrace_EX_TrcAsXML
    E_SECTION_IS_ACTIVE = _connect.CTestAnalyzerTrace_E_SECTION_IS_ACTIVE
    E_SECTION_EXPORT_FORMAT = _connect.CTestAnalyzerTrace_E_SECTION_EXPORT_FORMAT
    E_SECTION_EXPORT_FILE = _connect.CTestAnalyzerTrace_E_SECTION_EXPORT_FILE

    def __init__(self, parent: "isys::CTestBaseSPtr const &"):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class. Used
                          only when parsing YAML declaration. Can be
                          specified as NULL if the object is not
                          initialized by parser.
        """
        _connect.CTestAnalyzerTrace_swiginit(self, _connect.new_CTestAnalyzerTrace(parent))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestAnalyzerTrace_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestAnalyzerTrace":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestAnalyzerTrace_cast(testBase)

    def isMerged(self) -> "bool":
        return _connect.CTestAnalyzerTrace_isMerged(self)

    def isActive(self) -> "iconnect::ETristate":
        r"""
        Returns E_TRUE if this section is active (export is performed,
        and analysis is run for coverage and profiler).
        """
        return _connect.CTestAnalyzerTrace_isActive(self)

    def getExportFormat(self) -> "isys::CTestAnalyzerTrace::ETraceExportFormat":
        r""" Returns the export format type. See CAnalyzerDocController for possible values."""
        return _connect.CTestAnalyzerTrace_getExportFormat(self)

    def getExportFileName(self) -> "std::string":
        r""" Returns the export file name."""
        return _connect.CTestAnalyzerTrace_getExportFileName(self)

    def setActive(self, isActive: "iconnect::ETristate") -> "void":
        r"""
        If ``isActive`` == ``true``, recording is exported and
        analysis is performed.
        """
        return _connect.CTestAnalyzerTrace_setActive(self, isActive)

    def setExportFormat(self, exportFormat: "isys::CTestAnalyzerTrace::ETraceExportFormat") -> "void":
        r"""
        Sets export format for the trace document. See CAnalyzerDocController
        for possible values.
        """
        return _connect.CTestAnalyzerTrace_setExportFormat(self, exportFormat)

    def setExportFileName(self, exportFileName: "std::string const &") -> "void":
        r""" Sets the export file name."""
        return _connect.CTestAnalyzerTrace_setExportFileName(self, exportFileName)
    __swig_destroy__ = _connect.delete_CTestAnalyzerTrace

# Register CTestAnalyzerTrace in _connect:
_connect.CTestAnalyzerTrace_swigregister(CTestAnalyzerTrace)

def CTestAnalyzerTrace_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestAnalyzerTrace":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestAnalyzerTrace_cast(testBase)

class CTestAnalyzerCoverage(CTestBase):
    r"""
    This class contains specification for coverage recording during
    test execution.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EX_CCAsHTML = _connect.CTestAnalyzerCoverage_EX_CCAsHTML
    EX_CCAsText = _connect.CTestAnalyzerCoverage_EX_CCAsText
    EX_CCAsCSV = _connect.CTestAnalyzerCoverage_EX_CCAsCSV
    EX_CCAsXML = _connect.CTestAnalyzerCoverage_EX_CCAsXML
    EX_CCAsReviewHTML = _connect.CTestAnalyzerCoverage_EX_CCAsReviewHTML
    EX_CCAsReviewText = _connect.CTestAnalyzerCoverage_EX_CCAsReviewText
    ENone = _connect.CTestAnalyzerCoverage_ENone
    r""" no merging is performed"""
    ESiblingsOnly = _connect.CTestAnalyzerCoverage_ESiblingsOnly
    r""" only coverage of test cases with the same immediate parent and their children get merged"""
    ESiblingsAndParent = _connect.CTestAnalyzerCoverage_ESiblingsAndParent
    r""" only coverage of parent and test cases with the same immediate parent and their children get merged"""
    EAll = _connect.CTestAnalyzerCoverage_EAll
    r""" coverage of all test cases executed so far will be merged."""
    E_SECTION_IS_ACTIVE = _connect.CTestAnalyzerCoverage_E_SECTION_IS_ACTIVE
    E_SECTION_IS_MEASURE_ALL_FUNCTIONS = _connect.CTestAnalyzerCoverage_E_SECTION_IS_MEASURE_ALL_FUNCTIONS
    E_SECTION_IS_IGNORE_UNREACHABLE_CODE = _connect.CTestAnalyzerCoverage_E_SECTION_IS_IGNORE_UNREACHABLE_CODE
    E_SECTION_MERGE_SCOPE = _connect.CTestAnalyzerCoverage_E_SECTION_MERGE_SCOPE
    E_SECTION_MERGE_FILTER = _connect.CTestAnalyzerCoverage_E_SECTION_MERGE_FILTER
    E_SECTION_EXPORT_FORMAT = _connect.CTestAnalyzerCoverage_E_SECTION_EXPORT_FORMAT
    E_SECTION_EXFMT_VARIANT = _connect.CTestAnalyzerCoverage_E_SECTION_EXFMT_VARIANT
    E_SECTION_EXPORT_FILE = _connect.CTestAnalyzerCoverage_E_SECTION_EXPORT_FILE
    E_SECTION_IS_ASSEMBLER_INFO = _connect.CTestAnalyzerCoverage_E_SECTION_IS_ASSEMBLER_INFO
    E_SECTION_IS_LAUNCH_VIEWER = _connect.CTestAnalyzerCoverage_E_SECTION_IS_LAUNCH_VIEWER
    E_SECTION_IS_EXPORT_MODULE_LINES = _connect.CTestAnalyzerCoverage_E_SECTION_IS_EXPORT_MODULE_LINES
    E_SECTION_IS_EXPORT_SOURCES = _connect.CTestAnalyzerCoverage_E_SECTION_IS_EXPORT_SOURCES
    E_SECTION_IS_EXPORT_FUNCTION_LINES = _connect.CTestAnalyzerCoverage_E_SECTION_IS_EXPORT_FUNCTION_LINES
    E_SECTION_IS_EXPORT_ASM = _connect.CTestAnalyzerCoverage_E_SECTION_IS_EXPORT_ASM
    E_SECTION_IS_EXPORT_RANGES = _connect.CTestAnalyzerCoverage_E_SECTION_IS_EXPORT_RANGES
    E_SECTION_EXPORT_FUNCTIONS_FILTER = _connect.CTestAnalyzerCoverage_E_SECTION_EXPORT_FUNCTIONS_FILTER
    E_SECTION_EXPORT_MODULES_FILTER = _connect.CTestAnalyzerCoverage_E_SECTION_EXPORT_MODULES_FILTER
    E_SECTION_STATISTICS = _connect.CTestAnalyzerCoverage_E_SECTION_STATISTICS

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new instance with NULL parent.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class. Used
                          only when parsing YAML declaration. Can be
                          specified as NULL if the object is not
                          initialized by parser.
        """
        _connect.CTestAnalyzerCoverage_swiginit(self, _connect.new_CTestAnalyzerCoverage(*args))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        r"""
        Creates new empty instance of this class. Can be used when we only have
        pointer to base but want to get instance of derived class.
        """
        return _connect.CTestAnalyzerCoverage_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestAnalyzerCoverage":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestAnalyzerCoverage_cast(testBase)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestAnalyzerCoverage_isMerged(self)

    def assignStatistics(self, src: "isys::CTestAnalyzerCoverageSPtr const &") -> "void":
        r"""This method copies statistics data from the object given as parameter to this object."""
        return _connect.CTestAnalyzerCoverage_assignStatistics(self, src)

    def isActive(self) -> "iconnect::ETristate":
        r"""
        Returns E_TRUE if this section is active (export is performed,
        and analysis is run for coverage and profiler).
        """
        return _connect.CTestAnalyzerCoverage_isActive(self)

    def isMeasureAllFunctions(self) -> "iconnect::ETristate":
        r"""
        Returns E_TRUE, if all functions should be measured, not only ones from
        statistics list. If E_FALSE is returned, only functions from statistics list
        will be measured.
        """
        return _connect.CTestAnalyzerCoverage_isMeasureAllFunctions(self)

    def isIgnoreNonReachableCode(self) -> "iconnect::ETristate":
        r"""
        Returns true, if the code inside the function which is not reachable by
        sequential or (conditional)direct branch flow is not considered for coverage statistics.
        """
        return _connect.CTestAnalyzerCoverage_isIgnoreNonReachableCode(self)

    def getMergeScope(self) -> "isys::CTestAnalyzerCoverage::EMergeScope":
        r"""Returns coverage merge scope."""
        return _connect.CTestAnalyzerCoverage_getMergeScope(self)

    def getMergeFilter(self, isConst: "bool") -> "CTestFilter":
        r"""
        Returns coverage merge filer. Test cases included in
        merge scope are included in merge only if they
        match this filter.
        """
        return _connect.CTestAnalyzerCoverage_getMergeFilter(self, isConst)

    def getExportFormat(self) -> "isys::CTestAnalyzerCoverage::ECoverageExportFormat":
        r""" Returns the export format. Empty string means XML format."""
        return _connect.CTestAnalyzerCoverage_getExportFormat(self)

    def getExportFormatVariant(self) -> "std::string":
        r""" Returns the export format variant. Empty string means the 'default' variant."""
        return _connect.CTestAnalyzerCoverage_getExportFormatVariant(self)

    def getExportFileName(self) -> "std::string":
        r""" Returns the export file name. If empty, no export is performed."""
        return _connect.CTestAnalyzerCoverage_getExportFileName(self)

    def isProvideAssemblerInfo(self) -> "iconnect::ETristate":
        r"""
        Returns ETrue, if assembly level coverage should be performed.
        EDefault means that assembly level coverage will **not** be performed.
        """
        return _connect.CTestAnalyzerCoverage_isProvideAssemblerInfo(self)

    def isLaunchViewer(self) -> "iconnect::ETristate":
        r""" Returns true, if viewer should be launched after coverage."""
        return _connect.CTestAnalyzerCoverage_isLaunchViewer(self)

    def isExportModuleLines(self) -> "iconnect::ETristate":
        r""" Returns true, if module lines coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_isExportModuleLines(self)

    def isExportSources(self) -> "iconnect::ETristate":
        r""" Returns true, if source files coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_isExportSources(self)

    def isExportFunctionLines(self) -> "iconnect::ETristate":
        r""" Returns true, if function lines coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_isExportFunctionLines(self)

    def isExportAsm(self) -> "iconnect::ETristate":
        r""" Returns true, if assembler coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_isExportAsm(self)

    def isExportRanges(self) -> "iconnect::ETristate":
        r""" Returns true, if ranges coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_isExportRanges(self)

    def getExportFunctionsFilter(self) -> "std::string":
        r""" Returns filter for functions export."""
        return _connect.CTestAnalyzerCoverage_getExportFunctionsFilter(self)

    def getExportModulesFilter(self) -> "std::string":
        r""" Returns filter for modules export."""
        return _connect.CTestAnalyzerCoverage_getExportModulesFilter(self)

    def getStatisticsList(self, isConst: "bool") -> "CTestBaseList":
        r""" Returns vector of coverage statistic items."""
        return _connect.CTestAnalyzerCoverage_getStatisticsList(self, isConst)

    def findStatistic(self, functionName: "std::string const &") -> "int":
        r"""
        Returns index of statistics for the given function, or -1 if no such
        function exists.
        """
        return _connect.CTestAnalyzerCoverage_findStatistic(self, functionName)

    def getStatistics(self, idx: "int") -> "CTestCoverageStatistics":
        r"""Returns the requested statistics."""
        return _connect.CTestAnalyzerCoverage_getStatistics(self, idx)

    def swapStatistics(self, idx1: "int", idx2: "int") -> "void":
        r""" Swaps two statistics in the list."""
        return _connect.CTestAnalyzerCoverage_swapStatistics(self, idx1, idx2)

    def setActive(self, isActive: "iconnect::ETristate") -> "void":
        r"""
        If ``isActive`` == ``true``, recording is exported and
        analysis is performed.
        """
        return _connect.CTestAnalyzerCoverage_setActive(self, isActive)

    def setMeasureAllFunctions(self, isMeasureAllFunctions: "iconnect::ETristate") -> "void":
        r"""
        :type isMeasureAllFunctions: int
        :param isMeasureAllFunctions: if E_TRUE, all functions should be
            measured, not only ones from
            statistics list. If E_FALSE, only functions from statistics list
            will be measured.
        """
        return _connect.CTestAnalyzerCoverage_setMeasureAllFunctions(self, isMeasureAllFunctions)

    def setExportFormat(self, format: "isys::CTestAnalyzerCoverage::ECoverageExportFormat") -> "void":
        r""" Sets format variant of the export format."""
        return _connect.CTestAnalyzerCoverage_setExportFormat(self, format)

    def setExportFormatVariant(self, variant: "std::string const &") -> "void":
        r""" Sets format variant of the export format."""
        return _connect.CTestAnalyzerCoverage_setExportFormatVariant(self, variant)

    def setExportFileName(self, file: "std::string const &") -> "void":
        r""" Sets format variant of the export format."""
        return _connect.CTestAnalyzerCoverage_setExportFileName(self, file)

    def setAssemblyInfo(self, isAssemblyInfo: "iconnect::ETristate") -> "void":
        r"""
        Sets whether assembly information should be provided with coverage.
        :type isAssemblyInfo: int
        :param isAssemblyInfo: if EDefault assembly information will **not** be
                                  provided with coverage.
        """
        return _connect.CTestAnalyzerCoverage_setAssemblyInfo(self, isAssemblyInfo)

    def setLaunchViewer(self, isLaunchViewer: "iconnect::ETristate") -> "void":
        r""" Sets whether viewer should be launched after coverage."""
        return _connect.CTestAnalyzerCoverage_setLaunchViewer(self, isLaunchViewer)

    def setExportModuleLines(self, isExportModuleLines: "iconnect::ETristate") -> "void":
        r""" Sets whether module lines coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_setExportModuleLines(self, isExportModuleLines)

    def setExportSources(self, isExportSources: "iconnect::ETristate") -> "void":
        r""" Sets whether source files coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_setExportSources(self, isExportSources)

    def setExportFunctionLines(self, isExportFunctionLines: "iconnect::ETristate") -> "void":
        r""" Sets whether function lines coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_setExportFunctionLines(self, isExportFunctionLines)

    def setExportAsm(self, isExportAsm: "iconnect::ETristate") -> "void":
        r""" Sets whether assembler coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_setExportAsm(self, isExportAsm)

    def setExportRanges(self, isExportRanges: "iconnect::ETristate") -> "void":
        r""" Sets whether ranges coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_setExportRanges(self, isExportRanges)

    def setExportFunctionsFilter(self, filter: "std::string const &") -> "void":
        r""" Sets filter for functions export."""
        return _connect.CTestAnalyzerCoverage_setExportFunctionsFilter(self, filter)

    def setExportModulesFilter(self, filter: "std::string const &") -> "void":
        r""" Sets filter for modules export."""
        return _connect.CTestAnalyzerCoverage_setExportModulesFilter(self, filter)
    __swig_destroy__ = _connect.delete_CTestAnalyzerCoverage

# Register CTestAnalyzerCoverage in _connect:
_connect.CTestAnalyzerCoverage_swigregister(CTestAnalyzerCoverage)

def CTestAnalyzerCoverage_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestAnalyzerCoverage":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestAnalyzerCoverage_cast(testBase)

class CTestAnalyzerProfiler(CTestBase):
    r"""
    This class contains specification for profiler recording during
    test execution.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DATA_AREA = _connect.CTestAnalyzerProfiler_DATA_AREA
    r""" profiler data area"""
    CODE_AREA = _connect.CTestAnalyzerProfiler_CODE_AREA
    r""" profiler code area"""
    EProfilerAsText = _connect.CTestAnalyzerProfiler_EProfilerAsText
    EProfilerAsXML = _connect.CTestAnalyzerProfiler_EProfilerAsXML
    EProfilerAsCSV = _connect.CTestAnalyzerProfiler_EProfilerAsCSV
    EProfilerAsText1 = _connect.CTestAnalyzerProfiler_EProfilerAsText1
    EProfilerAsXMLBinaryTimeline = _connect.CTestAnalyzerProfiler_EProfilerAsXMLBinaryTimeline
    EProfilerAsBTF = _connect.CTestAnalyzerProfiler_EProfilerAsBTF
    EProfilerAsMDF = _connect.CTestAnalyzerProfiler_EProfilerAsMDF
    E_SECTION_IS_ACTIVE = _connect.CTestAnalyzerProfiler_E_SECTION_IS_ACTIVE
    E_SECTION_IS_MEASURE_ALL_FUNCTIONS = _connect.CTestAnalyzerProfiler_E_SECTION_IS_MEASURE_ALL_FUNCTIONS
    E_SECTION_EXPORT_FORMAT = _connect.CTestAnalyzerProfiler_E_SECTION_EXPORT_FORMAT
    E_SECTION_EXPORT_FILE = _connect.CTestAnalyzerProfiler_E_SECTION_EXPORT_FILE
    E_SECTION_IS_EXPORT_ACTIVE_AREAS_ONLY = _connect.CTestAnalyzerProfiler_E_SECTION_IS_EXPORT_ACTIVE_AREAS_ONLY
    E_SECTION_IS_PROFILE_AUX = _connect.CTestAnalyzerProfiler_E_SECTION_IS_PROFILE_AUX
    E_SECTION_IS_SAVE_HISTORY = _connect.CTestAnalyzerProfiler_E_SECTION_IS_SAVE_HISTORY
    E_SECTION_CODE_AREAS = _connect.CTestAnalyzerProfiler_E_SECTION_CODE_AREAS
    E_SECTION_DATA_AREAS = _connect.CTestAnalyzerProfiler_E_SECTION_DATA_AREAS

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Initializes new instance.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class. Used
                          only when parsing YAML declaration. Can be
                          specified as NULL if the object is not
                          initialized by parser.
        """
        _connect.CTestAnalyzerProfiler_swiginit(self, _connect.new_CTestAnalyzerProfiler(*args))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        r""" Creates a new empty instance of this class."""
        return _connect.CTestAnalyzerProfiler_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestAnalyzerProfiler":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestAnalyzerProfiler_cast(testBase)

    def assignCodeAreas(self, src: "isys::CTestAnalyzerProfilerSPtr &") -> "void":
        r"""This method copies code areas from src to this object."""
        return _connect.CTestAnalyzerProfiler_assignCodeAreas(self, src)

    def assignDataAreas(self, src: "isys::CTestAnalyzerProfilerSPtr &") -> "void":
        r"""This method copies code areas from src to this object."""
        return _connect.CTestAnalyzerProfiler_assignDataAreas(self, src)

    def isActive(self) -> "iconnect::ETristate":
        r"""
        Returns E_TRUE if this section is active (export is performed,
        and analysis is run for coverage and profiler).
        """
        return _connect.CTestAnalyzerProfiler_isActive(self)

    def isMeasureAllFunctions(self) -> "iconnect::ETristate":
        r"""
        Returns E_TRUE, if all functions should be measured, not only ones from
        code areas list. If E_FALSE is returned, only functions from code areas list
        will be measured.
        """
        return _connect.CTestAnalyzerProfiler_isMeasureAllFunctions(self)

    def isMerged(self) -> "bool":
        r"""
        Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestAnalyzerProfiler_isMerged(self)

    def getExportFormat(self) -> "isys::CTestAnalyzerProfiler::EProfilerExportFormat":
        r""" Returns the export format. Empty string means XML format."""
        return _connect.CTestAnalyzerProfiler_getExportFormat(self)

    def getExportFileName(self) -> "std::string":
        r""" Returns the export file name. If empty, no export is performed."""
        return _connect.CTestAnalyzerProfiler_getExportFileName(self)

    def isExportActiveAreasOnly(self) -> "iconnect::ETristate":
        r"""
        Returns true, when only areas with recoded activity will be exported.
        Returns false, if all configured areas will be exported.
        """
        return _connect.CTestAnalyzerProfiler_isExportActiveAreasOnly(self)

    def isProfileAUX(self) -> "iconnect::ETristate":
        r""" Returns true, if AUX signals should be recorded during profiler session."""
        return _connect.CTestAnalyzerProfiler_isProfileAUX(self)

    def isSaveHistory(self) -> "iconnect::ETristate":
        r""" Returns true, if profiler history should also be saved to output file."""
        return _connect.CTestAnalyzerProfiler_isSaveHistory(self)

    def getAreas(self, areaType: "isys::CTestAnalyzerProfiler::EAreaType", isConst: "bool") -> "CTestBaseList":
        r""" Returns areas of the given type."""
        return _connect.CTestAnalyzerProfiler_getAreas(self, areaType, isConst)

    def getCodeAreas(self, isConst: "bool") -> "CTestBaseList":
        r"""
        Returns code areas specified for profiler. The returned list contains instances
        of CTestProfilerStatisticsSPtr.
        """
        return _connect.CTestAnalyzerProfiler_getCodeAreas(self, isConst)

    def getDataAreas(self, isConst: "bool") -> "CTestBaseList":
        r"""
        Returns code areas specified for profiler. The returned list contains instances
        of CTestProfilerStatisticsSPtr.
        """
        return _connect.CTestAnalyzerProfiler_getDataAreas(self, isConst)

    def findArea(self, *args) -> "int":
        r"""
        *Overload 1:*

        Returns index of the area or -1 if the area is not found.

        :type areaType: int
        :param areaType: if set to DATA_AREA, then only data areas
                            without value set can match.

        |

        *Overload 2:*

        Returns index of the data area, or -1 if the area is not found.
        This method searches for data areas with value set.
        """
        return _connect.CTestAnalyzerProfiler_findArea(self, *args)

    def getArea(self, areaType: "isys::CTestAnalyzerProfiler::EAreaType", idx: "int") -> "CTestProfilerStatistics":
        r""" Returns the requested area."""
        return _connect.CTestAnalyzerProfiler_getArea(self, areaType, idx)

    def swapAreas(self, areaType: "isys::CTestAnalyzerProfiler::EAreaType", idx1: "int", idx2: "int") -> "void":
        r""" Swaps two areas in the list."""
        return _connect.CTestAnalyzerProfiler_swapAreas(self, areaType, idx1, idx2)

    def setActive(self, isActive: "iconnect::ETristate") -> "void":
        r"""
        If ``isActive`` == ``true``, recording is exported and
        analysis is performed.
        """
        return _connect.CTestAnalyzerProfiler_setActive(self, isActive)

    def setMeasureAllFunctions(self, isMeasureAllFunctions: "iconnect::ETristate") -> "void":
        r"""
        :type isMeasureAllFunctions: int
        :param isMeasureAllFunctions: if E_TRUE, all functions should be
            measured, not only ones from
            code areas list. If E_FALSE, only functions from code areas list
            will be measured.
        """
        return _connect.CTestAnalyzerProfiler_setMeasureAllFunctions(self, isMeasureAllFunctions)

    def setExportFormat(self, exportFormat: "isys::CTestAnalyzerProfiler::EProfilerExportFormat") -> "void":
        r""" Sets format variant of the export format."""
        return _connect.CTestAnalyzerProfiler_setExportFormat(self, exportFormat)

    def setExportFileName(self, file: "std::string const &") -> "void":
        r""" Sets format variant of the export format."""
        return _connect.CTestAnalyzerProfiler_setExportFileName(self, file)

    def setExportActiveAreasOnly(self, isExportActiveAreasOnly: "iconnect::ETristate") -> "void":
        r"""
        If ``isExportActiveAreasOnly`` is true, then only areas with
        recorded activity (executed functions and modified data) will
        be exported. Otherwise all configured areas will be exported.
        """
        return _connect.CTestAnalyzerProfiler_setExportActiveAreasOnly(self, isExportActiveAreasOnly)

    def setProfileAUX(self, isProfileAUX: "iconnect::ETristate") -> "void":
        r"""If parameter is ``true``, then AUX signals are recorded during profiling."""
        return _connect.CTestAnalyzerProfiler_setProfileAUX(self, isProfileAUX)

    def setSaveHistory(self, isSave: "iconnect::ETristate") -> "void":
        r"""Sets the save mode for output file. If true, history will also be saved."""
        return _connect.CTestAnalyzerProfiler_setSaveHistory(self, isSave)

    def setCodeAreas(self, arg2: "isys::CTestBaseListSPtr &") -> "void":
        r""" Sets code areas for profiler."""
        return _connect.CTestAnalyzerProfiler_setCodeAreas(self, arg2)

    def setDataAreas(self, arg2: "isys::CTestBaseListSPtr &") -> "void":
        r""" Sets data areas for profiler."""
        return _connect.CTestAnalyzerProfiler_setDataAreas(self, arg2)
    __swig_destroy__ = _connect.delete_CTestAnalyzerProfiler

# Register CTestAnalyzerProfiler in _connect:
_connect.CTestAnalyzerProfiler_swigregister(CTestAnalyzerProfiler)

def CTestAnalyzerProfiler_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestAnalyzerProfiler":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestAnalyzerProfiler_cast(testBase)

class CTestCoverageStatistics(CTestBase):
    r"""
    This class contains coverage requirements. If function name is not specified, function under test
    is assumed. This is serializable version of CCoverageStatistics2.
    This class is aggregated by CTestAnalyzerCoverage (values are specified in
    percentage) and CTestCoverageResult.
    All results are set and returned in percentage, which means in range [0%..100%].
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_FUNC_NAME = _connect.CTestCoverageStatistics_E_SECTION_FUNC_NAME
    E_SECTION_BYTES_EXECUTED = _connect.CTestCoverageStatistics_E_SECTION_BYTES_EXECUTED
    E_SECTION_SOURCE_LINES_EXECUTED = _connect.CTestCoverageStatistics_E_SECTION_SOURCE_LINES_EXECUTED
    E_SECTION_BRANCH_EXECUTED = _connect.CTestCoverageStatistics_E_SECTION_BRANCH_EXECUTED
    E_SECTION_BRANCH_TAKEN = _connect.CTestCoverageStatistics_E_SECTION_BRANCH_TAKEN
    E_SECTION_BRANCH_NOT_TAKEN = _connect.CTestCoverageStatistics_E_SECTION_BRANCH_NOT_TAKEN
    E_SECTION_BRANCH_BOTH = _connect.CTestCoverageStatistics_E_SECTION_BRANCH_BOTH
    E_SECTION_EXECUTION_COUNT = _connect.CTestCoverageStatistics_E_SECTION_EXECUTION_COUNT
    E_SECTION_CALL_COUNT = _connect.CTestCoverageStatistics_E_SECTION_CALL_COUNT
    E_SECTION_MC_DC = _connect.CTestCoverageStatistics_E_SECTION_MC_DC

    def __init__(self, *args):
        _connect.CTestCoverageStatistics_swiginit(self, _connect.new_CTestCoverageStatistics(*args))
    __swig_destroy__ = _connect.delete_CTestCoverageStatistics

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestCoverageStatistics_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestCoverageStatistics":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestCoverageStatistics_cast(testBase)

    def getFunctionName(self) -> "std::string":
        r""" Returns function name."""
        return _connect.CTestCoverageStatistics_getFunctionName(self)

    def getSourceLinesExecuted(self) -> "float":
        r""" Returns the ratio of source lines to be executed in %."""
        return _connect.CTestCoverageStatistics_getSourceLinesExecuted(self)

    def getBytesExecuted(self) -> "float":
        r""" Returns the ratio of bytes to be executed in %."""
        return _connect.CTestCoverageStatistics_getBytesExecuted(self)

    def getBranchExecuted(self) -> "float":
        r""" Returns the ratio of branches to be executed in %."""
        return _connect.CTestCoverageStatistics_getBranchExecuted(self)

    def getBranchTaken(self) -> "float":
        r""" Returns the ratio of branches to be taken in %."""
        return _connect.CTestCoverageStatistics_getBranchTaken(self)

    def getBranchNotTaken(self) -> "float":
        r""" Returns the ratio of branches not to be taken in %."""
        return _connect.CTestCoverageStatistics_getBranchNotTaken(self)

    def getBranchBoth(self) -> "float":
        r""" Returns the ratio of branches to be executed both ways in %."""
        return _connect.CTestCoverageStatistics_getBranchBoth(self)

    def getExecutionCount(self) -> "int64_t":
        r""" Returns how may times the item was executed."""
        return _connect.CTestCoverageStatistics_getExecutionCount(self)

    def getBytesExecutedText(self) -> "std::string":
        r""" Returns true if MC/DC coverage is required."""
        return _connect.CTestCoverageStatistics_getBytesExecutedText(self)

    def getSourceLinesExecutedText(self) -> "std::string":
        return _connect.CTestCoverageStatistics_getSourceLinesExecutedText(self)

    def getBranchExecutedText(self) -> "std::string":
        return _connect.CTestCoverageStatistics_getBranchExecutedText(self)

    def getBranchTakenText(self) -> "std::string":
        return _connect.CTestCoverageStatistics_getBranchTakenText(self)

    def getBranchNotTakenText(self) -> "std::string":
        return _connect.CTestCoverageStatistics_getBranchNotTakenText(self)

    def getBranchBothText(self) -> "std::string":
        return _connect.CTestCoverageStatistics_getBranchBothText(self)

    def setFunctionName(self, functionName: "std::string const &") -> "void":
        r""" Sets the name of the function to be covered."""
        return _connect.CTestCoverageStatistics_setFunctionName(self, functionName)

    def setCodeExecuted(self, codeExecuted: "std::string const &") -> "void":
        r""" Sets the amount of code executed in %."""
        return _connect.CTestCoverageStatistics_setCodeExecuted(self, codeExecuted)

    def setSourceLinesExecuted(self, codeExecuted: "std::string const &") -> "void":
        r""" Sets the amount of source lines executed in %."""
        return _connect.CTestCoverageStatistics_setSourceLinesExecuted(self, codeExecuted)

    def setBranchExecuted(self, branchExecuted: "std::string const &") -> "void":
        r""" Sets the number of branches executed in %."""
        return _connect.CTestCoverageStatistics_setBranchExecuted(self, branchExecuted)

    def setBranchTaken(self, branchTaken: "std::string const &") -> "void":
        r""" Sets the number of branches taken in %."""
        return _connect.CTestCoverageStatistics_setBranchTaken(self, branchTaken)

    def setBranchNotTaken(self, branchNotTaken: "std::string const &") -> "void":
        r""" Sets the number of branches not taken in %."""
        return _connect.CTestCoverageStatistics_setBranchNotTaken(self, branchNotTaken)

    def setBranchBoth(self, branchBoth: "std::string const &") -> "void":
        r""" Sets the number of branches taken both ways in %."""
        return _connect.CTestCoverageStatistics_setBranchBoth(self, branchBoth)

# Register CTestCoverageStatistics in _connect:
_connect.CTestCoverageStatistics_swigregister(CTestCoverageStatistics)

def CTestCoverageStatistics_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestCoverageStatistics":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestCoverageStatistics_cast(testBase)

class CTestProfilerTime(CTestBase):
    r"""
    This class stores expected profiler results for one time type (net, call, gross, ...).


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_MIN_TIME = _connect.CTestProfilerTime_E_SECTION_MIN_TIME
    r""" min time ID"""
    E_SECTION_MIN_START_TIME = _connect.CTestProfilerTime_E_SECTION_MIN_START_TIME
    r""" min start time ID"""
    E_SECTION_MIN_END_TIME = _connect.CTestProfilerTime_E_SECTION_MIN_END_TIME
    r""" min end time ID"""
    E_SECTION_MAX_TIME = _connect.CTestProfilerTime_E_SECTION_MAX_TIME
    r""" max time ID"""
    E_SECTION_MAX_START_TIME = _connect.CTestProfilerTime_E_SECTION_MAX_START_TIME
    r""" max start time ID"""
    E_SECTION_MAX_END_TIME = _connect.CTestProfilerTime_E_SECTION_MAX_END_TIME
    r""" max end time ID"""
    E_SECTION_TOTAL_TIME = _connect.CTestProfilerTime_E_SECTION_TOTAL_TIME
    r""" total time ID"""
    E_SECTION_AVERAGE_TIME = _connect.CTestProfilerTime_E_SECTION_AVERAGE_TIME
    r""" average time ID"""

    def __init__(self, *args):
        _connect.CTestProfilerTime_swiginit(self, _connect.new_CTestProfilerTime(*args))
    __swig_destroy__ = _connect.delete_CTestProfilerTime

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestProfilerTime_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestProfilerTime":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestProfilerTime_cast(testBase)

    def getTime(self, profilerStatSectionId: "isys::CTestProfilerTime::EProfilerTimeSectionId", idx: "int") -> "std::string":
        r"""
         Returns expected interval boundary for the given time type.

        :type idx: int
        :param idx: should be 0 for lower boundary, 1 for upper boundary
        """
        return _connect.CTestProfilerTime_getTime(self, profilerStatSectionId, idx)

    def setTime(self, profilerStatSectionId: "isys::CTestProfilerTime::EProfilerTimeSectionId", time: "std::string const &", idx: "int") -> "void":
        r""" Sets time for the given section."""
        return _connect.CTestProfilerTime_setTime(self, profilerStatSectionId, time, idx)

    @staticmethod
    def a2d(strNum: "std::string const &") -> "double":
        r"""
        Converts string to double.

        :type strNum: string
        :param strNum: string number, which may contain underscores for better readability,
                          and may have time unit appended: ns, us, ms, s. If there is no
                          unit appended, ns is assumed. Underscore is not allowed as the
                          first character.
        """
        return _connect.CTestProfilerTime_a2d(strNum)

# Register CTestProfilerTime in _connect:
_connect.CTestProfilerTime_swigregister(CTestProfilerTime)

def CTestProfilerTime_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestProfilerTime":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestProfilerTime_cast(testBase)

def CTestProfilerTime_a2d(strNum: "std::string const &") -> "double":
    r"""
    Converts string to double.

    :type strNum: string
    :param strNum: string number, which may contain underscores for better readability,
                      and may have time unit appended: ns, us, ms, s. If there is no
                      unit appended, ns is assumed. Underscore is not allowed as the
                      first character.
    """
    return _connect.CTestProfilerTime_a2d(strNum)

class CTestProfilerStatistics(CTestBase):
    r"""
    This class stores expected profiler results for one area.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_AREA_NAME = _connect.CTestProfilerStatistics_E_SECTION_AREA_NAME
    E_SECTION_AREA_VALUE = _connect.CTestProfilerStatistics_E_SECTION_AREA_VALUE
    E_SECTION_NET_TIME = _connect.CTestProfilerStatistics_E_SECTION_NET_TIME
    r""" net time ID"""
    E_SECTION_GROSS_TIME = _connect.CTestProfilerStatistics_E_SECTION_GROSS_TIME
    r""" gross time ID"""
    E_SECTION_CALL_TIME = _connect.CTestProfilerStatistics_E_SECTION_CALL_TIME
    r""" call time ID"""
    E_SECTION_PERIOD_TIME = _connect.CTestProfilerStatistics_E_SECTION_PERIOD_TIME
    r""" period time ID"""
    E_SECTION_OUTSIDE_TIME = _connect.CTestProfilerStatistics_E_SECTION_OUTSIDE_TIME
    r""" outside time ID"""
    E_SECTION_HITS = _connect.CTestProfilerStatistics_E_SECTION_HITS
    E_SECTION_MIN_AREA_TIME = _connect.CTestProfilerStatistics_E_SECTION_MIN_AREA_TIME
    E_SECTION_MAX_AREA_TIME = _connect.CTestProfilerStatistics_E_SECTION_MAX_AREA_TIME
    E_SECTION_TOTAL_AREA_TIME = _connect.CTestProfilerStatistics_E_SECTION_TOTAL_AREA_TIME

    def __init__(self, *args):
        _connect.CTestProfilerStatistics_swiginit(self, _connect.new_CTestProfilerStatistics(*args))
    __swig_destroy__ = _connect.delete_CTestProfilerStatistics

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestProfilerStatistics_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestProfilerStatistics":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestProfilerStatistics_cast(testBase)

    def getAreaName(self) -> "std::string":
        r""" Returns area name."""
        return _connect.CTestProfilerStatistics_getAreaName(self)

    def getAreaValue(self) -> "std::string":
        r""" Returns area value."""
        return _connect.CTestProfilerStatistics_getAreaValue(self)

    def getTime(self, sectionId: "isys::CTestProfilerStatistics::EProfilerStatisticsSectionId", isConst: "bool") -> "CTestProfilerTime":
        r""" Returns expected time interval for the given time scope."""
        return _connect.CTestProfilerStatistics_getTime(self, sectionId, isConst)

    def getHits(self, idx: "int") -> "std::string":
        r"""
        Returns limit for hits.

        :type idx: int
        :param idx: should be 0 for lower boundary, 1 for upper boundary
        """
        return _connect.CTestProfilerStatistics_getHits(self, idx)

    def isAreaValueSet(self) -> "bool":
        r"""
        Returns true, if value is set, false otherwise. Returns ``true`` after call to
        setAreaValue().
        """
        return _connect.CTestProfilerStatistics_isAreaValueSet(self)

    def isAreaValueNumber(self) -> "bool":
        r"""Returns true, if area value is set, _and_ it is a number."""
        return _connect.CTestProfilerStatistics_isAreaValueNumber(self)

    def setAreaName(self, areaName: "std::string const &") -> "void":
        r""" Sets area name."""
        return _connect.CTestProfilerStatistics_setAreaName(self, areaName)

    def setAreaValue(self, value: "std::string const &") -> "void":
        r""" Sets area value."""
        return _connect.CTestProfilerStatistics_setAreaValue(self, value)

    def clearAreaValue(self) -> "void":
        r"""
        Marks area value as not set. If it is not set, statistics limits are used
        for all values not explicitly set in test specification. See YAML test
        spec, item ``value`` in ``profiler`` section for example.

        See also: isAreaValueSet()
        """
        return _connect.CTestProfilerStatistics_clearAreaValue(self)

    def setHits(self, limits: "std::string const &", idx: "int") -> "void":
        r""" Sets hits number - how many times function was called or state variable changed."""
        return _connect.CTestProfilerStatistics_setHits(self, limits, idx)

    def getQualifiedAreaName(self, defaultDownloadFile: "std::string const &") -> "std::string":
        r"""
        Returns area name with default download file appended, if there is
        currently no download file specified in area name.
        """
        return _connect.CTestProfilerStatistics_getQualifiedAreaName(self, defaultDownloadFile)

    def getQualifiedAreaNameForStateVar(self, defaultDownloadFile: "std::string const &") -> "std::string":
        r"""
        Returns area name with default download file appended, if there is
        currently no download file specified in area name. For state variables
        '%' and area value are appended, if defined.
        """
        return _connect.CTestProfilerStatistics_getQualifiedAreaNameForStateVar(self, defaultDownloadFile)

    def createTestBase(self, section: "int", lineNo: "size_t") -> "CTestBase":
        return _connect.CTestProfilerStatistics_createTestBase(self, section, lineNo)

# Register CTestProfilerStatistics in _connect:
_connect.CTestProfilerStatistics_swigregister(CTestProfilerStatistics)

def CTestProfilerStatistics_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestProfilerStatistics":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestProfilerStatistics_cast(testBase)

class CTestCoverageResult(CTestBase):
    r"""This class contains coverage results."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_BYTES_ALL = _connect.CTestCoverageResult_E_SECTION_BYTES_ALL
    E_SECTION_LINES_ALL = _connect.CTestCoverageResult_E_SECTION_LINES_ALL
    E_SECTION_CONDITIONS_ALL = _connect.CTestCoverageResult_E_SECTION_CONDITIONS_ALL
    E_SECTION_COVERAGE_STATS_EXPECTED = _connect.CTestCoverageResult_E_SECTION_COVERAGE_STATS_EXPECTED
    E_SECTION_COVERAGE_STATS_MEASURED = _connect.CTestCoverageResult_E_SECTION_COVERAGE_STATS_MEASURED

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new instance.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: reference to parent or empty shared ptr.
        """
        _connect.CTestCoverageResult_swiginit(self, _connect.new_CTestCoverageResult(*args))
    __swig_destroy__ = _connect.delete_CTestCoverageResult

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestCoverageResult_createInstance(self, parent)

    def isMerged(self) -> "bool":
        r"""Overrides base method, always returns false, because results can't be merged."""
        return _connect.CTestCoverageResult_isMerged(self)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestCoverageResult":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestCoverageResult_cast(testBase)

    def getExpectedCoverage(self, isConst: "bool") -> "CTestCoverageStatistics":
        r""" Returns object containing expected coverage values."""
        return _connect.CTestCoverageResult_getExpectedCoverage(self, isConst)

    def getMeasuredCoverage(self, isConst: "bool") -> "CTestCoverageStatistics":
        r""" Returns object containing measured coverage values."""
        return _connect.CTestCoverageResult_getMeasuredCoverage(self, isConst)

    def getMeasuredResults(self) -> "isys::CCoverageStatistic2SPtr const":
        r"""
        Deprecated: since 9.12.268 (2015-12). Call  getMeasuredCoverage() and getMeasured() instead.

        Returns measured data.
        """
        return _connect.CTestCoverageResult_getMeasuredResults(self)

    def getMeasured(self, section: "isys::CTestCoverageResult::ESectionCoverageResult") -> "int":
        r"""
        Returns measured value for the given section.
        :type section: int
        :param section: scalar ID from ESectionCoverageResult:
                   E_SECTION_BYTES_ALL, E_SECTION_LINES_ALL, E_SECTION_CONDITIONS_ALL.
        """
        return _connect.CTestCoverageResult_getMeasured(self, section)

    def isError(self) -> "bool":
        r""" Returns true, if any error of more specific errors occurred."""
        return _connect.CTestCoverageResult_isError(self)

    def isBytesExecutedError(self) -> "bool":
        r""" Returns true, if not enough bytes were executed."""
        return _connect.CTestCoverageResult_isBytesExecutedError(self)

    def isSourceLinesExecutedError(self) -> "bool":
        r""" Returns true, if not enough source lines were executed."""
        return _connect.CTestCoverageResult_isSourceLinesExecutedError(self)

    def isBranchesExecutedError(self) -> "bool":
        r""" Returns true, if not enough branches were executed."""
        return _connect.CTestCoverageResult_isBranchesExecutedError(self)

    def isBranchesTakenError(self) -> "bool":
        r""" Returns true, if not enough branches were taken."""
        return _connect.CTestCoverageResult_isBranchesTakenError(self)

    def isBranchesNotTakenError(self) -> "bool":
        r""" Returns true, if not enough branches were not taken."""
        return _connect.CTestCoverageResult_isBranchesNotTakenError(self)

    def isBranchesBothError(self) -> "bool":
        r""" Returns true, if not enough branches were executed both ways."""
        return _connect.CTestCoverageResult_isBranchesBothError(self)

# Register CTestCoverageResult in _connect:
_connect.CTestCoverageResult_swigregister(CTestCoverageResult)

def CTestCoverageResult_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestCoverageResult":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestCoverageResult_cast(testBase)

class CTestTreeNode(CTestBase):
    r"""
    This interface defines common methods for CTestSpecification and CTestGroup
    classes, which are used in testIDEA UI.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestTreeNode":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestTreeNode_cast(testBase)

    def getChildren(self, isConst: "bool") -> "CTestBaseList":
        return _connect.CTestTreeNode_getChildren(self, isConst)

    def getNoOfAllChildrenInHierarchy(self) -> "size_t":
        r"""Returns the number of all children down the hierarchy."""
        return _connect.CTestTreeNode_getNoOfAllChildrenInHierarchy(self)

    def getParentNode(self) -> "CTestTreeNode":
        r"""
        Returns parent node or mull it there is no parent or it is not of correct type,
        for example it is CTestBench.
        """
        return _connect.CTestTreeNode_getParentNode(self)

    def toUIString(self) -> "std::string":
        r"""
        Returns string containing data set in an object. It is intended for UI
        only and should not be parsed.
        """
        return _connect.CTestTreeNode_toUIString(self)

    def compare(self, testNode: "isys::CTestTreeNodeSPtr") -> "bool":
        r"""Returns true, if the given testSpec is the same object as this one."""
        return _connect.CTestTreeNode_compare(self, testNode)

    def hashCodeAsPtr(self) -> "int64_t":
        r"""
        Returns pointer value as hash code. This value can be used to
        identify test specification objects. Each object has its unique
        value.
        """
        return _connect.CTestTreeNode_hashCodeAsPtr(self)

    def addChildAndSetParent(self, idx: "int", child: "isys::CTestTreeNodeSPtr const &") -> "void":
        return _connect.CTestTreeNode_addChildAndSetParent(self, idx, child)

    def deleteChild(self, child: "isys::CTestTreeNodeSPtr const &") -> "int":
        return _connect.CTestTreeNode_deleteChild(self, child)

    def hasChildren(self) -> "bool":
        return _connect.CTestTreeNode_hasChildren(self)

    def getId(self) -> "std::string":
        return _connect.CTestTreeNode_getId(self)

    def getUILabel(self) -> "std::string":
        return _connect.CTestTreeNode_getUILabel(self)

    def isGroup(self) -> "bool":
        return _connect.CTestTreeNode_isGroup(self)
    __swig_destroy__ = _connect.delete_CTestTreeNode

# Register CTestTreeNode in _connect:
_connect.CTestTreeNode_swigregister(CTestTreeNode)

def CTestTreeNode_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestTreeNode":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestTreeNode_cast(testBase)

class CTestGroup(CTestTreeNode):
    r"""
    This class defines group of test cases or other subgroups. It is
    intended to be used for grouping test cases per partition, module,
    function or custom criteria.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ECore = _connect.CTestGroup_ECore
    EPartition = _connect.CTestGroup_EPartition
    EModule = _connect.CTestGroup_EModule
    EFunction = _connect.CTestGroup_EFunction
    ECustom = _connect.CTestGroup_ECustom
    E_SECTION_GROUP_ID = _connect.CTestGroup_E_SECTION_GROUP_ID
    E_SECTION_IS_EXECUTE = _connect.CTestGroup_E_SECTION_IS_EXECUTE
    E_SECTION_DESCRIPTION = _connect.CTestGroup_E_SECTION_DESCRIPTION
    E_SECTION_FILTER = _connect.CTestGroup_E_SECTION_FILTER
    E_SECTION_MERGED_ANALYZER_FILE = _connect.CTestGroup_E_SECTION_MERGED_ANALYZER_FILE
    E_SECTION_CLOSE_ANALYZER_FILE = _connect.CTestGroup_E_SECTION_CLOSE_ANALYZER_FILE
    E_SECTION_COVERAGE_EXPORT = _connect.CTestGroup_E_SECTION_COVERAGE_EXPORT
    E_SECTION_COVERAGE_ALL_CODE_IN_GROUP = _connect.CTestGroup_E_SECTION_COVERAGE_ALL_CODE_IN_GROUP
    E_SECTION_COVERAGE_TEST_CASES_ONLY = _connect.CTestGroup_E_SECTION_COVERAGE_TEST_CASES_ONLY
    E_SECTION_GROUP_INIT_SCRIPT = _connect.CTestGroup_E_SECTION_GROUP_INIT_SCRIPT
    E_SECTION_GROUP_END_SCRIPT = _connect.CTestGroup_E_SECTION_GROUP_END_SCRIPT
    E_SECTION_CHILDREN = _connect.CTestGroup_E_SECTION_CHILDREN

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new instance.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: reference to parent or empty shared ptr.
        """
        _connect.CTestGroup_swiginit(self, _connect.new_CTestGroup(*args))
    __swig_destroy__ = _connect.delete_CTestGroup

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestGroup_createInstance(self, parent)

    def isMerged(self) -> "bool":
        r"""Overrides base method, always returns false, because groups can't be merged."""
        return _connect.CTestGroup_isMerged(self)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestGroup":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestGroup_cast(testBase)

    def getParentGroup(self) -> "CTestGroup":
        r""" Returns parent group or null if it has no parent or parent is not of type CTestGroup."""
        return _connect.CTestGroup_getParentGroup(self)

    def getContainerTestNode(self) -> "CTestTreeNode":
        return _connect.CTestGroup_getContainerTestNode(self)

    def getUILabel(self) -> "std::string":
        r""" Returns label to be shown in testIDEA."""
        return _connect.CTestGroup_getUILabel(self)

    def isGroup(self) -> "bool":
        r""" Returns true, if this object is of type CTestGroup, false if it is CTestSpecification."""
        return _connect.CTestGroup_isGroup(self)

    def getId(self) -> "std::string":
        r""" Returns group type.  Returns group name, for example download file name, source file name, ..."""
        return _connect.CTestGroup_getId(self)

    def getDescription(self) -> "std::string":
        r""" Returns group description."""
        return _connect.CTestGroup_getDescription(self)

    def getFilter(self, isConst: "bool") -> "CTestFilter":
        r""" Returns filter of test cases for this group."""
        return _connect.CTestGroup_getFilter(self, isConst)

    def getMergedAnalyzerFileName(self) -> "std::string":
        r""" Returns name of analyzer file, which contains merged coverage of all test cases in a group."""
        return _connect.CTestGroup_getMergedAnalyzerFileName(self)

    def isCloseAfterTest(self) -> "bool":
        r""" Returns true, if analyzer file should be closed in winIDEA after test."""
        return _connect.CTestGroup_isCloseAfterTest(self)

    def getCoverageExportConfig(self, isConst: "bool") -> "CTestAnalyzerCoverage":
        r""" Returns coverage export parameters."""
        return _connect.CTestGroup_getCoverageExportConfig(self, isConst)

    def getCoverageStatForAllCodeInGroup(self, isConst: "bool") -> "CTestCoverageStatistics":
        r"""
        Returns expected coverage statistics for all code in a group, for example
        if it is module group, for all code in a module.

        See also: getCoverageStatForTestCasesOnly
        """
        return _connect.CTestGroup_getCoverageStatForAllCodeInGroup(self, isConst)

    def getCoverageStatForTestCasesOnly(self, isConst: "bool") -> "CTestCoverageStatistics":
        r"""
        Returns expected coverage for functions in test cases only.

        See also: getCoverageStatForTestCasesOnly
        """
        return _connect.CTestGroup_getCoverageStatForTestCasesOnly(self, isConst)

    def getScriptFunction(self, section: "isys::CTestGroup::ESectionCTestGroup", isConst: "bool") -> "CTestFunction":
        r"""
        if section == E_SECTION_GROUP_INIT_SCRIPT, this method
        eturns specification for script function to be called before execution of test
        cases start. 'init' script functions of all groups are called before execution
        of the first test case.

        if section == E_SECTION_GROUP_END_SCRIPT, this method
        returns specification for script function to be called after execution of test
        cases. 'end' script functions of all groups are called after execution of the last
        test case.
        """
        return _connect.CTestGroup_getScriptFunction(self, section, isConst)

    def getNoOfTestCasesInGroup(self) -> "int":
        r"""Returns the number of test cases in this group and all child groups."""
        return _connect.CTestGroup_getNoOfTestCasesInGroup(self)

    def addChildAndSetParent(self, idx: "int", child: "isys::CTestTreeNodeSPtr const &") -> "void":
        r"""
        Adds given child to the list of children
        at the given index. Parent of the added child is set to 'this'!

        :type idx: int
        :param idx: advice where to put the child in the children list
                   If -1 or out of range, the child is added to the end of the list.
        """
        return _connect.CTestGroup_addChildAndSetParent(self, idx, child)

    def getChildren(self, isConst: "bool") -> "CTestBaseList":
        return _connect.CTestGroup_getChildren(self, isConst)

    def hasChildren(self) -> "bool":
        return _connect.CTestGroup_hasChildren(self)

    def deleteChild(self, child: "isys::CTestTreeNodeSPtr const &") -> "int":
        return _connect.CTestGroup_deleteChild(self, child)

    def hasTestSpecs(self) -> "bool":
        r""" Returns true, if there is at least one test case in this group."""
        return _connect.CTestGroup_hasTestSpecs(self)

    def clearTestSpecs(self) -> "void":
        r""" Removes all test cases from this group."""
        return _connect.CTestGroup_clearTestSpecs(self)

    def isTestSpecOwner(self) -> "bool":
        return _connect.CTestGroup_isTestSpecOwner(self)

    def getOwnedTestSpec(self) -> "CTestSpecification":
        return _connect.CTestGroup_getOwnedTestSpec(self)

    def getTestOwnerGroupsSize(self) -> "size_t":
        return _connect.CTestGroup_getTestOwnerGroupsSize(self)

    def getTestOwnerGroup(self, idx: "size_t") -> "CTestGroup":
        return _connect.CTestGroup_getTestOwnerGroup(self, idx)

    def isBelongsToFilterGroup(self) -> "bool":
        return _connect.CTestGroup_isBelongsToFilterGroup(self)

# Register CTestGroup in _connect:
_connect.CTestGroup_swigregister(CTestGroup)
TAG_GROUP_ID = cvar.TAG_GROUP_ID
TAG_GROUP_DESCRIPTION = cvar.TAG_GROUP_DESCRIPTION

def CTestGroup_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestGroup":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestGroup_cast(testBase)

class CTestResultBase(CTestBase):
    r"""Base class for test case and group results."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_CTestResultBase

    def isError(self) -> "bool":
        r"""
        Returns true if any of possible errors occurred - expressions, profiler,
        coverage, or exception.
        """
        return _connect.CTestResultBase_isError(self)

    def isException(self) -> "bool":
        r"""
        Returns true, if group result could not be created because of an error
        during test execution.
        """
        return _connect.CTestResultBase_isException(self)

    def getExceptionString(self) -> "std::string":
        r"""Returns exception message or empty string if there was no exception thrown."""
        return _connect.CTestResultBase_getExceptionString(self)

    def getResultComment(self) -> "std::string":
        r"""
        Returns comment, which describes specific test run. This value is typically
        entered by user after test run and before saving test report.
        """
        return _connect.CTestResultBase_getResultComment(self)

    def isScriptError(self, *args) -> "bool":
        r"""
        *Overload 1:*
        Returns true, if there was error when executing script functions.

        |

        *Overload 2:*
        Returns true, if there was error when executing the given script function.
        """
        return _connect.CTestResultBase_isScriptError(self, *args)

    def isStackUsageError(self) -> "bool":
        r""" Returns true, if there was error in stack usage."""
        return _connect.CTestResultBase_isStackUsageError(self)

    def getScriptError(self, scriptFunctionType: "std::string const &") -> "std::string":
        r"""
        Returns string returned by the given script function.
        If there was no error, an empty string is returned.
        """
        return _connect.CTestResultBase_getScriptError(self, scriptFunctionType)

    def getScriptOutput(self, scriptFunctionType: "std::string const &") -> "std::string":
        r"""Returns everything printed to std out by script function."""
        return _connect.CTestResultBase_getScriptOutput(self, scriptFunctionType)

    def appendScriptError(self, scriptFunctionType: "std::string const &", errorDesc: "std::string const &") -> "void":
        return _connect.CTestResultBase_appendScriptError(self, scriptFunctionType, errorDesc)

    def appendScriptOutput(self, scriptFunctionType: "std::string const &", outStr: "std::string const &") -> "void":
        return _connect.CTestResultBase_appendScriptOutput(self, scriptFunctionType, outStr)

# Register CTestResultBase in _connect:
_connect.CTestResultBase_swigregister(CTestResultBase)
CTestResultBase.SE_INIT_SEQ = _connect.cvar.CTestResultBase_SE_INIT_SEQ
CTestResultBase.SE_INIT_TARGET = _connect.cvar.CTestResultBase_SE_INIT_TARGET
CTestResultBase.SE_INIT_FUNC = _connect.cvar.CTestResultBase_SE_INIT_FUNC
CTestResultBase.SE_END_FUNC = _connect.cvar.CTestResultBase_SE_END_FUNC
CTestResultBase.SE_RESTORE_TARGET = _connect.cvar.CTestResultBase_SE_RESTORE_TARGET
CTestResultBase.SE_STUB = _connect.cvar.CTestResultBase_SE_STUB
CTestResultBase.SE_TEST_POINT = _connect.cvar.CTestResultBase_SE_TEST_POINT
CTestResultBase.SE_FILTER = _connect.cvar.CTestResultBase_SE_FILTER
CTestResultBase.SE_GROUP_INIT_FUNC = _connect.cvar.CTestResultBase_SE_GROUP_INIT_FUNC
CTestResultBase.SE_GROUP_END_FUNC = _connect.cvar.CTestResultBase_SE_GROUP_END_FUNC

class CProfilerTestResult(object):
    r"""
    This class can be used to store arbitrary information as key-value pairs.
    The order is preserved, which means that items are serialized in the same
    order as they are put into the container.
    If strings contain characters, which have special meaning in the output format,
    they have to be escaped or the appropriate ``add...()`` method used.
    Keys should contain alphanumeric characters and underscore '_' only.

         Removed, because this info was added to CTestReportConfig as userInfo of type
         CYAMLMap. This way serialization.deserialization to/from YAML was more consistent.

        class CSerializableInfo : public ISerializable
        {
        private:
            class StrStrPair {
            public:
                std::string m_key;
                std::string m_value;

                StrStrPair(const std::string &key, const std::string &value) :
                    m_key(key),
                    m_value(value) {}
            };

            std::vector<StrStrPair> m_infoVector;

        public:

    Default ctor. Do not use it from other languages than C++. Call createInstance()
    instead./
            CSerializableInfo() {}

    Adds key / value pair without any modifications. /
            void add(const std::string &key, const std::string &value);

    Writes object's data to report!. /
            void serialize(isys::IEmitterSPtr &emitter) const;

    This method converts pointer to derived class to base class. It is required
    for scripting languages, which can not perform such conversion automatically. /
            isys::ISerializableSPtr upcast(const isys::CSerializableInfoSPtr &ptr);

    Create a new instance of this class. /
            static isys::CSerializableInfoSPtr createInstance();
        };
    This class contains expected results of coverage test. All values are
    in range [0..1], where 1 means 100%.
          Shared pointer for CCoverageTestResult.
    This class stores result of profiler test. This class is not intended to be
    instantiated by clients. Call isys::CTestCase::getTestResults() or similar
    method in the scripting language wrapper to get test results.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ERR_NONE = _connect.CProfilerTestResult_ERR_NONE
    r""" no error"""
    ERR_MIN = _connect.CProfilerTestResult_ERR_MIN
    r""" error on lower boundary"""
    ERR_MAX = _connect.CProfilerTestResult_ERR_MAX
    r""" error on upper boundary"""
    ERR_BOTH = _connect.CProfilerTestResult_ERR_BOTH
    r"""
    used for data values without value specified,
    which means that multiple values
    map to the same specification, so both boundaries
    may cause error.
    """

    def __init__(self, *args):
        _connect.CProfilerTestResult_swiginit(self, _connect.new_CProfilerTestResult(*args))

    def isValueSet(self) -> "bool":
        r"""
        Returns true, if data value in the test specification was set. For function
        profiling it always returns false.
        """
        return _connect.CProfilerTestResult_isValueSet(self)

    def isResultSet(self) -> "bool":
        r"""Returns true, if result was set for this area."""
        return _connect.CProfilerTestResult_isResultSet(self)

    def getMeasuredResult(self) -> "isys::CProfilerStatistics2":
        r""" Returns measured data, but only if isResultSet() returns true."""
        return _connect.CProfilerTestResult_getMeasuredResult(self)

    def isError(self) -> "bool":
        r"""
        Returns true, if any error occurred. Calls
        all ``validate...()`` methods.
        """
        return _connect.CProfilerTestResult_isError(self)

    def validateError(self, statsId: "isys::CTestProfilerStatistics::EProfilerStatisticsSectionId", timeId: "isys::CTestProfilerTime::EProfilerTimeSectionId") -> "isys::CProfilerTestResult::ProfilerErrCode":
        r""" Returns error status for the given time scope and time type."""
        return _connect.CProfilerTestResult_validateError(self, statsId, timeId)

    def validateAllTimes(self, prevError: "isys::CProfilerTestResult::ProfilerErrCode") -> "isys::CProfilerTestResult::ProfilerErrCode":
        r""" Returns error status for all time measurements."""
        return _connect.CProfilerTestResult_validateAllTimes(self, prevError)

    def validateTimeScopeForAllTimeTypes(self, statsId: "isys::CTestProfilerStatistics::EProfilerStatisticsSectionId") -> "isys::CProfilerTestResult::ProfilerErrCode":
        r""" Returns error status for the given time scope for all time types."""
        return _connect.CProfilerTestResult_validateTimeScopeForAllTimeTypes(self, statsId)

    def validateTimeTypeForAllScopes(self, timeTypeId: "isys::CTestProfilerTime::EProfilerTimeSectionId") -> "isys::CProfilerTestResult::ProfilerErrCode":
        r""" Returns error status for the given time type for all time scopes."""
        return _connect.CProfilerTestResult_validateTimeTypeForAllScopes(self, timeTypeId)

    def validateHits(self) -> "isys::CProfilerTestResult::ProfilerErrCode":
        r""" Checks for hits error."""
        return _connect.CProfilerTestResult_validateHits(self)

    def getMeasuredTime(self, statsId: "isys::CTestProfilerStatistics::EProfilerStatisticsSectionId", timeId: "isys::CTestProfilerTime::EProfilerTimeSectionId") -> "std::string":
        r"""
        Returns the number of hits as string. If this is data area with multiple
        measurements (for multiple states), then string 'min / max' is returned.
        """
        return _connect.CProfilerTestResult_getMeasuredTime(self, statsId, timeId)

    def getMeasuredHits(self) -> "std::string":
        r"""
        Returns the number of hits as string. If this is data area with multiple
        measurements (for multiple states), then string 'min / max' is returned.
        """
        return _connect.CProfilerTestResult_getMeasuredHits(self)

    def getExpectedResult(self) -> "CTestProfilerStatistics":
        r""" Returns constraints as specified in test specification."""
        return _connect.CProfilerTestResult_getExpectedResult(self)

    def getValue(self) -> "std::string":
        r"""
         Returns min time as specified in test specification.  Returns max time as specified in test specification.  Returns total time as specified in test specification.  Returns hits as specified in test specification.
        Returns value for this result. The value is valid only when isValueSet()
        returns true.
        """
        return _connect.CProfilerTestResult_getValue(self)

    def serialize(self, emitter: "isys::IEmitterSPtr const &") -> "void":
        r""" Writes object data to destination object."""
        return _connect.CProfilerTestResult_serialize(self, emitter)

    def serializeErrorsOnly(self, emitter: "isys::IEmitterSPtr const &") -> "void":
        r""" Writes object error data to destination object."""
        return _connect.CProfilerTestResult_serializeErrorsOnly(self, emitter)
    __swig_destroy__ = _connect.delete_CProfilerTestResult

# Register CProfilerTestResult in _connect:
_connect.CProfilerTestResult_swigregister(CProfilerTestResult)

class CLogResult(CTestBase):
    r"""
    This class stores results of ``log`` section. These values are
    not used for validating test, but for documentation purposes.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_BEFORE_ASSIGN = _connect.CLogResult_E_SECTION_BEFORE_ASSIGN
    r""" expression was evaluated before assignment was made"""
    E_SECTION_AFTER_ASSIGN = _connect.CLogResult_E_SECTION_AFTER_ASSIGN
    r""" expression was evaluated after assignment was made"""

    def __init__(self, parent: "isys::CTestBaseSPtr const &"):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestPoint class.
        """
        _connect.CLogResult_swiginit(self, _connect.new_CLogResult(parent))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CLogResult_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CLogResult":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CLogResult_cast(testBase)

    def serialize(self, emitter: "isys::IEmitterSPtr const &") -> "void":
        return _connect.CLogResult_serialize(self, emitter)

    def add(self, expr: "std::string const &", result: "std::string const &", logType: "isys::CLogResult::ETestResultSections") -> "void":
        r"""
        Add result of expression evaluation. Results should be added in the
        same order as expressions are specified in test spec.
        """
        return _connect.CLogResult_add(self, expr, result, logType)

    def getLog(self, expressions: "StrVector", results: "StrVector", logType: "isys::CLogResult::ETestResultSections") -> "void":
        r"""
        Returns expressions and their evaluated values. Sizes of both vectors are
        the same after return.
        """
        return _connect.CLogResult_getLog(self, expressions, results, logType)
    __swig_destroy__ = _connect.delete_CLogResult

# Register CLogResult in _connect:
_connect.CLogResult_swigregister(CLogResult)

def CLogResult_cast(testBase: "isys::CTestBaseSPtr const &") -> "CLogResult":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CLogResult_cast(testBase)

class CTestPointResult(CTestBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_TEST_POINT_ID = _connect.CTestPointResult_E_SECTION_TEST_POINT_ID
    E_SECTION_LOCATION = _connect.CTestPointResult_E_SECTION_LOCATION
    E_SECTION_EXEC_STATUS = _connect.CTestPointResult_E_SECTION_EXEC_STATUS
    E_SECTION_HIT_NO = _connect.CTestPointResult_E_SECTION_HIT_NO
    E_SECTION_STEP_IDX = _connect.CTestPointResult_E_SECTION_STEP_IDX
    E_SECTION_LOG_RESULT = _connect.CTestPointResult_E_SECTION_LOG_RESULT
    E_SECTION_SCRIPT_INFO_VAR = _connect.CTestPointResult_E_SECTION_SCRIPT_INFO_VAR
    E_SECTION_SCRIPT_RET_VAL = _connect.CTestPointResult_E_SECTION_SCRIPT_RET_VAL
    E_SECTION_EXPR_ERRORS = _connect.CTestPointResult_E_SECTION_EXPR_ERRORS
    EXECUTED = _connect.CTestPointResult_EXECUTED
    r""" test point was hit and assignments and verification were executed"""
    CONDITION_FALSE = _connect.CTestPointResult_CONDITION_FALSE
    r"""
    test point was hit, but condition was false, so assignments or
    verification were not executed
    """
    HIT_COUNT_FALSE = _connect.CTestPointResult_HIT_COUNT_FALSE
    r"""
    test point was hit, but hit count did not match, so assignments
    or verification were not executed
    """

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestPoint class.
        """
        _connect.CTestPointResult_swiginit(self, _connect.new_CTestPointResult(*args))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestPointResult_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestPointResult":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestPointResult_cast(testBase)

    def serialize(self, emitter: "isys::IEmitterSPtr const &") -> "void":
        return _connect.CTestPointResult_serialize(self, emitter)

    def isError(self) -> "bool":
        r"""
        Returns true, if there was script error, or any of the expected
        expressions evaluated to false.
        """
        return _connect.CTestPointResult_isError(self)

    def isExprError(self) -> "bool":
        r"""Returns true if at least one of expressions evaluated to false"""
        return _connect.CTestPointResult_isExprError(self)

    def isScriptError(self) -> "bool":
        r""" Returns true if script returned error description."""
        return _connect.CTestPointResult_isScriptError(self)

    def hasData(self) -> "bool":
        r"""
        Returns true, if any other data or error except hit number or
        step index is set. We don't want to save test point results
        if there are only hit number and step index set - this would mean
        a lot of data to save with little information value.
        """
        return _connect.CTestPointResult_hasData(self)

    def getExecStatus(self) -> "isys::CTestPointResult::EExecStatus":
        r"""
        Returns execution status - test point or stub may be hit, but not
        executed due to condition or hit count.
        """
        return _connect.CTestPointResult_getExecStatus(self)

    def getLogResult(self, isConst: "bool") -> "CLogResult":
        r""" Returns log result."""
        return _connect.CTestPointResult_getLogResult(self, isConst)

    def setLogResult(self, logResult: "isys::CLogResultSPtr const &") -> "void":
        r""" Sets log result."""
        return _connect.CTestPointResult_setLogResult(self, logResult)

    def getId(self) -> "std::string":
        r""" Returns test point ID or name of stubbed function."""
        return _connect.CTestPointResult_getId(self)

    def getLocation(self) -> "std::string":
        r""" Returns test point location as string."""
        return _connect.CTestPointResult_getLocation(self)

    def getHitNo(self) -> "int":
        return _connect.CTestPointResult_getHitNo(self)

    def getStepIdx(self) -> "int":
        return _connect.CTestPointResult_getStepIdx(self)

    def getScriptInfoVar(self) -> "std::string":
        return _connect.CTestPointResult_getScriptInfoVar(self)

    def getScriptRetVal(self) -> "std::string":
        return _connect.CTestPointResult_getScriptRetVal(self)

    def getExpressionErrors(self, expressions: "StrVector", results: "StrVector") -> "void":
        return _connect.CTestPointResult_getExpressionErrors(self, expressions, results)

    def setId(self, testPointId: "std::string const &") -> "void":
        r""" Sets test point ID of name of stubbed function."""
        return _connect.CTestPointResult_setId(self, testPointId)

    def setLocation(self, location: "std::string const &") -> "void":
        r""" Sets test point location as string. It is not used internally and can be any string."""
        return _connect.CTestPointResult_setLocation(self, location)

    def setExecStatus(self, execStatus: "isys::CTestPointResult::EExecStatus") -> "void":
        r""" Sets test point or stub execution status."""
        return _connect.CTestPointResult_setExecStatus(self, execStatus)

    def setHitNoAndStepIdx(self, hitNo: "int", stepIdx: "int") -> "void":
        r""" Sets hit number for test point or stub and step index."""
        return _connect.CTestPointResult_setHitNoAndStepIdx(self, hitNo, stepIdx)

    def setScriptInfoVar(self, scriptOutput: "std::string const &") -> "void":
        r""" Sets information returned by script function called on test point or stub hit."""
        return _connect.CTestPointResult_setScriptInfoVar(self, scriptOutput)

    def setScriptRetVal(self, scriptError: "std::string const &") -> "void":
        r""" Sets return value of script function called on test point or stub hit."""
        return _connect.CTestPointResult_setScriptRetVal(self, scriptError)

    def addExpressionError(self, expr: "std::string const &", result: "std::string const &") -> "void":
        r""" Sets error in expression evaluated on test point or stub hit."""
        return _connect.CTestPointResult_addExpressionError(self, expr, result)
    __swig_destroy__ = _connect.delete_CTestPointResult

# Register CTestPointResult in _connect:
_connect.CTestPointResult_swigregister(CTestPointResult)

def CTestPointResult_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestPointResult":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestPointResult_cast(testBase)

class CStackUsageResult(CTestBase):
    r"""This class stores result for stack usage."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_USAGE_BEFORE_TEST = _connect.CStackUsageResult_E_SECTION_USAGE_BEFORE_TEST
    E_SECTION_TEST_IDEA_USAGE = _connect.CStackUsageResult_E_SECTION_TEST_IDEA_USAGE
    E_SECTION_APPLICATION_USAGE = _connect.CStackUsageResult_E_SECTION_APPLICATION_USAGE
    E_SECTION_MAX_EXPECTED_SIZE = _connect.CStackUsageResult_E_SECTION_MAX_EXPECTED_SIZE

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestPoint class.
        """
        _connect.CStackUsageResult_swiginit(self, _connect.new_CStackUsageResult(*args))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CStackUsageResult_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CStackUsageResult":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CStackUsageResult_cast(testBase)

    def isError(self) -> "bool":
        r"""Returns true, if more stack usage was used than expected."""
        return _connect.CStackUsageResult_isError(self)

    def getMaxExpectedSize(self) -> "int":
        return _connect.CStackUsageResult_getMaxExpectedSize(self)

    def getUsageBeforeTest(self) -> "int":
        return _connect.CStackUsageResult_getUsageBeforeTest(self)

    def getTestIDEAUsage(self) -> "int":
        return _connect.CStackUsageResult_getTestIDEAUsage(self)

    def getApplicationUsage(self) -> "int":
        return _connect.CStackUsageResult_getApplicationUsage(self)

    def setValues(self, minExpSize: "ADDRESS_64", maxExpSize: "ADDRESS_64", stackUsedBeforeTest: "ADDRESS_64", testUsage: "ADDRESS_64", appUsage: "ADDRESS_64") -> "void":
        r"""
        Sets measured values of stack usage.
        :type minExpSize: int
        :param minExpSize: defines minimal expected stack size to be used, __currently__
                              __ignored__
        :type maxExpSize: int
        :param maxExpSize: defines maximal expected stack size to be used.
        :type stackUsedBeforeTest: int
        :param stackUsedBeforeTest: amount of stack used before test
        :type testUsage: int
        :param testUsage: amount of stack used for test, for example if test script
                             puts some data on stack before test.
        :type appUsage: int
        :param appUsage: amount of stack used by code under test
        """
        return _connect.CStackUsageResult_setValues(self, minExpSize, maxExpSize, stackUsedBeforeTest, testUsage, appUsage)
    __swig_destroy__ = _connect.delete_CStackUsageResult

# Register CStackUsageResult in _connect:
_connect.CStackUsageResult_swigregister(CStackUsageResult)

def CStackUsageResult_cast(testBase: "isys::CTestBaseSPtr const &") -> "CStackUsageResult":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CStackUsageResult_cast(testBase)

class CTestExprResult(CTestBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_EXPR_RESULT_EXPR = _connect.CTestExprResult_E_SECTION_EXPR_RESULT_EXPR
    E_SECTION_EXPR_RESULT_SUBEXPRS = _connect.CTestExprResult_E_SECTION_EXPR_RESULT_SUBEXPRS
    E_SECTION_EXPR_RESULT_IS_ERROR = _connect.CTestExprResult_E_SECTION_EXPR_RESULT_IS_ERROR

    def __init__(self, *args):
        _connect.CTestExprResult_swiginit(self, _connect.new_CTestExprResult(*args))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestExprResult_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestExprResult":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestExprResult_cast(testBase)

    def getExpression(self) -> "std::string":
        r""" Returns expression, which was evaluated."""
        return _connect.CTestExprResult_getExpression(self)

    def getSubexpressions(self, isConst: "bool") -> "isys::CMapAdapter":
        r""" Returns mapping of subexpressions and their values."""
        return _connect.CTestExprResult_getSubexpressions(self, isConst)

    def isError(self) -> "bool":
        r""" Returns *true* if expression evaluated to *true*, *false* otherwise."""
        return _connect.CTestExprResult_isError(self)

    def toUIString(self) -> "std::string":
        r""" Returns string with expression and indented subexpressions with values."""
        return _connect.CTestExprResult_toUIString(self)

    def setExpression(self, expression: "std::string const &") -> "void":
        r""" Sets expression, which was evaluated."""
        return _connect.CTestExprResult_setExpression(self, expression)

    def addSubexpression(self, subExpression: "std::string const &", value: "std::string const &") -> "void":
        r""" Adds subexpression and its value."""
        return _connect.CTestExprResult_addSubexpression(self, subExpression, value)

    def setError(self, isError: "bool") -> "void":
        r"""
        Sets expression result - if `isError` == false, expression evaluated to `true`,
        as expected.
        """
        return _connect.CTestExprResult_setError(self, isError)
    __swig_destroy__ = _connect.delete_CTestExprResult

# Register CTestExprResult in _connect:
_connect.CTestExprResult_swigregister(CTestExprResult)

def CTestExprResult_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestExprResult":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestExprResult_cast(testBase)

class CTestResult(CTestResultBase):
    r"""
    This class stores results of test case run. Normally it is not intended to be
    instantiated by clients - call isys::CTestCase::getTestResult() or similar
    method in the scripting language wrapper to get test results. However, if you'd
    like to create testIDE-like reports with custom scripts, feel free to use it.

    Python example from ``testResults.py``:



    Previous sample script also contains code for detailed result analysis. In many cases
    the simple method used in ``itestSample.py`` is enough:








    createTestReport.py Python example. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_RESULT_COMMENT = _connect.CTestResult_E_SECTION_RESULT_COMMENT
    r"""
    comment user enters in tesIDEA to be saved to report.
    It should describe conditions for particular test run.
    """
    E_SECTION_DEFAULT_DOWNLOAD_FILE = _connect.CTestResult_E_SECTION_DEFAULT_DOWNLOAD_FILE
    E_SECTION_STUB_RESULTS = _connect.CTestResult_E_SECTION_STUB_RESULTS
    E_SECTION_TEST_POINT_RESULTS = _connect.CTestResult_E_SECTION_TEST_POINT_RESULTS
    E_SECTION_STACK_USAGE_RESULTS = _connect.CTestResult_E_SECTION_STACK_USAGE_RESULTS
    E_SECTION_TARGET_EXCEPTION = _connect.CTestResult_E_SECTION_TARGET_EXCEPTION
    E_SECTION_PRE_CONDITION = _connect.CTestResult_E_SECTION_PRE_CONDITION
    E_SECTION_ASSERT = _connect.CTestResult_E_SECTION_ASSERT
    E_SECTION_LOG = _connect.CTestResult_E_SECTION_LOG
    E_SECTION_DRY_RUN_ASSIGNMENTS = _connect.CTestResult_E_SECTION_DRY_RUN_ASSIGNMENTS
    E_SECTION_DIAGRAMS = _connect.CTestResult_E_SECTION_DIAGRAMS
    E_SECTION_SCRIPT_ERRORS = _connect.CTestResult_E_SECTION_SCRIPT_ERRORS
    E_SECTION_SCRIPT_OUTPUT = _connect.CTestResult_E_SECTION_SCRIPT_OUTPUT

    def __init__(self, *args):
        _connect.CTestResult_swiginit(self, _connect.new_CTestResult(*args))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestResult_createInstance(self, parent)

    def getResultComment(self) -> "std::string":
        r"""
        Returns comment, which describes specific test run. This value is typically
        entered by user after test run and before saving test report.
        """
        return _connect.CTestResult_getResultComment(self)

    def getDefaultDownloadFile(self) -> "std::string":
        r"""
        Returns default download file name. It is set only when profiler was run
        during test.
        """
        return _connect.CTestResult_getDefaultDownloadFile(self)

    def getTestId(self) -> "std::string":
        r"""Returns the testId."""
        return _connect.CTestResult_getTestId(self)

    def getFunction(self) -> "std::string":
        r"""Returns the name of the function under test."""
        return _connect.CTestResult_getFunction(self)

    def getTestSpecification(self) -> "CTestSpecification":
        r"""
        Returns test specification, which produced this result. Usually this is
        the merged test specification.
        """
        return _connect.CTestResult_getTestSpecification(self)

    def getProfilerExportFileName(self) -> "std::string":
        r"""
        Returns name of the file, where profiler data was exported - this is
        real file name, without host variables (they were replaced with values
        before test execution and saved in this class).
        """
        return _connect.CTestResult_getProfilerExportFileName(self)

    def isError(self) -> "bool":
        r"""
        Returns true if any of possible errors occurred - expressions, profiler,
        coverage, exception, ...
        """
        return _connect.CTestResult_isError(self)

    def isException(self) -> "bool":
        r""" Returns true, if an exception was thrown."""
        return _connect.CTestResult_isException(self)

    def getExceptionString(self) -> "std::string":
        r""" If ``isException()`` returns true, this method returns the message of the exception."""
        return _connect.CTestResult_getExceptionString(self)

    def isTargetException(self) -> "bool":
        r""" Returns true, if exception was thrown by function on the target."""
        return _connect.CTestResult_isTargetException(self)

    def isExpressionError(self) -> "bool":
        r"""
         Returns true, if target values after test run don't match
        expected values given in test specification (section 'expected').
        """
        return _connect.CTestResult_isExpressionError(self)

    def isPreConditionError(self) -> "bool":
        r""" Returns true, if conditions verified before test failed."""
        return _connect.CTestResult_isPreConditionError(self)

    def isTargetExceptionError(self) -> "bool":
        r"""
        Returns true, if exception was thrown on target, but it is not expected as
        test result, or it is expected as test result, but it was not thrown on
        the target.
        """
        return _connect.CTestResult_isTargetExceptionError(self)

    def isCodeCoverageError(self) -> "bool":
        r""" Returns true, if coverage results don't match the test specification requirements."""
        return _connect.CTestResult_isCodeCoverageError(self)

    def isProfilerCodeError(self) -> "bool":
        r""" Returns true, if profiler code results don't match the test specification requirements."""
        return _connect.CTestResult_isProfilerCodeError(self)

    def isProfilerDataError(self) -> "bool":
        r""" Returns true, if profiler data results don't match the test specification requirements."""
        return _connect.CTestResult_isProfilerDataError(self)

    def isScriptError(self, *args) -> "bool":
        r"""
        *Overload 1:*
        Returns true, if there was error when executing script functions.

        |

        *Overload 2:*
        Returns true, if there was error when executing the given script function.
        """
        return _connect.CTestResult_isScriptError(self, *args)

    def isTestPointError(self) -> "bool":
        r""" Returns true, if there was error in test points."""
        return _connect.CTestResult_isTestPointError(self)

    def isStubError(self) -> "bool":
        r""" Returns true, if there was error in stub."""
        return _connect.CTestResult_isStubError(self)

    def isStackUsageError(self) -> "bool":
        r""" Returns true, if there was error in stack usage."""
        return _connect.CTestResult_isStackUsageError(self)

    def getScriptError(self, scriptFunctionType: "std::string const &") -> "std::string":
        r"""
        Returns string returned by the given script function.
        If there was no error, an empty string is returned.
        """
        return _connect.CTestResult_getScriptError(self, scriptFunctionType)

    def getScriptOutput(self, scriptFunctionType: "std::string const &") -> "std::string":
        r"""Returns everything printed to std out by script function."""
        return _connect.CTestResult_getScriptOutput(self, scriptFunctionType)

    def getPreConditionResults(self, isConst: "bool") -> "CTestBaseList":
        r""" Returns list of precondition evaluations."""
        return _connect.CTestResult_getPreConditionResults(self, isConst)

    def getAssertResults(self, isConst: "bool") -> "CTestBaseList":
        r""" Returns list of CTestExprResult -s, one item per assert expression."""
        return _connect.CTestResult_getAssertResults(self, isConst)

    def getLogResult(self, isConst: "bool") -> "CLogResult":
        r""" Returns object containing logged values."""
        return _connect.CTestResult_getLogResult(self, isConst)

    def getCoverageResults(self, resultMap: "StrCoverageTestResultsMap") -> "void":
        r""" Returns all coverage results."""
        return _connect.CTestResult_getCoverageResults(self, resultMap)

    def getCoverageResultsWithError(self, resultMap: "StrCoverageTestResultsMap") -> "void":
        r""" Returns only those coverage results, which do match expected values."""
        return _connect.CTestResult_getCoverageResultsWithError(self, resultMap)

    def getProfilerCodeResult(self, areaName: "std::string const") -> "CProfilerTestResult":
        r"""Returns profiler code result if exists, NULL otherwise."""
        return _connect.CTestResult_getProfilerCodeResult(self, areaName)

    def getProfilerCodeResults(self, resultMap: "StrProfilerTestResultsMap") -> "void":
        r""" Returns all profiler code results."""
        return _connect.CTestResult_getProfilerCodeResults(self, resultMap)

    def getProfilerDataResult(self, areaName: "std::string const") -> "CProfilerTestResult":
        r"""Returns profiler data result without value set if exists, NULL otherwise."""
        return _connect.CTestResult_getProfilerDataResult(self, areaName)

    def getProfilerDataResults(self, resultMap: "StrProfilerTestResultsMap") -> "void":
        r""" Returns all profiler data results."""
        return _connect.CTestResult_getProfilerDataResults(self, resultMap)

    def serialize(self, emitter: "isys::IEmitterSPtr const &", reportConfig: "isys::CTestReportConfigSPtr const &") -> "void":
        r"""
        Writes result to destination stream, which is usually associated with file.

        :type emitter: :py:class:`IEmitter`
        :param emitter: destination object for serialized data
        :type reportConfig: :py:class:`CTestReportConfig`
        :param reportConfig: report configuration. If set to NULL, default configuration
                                is used. If ``CTestReportConfig::setReportContents(RCONFIG_ERRORS_ONLY)``
                                is called, this call is identical to call serializeErrorsOnly() below.
        """
        return _connect.CTestResult_serialize(self, emitter, reportConfig)

    def serializeErrorsOnly(self, emitter: "isys::IEmitterSPtr const &", reportConfig: "isys::CTestReportConfigSPtr const &") -> "void":
        r"""
        Writes errors to destination stream, which is usually associated with file.

        :type emitter: :py:class:`IEmitter`
        :param emitter: destination object for serialized data
        :type reportConfig: :py:class:`CTestReportConfig`
        :param reportConfig: report configuration. If set to NULL, default configuration
                                is used.
        """
        return _connect.CTestResult_serializeErrorsOnly(self, emitter, reportConfig)

    def toString(self) -> "std::string":
        r"""
         Returns object's data as YAML string. This method is intended for debugging
        purposes only, do not parse the returned data!
        """
        return _connect.CTestResult_toString(self)

    def toUIString(self) -> "std::string":
        r""" Returns string readable also as pure text, only errors are included."""
        return _connect.CTestResult_toUIString(self)

    def diffsToUIString(self, section: "isys::CTestResult::ETestResultSection") -> "std::string":
        return _connect.CTestResult_diffsToUIString(self, section)

    def setTargetException(self, isTargetException: "bool") -> "void":
        r"""
        Set to true, if exception on target occurred during test.
        See also: #setTargetExceptionStr
        """
        return _connect.CTestResult_setTargetException(self, isTargetException)

    def setResultComment(self, resultComment: "std::string const &") -> "void":
        r""" Set arbitrary text to appear in test report, for example test description or purpose."""
        return _connect.CTestResult_setResultComment(self, resultComment)

    def setLogResult(self, logResult: "isys::CLogResultSPtr const &") -> "void":
        r""" Sets log result."""
        return _connect.CTestResult_setLogResult(self, logResult)

    def addExprResult(self, section: "isys::CTestResult::ETestResultSection", result: "isys::CTestExprResultSPtr &") -> "void":
        r"""
         Adds result of evaluated test expression.
        :type section: int
        :param section: should be CTestResult::E_SECTION_PRE_CONDITION, or
                   CTestResult::E_SECTION_ASSERT, if expression is evaluated
                   before or after test respectively.
        """
        return _connect.CTestResult_addExprResult(self, section, result)

    def addStubResult(self, result: "isys::CTestPointResultSPtr &") -> "void":
        r""" Adds stub result."""
        return _connect.CTestResult_addStubResult(self, result)

    def addTestPointResult(self, result: "isys::CTestPointResultSPtr &") -> "void":
        r""" Adds test point result."""
        return _connect.CTestResult_addTestPointResult(self, result)

    def setStackUsageResult(self, stackUsageResult: "isys::CStackUsageResultSPtr") -> "void":
        r""" Sets Stack usage result."""
        return _connect.CTestResult_setStackUsageResult(self, stackUsageResult)

    def setTargetExceptionStr(self, targetException: "std::string const &") -> "void":
        r"""
        Sets description of target exception.
        See also: #setTargetException
        """
        return _connect.CTestResult_setTargetExceptionStr(self, targetException)

    def appendScriptError(self, scriptFunctionType: "std::string const &", errorDesc: "std::string const &") -> "void":
        r""" Appends error message of script function."""
        return _connect.CTestResult_appendScriptError(self, scriptFunctionType, errorDesc)

    def appendScriptOutput(self, scriptFunctionType: "std::string const &", outStr: "std::string const &") -> "void":
        r""" Appends stdout of script function."""
        return _connect.CTestResult_appendScriptOutput(self, scriptFunctionType, outStr)

    def getAnalyzerFileName(self) -> "std::string":
        return _connect.CTestResult_getAnalyzerFileName(self)

    def getStubResults(self, isConst: "bool") -> "CTestBaseList":
        return _connect.CTestResult_getStubResults(self, isConst)

    def getTestPointResults(self, isConst: "bool") -> "CTestBaseList":
        return _connect.CTestResult_getTestPointResults(self, isConst)

    def getStackUsageResult(self, isConst: "bool") -> "CStackUsageResult":
        return _connect.CTestResult_getStackUsageResult(self, isConst)

    def setDefaultDownloadFile(self, defaultDlFileName: "std::string const &") -> "void":
        return _connect.CTestResult_setDefaultDownloadFile(self, defaultDlFileName)

    def setTestSpecification(self, testSpec: "isys::CTestSpecificationSPtr &") -> "void":
        return _connect.CTestResult_setTestSpecification(self, testSpec)

    def addDryRunAssignment(self, varName: "std::string const &", value: "std::string const &") -> "void":
        return _connect.CTestResult_addDryRunAssignment(self, varName, value)

    def addDiagram(self, imageFileName: "std::string const &") -> "void":
        return _connect.CTestResult_addDiagram(self, imageFileName)

    @staticmethod
    def funcType2PyVarName(scriptFunctionType: "std::string const &") -> "std::string":
        return _connect.CTestResult_funcType2PyVarName(scriptFunctionType)
    __swig_destroy__ = _connect.delete_CTestResult

# Register CTestResult in _connect:
_connect.CTestResult_swigregister(CTestResult)

def CTestResult_funcType2PyVarName(scriptFunctionType: "std::string const &") -> "std::string":
    return _connect.CTestResult_funcType2PyVarName(scriptFunctionType)

class CTestGroupResult(CTestResultBase):
    r"""
    This class defines group of test cases or other subgroups. It is
    intended to be used for grouping test cases per partition, module,
    function or custom criteria.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_NO_OF_TEST_CASES_IN_GROUP = _connect.CTestGroupResult_E_NO_OF_TEST_CASES_IN_GROUP
    E_NO_OF_FUNCTIONS_IN_GROUP = _connect.CTestGroupResult_E_NO_OF_FUNCTIONS_IN_GROUP
    E_NO_OF_MODULES_IN_GROUP = _connect.CTestGroupResult_E_NO_OF_MODULES_IN_GROUP
    E_NO_OF_PARTITIONS_IN_GROUP = _connect.CTestGroupResult_E_NO_OF_PARTITIONS_IN_GROUP
    E_EXCEPTION_MSG = _connect.CTestGroupResult_E_EXCEPTION_MSG
    E_PASSED_TCS = _connect.CTestGroupResult_E_PASSED_TCS
    E_FAILED_TCS = _connect.CTestGroupResult_E_FAILED_TCS
    E_ERROR_TCS = _connect.CTestGroupResult_E_ERROR_TCS
    E_PASSED_FUNCTIONS = _connect.CTestGroupResult_E_PASSED_FUNCTIONS
    E_FAILED_FUNCTIONS = _connect.CTestGroupResult_E_FAILED_FUNCTIONS
    E_ERROR_FUNCTIONS = _connect.CTestGroupResult_E_ERROR_FUNCTIONS
    E_PASSED_MODULES = _connect.CTestGroupResult_E_PASSED_MODULES
    E_FAILED_MODULES = _connect.CTestGroupResult_E_FAILED_MODULES
    E_ERROR_MODULES = _connect.CTestGroupResult_E_ERROR_MODULES
    E_PASSED_PARTITIONS = _connect.CTestGroupResult_E_PASSED_PARTITIONS
    E_FAILED_PARTITIONS = _connect.CTestGroupResult_E_FAILED_PARTITIONS
    E_ERROR_PARTITIONS = _connect.CTestGroupResult_E_ERROR_PARTITIONS
    E_FAILED_PRECOND = _connect.CTestGroupResult_E_FAILED_PRECOND
    E_FAILED_ASSERT = _connect.CTestGroupResult_E_FAILED_ASSERT
    E_FAILED_COVERAGE = _connect.CTestGroupResult_E_FAILED_COVERAGE
    E_FAILED_PROFILER_CODE = _connect.CTestGroupResult_E_FAILED_PROFILER_CODE
    E_FAILED_PROFILER_DATA = _connect.CTestGroupResult_E_FAILED_PROFILER_DATA
    E_FAILED_STUB = _connect.CTestGroupResult_E_FAILED_STUB
    E_FAILED_TEST_POINT = _connect.CTestGroupResult_E_FAILED_TEST_POINT
    E_FAILED_STACK_USAGE = _connect.CTestGroupResult_E_FAILED_STACK_USAGE
    E_FAILED_TARGET_EXCEPTIONS = _connect.CTestGroupResult_E_FAILED_TARGET_EXCEPTIONS
    E_SECTION_RESULT_COMMENT = _connect.CTestGroupResult_E_SECTION_RESULT_COMMENT
    E_SECTION_DEFAULT_DOWNLOAD_FILE = _connect.CTestGroupResult_E_SECTION_DEFAULT_DOWNLOAD_FILE
    E_SECTION_STACK_USAGE_RESULTS = _connect.CTestGroupResult_E_SECTION_STACK_USAGE_RESULTS
    E_SECTION_DIAGRAMS = _connect.CTestGroupResult_E_SECTION_DIAGRAMS
    E_MIN_TCS_FOR_FUNCTION = _connect.CTestGroupResult_E_MIN_TCS_FOR_FUNCTION
    E_AVG_TCS_FOR_FUNCTION = _connect.CTestGroupResult_E_AVG_TCS_FOR_FUNCTION
    E_MAX_TCS_FOR_FUNCTION = _connect.CTestGroupResult_E_MAX_TCS_FOR_FUNCTION
    E_FUNCTIONS_W_TEST_CASES = _connect.CTestGroupResult_E_FUNCTIONS_W_TEST_CASES
    E_MODULES_W_TEST_CASES = _connect.CTestGroupResult_E_MODULES_W_TEST_CASES
    E_PARTITIONS_W_TEST_CASES = _connect.CTestGroupResult_E_PARTITIONS_W_TEST_CASES
    E_SCRIPT_ERRORS = _connect.CTestGroupResult_E_SCRIPT_ERRORS
    E_SCRIPT_OUTPUT = _connect.CTestGroupResult_E_SCRIPT_OUTPUT
    E_TCS_PER_MODULE = _connect.CTestGroupResult_E_TCS_PER_MODULE
    E_TCS_PER_PARTITION = _connect.CTestGroupResult_E_TCS_PER_PARTITION
    E_CVRG_DOCUMENT = _connect.CTestGroupResult_E_CVRG_DOCUMENT
    E_CVRG_EXPORT_FILE = _connect.CTestGroupResult_E_CVRG_EXPORT_FILE
    E_CVRG_STAT_FOR_ALL_ITEMS = _connect.CTestGroupResult_E_CVRG_STAT_FOR_ALL_ITEMS
    E_CVRG_STAT_FOR_TESTED_ITEMS = _connect.CTestGroupResult_E_CVRG_STAT_FOR_TESTED_ITEMS
    E_SRC_LINE_CVRG = _connect.CTestGroupResult_E_SRC_LINE_CVRG
    E_FUNC_STATS = _connect.CTestGroupResult_E_FUNC_STATS

    def __init__(self, *args):
        _connect.CTestGroupResult_swiginit(self, _connect.new_CTestGroupResult(*args))
    __swig_destroy__ = _connect.delete_CTestGroupResult

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestGroupResult_createInstance(self, parent)

    def isMerged(self) -> "bool":
        r"""Overrides base method, always returns false, because groups can't be merged."""
        return _connect.CTestGroupResult_isMerged(self)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestGroupResult":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestGroupResult_cast(testBase)

    def isException(self) -> "bool":
        r"""
        Returns true, if group result could not be created because of an error
        during test execution.
        """
        return _connect.CTestGroupResult_isException(self)

    def getExceptionString(self) -> "std::string":
        r"""Returns exception message or empty string if there was no exception thrown."""
        return _connect.CTestGroupResult_getExceptionString(self)

    def isError(self) -> "bool":
        r"""Returns true, if coverage criteria in the group are not met."""
        return _connect.CTestGroupResult_isError(self)

    def isErrorInChildTestCases(self) -> "bool":
        r"""Returns true, if there was error in any child test case."""
        return _connect.CTestGroupResult_isErrorInChildTestCases(self)

    def isChildGroupError(self) -> "bool":
        r"""
        Returns true, if there was an error in any of the child groups. Only
        group criteria is taken into account, without test cases.
        """
        return _connect.CTestGroupResult_isChildGroupError(self)

    def getIntValue(self, section: "isys::CTestGroupResult::EGroupResultSection") -> "int":
        r""" Returns value of the specified section."""
        return _connect.CTestGroupResult_getIntValue(self, section)

    def getResultComment(self) -> "std::string":
        r""" Returns result comment."""
        return _connect.CTestGroupResult_getResultComment(self)

    def getDefaultDownloadFile(self) -> "std::string":
        r""" Returns default download file."""
        return _connect.CTestGroupResult_getDefaultDownloadFile(self)

    def getStackUsageResult(self, isConst: "bool") -> "CStackUsageResult":
        r""" Returns max stack usage values of all children test cases."""
        return _connect.CTestGroupResult_getStackUsageResult(self, isConst)

    def getCoverageResultForTestedCode(self, isConst: "bool") -> "CTestCoverageResult":
        r""" Returns coverage statistic for all functions, which have test cases."""
        return _connect.CTestGroupResult_getCoverageResultForTestedCode(self, isConst)

    def getCoverageResultForAllCode(self, isConst: "bool") -> "CTestCoverageResult":
        r""" Returns coverage statistic for all functions in a group, including those without test cases."""
        return _connect.CTestGroupResult_getCoverageResultForAllCode(self, isConst)

    def getFunctionStatList(self, isConst: "bool") -> "CTestBaseList":
        r""" Returns list of coverage statistics for functions in a group."""
        return _connect.CTestGroupResult_getFunctionStatList(self, isConst)

    def isScriptError(self, *args) -> "bool":
        r"""
        *Overload 1:*
        Returns true, if there was error when executing script functions.

        |

        *Overload 2:*
        Returns true, if there was error when executing the given script function.
        """
        return _connect.CTestGroupResult_isScriptError(self, *args)

    def isStackUsageError(self) -> "bool":
        return _connect.CTestGroupResult_isStackUsageError(self)

    def getScriptError(self, scriptFunctionType: "std::string const &") -> "std::string":
        r"""
        Returns string returned by the given script function.
        If there was no error, an empty string is returned.
        """
        return _connect.CTestGroupResult_getScriptError(self, scriptFunctionType)

    def getScriptOutput(self, scriptFunctionType: "std::string const &") -> "std::string":
        r"""Returns everything printed to std out by script function."""
        return _connect.CTestGroupResult_getScriptOutput(self, scriptFunctionType)

    def getFailedSections(self) -> "std::string":
        r"""
        Returns human readable string with comma separated list of sections,
        which have failed at least in one test case.
        """
        return _connect.CTestGroupResult_getFailedSections(self)

    def appendScriptError(self, scriptFunctionType: "std::string const &", errorDesc: "std::string const &") -> "void":
        return _connect.CTestGroupResult_appendScriptError(self, scriptFunctionType, errorDesc)

    def appendScriptOutput(self, scriptFunctionType: "std::string const &", outStr: "std::string const &") -> "void":
        return _connect.CTestGroupResult_appendScriptOutput(self, scriptFunctionType, outStr)

    def toUIString(self) -> "std::string":
        r""" Returns string readable also as pure text, only errors are included."""
        return _connect.CTestGroupResult_toUIString(self)

# Register CTestGroupResult in _connect:
_connect.CTestGroupResult_swigregister(CTestGroupResult)

def CTestGroupResult_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestGroupResult":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestGroupResult_cast(testBase)

class CTestGrpFuncStat(CTestBase):
    r""" This class contains statistics for all test cases for one function in a group."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_QUAL_FUNC_NAME = _connect.CTestGrpFuncStat_E_QUAL_FUNC_NAME
    E_TESTS_PASSED = _connect.CTestGrpFuncStat_E_TESTS_PASSED
    E_TESTS_FAILED = _connect.CTestGrpFuncStat_E_TESTS_FAILED
    E_TESTS_ERROR = _connect.CTestGrpFuncStat_E_TESTS_ERROR
    E_CVRG_BYTES_ALL = _connect.CTestGrpFuncStat_E_CVRG_BYTES_ALL
    E_CVRG_BYTES_EXECUTED = _connect.CTestGrpFuncStat_E_CVRG_BYTES_EXECUTED
    E_CVRG_COND_ALL = _connect.CTestGrpFuncStat_E_CVRG_COND_ALL
    E_CVRG_COND_FALSE = _connect.CTestGrpFuncStat_E_CVRG_COND_FALSE
    E_CVRG_COND_TRUE = _connect.CTestGrpFuncStat_E_CVRG_COND_TRUE
    E_CVRG_COND_BOTH = _connect.CTestGrpFuncStat_E_CVRG_COND_BOTH
    E_CVRG_EXECUTION_COUNT = _connect.CTestGrpFuncStat_E_CVRG_EXECUTION_COUNT

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new instance.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: reference to group which generate this result.
        """
        _connect.CTestGrpFuncStat_swiginit(self, _connect.new_CTestGrpFuncStat(*args))

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestGrpFuncStat_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestGrpFuncStat":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestGrpFuncStat_cast(testBase)

    def getNoOfTestCases(self) -> "int":
        r""" Returns the number of executed test cases."""
        return _connect.CTestGrpFuncStat_getNoOfTestCases(self)

    def getQualFuncName(self) -> "std::string":
        r""" Returns name of qualified function."""
        return _connect.CTestGrpFuncStat_getQualFuncName(self)

    def getCoverage(self, section: "isys::CTestGrpFuncStat::ESectionFuncTestStats") -> "int":
        r""" Returns coverage info for the given section. Valid values are E_CVRG_..."""
        return _connect.CTestGrpFuncStat_getCoverage(self, section)
    __swig_destroy__ = _connect.delete_CTestGrpFuncStat

# Register CTestGrpFuncStat in _connect:
_connect.CTestGrpFuncStat_swigregister(CTestGrpFuncStat)

def CTestGrpFuncStat_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestGrpFuncStat":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestGrpFuncStat_cast(testBase)

class IEmitter(object):
    r"""
    This interface defines methods to be implemented by concrete emitters.
    Emitters are classes, which receive data from data objects, and write
    it to the given stream in specific format. For example, isys::CXMLEmitter writes
    the data in XML format.

    This abstract class can be used from C++ only.

    Example:


      CfileStreamSPtr xmlReportFileStream(new CFileStream("fullReport.xml"));
      IEmitterSPtr xmlReportEmitter = ic.EmitterFactory.createXmlEmitter(xmlReportFileStream);
      xmlReportEmitter.startStream('<?xml-stylesheet type="text/xsl" href="itestResult.xslt"?>\n');

      // add content
      xmlReportEmitter.startDocument(true);
      testResult_1.serialize(xmlReportEmitter);
      xmlReportEmitter.endDocument(true);

      xmlReportEmitter.startDocument(true);
      testResult_2.serialize(xmlReportEmitter);
      xmlReportEmitter.endDocument(true);

      xmlReportEmitter.endStream();
      xmlReportFileStream.close();


    See also: isys::CYAMLEmitter and isys::CXMLEmitter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ETestReportConfig = _connect.IEmitter_ETestReportConfig
    ETestReportStatistics = _connect.IEmitter_ETestReportStatistics
    ETestReport = _connect.IEmitter_ETestReport
    LINE_NUM_NOT_SET = _connect.IEmitter_LINE_NUM_NOT_SET
    EYAML_ANY_STYLE = _connect.IEmitter_EYAML_ANY_STYLE
    r""" any style is allowed"""
    EYAML_FLOW_STYLE = _connect.IEmitter_EYAML_FLOW_STYLE
    r""" uses [] for sequences, {} for maps"""
    EYAML_BLOCK_STYLE = _connect.IEmitter_EYAML_BLOCK_STYLE
    r""" moves to next line"""

    def getIndent(self) -> "std::string":
        r""" Returns indentation string added to each line of output."""
        return _connect.IEmitter_getIndent(self)

    def setIndent(self, indent: "std::string const &") -> "void":
        r""" Sets indentation string added to each line of output."""
        return _connect.IEmitter_setIndent(self, indent)

    def getLineNumber(self) -> "int":
        r"""
        This method provides information about current line being written
                   to the file. Not all emitters may provide this information. If emitter
                   does not keep track of line numbers, this method should return LINE_NUM_NOT_SET.
                   Emitter may return the number of all lines (for example CCSVEmitter).
        """
        return _connect.IEmitter_getLineNumber(self)

    def getRow(self, row: "StrVector", rowIndex: "int") -> "void":
        r"""
        This method returns row for the given index. Not all emitters may
        implement this method - an exception is throw in such case.
        """
        return _connect.IEmitter_getRow(self, row, rowIndex)

    def setLineNumber(self, lineNumber: "int") -> "void":
        r"""
        Can be used to set current line number in cases, where emitter does not
        start at the beginning of the stream, or to disable line counting by
        setting 'lineNumber' to LINE_NUM_NOT_SET. This is also the default value,
        so to enable line counting, call this method with value >= 0.
        """
        return _connect.IEmitter_setLineNumber(self, lineNumber)

    def startStream(self, *args) -> "void":
        r"""
        *Overload 1:*
         Initializes the output stream object.

        |

        *Overload 2:*

        Initializes the output stream object.

        :type userData: string
        :param userData: text written directly to output stream, bypassing the
                   underlying emitter. This can be used for writing comments or
                   preprocessing instructions.
        """
        return _connect.IEmitter_startStream(self, *args)

    def endStream(self) -> "void":
        r"""
        Ends output stream. The output stream is NOT
        closed. Call this method after emitting is done.
        """
        return _connect.IEmitter_endStream(self)

    def startDocument(self, implicit: "bool") -> "void":
        r"""
        Starts the document. This method should be called after startStream().

        :type implicit: boolean
        :param implicit: currently used by YAML emitter only. When true, the
                            document is emitted without the leading '---'.
        """
        return _connect.IEmitter_startDocument(self, implicit)

    def endDocument(self, implicit: "bool") -> "void":
        r"""
        Ends the document.

        :type implicit: boolean
        :param implicit: if the document end indicator is implicit. It is
            considered as a stylistic parameter and may be ignored by the emitter.
            If true, YAML emitter adds terminating doc sequence: '...'
        """
        return _connect.IEmitter_endDocument(self, implicit)

    def escapeSpecialChars(self, data: "std::string const &") -> "std::string":
        r"""
        This method modifies the input string so that it is in proper syntax
        for scalars. See CYAMLEmitter::escapeSpecialChars()
        and CXMLEmitter::escapeSpecialChars().
        """
        return _connect.IEmitter_escapeSpecialChars(self, data)

    def flush(self) -> "void":
        r"""Flush the accumulated characters to the output."""
        return _connect.IEmitter_flush(self)

    def mapStart(self, *args) -> "void":
        return _connect.IEmitter_mapStart(self, *args)

    def writeMapEnd(self) -> "void":
        return _connect.IEmitter_writeMapEnd(self)

    def mapEnd(self) -> "void":
        return _connect.IEmitter_mapEnd(self)

    def sequenceStart(self, *args) -> "void":
        return _connect.IEmitter_sequenceStart(self, *args)

    def sequenceEnd(self) -> "void":
        return _connect.IEmitter_sequenceEnd(self)

    def writeSequenceEnd(self) -> "void":
        return _connect.IEmitter_writeSequenceEnd(self)

    def writeString(self, yamlData: "std::string const &") -> "void":
        return _connect.IEmitter_writeString(self, yamlData)

    def writeText(self, text: "std::string const &") -> "void":
        r"""Writes unmodified text to output."""
        return _connect.IEmitter_writeText(self, text)
    __swig_destroy__ = _connect.delete_IEmitter

# Register IEmitter in _connect:
_connect.IEmitter_swigregister(IEmitter)

class IStream(object):
    r"""
    This interface provides common methods for streams. It can be used
    from C++ only.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def write(self, str: "std::string const &") -> "void":
        r"""
        Writes string to output. Use this method to add custom data to
        output file. However, take care to keep the file format valid,
        for example if it is XML file, to use tags consistently.
        """
        return _connect.IStream_write(self, str)

    def close(self) -> "void":
        r"""
        Closes the underlying stream. If this method is not called, not
        all data may be written to the output.
        """
        return _connect.IStream_close(self)
    __swig_destroy__ = _connect.delete_IStream

# Register IStream in _connect:
_connect.IStream_swigregister(IStream)

class CStringStream(IStream):
    r"""
    This class writes data to string stream.

    cumulativeCoverage.py Python example with coverage. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Creates object with empty string stream."""
        _connect.CStringStream_swiginit(self, _connect.new_CStringStream())

    def write(self, str: "std::string const &") -> "void":
        r"""
        Writes string to output. Use this method to add custom data to
        output file. However, take care to keep the file format valid,
        for example if it is XML file, to use tags consistently.
        """
        return _connect.CStringStream_write(self, str)

    def close(self) -> "void":
        r"""
        Closes the underlying stream. If this method is not called, not
        all data may be written to the output.
        """
        return _connect.CStringStream_close(self)

    def getString(self) -> "std::string":
        r"""Returns contents of this stream as a string."""
        return _connect.CStringStream_getString(self)
    __swig_destroy__ = _connect.delete_CStringStream

# Register CStringStream in _connect:
_connect.CStringStream_swigregister(CStringStream)

class CFileStream(IStream):
    r"""
    This class should be used by client applications to create native
    file stream for emitter output.

    cumulativeCoverage.py Python example with coverage. 

    emitterDemo.py Python example. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fileName: "std::string const &", isAppend: "bool"=False):
        r"""
        Output will be written to file.

        :type fileName: string
        :param fileName: name of the output file
        :type isAppend: boolean, optional
        :param isAppend: if true, output is appended to the existing
                            contents of file. If false, the file contents
                            is erased.
        """
        _connect.CFileStream_swiginit(self, _connect.new_CFileStream(fileName, isAppend))

    def write(self, str: "std::string const &") -> "void":
        r"""
        Writes string to output. Use this method to add custom data to
        output file. However, take care to keep the file format valid,
        for example if it is XML file, to use tags consistently.
        """
        return _connect.CFileStream_write(self, str)

    def close(self) -> "void":
        r"""
        Closes the underlying stream. If this method is not called, not
        all data may be written to the output.
        """
        return _connect.CFileStream_close(self)
    __swig_destroy__ = _connect.delete_CFileStream

# Register CFileStream in _connect:
_connect.CFileStream_swigregister(CFileStream)

class EmitterFactory(object):
    r"""
    This is a factory class for emitters. Emitters can be used to write
    iSystem test results to file. See isys::CTestResult.

    cumulativeCoverage.py Python example with coverage. 

    emitterDemo.py Python example. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def createYamlEmitter(stream: "isys::IStreamSPtr &") -> "isys::IEmitterSPtr":
        r""" Creates emitter for YAML format."""
        return _connect.EmitterFactory_createYamlEmitter(stream)

    @staticmethod
    def createCSVEmitter(fileStream: "isys::IStreamSPtr &", separator: "std::string const &", isHeaderLine: "bool") -> "isys::IEmitterSPtr":
        r""" Creates emitter for CSV format."""
        return _connect.EmitterFactory_createCSVEmitter(fileStream, separator, isHeaderLine)

    def __init__(self):
        _connect.EmitterFactory_swiginit(self, _connect.new_EmitterFactory())
    __swig_destroy__ = _connect.delete_EmitterFactory

# Register EmitterFactory in _connect:
_connect.EmitterFactory_swigregister(EmitterFactory)

def EmitterFactory_createYamlEmitter(stream: "isys::IStreamSPtr &") -> "isys::IEmitterSPtr":
    r""" Creates emitter for YAML format."""
    return _connect.EmitterFactory_createYamlEmitter(stream)

def EmitterFactory_createCSVEmitter(fileStream: "isys::IStreamSPtr &", separator: "std::string const &", isHeaderLine: "bool") -> "isys::IEmitterSPtr":
    r""" Creates emitter for CSV format."""
    return _connect.EmitterFactory_createCSVEmitter(fileStream, separator, isHeaderLine)

class CTestSpecification(CTestTreeNode):
    r"""
    This class encapsulates all data required for one test. It
    is the top level class aggregating all other classes related to
    test specification. It may also contain children, which inherit
    parts of specification.

    Python example from ``cumulativeModuleCoverage.py``:

    \skipline runDerivedTests

    This class is directly or indirectly used in all test examples.
    <p>
    @link cumulativeCoverage.py                Python example with coverage. @endlink<br>
    @link cumulativeModuleCoverage.py          Python example with module coverage. @endlink<br>
    @link itestWithParameters.py               Python example modifies function parameters. @endlink<br>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_ID = _connect.CTestSpecification_E_SECTION_ID
    E_SECTION_TEST_SCOPE = _connect.CTestSpecification_E_SECTION_TEST_SCOPE
    E_SECTION_BASE_ID = _connect.CTestSpecification_E_SECTION_BASE_ID
    E_SECTION_RUN = _connect.CTestSpecification_E_SECTION_RUN
    E_SECTION_IMPORTS = _connect.CTestSpecification_E_SECTION_IMPORTS
    E_SECTION_DESC = _connect.CTestSpecification_E_SECTION_DESC
    E_SECTION_TAGS = _connect.CTestSpecification_E_SECTION_TAGS
    E_SECTION_OPTIONS = _connect.CTestSpecification_E_SECTION_OPTIONS
    E_SECTION_PERSIST_VARS = _connect.CTestSpecification_E_SECTION_PERSIST_VARS
    E_SECTION_LOCALS = _connect.CTestSpecification_E_SECTION_LOCALS
    E_SECTION_INIT = _connect.CTestSpecification_E_SECTION_INIT
    E_SECTION_BEGIN_STOP_CONDITION = _connect.CTestSpecification_E_SECTION_BEGIN_STOP_CONDITION
    E_SECTION_END_STOP_CONDITION = _connect.CTestSpecification_E_SECTION_END_STOP_CONDITION
    E_SECTION_FUNC = _connect.CTestSpecification_E_SECTION_FUNC
    E_SECTION_TIMEOUT = _connect.CTestSpecification_E_SECTION_TIMEOUT
    E_SECTION_CORE_ID = _connect.CTestSpecification_E_SECTION_CORE_ID
    E_SECTION_INIT_TARGET = _connect.CTestSpecification_E_SECTION_INIT_TARGET
    E_SECTION_INITFUNC = _connect.CTestSpecification_E_SECTION_INITFUNC
    E_SECTION_ENDFUNC = _connect.CTestSpecification_E_SECTION_ENDFUNC
    E_SECTION_RESTORE_TARGET = _connect.CTestSpecification_E_SECTION_RESTORE_TARGET
    E_SECTION_STUBS = _connect.CTestSpecification_E_SECTION_STUBS
    E_SECTION_USER_STUBS = _connect.CTestSpecification_E_SECTION_USER_STUBS
    E_SECTION_TEST_POINTS = _connect.CTestSpecification_E_SECTION_TEST_POINTS
    E_SECTION_PRE_CONDITION = _connect.CTestSpecification_E_SECTION_PRE_CONDITION
    E_SECTION_ASSERT = _connect.CTestSpecification_E_SECTION_ASSERT
    E_SECTION_STACK_USAGE = _connect.CTestSpecification_E_SECTION_STACK_USAGE
    E_SECTION_LOG = _connect.CTestSpecification_E_SECTION_LOG
    E_SECTION_ANALYZER = _connect.CTestSpecification_E_SECTION_ANALYZER
    E_SECTION_HIL = _connect.CTestSpecification_E_SECTION_HIL
    E_SECTION_DRY_RUN = _connect.CTestSpecification_E_SECTION_DRY_RUN
    E_SECTION_DIAGRAMS = _connect.CTestSpecification_E_SECTION_DIAGRAMS
    E_SECTION_TESTS = _connect.CTestSpecification_E_SECTION_TESTS
    E_SECTION_PARAMS_PRIVATE = _connect.CTestSpecification_E_SECTION_PARAMS_PRIVATE
    E_SECTION_TRACE = _connect.CTestSpecification_E_SECTION_TRACE
    E_SECTION_COVERAGE = _connect.CTestSpecification_E_SECTION_COVERAGE
    E_SECTION_PROFILER = _connect.CTestSpecification_E_SECTION_PROFILER
    E_SECTION_EXPECT = _connect.CTestSpecification_E_SECTION_EXPECT
    E_UNIT_TEST = _connect.CTestSpecification_E_UNIT_TEST
    r"""
    function is tested, test starts with a function call
    and ends when the function returns
    """
    E_SYSTEM_TEST = _connect.CTestSpecification_E_SYSTEM_TEST
    r""" system is tested, test end is specified as breakpoint or timeout"""

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Should be used for root specification only.

        |

        *Overload 2:*
        Creates an empty instance with the given parent.
        """
        _connect.CTestSpecification_swiginit(self, _connect.new_CTestSpecification(*args))
    __swig_destroy__ = _connect.delete_CTestSpecification

    def getUILabel(self) -> "std::string":
        r""" Returns label to be shown in testIDEA."""
        return _connect.CTestSpecification_getUILabel(self)

    def isGroup(self) -> "bool":
        r""" Returns true, if this object is of type CTestGroup, false if it is CTestSpecification."""
        return _connect.CTestSpecification_isGroup(self)

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        r"""
        Creates an empty instance of this class.

        :type parent: :py:class:`CTestBase`
        :param parent: must be of instance CTestSpecification, since other classes
                   can not be parents of CTestSpecification.
        """
        return _connect.CTestSpecification_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestSpecification":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestSpecification_cast(testBase)

    def assign(self, testSpec: "isys::CTestObjectSPtr const &") -> "void":
        return _connect.CTestSpecification_assign(self, testSpec)

    def getContainerTestNode(self) -> "CTestTreeNode":
        r"""
        Always returns this. This method is overridden from CTestBase,
        and is used by other aggregated classes to find the container test spec,
        which is this.
        """
        return _connect.CTestSpecification_getContainerTestNode(self)

    def getParentTestSpecification(self) -> "CTestSpecification":
        r"""Returns parent test specification or NULL, if this is the root specification."""
        return _connect.CTestSpecification_getParentTestSpecification(self)

    def getSourceLineNumber(self) -> "int":
        r"""
         Returns number of the line in file, where this test spec is defined, or
        -1 if not set. This value is not valid, after test specification is moved
        to other location in test tree or pasted from clipboard. In such cases it
        shows the source, where the test specification WILL be saved.
        """
        return _connect.CTestSpecification_getSourceLineNumber(self)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestSpecification_isMerged(self)

    def isTestSpecification(self) -> "bool":
        r""" Always returns true. Needed because type info is lost with SWIG."""
        return _connect.CTestSpecification_isTestSpecification(self)

    def getCachedMergedTestSpec(self, *args) -> "CTestBase":
        r"""
        *Overload 1:*

        If section is merged, returns cached merged test spec., which was set with
        setCachedMergedTestSpec(), else null is returned.
        Needed for optimization purposes.

        |

        *Overload 2:*

        Returns merged test spec, if set, null otherwise.
        """
        return _connect.CTestSpecification_getCachedMergedTestSpec(self, *args)

    def setCachedMergedTestSpec(self, mergedTestSpec: "isys::CTestSpecificationSPtr &") -> "void":
        r"""
        Caches merged test spec. to be used in subsequent calls. Needed for
        optimization purposes.
        """
        return _connect.CTestSpecification_setCachedMergedTestSpec(self, mergedTestSpec)

    def getId(self) -> "std::string":
        r""" Return true, if there is no data in test specification.  Returns test id as specified in tag **id**."""
        return _connect.CTestSpecification_getId(self)

    def getTestId(self) -> "std::string":
        r""" Deprecated since Jan 2016. Use getId() instead."""
        return _connect.CTestSpecification_getTestId(self)

    def getBaseId(self) -> "std::string":
        r"""
        Returns id of the parent. This tag is used only when test specifications
        are specified in the source code file, and is ignored otherwise.
        """
        return _connect.CTestSpecification_getBaseId(self)

    def getRunFlag(self) -> "iconnect::ETristate":
        r"""
        Returns run flag. If value is E_TRUE or E_DEFAULT,
        test specification should be executed - it is not used just as a base class.
        """
        return _connect.CTestSpecification_getRunFlag(self)

    def getDescription(self) -> "std::string":
        r""" Returns test description as specified in tag **description**."""
        return _connect.CTestSpecification_getDescription(self)

    def getTags(self, tags: "StrVector") -> "void":
        r""" Returns test tags as specified in tag **tags**."""
        return _connect.CTestSpecification_getTags(self, tags)

    def getTestScope(self) -> "isys::CTestSpecification::ETestScope":
        r""" Returns test type - unit or system test."""
        return _connect.CTestSpecification_getTestScope(self)

    def getFunctionUnderTest(self, isConst: "bool") -> "CTestFunction":
        r""" Returns specification for the function under test."""
        return _connect.CTestSpecification_getFunctionUnderTest(self, isConst)

    def getTestTimeout(self) -> "int":
        r"""
        Returns timeout (in milliseconds), after which test execution is terminated.
        Value 0 means infinite timeout. If this value is not specified,
        this method returns -1 (global timeout setting will be used).
        """
        return _connect.CTestSpecification_getTestTimeout(self)

    def getCoreId(self) -> "std::string":
        r"""
        Returns ID of CPU core, where this test case should be executed,
        or empty string if core ID is not specified.
        """
        return _connect.CTestSpecification_getCoreId(self)

    def getPositionParams(self, params: "StrVector") -> "void":
        r""" Returns function parameters specified in 'func:' section."""
        return _connect.CTestSpecification_getPositionParams(self, params)

    def hasPositionParams(self) -> "bool":
        r""" Returns true, if there are function parameters specified in 'func:' section."""
        return _connect.CTestSpecification_hasPositionParams(self)

    def getInitFunction(self, isConst: "bool") -> "CTestFunction":
        r"""
        Returns specification for the ``init`` function,
        which is called just before the function under test is
        executed.
        """
        return _connect.CTestSpecification_getInitFunction(self, isConst)

    def getEndFunction(self, isConst: "bool") -> "CTestFunction":
        r"""
        Returns specification for the ``end`` function,
        which is called immediately after the function under test is
        executed.
        """
        return _connect.CTestSpecification_getEndFunction(self, isConst)

    def getInitTargetFunction(self, isConst: "bool") -> "CTestFunction":
        r"""
        Returns specification for script function to be called before any test
        initialization is done. Use it to initialize target before test.
        """
        return _connect.CTestSpecification_getInitTargetFunction(self, isConst)

    def getRestoreTargetFunction(self, isConst: "bool") -> "CTestFunction":
        r"""
        Returns specification for script function to be called after test environment
        on the stack is destroyed. Use it to restore target state after test.
        """
        return _connect.CTestSpecification_getRestoreTargetFunction(self, isConst)

    def getStubs(self, isConst: "bool") -> "CTestBaseList":
        r"""Returns stubs in another type of container."""
        return _connect.CTestSpecification_getStubs(self, isConst)

    def getStub(self, functionName: "std::string const &") -> "CTestStub":
        r""" Returns stub object for the given function."""
        return _connect.CTestSpecification_getStub(self, functionName)

    def getUserStubs(self, isConst: "bool") -> "CTestBaseList":
        r"""
        Returns reference to list of all user stub specifications. New stubs
        can be added by adding them to the returned vector.
        """
        return _connect.CTestSpecification_getUserStubs(self, isConst)

    def getUserStub(self, functionName: "std::string const &") -> "CTestUserStub":
        r""" Returns user stub object for the given function."""
        return _connect.CTestSpecification_getUserStub(self, functionName)

    def getTestPoints(self, isConst: "bool") -> "CTestBaseList":
        r"""
        Returns reference to list of all test point specifications. New
        test points can be added by adding them to the returned vector.
        """
        return _connect.CTestSpecification_getTestPoints(self, isConst)

    def getTestPoint(self, testPointId: "std::string const &") -> "CTestPoint":
        r"""
        Returns test point object for the given id or NULL ptr if test
        point was not found.
        """
        return _connect.CTestSpecification_getTestPoint(self, testPointId)

    def getTestPointIdx(self, testPointId: "std::string const &") -> "int":
        r"""
        :rtype: int
        :return: index of test point in test points vector, or -1 if the test
            point with the given Id was not found.
        """
        return _connect.CTestSpecification_getTestPointIdx(self, testPointId)

    def assignTestPoints(self, src: "isys::CTestSpecificationSPtr const &") -> "void":
        r"""
        This method copies test points from src to this object. Original
        test points are removed.
        """
        return _connect.CTestSpecification_assignTestPoints(self, src)

    def removeStub(self, *args) -> "int":
        r"""
        *Overload 1:*
         Removes stub.

        |

        *Overload 2:*

        Removes stub with the given function name.
        Returns stub index in a list, if stub was removed, -1 if the stub
        did not exist.
        """
        return _connect.CTestSpecification_removeStub(self, *args)

    def assignStubs(self, src: "isys::CTestSpecificationSPtr const &") -> "void":
        r"""This method copies stubs from src to this object. Original stubs are removed."""
        return _connect.CTestSpecification_assignStubs(self, src)

    def removeUserStub(self, functionName: "std::string const &") -> "int":
        r"""
        Removes user stub with the given function name.
        Returns stub index in a list, if stub was removed, -1 if the stub
        did not exist.
        """
        return _connect.CTestSpecification_removeUserStub(self, functionName)

    def assignUserStubs(self, src: "isys::CTestSpecificationSPtr const &") -> "void":
        r"""This method copies stubs from src to this object. Original stubs are removed."""
        return _connect.CTestSpecification_assignUserStubs(self, src)

    def assignOptions(self, src: "CTestSpecification") -> "void":
        r"""This method copies stubs from src to this object."""
        return _connect.CTestSpecification_assignOptions(self, src)

    def getLocalVariables(self, localVars: "StrStrMap") -> "void":
        r"""
        Returns local variables specified as a map of
        ``[var name, var type]`` pairs.

        :type localVars: :py:class:`StrStrMap`
        :param localVars: map to receive local variables
        """
        return _connect.CTestSpecification_getLocalVariables(self, localVars)

    def getLocalVariablesKeys(self, vars: "StrVector") -> "void":
        r"""
        Returns names of local variable in the same order as they were
        entered in test specification.
        """
        return _connect.CTestSpecification_getLocalVariablesKeys(self, vars)

    def getInitKeys(self, *args) -> "void":
        r"""
        *Overload 1:*

        Returns vector with names of variables to be initialized.
        The vector contains variables in the same order in which they
        were inserted into internal map, and this is also the order
        that should be used for initialization.
        See also getInitValues().

        |

        *Overload 2:*
         Returns the same info as getInitKeys(), but with original quoting.
        """
        return _connect.CTestSpecification_getInitKeys(self, *args)

    def getInitValues(self, values: "StrVector") -> "void":
        r"""
        Returns vector with values of variables to be initialized. Values
        are returned in the order which matches keys returned by getInitKeys().
        See also getInitKeys().
        """
        return _connect.CTestSpecification_getInitValues(self, values)

    def getInitMap(self, initMap: "StrStrMap") -> "void":
        r"""
        Returns initialization assignments of local variables.
        Note: The order of assignments is not preserved! Use this method
        to get values of the known variables, but not to modify it and then
        use it for setting of assignments.

        :type initMap: :py:class:`StrStrMap`
        :param initMap: object to receive mapping data
        """
        return _connect.CTestSpecification_getInitMap(self, initMap)

    def getExpectedResults(self, expectedResults: "StrVector") -> "void":
        r"""
        Deprecated: use getAssert() instead.

        Returns expected values, specified as a list of expressions.

        :type expectedResults: :py:class:`StrVector`
        :param expectedResults: StrVector to receive expected values
        """
        return _connect.CTestSpecification_getExpectedResults(self, expectedResults)

    def getPrecondition(self, isConst: "bool") -> "CTestAssert":
        r"""Returns object containing assertions to be verified *before* test start."""
        return _connect.CTestSpecification_getPrecondition(self, isConst)

    def getAssert(self, isConst: "bool") -> "CTestAssert":
        r"""Returns object containing assertions for test result."""
        return _connect.CTestSpecification_getAssert(self, isConst)

    def getLog(self, isConst: "bool") -> "CTestLog":
        r"""
        Returns object containing expressions to be logged before test
        starts and when test ends.
        """
        return _connect.CTestSpecification_getLog(self, isConst)

    def getAnalyzer(self, isConst: "bool") -> "CTestAnalyzer":
        r""" Returns analyzer configuration."""
        return _connect.CTestSpecification_getAnalyzer(self, isConst)

    def getTrace(self, isConst: "bool") -> "CTestAnalyzerTrace":
        r""" Deprecated: call getAnalyzer().getTrace() instead."""
        return _connect.CTestSpecification_getTrace(self, isConst)

    def getCoverage(self, isConst: "bool") -> "CTestAnalyzerCoverage":
        r"""Deprecated: call getAnalyzer().getCoverage() instead."""
        return _connect.CTestSpecification_getCoverage(self, isConst)

    def getProfiler(self, isConst: "bool") -> "CTestAnalyzerProfiler":
        r"""Deprecated: call getAnalyzer().getProfiler() instead."""
        return _connect.CTestSpecification_getProfiler(self, isConst)

    def getHIL(self, isConst: "bool") -> "CTestHIL":
        r""" Returns HIL configuration."""
        return _connect.CTestSpecification_getHIL(self, isConst)

    def getDryRun(self, isConst: "bool") -> "CTestDryRun":
        r""" Returns Dry Run configuration."""
        return _connect.CTestSpecification_getDryRun(self, isConst)

    def getStackUsage(self, isConst: "bool") -> "CTestStackUsage":
        r""" Returns settings for stack usage."""
        return _connect.CTestSpecification_getStackUsage(self, isConst)

    def getPersistentVars(self, isConst: "bool") -> "CTestPersistentVars":
        r""" Returns persistent variables."""
        return _connect.CTestSpecification_getPersistentVars(self, isConst)

    def getOptionKeys(self, *args) -> "void":
        r"""
        *Overload 1:*
        Returns names of winIDEA options to be set. See also getOptionValues().

        |

        *Overload 2:*
        Returns names of winIDEA options to be set with original quoting.
        """
        return _connect.CTestSpecification_getOptionKeys(self, *args)

    def getOptionValues(self, values: "StrVector") -> "void":
        r"""
        Returns values of winIDEA options to be set. They are in
        the same order as keys returned by getOptionKeys().
        """
        return _connect.CTestSpecification_getOptionValues(self, values)

    def getImports(self, isConst: "bool") -> "CTestImports":
        r""" Returns reference to modifiable specification of imports."""
        return _connect.CTestSpecification_getImports(self, isConst)

    def getBeginStopCondition(self, isConst: "bool") -> "CTestStopCondition":
        r""" Returns stop condition to be used before system test for target initialization."""
        return _connect.CTestSpecification_getBeginStopCondition(self, isConst)

    def getEndStopCondition(self, isConst: "bool") -> "CTestStopCondition":
        r""" Returns stop condition to be used as system test termination."""
        return _connect.CTestSpecification_getEndStopCondition(self, isConst)

    def getDiagrams(self, isConst: "bool") -> "CTestDiagrams":
        return _connect.CTestSpecification_getDiagrams(self, isConst)

    def hasChildren(self) -> "bool":
        r""" Returns true, if there are derived test specifications."""
        return _connect.CTestSpecification_hasChildren(self)

    def getChildren(self, isConst: "bool") -> "CTestBaseList":
        r"""Returns pointer to the list of derives test cases."""
        return _connect.CTestSpecification_getChildren(self, isConst)

    def getNoOfDerivedSpecs(self) -> "int":
        r""" Returns the number of derived test specs."""
        return _connect.CTestSpecification_getNoOfDerivedSpecs(self)

    def getDerivedTestSpec(self, idx: "int") -> "CTestSpecification":
        r"""
        Returns derived test spec at the given index. The returned test specification
        contains only its own data, no data from base test specification is inherited
        with this call. To get a test specification with inherited data, which can be
        executed, call method ``merge()`` on the returned test specification object.

        :type idx: int
        :param idx: index to derived test specification. It should be
            and less than the value returned by ``getNoOfDerivedSpecs()``, and >= 0.

        :raises: IndexOutOfBoundsException if index is not valid.
        """
        return _connect.CTestSpecification_getDerivedTestSpec(self, idx)

    def findDerivedTestSpec(self, *args) -> "CTestSpecification":
        r"""
        *Overload 1:*

        Returns index of the given test specification, or -1 if not found.
        Pointer equality is checked, only the first level is searched.

        |

        *Overload 2:*

        This method returns the first derived test specification with the given ID.
        It does not check if there are other derived test specs with the given ID.

        :type testId: string
        :param testId:
        :type recursiveLevel: int
        :param recursiveLevel: defines how deep in hierarchy the search should go.
            Usually it has value 0, which means only derived test specs of the
            containerTestSpec, or -1, which means infinite depth.
        :rtype: :py:class:`CTestSpecification`
        :return: test spec with the given ID or null, if no test spec was found
        """
        return _connect.CTestSpecification_findDerivedTestSpec(self, *args)

    def addDerivedTestSpec(self, idx: "int", testSpec: "isys::CTestSpecificationSPtr") -> "void":
        r"""
        Adds given test specification to the list of derived specifications
        at the given index. Parent of the added test specification is NOT modified!
        Use this method when adding test specification to container test spec, not
        to parent in the model. For example, if user selects several distinct test specs
        in tree, a container test spec can be used to group all selected test specs
        together and then for example execute them. However, their parents MUST NOT be
        modified, because they are still members of the test tree!

        :type idx: int
        :param idx: advice where to put test spec in the derived test spec list
                   If -1 or out of range, the test spec is added to the end of the list.
        """
        return _connect.CTestSpecification_addDerivedTestSpec(self, idx, testSpec)

    def addChildAndSetParent(self, idx: "int", testSpec: "isys::CTestTreeNodeSPtr const &") -> "void":
        r"""
        Adds given test specification to the list of derived specifications
        at the given index. Parent of the added test specification is set to 'this'!
        Use this method when modifying test specification tree.

        :type idx: int
        :param idx: advice where to put test spec in the derived test spec list
                   If -1 or out of range, the test spec is added to the end of the list.
        """
        return _connect.CTestSpecification_addChildAndSetParent(self, idx, testSpec)

    def deleteAllDerivedTestSpecs(self) -> "void":
        r"""Deletes all derived test specifications."""
        return _connect.CTestSpecification_deleteAllDerivedTestSpecs(self)

    def deleteDerivedTestSpec(self, idx: "int") -> "void":
        r"""Deletes test spec at the given index."""
        return _connect.CTestSpecification_deleteDerivedTestSpec(self, idx)

    def deleteChild(self, child: "isys::CTestTreeNodeSPtr const &") -> "int":
        r"""
        Deletes the given derived test spec. Returns index of deleted test spec,
        if the spec was found and deleted, -1 if it was not found.
        """
        return _connect.CTestSpecification_deleteChild(self, child)

    def getWarnings(self) -> "std::string":
        r"""
        If there were any warnings detected during parsing, this method returns
        non-empty string with description of warnings. It is recommended to
        call this method always after parsing.

        See also: CTestBench::getWarnings()
        """
        return _connect.CTestSpecification_getWarnings(self)

    def serializeMember(self, emitter: "isys::IEmitterSPtr", section: "isys::CTestSpecification::SectionIds") -> "void":
        r"""
         Outputs contents of this class to emitter.
        Outputs contents of this class in yaml.

        :type emitter: :py:class:`IEmitter`
        :param emitter: emitter to produce output
        :param isEmitMappingStart: if true, then mapping start and end is also emitted.
            This parameter should be false, if test specification is part of a bigger
            document, for example test bench doc with 'env' section, because emitter
            can not handle the following sequence:
            mapStart, scalar, scalar, mapEnd, <expects doc end here> mapStart, ...
        """
        return _connect.CTestSpecification_serializeMember(self, emitter, section)

    def isEmptyExceptDerived(self) -> "bool":
        r"""
        Returns true, if test spec has no data, except derived test specs.
          This is used in GUI, which may hide the root test spec in such case.
        """
        return _connect.CTestSpecification_isEmptyExceptDerived(self)

    def merge(self) -> "CTestSpecification":
        r"""
        This method merges all parent test specifications with this one.

        All sections, which are defined in parent test specifications and
        not in this test spec., are copied to the returned test specification.
        Original test specifications are not modified.


        :rtype: :py:class:`CTestSpecification`
        :return: new test specification with merged test sections.
        """
        return _connect.CTestSpecification_merge(self)

    def getMergedTestScope(self) -> "isys::CTestSpecification::ETestScope":
        r"""This method returns merged value of test scope section."""
        return _connect.CTestSpecification_getMergedTestScope(self)

    def isSectionEmpty(self, sectionId: "isys::CTestSpecification::SectionIds") -> "bool":
        return _connect.CTestSpecification_isSectionEmpty(self, sectionId)

    def isSectionMerged(self, sectionId: "isys::CTestSpecification::SectionIds") -> "bool":
        r"""
        This method returns true, if the section is defined in parent
        test spec, but not in this test spec. This rule is processed
        recursively for all parents. If a parent with non-empty section is
        found, this method returns true. This method does not take 'imports'
        section into account - see method isInheritSection().
        """
        return _connect.CTestSpecification_isSectionMerged(self, sectionId)

    def isInheritSection(self, sectionId: "isys::CTestSpecification::SectionIds") -> "bool":
        r"""
        This method returns true, if isSectionMerged() returns true, AND
        this section is marked as inherited in the 'imports' section.


        Rules for inheritance:

        | isInherit  | definedInBase |definedInDerived | isInheritSection | isEditable |
        | :--------: | :-----------: | :-------------: | :--------------: | :--------: |
        |     0      |      0        |       0         |        0         |   1        |
        |     0      |      0        |       1         |        0         |   1        |
        |     0      |      1        |       0         |        0         |   1        |
        |     0      |      1        |       1         |        0         |   1        |
        |            |               |                 |                  |            |
        |     1      |      0        |       0         |        0         |   1        |
        |     1      |      0        |       1         |        0         |   1        |
        |     1      |      1        |       0         |        1         |   0        |
        |     1      |      1        |       1         |        0         |   1        |
        |            |               |                 |                  |            |
        | from _imports_ |   isSectionMerged()        ||                  |            |
        """
        return _connect.CTestSpecification_isInheritSection(self, sectionId)

    def setMainMapStyle(self, mappingStyle: "isys::IEmitter::EYamlStyle") -> "void":
        r"""
        Always sets mapping style to BLOCK. Because of YAML comments
        FLOW style is not allowed for instances of this class.
        """
        return _connect.CTestSpecification_setMainMapStyle(self, mappingStyle)

    def setTestId(self, testId: "std::string const &") -> "void":
        r""" Sets test id."""
        return _connect.CTestSpecification_setTestId(self, testId)

    def setBaseId(self, testId: "std::string const &") -> "void":
        r"""
        Sets parent id.
        See also: getParentId
        """
        return _connect.CTestSpecification_setBaseId(self, testId)

    def setRunFlag(self, isRun: "iconnect::ETristate") -> "void":
        r""" Sets run flag."""
        return _connect.CTestSpecification_setRunFlag(self, isRun)

    def setDescription(self, description: "std::string const &") -> "void":
        r""" Sets description."""
        return _connect.CTestSpecification_setDescription(self, description)

    def setTags(self, *args) -> "void":
        r"""
        *Overload 1:*

        Deprecated: use setTags(StrVector)
        Sets tags.

        |

        *Overload 2:*

        Sets tags.
        """
        return _connect.CTestSpecification_setTags(self, *args)

    def setTestScope(self, testType: "isys::CTestSpecification::ETestScope") -> "void":
        r""" Sets test type."""
        return _connect.CTestSpecification_setTestScope(self, testType)

    def setLocalVariables(self, yamlSpec: "std::string const &") -> "void":
        r"""
        Sets declarations of local variables used in test.

        :type yamlSpec: string
        :param yamlSpec: map of ``var_name``: ``var_type`` pairs in YAML format.
        """
        return _connect.CTestSpecification_setLocalVariables(self, yamlSpec)

    def setInitValues(self, yamlSpec: "std::string const &") -> "void":
        r"""
        Sets initialization values of variables used in test.

        :type yamlSpec: string
        :param yamlSpec: map of ``var_name``: ``init_value`` pairs in YAML format.
        """
        return _connect.CTestSpecification_setInitValues(self, yamlSpec)

    def setExpectedResults(self, expectedResults: "StrVector") -> "void":
        r"""
        Deprecated: Use getAssert(), and then setExpressions() on returned object.

        Sets expected test results.

        :param yamlSpec: list of C expressions items in YAML format, where
            expression is expected to evaluate to true for the test to pass. Example:

            ['retVal < 10', 'g_counter == 23  &&  g_mode == 3']


        itestWithParameters.py Python example. 


        :type expectedResults: :py:class:`StrVector`
        :param expectedResults:
        """
        return _connect.CTestSpecification_setExpectedResults(self, expectedResults)

    def setIdeOptions(self, yamlSpec: "std::string const &") -> "void":
        r"""
        Sets IDE options.

        :type yamlSpec: string
        :param yamlSpec: map of ``option_path``: ``option_value`` pairs in YAML format.
        """
        return _connect.CTestSpecification_setIdeOptions(self, yamlSpec)

    def setTestTimeout(self, timeout: "int") -> "void":
        r"""
        Sets timeout (in milliseconds), after which test execution is terminated.
        Value 0 means infinite timeout, value -1 means that timeout is not specified,
        and that global timeout setting will be used.
        """
        return _connect.CTestSpecification_setTestTimeout(self, timeout)

    def setCoreId(self, coreId: "std::string const &") -> "void":
        r"""Sets core ID where this test case should be executed."""
        return _connect.CTestSpecification_setCoreId(self, coreId)

    def validate(self) -> "std::string":
        return _connect.CTestSpecification_validate(self)

    def getNoOfTests(self, isSkipAbstractTests: "bool") -> "int":
        r"""
        Returns the number of tests in this test specification - counts
        this specification and all derived tests.

        :type isSkipAbstractTests: boolean
        :param isSkipAbstractTests: if true, abstract tests are not
            counted (tests with 'run' tag set to false) - the number of runnable
            tests is returned.

        cumulativeCoverage.py Python example. 
        """
        return _connect.CTestSpecification_getNoOfTests(self, isSkipAbstractTests)

    def clearEmptySections(self) -> "void":
        r"""
        This method releases all sections, which contain no data (only
        empty strings). It can save some memory this way - it exists for
        optimization purposes, not functionality.
        """
        return _connect.CTestSpecification_clearEmptySections(self)

    def save(self, fileName: "std::string const &", isAppend: "bool"=False) -> "void":
        r"""
        Writes test spec to the given file.

        :type fileName: string
        :param fileName: name of the file to write specification to
        :type isAppend: boolean, optional
        :param isAppend: if true, test spec is appended to the given file.
                            This is useful, if test spec must be inserted into the file -
                            caller copies the first part of the file, calls this method,
                            and finally copies the rest of the file.
        """
        return _connect.CTestSpecification_save(self, fileName, isAppend)

    @staticmethod
    def load(fileName: "std::string const &", filePos: "size_t"=0) -> "CTestSpecification":
        r"""
        Loads test specification from file.

        :type fileName: string
        :param fileName: name of the file to load.
        :type filePos: int, optional
        :param filePos: offset in file to start reading from.
        """
        return _connect.CTestSpecification_load(fileName, filePos)

    @staticmethod
    def parseTestSpec(yamlSpec: "std::string const &") -> "CTestSpecification":
        r"""
        Parses test specification in YAML format and returns new object
        containing the given information.
        This method is implemented for access from SWIG wrappers, which are not
        aware of ITestParserEventReceiver. C++ apps should use more generic
        parseYAML() method.

        :type yamlSpec: string
        :param yamlSpec: test spec. in YAML format

        cumulativeCoverage.py Python example. 

        cumulativeModuleCoverage.py Python example. 
        """
        return _connect.CTestSpecification_parseTestSpec(yamlSpec)

    def clearMergedFilterInfo(self, isClearRecursively: "bool") -> "void":
        r"""
        For optimization reasons test specification stores merged info
        during filtering. However, it is not automatically reset on
        test spec change (for example when setTestId() is called), so
        this method must be explicitly called before running tests with
        filtering. Otherwise stale data in cache will corrupt filtering.
        """
        return _connect.CTestSpecification_clearMergedFilterInfo(self, isClearRecursively)

# Register CTestSpecification in _connect:
_connect.CTestSpecification_swigregister(CTestSpecification)

def CTestSpecification_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestSpecification":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestSpecification_cast(testBase)

def CTestSpecification_load(fileName: "std::string const &", filePos: "size_t"=0) -> "CTestSpecification":
    r"""
    Loads test specification from file.

    :type fileName: string
    :param fileName: name of the file to load.
    :type filePos: int, optional
    :param filePos: offset in file to start reading from.
    """
    return _connect.CTestSpecification_load(fileName, filePos)

def CTestSpecification_parseTestSpec(yamlSpec: "std::string const &") -> "CTestSpecification":
    r"""
    Parses test specification in YAML format and returns new object
    containing the given information.
    This method is implemented for access from SWIG wrappers, which are not
    aware of ITestParserEventReceiver. C++ apps should use more generic
    parseYAML() method.

    :type yamlSpec: string
    :param yamlSpec: test spec. in YAML format

    cumulativeCoverage.py Python example. 

    cumulativeModuleCoverage.py Python example. 
    """
    return _connect.CTestSpecification_parseTestSpec(yamlSpec)

class CTestStub(CTestBase):
    r"""
    This class contains specification for one stub. Since stubbed
    function will not be called, we have to specify its return
    values and other side effects. This information is stored in
    this class.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_STUBBED_FUNC = _connect.CTestStub_E_SECTION_STUBBED_FUNC
    E_SECTION_IS_ACTIVE = _connect.CTestStub_E_SECTION_IS_ACTIVE
    E_SECTION_IS_CUSTOM_ACTIVATION = _connect.CTestStub_E_SECTION_IS_CUSTOM_ACTIVATION
    E_SECTION_PARAM_NAMES = _connect.CTestStub_E_SECTION_PARAM_NAMES
    E_SECTION_RET_VAL_NAME = _connect.CTestStub_E_SECTION_RET_VAL_NAME
    E_SECTION_SCRIPT_FUNCTION = _connect.CTestStub_E_SECTION_SCRIPT_FUNCTION
    E_SECTION_HIT_LIMITS = _connect.CTestStub_E_SECTION_HIT_LIMITS
    E_SECTION_LOG = _connect.CTestStub_E_SECTION_LOG
    E_SECTION_ASSIGN_STEPS = _connect.CTestStub_E_SECTION_ASSIGN_STEPS
    E_SECTION_FUNC = _connect.CTestStub_E_SECTION_FUNC
    E_SECTION_ASSIGN = _connect.CTestStub_E_SECTION_ASSIGN
    E_SECTION_SCRIPT = _connect.CTestStub_E_SECTION_SCRIPT

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class. Used
                          only when parsing YAML declaration. Can be
                          specified as NULL if the object is not
                          initialized by parser.
        """
        _connect.CTestStub_swiginit(self, _connect.new_CTestStub(*args))
    __swig_destroy__ = _connect.delete_CTestStub

    def createInstance(self, *args) -> "void":
        return _connect.CTestStub_createInstance(self, *args)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestStub":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestStub_cast(testBase)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestStub_isMerged(self)

    def getFunctionName(self) -> "std::string":
        r""" Returns the name of stubbed function."""
        return _connect.CTestStub_getFunctionName(self)

    def isActive(self) -> "bool":
        r""" Returns true, if stub is active during test execution."""
        return _connect.CTestStub_isActive(self)

    def getActive(self) -> "iconnect::ETristate":
        r"""
         Returns string setting as specified in YAML file. Empty string
        means default setting.

        See also: isActive
        """
        return _connect.CTestStub_getActive(self)

    def isCustomActivation(self) -> "bool":
        r"""
        Returns true, if test point will not be activated before test execution,
        but during test execution from custom script. This
        functionality can be used when the order of test point hits is known, and
        there are not enough hardware breakpoints available.
        """
        return _connect.CTestStub_isCustomActivation(self)

    def getRetValName(self) -> "std::string":
        r"""Returns name assigned to the stub return value."""
        return _connect.CTestStub_getRetValName(self)

    def getParamNames(self, params: "StrVector") -> "void":
        r"""Returns names of parameters assigned to stubbed function parameters."""
        return _connect.CTestStub_getParamNames(self, params)

    def getScriptFunctionName(self) -> "std::string":
        r"""
        Returns the function to be called in the test
        suite, instead of the stubbed one on the target.
        This function may simulate side effects normally caused by the
        stubbed function.
        """
        return _connect.CTestStub_getScriptFunctionName(self)

    def getLogConfig(self, isConst: "bool") -> "CTestLog":
        r""" Returns logging configuration."""
        return _connect.CTestStub_getLogConfig(self, isConst)

    def getHitLimits(self, isConst: "bool") -> "CTestMinMax":
        r""" Returns hit limits."""
        return _connect.CTestStub_getHitLimits(self, isConst)

    def getAssignmentSteps(self, isConst: "bool") -> "CTestBaseList":
        r"""Returns assignment steps."""
        return _connect.CTestStub_getAssignmentSteps(self, isConst)

    def setFunctionName(self, functionName: "std::string const &") -> "void":
        r""" Sets the name of the function to be stubbed."""
        return _connect.CTestStub_setFunctionName(self, functionName)

    def setActive(self, isActive: "iconnect::ETristate") -> "void":
        r"""
        If parameter is ``true``, then the stub is active during test execution.
        Otherwise it will be ignored - the function on the target is called.
        """
        return _connect.CTestStub_setActive(self, isActive)

    def setCustomActivation(self, isActive: "iconnect::ETristate") -> "void":
        r"""
        If parameter is ``true``, then the stub will not be activated before
        test execution, but during test execution from custom script. This
        functionality can be used when the order of test point hits is known, and
        there are not enough hardware breskpoints available.
        """
        return _connect.CTestStub_setCustomActivation(self, isActive)

    def setRetValName(self, retValName: "std::string const &") -> "void":
        r"""Sets name assigned to the stub return value."""
        return _connect.CTestStub_setRetValName(self, retValName)

    def setScriptFunctionName(self, scriptFuncName: "std::string const &") -> "void":
        r"""Sets name assigned to the stub return value."""
        return _connect.CTestStub_setScriptFunctionName(self, scriptFuncName)

# Register CTestStub in _connect:
_connect.CTestStub_swigregister(CTestStub)

def CTestStub_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestStub":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestStub_cast(testBase)

class CTestLocation(CTestBase):
    r"""
    This class defines location in source code. Location can be given
    either as line number in file, or line number in function.
    Line numbers in files are 1-based, because this convention
    is used by most text editors. Line numbers in function are 0-based,
    because it is easy to see the line number of zeroth function line
    in editor,
    and line number of the line where we want to set a test point, and
    simply subtract them. Furthermore, most developers in embedded
    world use C language, which is 0-based. 

    (Note: We can also find
    reasoning to have file line numbers 0-based or function relative
    line numbers 1-based, so whatever decision is made, it will be wrong
    from some other point of view.
    See also: http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html)
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_RESOURCE_TYPE = _connect.CTestLocation_E_SECTION_RESOURCE_TYPE
    E_SECTION_RESOURCE_NAME = _connect.CTestLocation_E_SECTION_RESOURCE_NAME
    E_SECTION_SRC_FILE_LOCATION = _connect.CTestLocation_E_SECTION_SRC_FILE_LOCATION
    E_SECTION_LINE = _connect.CTestLocation_E_SECTION_LINE
    E_SECTION_IS_SEARCH = _connect.CTestLocation_E_SECTION_IS_SEARCH
    E_SECTION_LINES_RANGE = _connect.CTestLocation_E_SECTION_LINES_RANGE
    E_SECTION_SEARCH_CONTEXT = _connect.CTestLocation_E_SECTION_SEARCH_CONTEXT
    E_SECTION_MATCH_TYPE = _connect.CTestLocation_E_SECTION_MATCH_TYPE
    E_SECTION_PATTERN = _connect.CTestLocation_E_SECTION_PATTERN
    E_SECTION_LINE_OFFSET = _connect.CTestLocation_E_SECTION_LINE_OFFSET
    E_SECTION_NUM_STEPS = _connect.CTestLocation_E_SECTION_NUM_STEPS

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestPoint class.
        """
        _connect.CTestLocation_swiginit(self, _connect.new_CTestLocation(*args))
    __swig_destroy__ = _connect.delete_CTestLocation

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestLocation_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestLocation":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestLocation_cast(testBase)

    def getRuntimeLocation(self) -> "std::string":
        r"""
        Returns location as calculated during runtime - file name and
        line number. This information is available only after test execution,
        and is not stored to iyaml file. If runtime location has not been set yet,
        an empty string is returned.
        """
        return _connect.CTestLocation_getRuntimeLocation(self)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestLocation_isMerged(self)

    def getResourceType(self) -> "isys::CLineDescription::EResourceType":
        r""" Returns type of resource for which location is given."""
        return _connect.CTestLocation_getResourceType(self)

    def getResourceName(self) -> "std::string":
        r""" Returns name of resource where test point is located."""
        return _connect.CTestLocation_getResourceName(self)

    def getSrcFileLocation(self) -> "isys::CLineDescription::EFileLocation":
        r"""
        Returns location of source files - local host running test case
        or remote host running winIDEA.
        """
        return _connect.CTestLocation_getSrcFileLocation(self)

    def getLine(self) -> "int":
        r"""
        Returns line number, where test point is set, or where
        search range starts (if pattern is defined). Lines for file
        are 1-based, while lines for function are 0 based and can also be
        negative.
        """
        return _connect.CTestLocation_getLine(self)

    def isSearch(self) -> "iconnect::ETristate":
        r"""
        Returns true, if search is to be performed. Otherwise the line
        number returned by getLine() is used to set a test point.
        """
        return _connect.CTestLocation_isSearch(self)

    def getLinesRange(self) -> "int":
        r"""
        Returns the number of lines, which are searched for pattern.
        Value 0 means till the end of file.
        """
        return _connect.CTestLocation_getLinesRange(self)

    def getSearchContext(self) -> "isys::CLineDescription::ESearchContext":
        r""" Returns search context for pattern."""
        return _connect.CTestLocation_getSearchContext(self)

    def getMatchingType(self) -> "isys::CLineDescription::EMatchingType":
        r""" Returns matching type for pattern."""
        return _connect.CTestLocation_getMatchingType(self)

    def getSearchPattern(self) -> "std::string":
        r"""
        Returns search pattern. If this item is not defined (empty
        string is returned), then test point is located in line
        returned by ``getLine()``. No search is performed. Num lines,
        search context, and matching type are ignored.
        """
        return _connect.CTestLocation_getSearchPattern(self)

    def getLineOffset(self) -> "int":
        r"""
        Returns the number of lines, which are added to line found by search
        pattern above.
        """
        return _connect.CTestLocation_getLineOffset(self)

    def getNumSteps(self) -> "int":
        r"""
        Returns the number of single execution steps to be performed
        before logging/evaluations/assignments take place.
        """
        return _connect.CTestLocation_getNumSteps(self)

    def setRuntimeLocation(self, runtimeLocation: "std::string const &") -> "void":
        return _connect.CTestLocation_setRuntimeLocation(self, runtimeLocation)

    def setResourceType(self, resourceType: "isys::CLineDescription::EResourceType") -> "void":
        r""" Sets type of resource for which location is given."""
        return _connect.CTestLocation_setResourceType(self, resourceType)

    def setResourceName(self, resourceName: "std::string const &") -> "void":
        r""" Sets name of resource where test point is located."""
        return _connect.CTestLocation_setResourceName(self, resourceName)

    def setSrcFileLocation(self, srcFileLoc: "isys::CLineDescription::EFileLocation") -> "void":
        r""" Sets source file location."""
        return _connect.CTestLocation_setSrcFileLocation(self, srcFileLoc)

    def setLine(self, lineNumber: "int") -> "void":
        r"""
        Sets line number, where test point is set, or where
        search range starts (if pattern is defined). Lines are 1-based.
        """
        return _connect.CTestLocation_setLine(self, lineNumber)

    def setSearch(self, isSearch: "iconnect::ETristate") -> "void":
        r"""
        Sets the way to determine line number for test point.

        :type isSearch: int
        :param isSearch: if ``E_FALSE`` or E_DEFAULT, no search is done -
            then line returned by getLine() is used as test point location.
        """
        return _connect.CTestLocation_setSearch(self, isSearch)

    def setLinesRange(self, numLines: "int") -> "void":
        r"""
        Sets the number of lines, which are searched for pattern.
        Value 0 means till the end of file.
        """
        return _connect.CTestLocation_setLinesRange(self, numLines)

    def setSearchContext(self, searchContext: "isys::CLineDescription::ESearchContext") -> "void":
        r""" Sets search context for pattern."""
        return _connect.CTestLocation_setSearchContext(self, searchContext)

    def setMatchingType(self, matchingType: "isys::CLineDescription::EMatchingType") -> "void":
        r""" Sets matching type for pattern."""
        return _connect.CTestLocation_setMatchingType(self, matchingType)

    def setSearchPattern(self, searchPattern: "std::string const &") -> "void":
        r"""
        Sets search pattern. If this item is not defined (empty
        string is specified), then test point is located in line
        returned by ``getLine()``. No search is performed. Num lines,
        search context, and matching type are ignored.

        :type searchPattern: string
        :param searchPattern: depending on the value of matching type (see
                   ``setMatchingType()`` ) this pattern represents either
                   exact text to be found or regular expression.
        """
        return _connect.CTestLocation_setSearchPattern(self, searchPattern)

    def setLineOffset(self, offset: "int") -> "void":
        r"""
        Sets the number of lines, which are added to line found by search
        pattern above. Use this setting when the actual line has no specific
        pattern to search for, while the line before it can be identified more
        reliably.
        """
        return _connect.CTestLocation_setLineOffset(self, offset)

    def setNumSteps(self, numSteps: "int") -> "void":
        r"""
        Sets the number of single execution steps (step over in source code)
        to be performed before logging/evaluations/assignments take place.
        This setting may be useful when we want to
        log/evaluate/assign a variable _after_ the
        current line is executed. May also be used when test point is set at
        function start, and we want to execute function prolog, so that local
        variables and parameters are visible.
        """
        return _connect.CTestLocation_setNumSteps(self, numSteps)

    def validate(self) -> "std::string":
        r"""Validates consistency of data in object."""
        return _connect.CTestLocation_validate(self)

    def getLineDescription(self) -> "CLineDescription":
        r"""Returns adapter for this class, which can be used in CAddressController."""
        return _connect.CTestLocation_getLineDescription(self)

# Register CTestLocation in _connect:
_connect.CTestLocation_swigregister(CTestLocation)

def CTestLocation_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestLocation":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestLocation_cast(testBase)

class CTestPoint(CTestBase):
    r"""
    This class contains specification for test points.
    Test points are implemented as breakpoints at arbitrary points in
    executable, where test execution stops, expresisons can be
    evaluated to test target state, and variables modified to inject
    fault conditions. It is also possible to log values and include
    them to test reports.



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_TEST_POINT_ID = _connect.CTestPoint_E_SECTION_TEST_POINT_ID
    E_SECTION_IS_ACTIVE = _connect.CTestPoint_E_SECTION_IS_ACTIVE
    E_SECTION_IS_CUSTOM_ACTIVATION = _connect.CTestPoint_E_SECTION_IS_CUSTOM_ACTIVATION
    E_SECTION_CONDITION_COUNT = _connect.CTestPoint_E_SECTION_CONDITION_COUNT
    E_SECTION_CONDITION_EXPR = _connect.CTestPoint_E_SECTION_CONDITION_EXPR
    E_SECTION_SCRIPT_FUNC = _connect.CTestPoint_E_SECTION_SCRIPT_FUNC
    E_SECTION_LOCATION = _connect.CTestPoint_E_SECTION_LOCATION
    E_SECTION_LOG = _connect.CTestPoint_E_SECTION_LOG
    E_SECTION_HIT_LIMITS = _connect.CTestPoint_E_SECTION_HIT_LIMITS
    E_SECTION_STEPS = _connect.CTestPoint_E_SECTION_STEPS

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class.
        """
        _connect.CTestPoint_swiginit(self, _connect.new_CTestPoint(*args))
    __swig_destroy__ = _connect.delete_CTestPoint

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestPoint_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestPoint":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestPoint_cast(testBase)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestPoint_isMerged(self)

    def getId(self) -> "std::string const":
        r""" Returns the test point id."""
        return _connect.CTestPoint_getId(self)

    def isActive(self) -> "iconnect::ETristate":
        r""" Returns true, if test point is active during test execution."""
        return _connect.CTestPoint_isActive(self)

    def isCustomActivation(self) -> "bool":
        r"""
        Returns true, if test point will not be activated before test execution,
        but during test execution from custom script. This
        functionality can be used when the order of test point hits is known, and
        there are not enough hardware breakpoints available.
        """
        return _connect.CTestPoint_isCustomActivation(self)

    def getConditionCount(self) -> "int":
        r""" Returns condition count for test-point."""
        return _connect.CTestPoint_getConditionCount(self)

    def getConditionExpr(self) -> "std::string":
        r""" Returns condition expression for test-point."""
        return _connect.CTestPoint_getConditionExpr(self)

    def getScriptFunctionName(self) -> "std::string":
        r""" Returns script function to be called when test-point is hit."""
        return _connect.CTestPoint_getScriptFunctionName(self)

    def getLocation(self, isConst: "bool") -> "CTestLocation":
        r""" Returns location of test point."""
        return _connect.CTestPoint_getLocation(self, isConst)

    def getLogConfig(self, isConst: "bool") -> "CTestLog":
        r""" Returns logging configuration."""
        return _connect.CTestPoint_getLogConfig(self, isConst)

    def getHitLimits(self, isConst: "bool") -> "CTestMinMax":
        r""" Returns hit limits."""
        return _connect.CTestPoint_getHitLimits(self, isConst)

    def getSteps(self, isConst: "bool") -> "CTestBaseList":
        r"""
        Returns list of objects, which contain information about expected
        values and modifications of variable to perform.
        """
        return _connect.CTestPoint_getSteps(self, isConst)

    def setId(self, testPointId: "std::string const &") -> "void":
        r""" Sets the test point id."""
        return _connect.CTestPoint_setId(self, testPointId)

    def setActive(self, isActive: "iconnect::ETristate") -> "void":
        r"""If parameter is ``true``, then the test point is active during test execution."""
        return _connect.CTestPoint_setActive(self, isActive)

    def setCustomActivation(self, isActive: "iconnect::ETristate") -> "void":
        r"""
        If parameter is ``true``, then the test point will not be activated before
        test execution, but during test execution from custom script. This
        functionality can be used when the order of test point hits is known, and
        there are not enough hardware breakpoints available.
        """
        return _connect.CTestPoint_setCustomActivation(self, isActive)

    def setConditionCount(self, conditionCount: "int") -> "void":
        r""" Sets condition count for test-point."""
        return _connect.CTestPoint_setConditionCount(self, conditionCount)

    def setConditionExpr(self, expr: "std::string const &") -> "void":
        r""" Sets condition expression for test-point."""
        return _connect.CTestPoint_setConditionExpr(self, expr)

    def setScriptFunc(self, scriptFunc: "std::string const &") -> "void":
        r""" Sets script function to be called when test-point is hit."""
        return _connect.CTestPoint_setScriptFunc(self, scriptFunc)

    def validate(self) -> "std::string":
        r"""Validates consistency of data in object."""
        return _connect.CTestPoint_validate(self)

# Register CTestPoint in _connect:
_connect.CTestPoint_swigregister(CTestPoint)

def CTestPoint_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestPoint":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestPoint_cast(testBase)

class CTestMinMax(CTestBase):
    r"""
    This class is used where minumum and maximum limits of a value
    are specified.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_MIN = _connect.CTestMinMax_E_SECTION_MIN
    E_SECTION_MAX = _connect.CTestMinMax_E_SECTION_MAX

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent class. Used
                          only when parsing YAML declaration. Can be
                          specified as NULL if the object is not
                          initialized by parser.
        """
        _connect.CTestMinMax_swiginit(self, _connect.new_CTestMinMax(*args))

    def createInstance(self, *args) -> "void":
        return _connect.CTestMinMax_createInstance(self, *args)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestMinMax":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestMinMax_cast(testBase)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestMinMax_isMerged(self)

    def getMin(self) -> "int":
        r""" Returns lower value for limit."""
        return _connect.CTestMinMax_getMin(self)

    def getMax(self) -> "int":
        r""" Returns upper value for limit."""
        return _connect.CTestMinMax_getMax(self)

    def setMin(self, value: "int") -> "void":
        r""" Sets lower value for limit."""
        return _connect.CTestMinMax_setMin(self, value)

    def setMax(self, value: "int") -> "void":
        r""" Sets upper value for limit."""
        return _connect.CTestMinMax_setMax(self, value)
    __swig_destroy__ = _connect.delete_CTestMinMax

# Register CTestMinMax in _connect:
_connect.CTestMinMax_swigregister(CTestMinMax)

def CTestMinMax_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestMinMax":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestMinMax_cast(testBase)

class CTestLog(CTestBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_BEFORE = _connect.CTestLog_E_SECTION_BEFORE
    E_SECTION_AFTER = _connect.CTestLog_E_SECTION_AFTER

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestPoint class.
        """
        _connect.CTestLog_swiginit(self, _connect.new_CTestLog(*args))
    __swig_destroy__ = _connect.delete_CTestLog

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestLog_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestLog":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestLog_cast(testBase)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestLog_isMerged(self)

    def getExpressions(self, section: "isys::CTestLog::ESectionsLog", isConst: "bool") -> "isys::CSequenceAdapter":
        r"""
        Returns expressions for the given section.

        :type section: int
        :param section: which expressions to return
        :type isConst: boolean
        :param isConst: if true, then returned sequence may not be modified.
        """
        return _connect.CTestLog_getExpressions(self, section, isConst)

# Register CTestLog in _connect:
_connect.CTestLog_swigregister(CTestLog)

def CTestLog_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestLog":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestLog_cast(testBase)

class CTestEvalAssignStep(CTestBase):
    r"""This class defines stub assignments for one stub call."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_EXPECT = _connect.CTestEvalAssignStep_E_SECTION_EXPECT
    E_SECTION_ASSIGN = _connect.CTestEvalAssignStep_E_SECTION_ASSIGN
    E_SECTION_SCRIPT_PARAMS = _connect.CTestEvalAssignStep_E_SECTION_SCRIPT_PARAMS
    E_SECTION_NEXT_INDEX = _connect.CTestEvalAssignStep_E_SECTION_NEXT_INDEX

    def __init__(self, *args):
        _connect.CTestEvalAssignStep_swiginit(self, _connect.new_CTestEvalAssignStep(*args))
    __swig_destroy__ = _connect.delete_CTestEvalAssignStep

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestEvalAssignStep_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestEvalAssignStep":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestEvalAssignStep_cast(testBase)

    def getStepIdx(self) -> "std::string":
        r"""
        Returns index of the step to use on the next call.
        Negative values are indices from the end.
        If empty string is returned, the next step should be executed
        in the next call, unless the current step is the last step - in
        this case the last step is executed.
        """
        return _connect.CTestEvalAssignStep_getStepIdx(self)

    def setStepIdx(self, stepIdx: "int") -> "void":
        r"""
        Sets step index.
        See also: getStepIdx
        """
        return _connect.CTestEvalAssignStep_setStepIdx(self, stepIdx)

    def getExpectedExpressions(self, isConst: "bool") -> "isys::CSequenceAdapter":
        r""" Returns expressions, which should evaluate to true."""
        return _connect.CTestEvalAssignStep_getExpectedExpressions(self, isConst)

    def getAssignments(self, isConst: "bool") -> "isys::CMapAdapter":
        r""" Returns assignments to variables, registers, ..."""
        return _connect.CTestEvalAssignStep_getAssignments(self, isConst)

    def getScriptParams(self, isConst: "bool") -> "isys::CSequenceAdapter":
        r""" Returns parameters for script function."""
        return _connect.CTestEvalAssignStep_getScriptParams(self, isConst)

# Register CTestEvalAssignStep in _connect:
_connect.CTestEvalAssignStep_swigregister(CTestEvalAssignStep)

def CTestEvalAssignStep_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestEvalAssignStep":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestEvalAssignStep_cast(testBase)

class CTestUserStub(CTestBase):
    r"""
      contains specification for one user
    stub. User stubs are implemented as replacement functions on
    target - this class contains information which function to call
    instead. During test execution the stubbed function in target memory
    is modified so that the function specified in this class
    is called instead of the stubbed function.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_STUBBED_FUNC_NAME = _connect.CTestUserStub_E_SECTION_STUBBED_FUNC_NAME
    E_SECTION_IS_ACTIVE = _connect.CTestUserStub_E_SECTION_IS_ACTIVE
    E_SECTION_REPLACEMENT_FUNC_NAME = _connect.CTestUserStub_E_SECTION_REPLACEMENT_FUNC_NAME

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Initializes new instance.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class. Used
                          only when parsing YAML declaration. Can be
                          specified as NULL if the object is not
                          initialized by parser.
        """
        _connect.CTestUserStub_swiginit(self, _connect.new_CTestUserStub(*args))
    __swig_destroy__ = _connect.delete_CTestUserStub

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestUserStub_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestUserStub":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestUserStub_cast(testBase)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestUserStub_isMerged(self)

    def getFunctionName(self) -> "std::string const":
        r""" Returns the name of stubbed function."""
        return _connect.CTestUserStub_getFunctionName(self)

    def isActive(self) -> "iconnect::ETristate":
        r""" Returns true, if stub is active during test execution."""
        return _connect.CTestUserStub_isActive(self)

    def getReplacementFuncName(self) -> "std::string":
        r"""
        Returns name of the function which will be called instead of the
        stubbed function.
        """
        return _connect.CTestUserStub_getReplacementFuncName(self)

    def setFunctionName(self, functionName: "std::string const &") -> "void":
        r""" Sets the name of the function to be stubbed."""
        return _connect.CTestUserStub_setFunctionName(self, functionName)

    def setActive(self, isActive: "iconnect::ETristate") -> "void":
        r"""
        If parameter is ``true``, then the stub is active during test execution.
        Otherwise it will be ignored - the function on the target is called.
        """
        return _connect.CTestUserStub_setActive(self, isActive)

    def setReplacementFuncName(self, replacementFuncName: "std::string const &") -> "void":
        r"""
        Sets name of the function to be called instead of the
        stubbed function.
        """
        return _connect.CTestUserStub_setReplacementFuncName(self, replacementFuncName)

# Register CTestUserStub in _connect:
_connect.CTestUserStub_swigregister(CTestUserStub)

def CTestUserStub_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestUserStub":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestUserStub_cast(testBase)

class CTestHIL(CTestBase):
    r"""This class contains configuration for HIL."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_HIL_PARAMS = _connect.CTestHIL_E_SECTION_HIL_PARAMS

    def __init__(self, parent: "isys::CTestBaseSPtr const &"):
        _connect.CTestHIL_swiginit(self, _connect.new_CTestHIL(parent))
    __swig_destroy__ = _connect.delete_CTestHIL

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestHIL_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestHIL":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestHIL_cast(testBase)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestHIL_isMerged(self)

    def getHILParamKeys(self, *args) -> "void":
        r"""
        *Overload 1:*

        Returns vector with names of HIL parameters to be initialized.
        The vector contains the names in the same order in which they
        were inserted into internal map, and this is also the order
        that should be used for initialization.

        |

        *Overload 2:*

        Returns the same items as getHILParamKeys(), but with original quoting.
        """
        return _connect.CTestHIL_getHILParamKeys(self, *args)

    def getHILParamValues(self, values: "StrVector") -> "void":
        r"""
        Returns vector with values of HIL parameters to be used for
        initialization. Values are returned in the order which
        matches keys returned by getHILParamKeys().
        """
        return _connect.CTestHIL_getHILParamValues(self, values)

    def getHILParamMap(self, params: "StrStrMap") -> "void":
        r"""
        Returns assignments of HIL outputs in the same
        order as they were entered in stub specification.

        :type params: :py:class:`StrStrMap`
        :param params: object to receive mapping data
        """
        return _connect.CTestHIL_getHILParamMap(self, params)

    def setParam(self, key: "std::string const &", value: "std::string const &") -> "void":
        return _connect.CTestHIL_setParam(self, key, value)

# Register CTestHIL in _connect:
_connect.CTestHIL_swigregister(CTestHIL)

def CTestHIL_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestHIL":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestHIL_cast(testBase)

class CTestStackUsage(CTestBase):
    r"""This class defines expected values for stack usage during test."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_MIN_SIZE = _connect.CTestStackUsage_E_SECTION_MIN_SIZE
    E_SECTION_MAX_SIZE = _connect.CTestStackUsage_E_SECTION_MAX_SIZE

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default ctor.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class.
        """
        _connect.CTestStackUsage_swiginit(self, _connect.new_CTestStackUsage(*args))
    __swig_destroy__ = _connect.delete_CTestStackUsage

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestStackUsage_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestStackUsage":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestStackUsage_cast(testBase)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestStackUsage_isMerged(self)

    def getMinUsedSize(self) -> "std::string":
        r"""
        Returns min stack size - at least that amount of stack is expected to
        be used during test.
        """
        return _connect.CTestStackUsage_getMinUsedSize(self)

    def getMaxUsedSize(self) -> "std::string":
        r"""
        Returns max stack size - at most that amount of stack is expected to
        be used during test.
        """
        return _connect.CTestStackUsage_getMaxUsedSize(self)

    def setMinUsedSize(self, minSize: "int") -> "void":
        r"""
        Sets max stack size - at most that amount of stack is expected to
        be used during test.
        """
        return _connect.CTestStackUsage_setMinUsedSize(self, minSize)

    def setMaxUsedSize(self, maxSize: "int") -> "void":
        r"""
        Sets min stack size - at least that amount of stack is expected to
        be used during test.
        """
        return _connect.CTestStackUsage_setMaxUsedSize(self, maxSize)

# Register CTestStackUsage in _connect:
_connect.CTestStackUsage_swigregister(CTestStackUsage)

def CTestStackUsage_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestStackUsage":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestStackUsage_cast(testBase)

class CTestPersistentVars(CTestBase):
    r"""
    This section defines types and values of persistent variables. These
    variables exist on target between tests and can be used to preserve
    values from one test to be used in anoter test. It is also possible to
    specify persistent variables to be deleted.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_DECL = _connect.CTestPersistentVars_E_SECTION_DECL
    E_SECTION_DELETE = _connect.CTestPersistentVars_E_SECTION_DELETE
    E_SECTION_IS_DELETE_ALL = _connect.CTestPersistentVars_E_SECTION_IS_DELETE_ALL

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestVariables class.
        """
        _connect.CTestPersistentVars_swiginit(self, _connect.new_CTestPersistentVars(*args))
    __swig_destroy__ = _connect.delete_CTestPersistentVars

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestPersistentVars_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestPersistentVars":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestPersistentVars_cast(testBase)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestPersistentVars_isMerged(self)

    def isDeleteAll(self) -> "bool":
        return _connect.CTestPersistentVars_isDeleteAll(self)

    def setDeleteAll(self, isDeletaAll: "iconnect::ETristate") -> "void":
        return _connect.CTestPersistentVars_setDeleteAll(self, isDeletaAll)

# Register CTestPersistentVars in _connect:
_connect.CTestPersistentVars_swigregister(CTestPersistentVars)

def CTestPersistentVars_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestPersistentVars":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestPersistentVars_cast(testBase)

class CTestHostVars(object):
    r"""
    This class contains variables, which are stored on host, not on target.
    Variables, which name starts with underscore (_) are reserved for
    internal usage.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    LIST_SEPARATOR = _connect.CTestHostVars_LIST_SEPARATOR

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor.

        |

        *Overload 2:*
        Copy constructor.
        """
        _connect.CTestHostVars_swiginit(self, _connect.new_CTestHostVars(*args))

    def setDirs(self, winIDEAWorkspace: "std::string const &", iyamlDir: "std::string const &", reportDir: "std::string const &") -> "void":
        r"""Sets directories useful for itest."""
        return _connect.CTestHostVars_setDirs(self, winIDEAWorkspace, iyamlDir, reportDir)

    def setDefaultCoreId(self, coreId: "std::string const &") -> "void":
        r"""
        Sets coreID to be used when core ID value in test case is empty.
        Alternatively you can specify ``envConfig`` in initTestCaseVars().
        """
        return _connect.CTestHostVars_setDefaultCoreId(self, coreId)

    @staticmethod
    def getDiagramFileName(testSpec: "isys::CTestSpecificationSPtr &", diagConfig: "isys::CTestDiagramConfigSPtr &") -> "std::string":
        r"""
        Returns file name of a diagram, where all host vars are replaced with
        their values.
        """
        return _connect.CTestHostVars_getDiagramFileName(testSpec, diagConfig)

    def setValue(self, varName: "std::string const &", varValue: "std::string const &") -> "void":
        r"""Sets variable value."""
        return _connect.CTestHostVars_setValue(self, varName, varValue)

    def getValue(self, varName: "std::string const &") -> "std::string":
        r"""Returns variable value."""
        return _connect.CTestHostVars_getValue(self, varName)

    def removeVar(self, varName: "std::string const &") -> "void":
        r"""Removes variable from internal map."""
        return _connect.CTestHostVars_removeVar(self, varName)

    def replaceHostVars(self, expression: "std::string const &") -> "std::string":
        r"""
        Replaces all host variables in input string with their values.
        Returns string with replacements.
        """
        return _connect.CTestHostVars_replaceHostVars(self, expression)

    @staticmethod
    def getHostVarsForAnalyzerFileName(hostVars: "StrVector") -> "void":
        r"""Returns list of host variables available for analyzer file name."""
        return _connect.CTestHostVars_getHostVarsForAnalyzerFileName(hostVars)

    @staticmethod
    def getHostVarsForGroupAnalyzerFileName(hostVars: "StrVector") -> "void":
        r"""Returns list of host variables available for group analyzer file name."""
        return _connect.CTestHostVars_getHostVarsForGroupAnalyzerFileName(hostVars)

    @staticmethod
    def getHostVarsForAutoTestId(hostVars: "StrVector", isIncludeCoreId: "bool", isForProposals: "bool") -> "void":
        r"""Returns list of host variables available for test case ID."""
        return _connect.CTestHostVars_getHostVarsForAutoTestId(hostVars, isIncludeCoreId, isForProposals)

    def initEnvVars(self) -> "void":
        r"""
        This method stores all environment variables of the process to
        this class. All environment variables get prefix `_env_`, so they
        can not collide with user variables.
        """
        return _connect.CTestHostVars_initEnvVars(self)

    def initCommonHostVars(self) -> "void":
        r""" Initializes date, time, ISO time, user ID, and user name."""
        return _connect.CTestHostVars_initCommonHostVars(self)

    def initTestReportHostVars(self, wiWorkspaceDir: "std::string const &", wiWorkspaceFile: "std::string const &", defaultDlFile: "std::string const &") -> "void":
        r""" Initializes host vars used in test report output file name."""
        return _connect.CTestHostVars_initTestReportHostVars(self, wiWorkspaceDir, wiWorkspaceFile, defaultDlFile)

    def initSvnRevisionHostVar(self, workingCopyPath: "std::string const &") -> "void":
        r"""
        Initializes host var CTestHostVars::RESERVED_SVN_REVISION with
        current subversion number.

        :type workingCopyPath: string
        :param workingCopyPath: path to directory or file, on which svn info
                                   will be executed.
        """
        return _connect.CTestHostVars_initSvnRevisionHostVar(self, workingCopyPath)

    def initTestGroupVars(self, group: "isys::CTestGroupSPtr &", envConfig: "isys::CTestEnvironmentConfigSPtr") -> "void":
        r"""
        Initializes host variables from test group, for example ${_groupID}.
        If host variables with directories are needed, call setDirs() before
        this method.

        :param testSpec: the test group used to initialize variables
        :type envConfig: :py:class:`CTestEnvironmentConfig`
        :param envConfig: configuration used to get ID of core 0, if core
                             ID is not specified in the test case. Alternatively
                             you can specify default core ID by calling
                             setDefaultCoreId() before this method, and set this value to NULL.
        """
        return _connect.CTestHostVars_initTestGroupVars(self, group, envConfig)

    def initTestCaseVars(self, testSpec: "isys::CTestSpecificationSPtr &", envConfig: "isys::CTestEnvironmentConfigSPtr") -> "void":
        r"""
        Initializes host variables from test case, for example ${_testID}.
        If host variables with directories are needed, call setDirs() before
        this method.

        :type testSpec: :py:class:`CTestSpecification`
        :param testSpec: the test case used to initialize variables
        :type envConfig: :py:class:`CTestEnvironmentConfig`
        :param envConfig: configuration used to get ID of core 0, if core
                             ID is not specified in the test case. Alternatively
                             you can specify default core ID by calling
                             setDefaultCoreId() before this method, and set this value to NULL.
        """
        return _connect.CTestHostVars_initTestCaseVars(self, testSpec, envConfig)

    def initBatchVars(self) -> "void":
        r"""Initializes host variables for batch of test cases, for example date and time."""
        return _connect.CTestHostVars_initBatchVars(self)

    @staticmethod
    def createDiagramVars(testSpec: "isys::CTestSpecificationSPtr &", diagConfig: "isys::CTestDiagramConfigSPtr &") -> "CTestHostVars":
        r"""Creates instance of this class with host variables used in diagrams section."""
        return _connect.CTestHostVars_createDiagramVars(testSpec, diagConfig)

    @staticmethod
    def createTcAnalyzerFNameVars(testSpec: "isys::CTestSpecificationSPtr &") -> "CTestHostVars":
        r"""Initializes host vars for test case analyzer file name."""
        return _connect.CTestHostVars_createTcAnalyzerFNameVars(testSpec)

    @staticmethod
    def createGrpAnalyzerFNameVars(testGroup: "isys::CTestGroupSPtr &") -> "CTestHostVars":
        r"""Initializes host vars for group merged analyzer file name."""
        return _connect.CTestHostVars_createGrpAnalyzerFNameVars(testGroup)

    def toString(self) -> "std::string":
        r"""
        Returns all host variables and their values as string.
        Use this method for debugging purposes only.
        """
        return _connect.CTestHostVars_toString(self)
    __swig_destroy__ = _connect.delete_CTestHostVars

# Register CTestHostVars in _connect:
_connect.CTestHostVars_swigregister(CTestHostVars)
CTestHostVars.RESERVED_ENV_PREFIX = _connect.cvar.CTestHostVars_RESERVED_ENV_PREFIX
CTestHostVars.RESERVED_GROUP_ID = _connect.cvar.CTestHostVars_RESERVED_GROUP_ID
CTestHostVars.RESERVED_PARTITION = _connect.cvar.CTestHostVars_RESERVED_PARTITION
CTestHostVars.RESERVED_MODULE = _connect.cvar.CTestHostVars_RESERVED_MODULE
CTestHostVars.RESERVED_TEST_ID = _connect.cvar.CTestHostVars_RESERVED_TEST_ID
CTestHostVars.RESERVED_TAGS = _connect.cvar.CTestHostVars_RESERVED_TAGS
CTestHostVars.RESERVED_FUNCTION = _connect.cvar.CTestHostVars_RESERVED_FUNCTION
CTestHostVars.RESERVED_PARAMS = _connect.cvar.CTestHostVars_RESERVED_PARAMS
CTestHostVars.RESERVED_CORE_ID = _connect.cvar.CTestHostVars_RESERVED_CORE_ID
CTestHostVars.RESERVED_USER = _connect.cvar.CTestHostVars_RESERVED_USER
CTestHostVars.RESERVED_DATE = _connect.cvar.CTestHostVars_RESERVED_DATE
CTestHostVars.RESERVED_TIME = _connect.cvar.CTestHostVars_RESERVED_TIME
CTestHostVars.RESERVED_ISO_TIME = _connect.cvar.CTestHostVars_RESERVED_ISO_TIME
CTestHostVars.RESERVED_UID = _connect.cvar.CTestHostVars_RESERVED_UID
CTestHostVars.RESERVED_BATCH_DATE = _connect.cvar.CTestHostVars_RESERVED_BATCH_DATE
CTestHostVars.RESERVED_BATCH_TIME = _connect.cvar.CTestHostVars_RESERVED_BATCH_TIME
CTestHostVars.RESERVED_BATCH_UID = _connect.cvar.CTestHostVars_RESERVED_BATCH_UID
CTestHostVars.RESERVED_DIAGRAM_TYPE = _connect.cvar.CTestHostVars_RESERVED_DIAGRAM_TYPE
CTestHostVars.RESERVED_WINIDEA_WORKSPACE_DIR = _connect.cvar.CTestHostVars_RESERVED_WINIDEA_WORKSPACE_DIR
CTestHostVars.RESERVED_WINIDEA_WORKSPACE_FILE = _connect.cvar.CTestHostVars_RESERVED_WINIDEA_WORKSPACE_FILE
CTestHostVars.RESERVED_DEFAULT_DL_DIR = _connect.cvar.CTestHostVars_RESERVED_DEFAULT_DL_DIR
CTestHostVars.RESERVED_DEFAULT_DL_FILE = _connect.cvar.CTestHostVars_RESERVED_DEFAULT_DL_FILE
CTestHostVars.RESERVED_IYAML_DIR = _connect.cvar.CTestHostVars_RESERVED_IYAML_DIR
CTestHostVars.RESERVED_REPORT_DIR = _connect.cvar.CTestHostVars_RESERVED_REPORT_DIR
CTestHostVars.RESERVED_NID = _connect.cvar.CTestHostVars_RESERVED_NID
CTestHostVars.RESERVED_DID = _connect.cvar.CTestHostVars_RESERVED_DID
CTestHostVars.RESERVED_UUID = _connect.cvar.CTestHostVars_RESERVED_UUID
CTestHostVars.RESERVED_SEQ = _connect.cvar.CTestHostVars_RESERVED_SEQ
CTestHostVars.RESERVED_FUNC_UNDER_TEST = _connect.cvar.CTestHostVars_RESERVED_FUNC_UNDER_TEST
CTestHostVars.RESERVED_SVN_REVISION = _connect.cvar.CTestHostVars_RESERVED_SVN_REVISION
CTestHostVars.RESERVED_CUSTOM_DIAGRAM_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_CUSTOM_DIAGRAM_POSTFIX
CTestHostVars.RESERVED_SEQUENCE_DIAGRAM_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_SEQUENCE_DIAGRAM_POSTFIX
CTestHostVars.RESERVED_FLOW_CHART_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_FLOW_CHART_POSTFIX
CTestHostVars.RESERVED_RUNTIME_CALL_GRAPH_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_RUNTIME_CALL_GRAPH_POSTFIX
CTestHostVars.RESERVED_STATIC_CALL_GRAPH_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_STATIC_CALL_GRAPH_POSTFIX
CTestHostVars.RESERVED_FLAME_GRAPH_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_FLAME_GRAPH_POSTFIX

def CTestHostVars_getDiagramFileName(testSpec: "isys::CTestSpecificationSPtr &", diagConfig: "isys::CTestDiagramConfigSPtr &") -> "std::string":
    r"""
    Returns file name of a diagram, where all host vars are replaced with
    their values.
    """
    return _connect.CTestHostVars_getDiagramFileName(testSpec, diagConfig)

def CTestHostVars_getHostVarsForAnalyzerFileName(hostVars: "StrVector") -> "void":
    r"""Returns list of host variables available for analyzer file name."""
    return _connect.CTestHostVars_getHostVarsForAnalyzerFileName(hostVars)

def CTestHostVars_getHostVarsForGroupAnalyzerFileName(hostVars: "StrVector") -> "void":
    r"""Returns list of host variables available for group analyzer file name."""
    return _connect.CTestHostVars_getHostVarsForGroupAnalyzerFileName(hostVars)

def CTestHostVars_getHostVarsForAutoTestId(hostVars: "StrVector", isIncludeCoreId: "bool", isForProposals: "bool") -> "void":
    r"""Returns list of host variables available for test case ID."""
    return _connect.CTestHostVars_getHostVarsForAutoTestId(hostVars, isIncludeCoreId, isForProposals)

def CTestHostVars_createDiagramVars(testSpec: "isys::CTestSpecificationSPtr &", diagConfig: "isys::CTestDiagramConfigSPtr &") -> "CTestHostVars":
    r"""Creates instance of this class with host variables used in diagrams section."""
    return _connect.CTestHostVars_createDiagramVars(testSpec, diagConfig)

def CTestHostVars_createTcAnalyzerFNameVars(testSpec: "isys::CTestSpecificationSPtr &") -> "CTestHostVars":
    r"""Initializes host vars for test case analyzer file name."""
    return _connect.CTestHostVars_createTcAnalyzerFNameVars(testSpec)

def CTestHostVars_createGrpAnalyzerFNameVars(testGroup: "isys::CTestGroupSPtr &") -> "CTestHostVars":
    r"""Initializes host vars for group merged analyzer file name."""
    return _connect.CTestHostVars_createGrpAnalyzerFNameVars(testGroup)

class CTestDryRun(CTestBase):
    r"""
    This class contains specification for dry run. Assignments stored in
    this class will be evaluated during dry run test and then copied to
    section Variables.



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_ASSIGN = _connect.CTestDryRun_E_SECTION_ASSIGN
    E_SECTION_UPDATE_COVERAGE = _connect.CTestDryRun_E_SECTION_UPDATE_COVERAGE
    E_SECTION_UPDATE_PROFILER = _connect.CTestDryRun_E_SECTION_UPDATE_PROFILER
    E_SECTION_PROFILER_MULTIPLIER = _connect.CTestDryRun_E_SECTION_PROFILER_MULTIPLIER
    E_SECTION_PROFILER_OFFSET = _connect.CTestDryRun_E_SECTION_PROFILER_OFFSET

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new instance. Parent is not set.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class.
        """
        _connect.CTestDryRun_swiginit(self, _connect.new_CTestDryRun(*args))
    __swig_destroy__ = _connect.delete_CTestDryRun

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestDryRun_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestDryRun":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestDryRun_cast(testBase)

    def getAssignments(self, isConst: "bool") -> "isys::CMapAdapter":
        r""" Returns assignments to host variables."""
        return _connect.CTestDryRun_getAssignments(self, isConst)

    def isUpdateCoverage(self) -> "iconnect::ETristate":
        r"""
        Returns true, if required coverage statistics should be updated during
        dry run. Only items already defined in statistics will be modified.
        """
        return _connect.CTestDryRun_isUpdateCoverage(self)

    def isUpdateProfiler(self) -> "iconnect::ETristate":
        r"""
        Returns true, if required profiler statistics should be updated during
        dry run. Only items already defined in statistics will be modified.
        """
        return _connect.CTestDryRun_isUpdateProfiler(self)

    def getProfilerMultiplier(self) -> "std::string":
        r"""
        Returns value used to adapt profiler expected value according to
        measured value: new_value = measured_value * multiplier + offset.
        """
        return _connect.CTestDryRun_getProfilerMultiplier(self)

    def getProfilerOffset(self) -> "std::string":
        r"""
        Returns value used to adapt profiler expected value according to
        measured value: new_value = measured_value * multiplier + offset.
        """
        return _connect.CTestDryRun_getProfilerOffset(self)

    def setUpdateCoverage(self, isUpdate: "iconnect::ETristate") -> "void":
        r"""
        Set value to true, if required coverage statistics should be updated during
        dry run. Only items already defined in statistics will be modified.
        """
        return _connect.CTestDryRun_setUpdateCoverage(self, isUpdate)

    def setUpdateProfiler(self, isUpdate: "iconnect::ETristate") -> "void":
        r"""
        Set value to true, if required profiler statistics should be updated during
        dry run. Only items already defined in statistics will be modified.
        """
        return _connect.CTestDryRun_setUpdateProfiler(self, isUpdate)

# Register CTestDryRun in _connect:
_connect.CTestDryRun_swigregister(CTestDryRun)

def CTestDryRun_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestDryRun":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestDryRun_cast(testBase)

class CTestDiagramConfig(CTestBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_DIAG_CFG_IS_ACTIVE = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_IS_ACTIVE
    E_SECTION_DIAG_CFG_DIAG_TYPE = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_DIAG_TYPE
    E_SECTION_DIAG_CFG_SCRIPT = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_SCRIPT
    E_SECTION_DIAG_CFG_PARAMS = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_PARAMS
    E_SECTION_DIAG_CFG_OUT_FILE_NAME = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_OUT_FILE_NAME
    E_SECTION_DIAG_CFG_IS_ADD_TO_REPORT = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_IS_ADD_TO_REPORT
    E_SECTION_DIAG_CFG_VIEWER_TYPE = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_VIEWER_TYPE
    E_SECTION_DIAG_CFG_DATA_FORMAT = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_DATA_FORMAT
    E_SECTION_DIAG_CFG_EXTERNAL_VIEWER = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_EXTERNAL_VIEWER
    EFlowChart = _connect.CTestDiagramConfig_EFlowChart
    r""" flow chart based on assembly info"""
    ESequenceDiagram = _connect.CTestDiagramConfig_ESequenceDiagram
    r""" sequence diagram based on profiler recording"""
    ERuntimeCallGraph = _connect.CTestDiagramConfig_ERuntimeCallGraph
    r""" call graph based on profiler recording"""
    EStaticCallGraph = _connect.CTestDiagramConfig_EStaticCallGraph
    r""" call graph based on static information in download file"""
    EFlameGraph = _connect.CTestDiagramConfig_EFlameGraph
    r""" provides condensed call stack information"""
    ECustom = _connect.CTestDiagramConfig_ECustom
    r"""
    custom script is called, testIDEA waits until it returns.
    Use this option when script writes image to file. testIDEA
    also prints stdout and stderr in this case, which is useful in case of problems.
    """
    ECustomAsync = _connect.CTestDiagramConfig_ECustomAsync
    r"""
    custom script is called, testIDEA continues immediately.
    Use this option when Python script opens its own window
    with chart (calls matplotlib's show() method).
    """
    EMultipage = _connect.CTestDiagramConfig_EMultipage
    r"""
    open file in multipage editor window, one editor
    window per test case ID, one page (bottom tab) per diagram
    """
    ESinglePage = _connect.CTestDiagramConfig_ESinglePage
    r""" open file in editor window"""
    EExternal = _connect.CTestDiagramConfig_EExternal
    ENone = _connect.CTestDiagramConfig_ENone
    r"""
    do not open this file in viewer. In testIDEA output
    is shown below the table in section Diagrams on line
    selection
    """
    EByExtension = _connect.CTestDiagramConfig_EByExtension
    r""" display format is determined on extension: svg, csv, txt, png, jpg, jpeg, bmp"""
    EBitmap = _connect.CTestDiagramConfig_EBitmap
    r""" one of bitmap formats (jpg, bmp, ...)"""
    ESVG = _connect.CTestDiagramConfig_ESVG
    r""" SVG format"""

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default ctor.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestDiagrams class.
        """
        _connect.CTestDiagramConfig_swiginit(self, _connect.new_CTestDiagramConfig(*args))
    __swig_destroy__ = _connect.delete_CTestDiagramConfig

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestDiagramConfig_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestDiagramConfig":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestDiagramConfig_cast(testBase)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestDiagramConfig_isMerged(self)

    def isActive(self) -> "iconnect::ETristate":
        return _connect.CTestDiagramConfig_isActive(self)

    def getDiagramType(self) -> "isys::CTestDiagramConfig::EDiagType":
        return _connect.CTestDiagramConfig_getDiagramType(self)

    def getViewerType(self) -> "isys::CTestDiagramConfig::EViewerType":
        return _connect.CTestDiagramConfig_getViewerType(self)

    def getViewFormat(self) -> "isys::CTestDiagramConfig::EViewFormat":
        return _connect.CTestDiagramConfig_getViewFormat(self)

    def getScriptName(self) -> "std::string":
        return _connect.CTestDiagramConfig_getScriptName(self)

    def getParameters(self, isConst: "bool") -> "isys::CSequenceAdapter":
        return _connect.CTestDiagramConfig_getParameters(self, isConst)

    def getOutputFileName(self) -> "std::string":
        return _connect.CTestDiagramConfig_getOutputFileName(self)

    def isAddToReport(self) -> "iconnect::ETristate":
        return _connect.CTestDiagramConfig_isAddToReport(self)

    def getExternalViewerName(self) -> "std::string":
        return _connect.CTestDiagramConfig_getExternalViewerName(self)

    def getScriptCmdLineArgs(self, testSpec: "isys::CTestSpecificationSPtr &", outFile: "std::string const &", profilerExportFile: "std::string const &", dotExeDir: "std::string const &", cmdLineArgs: "StrVector") -> "void":
        return _connect.CTestDiagramConfig_getScriptCmdLineArgs(self, testSpec, outFile, profilerExportFile, dotExeDir, cmdLineArgs)

    def parsingEnd(self) -> "void":
        return _connect.CTestDiagramConfig_parsingEnd(self)

# Register CTestDiagramConfig in _connect:
_connect.CTestDiagramConfig_swigregister(CTestDiagramConfig)
CTestDiagramConfig.SEQ_AND_CALL_DIAG_PY = _connect.cvar.CTestDiagramConfig_SEQ_AND_CALL_DIAG_PY
CTestDiagramConfig.STATIC_CALL_GRAPH_PY = _connect.cvar.CTestDiagramConfig_STATIC_CALL_GRAPH_PY
CTestDiagramConfig.FLOW_CHART_PY = _connect.cvar.CTestDiagramConfig_FLOW_CHART_PY
CTestDiagramConfig.FLAME_GRAPH_PY = _connect.cvar.CTestDiagramConfig_FLAME_GRAPH_PY

def CTestDiagramConfig_cast(testBase: "isys::CTestBaseSPtr const &") -> "CTestDiagramConfig":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestDiagramConfig_cast(testBase)

class CTestDiagrams(CTestBase):
    r"""This class contains configurations for all diagrams of one test-case."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_DIAG_IS_ACTIVE = _connect.CTestDiagrams_E_SECTION_DIAG_IS_ACTIVE
    E_SECTION_DIAG_CONFIGS = _connect.CTestDiagrams_E_SECTION_DIAG_CONFIGS

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default ctor.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class.
        """
        _connect.CTestDiagrams_swiginit(self, _connect.new_CTestDiagrams(*args))
    __swig_destroy__ = _connect.delete_CTestDiagrams

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestDiagrams_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestDiagrams":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestDiagrams_cast(testBase)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestDiagrams_isMerged(self)

    def isActive(self) -> "iconnect::ETristate":
        return _connect.CTestDiagrams_isActive(self)

    def getConfigurations(self, isConst: "bool") -> "CTestBaseList":
        return _connect.CTestDiagrams_getConfigurations(self, isConst)

    def createTestBase(self, section: "int", lineNo: "size_t") -> "CTestBase":
        return _connect.CTestDiagrams_createTestBase(self, section, lineNo)

# Register CTestDiagrams in _connect:
_connect.CTestDiagrams_swigregister(CTestDiagrams)

def CTestDiagrams_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestDiagrams":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestDiagrams_cast(testBase)

class CTestStopCondition(CTestBase):
    r"""
    This class defines stop condition for system tests. There exist
    three possibilities:

    - set breakpoint: target will stop on the breakpoint
    - set timeout: target will be stopped after the timeout
    - breakpoint after timeout: breakpoint will be set after the
                                specified timeout, and target will stop
                                when the breakpoint is hit

    This condition can be applied before system test to initialize the
    target, and as test termination condition.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_BREAKPOINT = _connect.CTestStopCondition_E_BREAKPOINT
    E_STOP = _connect.CTestStopCondition_E_STOP
    E_RT_EXPRESSION = _connect.CTestStopCondition_E_RT_EXPRESSION
    E_NO_RUN = _connect.CTestStopCondition_E_NO_RUN
    E_SECTION_STOP_TYPE = _connect.CTestStopCondition_E_SECTION_STOP_TYPE
    E_SECTION_TIMEOUT = _connect.CTestStopCondition_E_SECTION_TIMEOUT
    E_SECTION_RT_EXPRESSION = _connect.CTestStopCondition_E_SECTION_RT_EXPRESSION
    E_SECTION_BP_CONDITION_COUNT = _connect.CTestStopCondition_E_SECTION_BP_CONDITION_COUNT
    E_SECTION_BP_CONDITION_EXPR = _connect.CTestStopCondition_E_SECTION_BP_CONDITION_EXPR
    E_SECTION_BP_LOCATION = _connect.CTestStopCondition_E_SECTION_BP_LOCATION

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestPoint class.
        """
        _connect.CTestStopCondition_swiginit(self, _connect.new_CTestStopCondition(*args))
    __swig_destroy__ = _connect.delete_CTestStopCondition

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestStopCondition_createInstance(self, parent)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestStopCondition":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestStopCondition_cast(testBase)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestStopCondition_isMerged(self)

    def getStopType(self) -> "isys::CTestStopCondition::EStopType":
        r""" Returns stop type."""
        return _connect.CTestStopCondition_getStopType(self)

    def getTimeout(self) -> "int":
        r""" Returns timeout in milliseconds."""
        return _connect.CTestStopCondition_getTimeout(self)

    def getRtExpression(self) -> "std::string":
        r""" Returns timeout in milliseconds."""
        return _connect.CTestStopCondition_getRtExpression(self)

    def getConditionCount(self) -> "int":
        r""" Returns condition count for breakpoint."""
        return _connect.CTestStopCondition_getConditionCount(self)

    def getConditionExpr(self) -> "std::string":
        r""" Returns condition expression for breakpoint."""
        return _connect.CTestStopCondition_getConditionExpr(self)

    def getBreakpointLocation(self, isConst: "bool") -> "CTestLocation":
        r""" Returns location of breakpoint."""
        return _connect.CTestStopCondition_getBreakpointLocation(self, isConst)

    def setStopType(self, stopType: "isys::CTestStopCondition::EStopType") -> "void":
        r""" Sets stop type."""
        return _connect.CTestStopCondition_setStopType(self, stopType)

    def setTimeout(self, timeout: "int") -> "void":
        r""" Sets timeout in milliseconds."""
        return _connect.CTestStopCondition_setTimeout(self, timeout)

    def setConditionCount(self, conditionCount: "int") -> "void":
        r""" Sets condition count for test-point."""
        return _connect.CTestStopCondition_setConditionCount(self, conditionCount)

    def setConditionExpr(self, expr: "std::string const &") -> "void":
        r""" Sets condition expression for test-point."""
        return _connect.CTestStopCondition_setConditionExpr(self, expr)

    def setRtExpression(self, rtExpression: "std::string const &") -> "void":
        r""" Returns timeout in milliseconds."""
        return _connect.CTestStopCondition_setRtExpression(self, rtExpression)

    def createTestBase(self, section: "int", lineNo: "size_t") -> "CTestBase":
        return _connect.CTestStopCondition_createTestBase(self, section, lineNo)

# Register CTestStopCondition in _connect:
_connect.CTestStopCondition_swigregister(CTestStopCondition)

def CTestStopCondition_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestStopCondition":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestStopCondition_cast(testBase)

class CTestImportSources(CTestBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_IS_INHERIT = _connect.CTestImportSources_E_SECTION_IS_INHERIT
    E_SECTION_TEST_IDS = _connect.CTestImportSources_E_SECTION_TEST_IDS

    def __init__(self, *args):
        _connect.CTestImportSources_swiginit(self, _connect.new_CTestImportSources(*args))
    __swig_destroy__ = _connect.delete_CTestImportSources

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestImportSources_createInstance(self, parent)

    def createTestBase(self, section: "int", lineNo: "size_t") -> "CTestBase":
        return _connect.CTestImportSources_createTestBase(self, section, lineNo)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestImportSources_isMerged(self)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestImportSources":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestImportSources_cast(testBase)

    def isInheritance(self) -> "iconnect::ETristate":
        r"""
        Returns true, if this section is inherited from base test
        specification, false otherwise.
        """
        return _connect.CTestImportSources_isInheritance(self)

    def setInheritance(self, inheritance: "iconnect::ETristate") -> "void":
        r"""
        Sets inheritance to the given value. Value E_INHERIT_DEFAULT
        removes setting from test spec.
        """
        return _connect.CTestImportSources_setInheritance(self, inheritance)

    def getImportedTestIds(self, isConst: "bool") -> "isys::CSequenceAdapter":
        return _connect.CTestImportSources_getImportedTestIds(self, isConst)

# Register CTestImportSources in _connect:
_connect.CTestImportSources_swigregister(CTestImportSources)

def CTestImportSources_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestImportSources":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestImportSources_cast(testBase)

class CTestImports(CTestBase):
    r"""This class defines test case inheritance and aggregation."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CTestImports_swiginit(self, _connect.new_CTestImports(*args))
    __swig_destroy__ = _connect.delete_CTestImports

    def createInstance(self, parent: "isys::CTestBaseSPtr const &") -> "CTestBase":
        return _connect.CTestImports_createInstance(self, parent)

    def createTestBase(self, section: "int", lineNo: "size_t") -> "CTestBase":
        return _connect.CTestImports_createTestBase(self, section, lineNo)

    def isMerged(self) -> "bool":
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestImports_isMerged(self)

    @staticmethod
    def cast(testBase: "isys::CTestBaseSPtr &") -> "CTestImports":
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestImports_cast(testBase)

    def getSectionSources(self, section: "isys::CTestSpecification::SectionIds", isConst: "bool") -> "CTestImportSources":
        r""" Returns sources for inheritance and aggregation."""
        return _connect.CTestImports_getSectionSources(self, section, isConst)

# Register CTestImports in _connect:
_connect.CTestImports_swigregister(CTestImports)

def CTestImports_cast(testBase: "isys::CTestBaseSPtr &") -> "CTestImports":
    r"""
    Casts the given object to this class. Returns NULL if input is NULL.

    :raises: IllegalArgumentException if input object is not instance of this class.
    """
    return _connect.CTestImports_cast(testBase)

class CSourceCodeFile(object):
    r"""
    This class handles parsing and writing of test specifications
    stored in special comments in C/C++ source code files.

    Because the natural order of functions may not be the natural order of
    base/derived test specifications, and developers do not like test tool
    to dictate the order of functions in a file, test specifications hierarchy
    is made more flexible. To achieve this flexibility, new tag 'baseId' has been
    added, which specifies the parent test spec, which may be defined in
    another comment.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CSourceCodeFile_swiginit(self, _connect.new_CSourceCodeFile())
    __swig_destroy__ = _connect.delete_CSourceCodeFile

    def load(self, fileName: "std::string const &") -> "CTestBench":
        r"""
        Loads test specifications from the given source code file. Test
        specifications must be stored in a special C comments, which start with '/ *#'.
        """
        return _connect.CSourceCodeFile_load(self, fileName)

    def save(self, testBench: "isys::CTestBenchSPtr") -> "void":
        r"""
        Saves the file. It is caller's responsibility to verify if some other
        application has changed the file since it was loaded. Call the method
        ``hasFileChenged()`` to find out.
        """
        return _connect.CSourceCodeFile_save(self, testBench)

    def saveAs(self, fileName: "std::string const &", testBench: "isys::CTestBenchSPtr", forceOverwrite: "bool") -> "bool":
        r"""
        Saves the file with new name.

        :type forceOverwrite: boolean
        :param forceOverwrite: if true, overwrites any existing file. Call this method
            first by setting this parameter to false, and if false is returned, ask the user if
            he wants to overwrite. Only then set this parameter to true.

        :rtype: boolean
        :return: false if forceOverwrite was false and the file already exists, true otherwise.
        """
        return _connect.CSourceCodeFile_saveAs(self, fileName, testBench, forceOverwrite)

    def close(self) -> "void":
        r"""
        Call this method to delete the temp file and make the object ready for new
        call to the ``load()`` method.
        """
        return _connect.CSourceCodeFile_close(self)

    def getErrors(self) -> "std::string":
        r"""
        Call this method after saving the source file. If there were any
        errors, the file is still saved, but user may have to fix something,
        for example assign test IDs.
        """
        return _connect.CSourceCodeFile_getErrors(self)

    def assignCommentLocation(self, testSpec: "isys::CTestSpecificationSPtr &") -> "void":
        r"""
        Assigns comment location of the given test spec. This method may be called
        when the 'testSpec' has been moved or inserted in the test tree. This way
        we can improve placement of test specifications into code comments,
        especially if many movements of neighboring test specifications are made back
        and forth.

        The algorithm:

        First the test specs on
        the same level are checked. If there are test specs preceding the given one,
        location of the predecessor's, which has location defined, is used. If there is no
        predecessor, location of the first successor with location defined is used. If neither
        successor with defined location exists, the parent's location is used. If also the
        parent's location is not defined, location of the 'testSpec' is set to NOT_SET.
        """
        return _connect.CSourceCodeFile_assignCommentLocation(self, testSpec)

# Register CSourceCodeFile in _connect:
_connect.CSourceCodeFile_swigregister(CSourceCodeFile)

class CYAMLUtil(object):
    r"""This class contains utility methods for handling of YAML data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def parseTestBase(yamlSpec: "std::string const &", testBase: "isys::CTestBaseSPtr") -> "void":
        r"""
        Parses the given yaml spec to the given test base. It is caller's responsibility
        that yamlSpec contains serialized derived class of the given test base.
        """
        return _connect.CYAMLUtil_parseTestBase(yamlSpec, testBase)

    @staticmethod
    def parseTestBaseList(yamlSpec: "std::string const &", parentTestBase: "isys::CTestBaseSPtr &", section: "int") -> "void":
        r"""
        Parses the given YAML string to the given section of the
        parentTestBase.
        """
        return _connect.CYAMLUtil_parseTestBaseList(yamlSpec, parentTestBase, section)

    @staticmethod
    def cto2ctb(src: "isys::CTestObjectSPtr const &") -> "CTestBase":
        r""" Casts CTestObjectSPtr to CTestBaseSPtr. Throws exception on failure."""
        return _connect.CYAMLUtil_cto2ctb(src)

    @staticmethod
    def cto2ctbl(src: "isys::CTestObjectSPtr const &") -> "CTestBaseList":
        r""" Casts CTestObjectSPtr to CTestBaseListSPtr. Throws exception on failure."""
        return _connect.CYAMLUtil_cto2ctbl(src)

    @staticmethod
    def isInstanceOfCtb(src: "isys::CTestObjectSPtr const &") -> "bool":
        r""" Returns true, if src is instance of CTestBase."""
        return _connect.CYAMLUtil_isInstanceOfCtb(src)

    @staticmethod
    def isInstanceOfCtbList(src: "isys::CTestObjectSPtr const &") -> "bool":
        r""" Returns true, if src is instance of CTestBaseList."""
        return _connect.CYAMLUtil_isInstanceOfCtbList(src)

    @staticmethod
    def strVector2Str(vec: "StrVector") -> "std::string":
        r"""
        Returns string representing vector of strings separated by commas,
        without '[' and ']'.
        It is valid YAML string only if members of vector are properly quoted.
        See parameter 'isForEditor' in CTestSpecification::getParameters()
        regarding quoting.
        """
        return _connect.CYAMLUtil_strVector2Str(vec)

    @staticmethod
    def strStrMap2OrderedStr(mapping: "StrStrMap", keys: "StrVector", isFlowStyle: "bool") -> "std::string":
        r"""
        Returns string representing mapping of strings in the order specified in ``keys``.
        No validation is done that all items from mapping have keys in ``keys`` parameter.

        It is valid YAML string only if members of mapping are properly quoted.
        See parameter 'isForEditor' in CTestSpecification::getLocalVariables()
        regarding quoting.

        :type mapping: :py:class:`StrStrMap`
        :param mapping: object containing data to be converted to string
        :type keys: :py:class:`StrVector`
        :param keys: vector with keys of mapping pairs to be added to string in
                        the same order as specified in this vector.
        :type isFlowStyle: boolean
        :param isFlowStyle: if true, result is in YAML flow style, with symbols {,}
        """
        return _connect.CYAMLUtil_strStrMap2OrderedStr(mapping, keys, isFlowStyle)

    @staticmethod
    def strVectorVector2Str(keys: "StrVector", values: "StrVector", isFlowStyle: "bool") -> "std::string":
        r"""
        Returns string representing mapping of strings.
        It is valid YAML string only if members of mapping are properly quoted.

        :type isFlowStyle: boolean
        :param isFlowStyle: if true, result is in YAML flow style, with symbols {,}
        """
        return _connect.CYAMLUtil_strVectorVector2Str(keys, values, isFlowStyle)

    @staticmethod
    def strVector2Sequence(dest: "isys::CTestBaseSPtr &", section: "int", items: "StrVector") -> "void":
        r"""Copies items from StrVector to the given section in CTestBase."""
        return _connect.CYAMLUtil_strVector2Sequence(dest, section, items)

    @staticmethod
    def verifyLimitedScalar(yamlSpec: "std::string const &", msg: "std::string const &") -> "void":
        r"""
        Deprecated: use verifyTestId() instead. This method uses YAML parser, which is
                    redundant step and may produce cryptic error messages if input is not
                    valid YAML scalar.
        This method may be used to verify, if the given string represents scalar
        with limited set of characters. Examples of such scalars are test IDs
        and tags.
        Exception with error description is thrown, if it is not.
        """
        return _connect.CYAMLUtil_verifyLimitedScalar(yamlSpec, msg)

    @staticmethod
    def getSymbolsAllowedTestId() -> "std::string":
        r""" Returns string containing all symbols (non-alphanum) chars allowed in test ID or group ID."""
        return _connect.CYAMLUtil_getSymbolsAllowedTestId()

    @staticmethod
    def verifyTestId(testID: "std::string const &", msg: "std::string const &") -> "std::string":
        r"""
        This method may be used to verify, if the given string represents scalar
        with limited set of characters. Examples of such scalars are test IDs
        and tags.
        Error description is returned in case of invalid entry, empty string otherwise.
        """
        return _connect.CYAMLUtil_verifyTestId(testID, msg)

    @staticmethod
    def verifyScalar(yamlSpec: "std::string const &") -> "void":
        r"""
        This method may be used to verify, if the given string represents YAML scalar.
        Exception with error description is thrown, if it is not.
        """
        return _connect.CYAMLUtil_verifyScalar(yamlSpec)

    @staticmethod
    def verifyList(yamlSpec: "std::string const &") -> "void":
        r"""
        This method may be used to verify, if the given string represents YAML list.
        Exception with error description is thrown, if it is not.
        """
        return _connect.CYAMLUtil_verifyList(yamlSpec)

    @staticmethod
    def verifyListOfLimitedScalars(yamlSpec: "std::string const &", msg: "std::string const &") -> "void":
        r"""
        This method verifies, if all scalars in the list contain only allowed characters.
        See CLimitedScalarValidator for details.
        """
        return _connect.CYAMLUtil_verifyListOfLimitedScalars(yamlSpec, msg)

    @staticmethod
    def verifyMap(yamlSpec: "std::string const &") -> "void":
        r"""
        This method may be used to verify, if the given string represents YAML map.
        Exception with error description is thrown, if it is not.
        """
        return _connect.CYAMLUtil_verifyMap(yamlSpec)

    @staticmethod
    def isAllowedCharForTestId(c: "char") -> "bool":
        r"""Returns true, if character is valid for testID."""
        return _connect.CYAMLUtil_isAllowedCharForTestId(c)

    @staticmethod
    def replaceInvalidChars(param: "std::string const") -> "std::string":
        r"""Replaces characters, which are invalid in testID or file name with '_'."""
        return _connect.CYAMLUtil_replaceInvalidChars(param)

    @staticmethod
    def join(params: "StrVector", separator: "char") -> "std::string":
        r"""Joins list of strings to single string."""
        return _connect.CYAMLUtil_join(params, separator)

    @staticmethod
    def getCurrentISODate() -> "std::string":
        r"""Returns current date in YYYY-MM-DD format."""
        return _connect.CYAMLUtil_getCurrentISODate()

    @staticmethod
    def getCurrentISOTime() -> "std::string":
        r"""Returns current time in HH-MM-SS format."""
        return _connect.CYAMLUtil_getCurrentISOTime()

    def __init__(self):
        _connect.CYAMLUtil_swiginit(self, _connect.new_CYAMLUtil())
    __swig_destroy__ = _connect.delete_CYAMLUtil

# Register CYAMLUtil in _connect:
_connect.CYAMLUtil_swigregister(CYAMLUtil)

def CYAMLUtil_parseTestBase(yamlSpec: "std::string const &", testBase: "isys::CTestBaseSPtr") -> "void":
    r"""
    Parses the given yaml spec to the given test base. It is caller's responsibility
    that yamlSpec contains serialized derived class of the given test base.
    """
    return _connect.CYAMLUtil_parseTestBase(yamlSpec, testBase)

def CYAMLUtil_parseTestBaseList(yamlSpec: "std::string const &", parentTestBase: "isys::CTestBaseSPtr &", section: "int") -> "void":
    r"""
    Parses the given YAML string to the given section of the
    parentTestBase.
    """
    return _connect.CYAMLUtil_parseTestBaseList(yamlSpec, parentTestBase, section)

def CYAMLUtil_cto2ctb(src: "isys::CTestObjectSPtr const &") -> "CTestBase":
    r""" Casts CTestObjectSPtr to CTestBaseSPtr. Throws exception on failure."""
    return _connect.CYAMLUtil_cto2ctb(src)

def CYAMLUtil_cto2ctbl(src: "isys::CTestObjectSPtr const &") -> "CTestBaseList":
    r""" Casts CTestObjectSPtr to CTestBaseListSPtr. Throws exception on failure."""
    return _connect.CYAMLUtil_cto2ctbl(src)

def CYAMLUtil_isInstanceOfCtb(src: "isys::CTestObjectSPtr const &") -> "bool":
    r""" Returns true, if src is instance of CTestBase."""
    return _connect.CYAMLUtil_isInstanceOfCtb(src)

def CYAMLUtil_isInstanceOfCtbList(src: "isys::CTestObjectSPtr const &") -> "bool":
    r""" Returns true, if src is instance of CTestBaseList."""
    return _connect.CYAMLUtil_isInstanceOfCtbList(src)

def CYAMLUtil_strVector2Str(vec: "StrVector") -> "std::string":
    r"""
    Returns string representing vector of strings separated by commas,
    without '[' and ']'.
    It is valid YAML string only if members of vector are properly quoted.
    See parameter 'isForEditor' in CTestSpecification::getParameters()
    regarding quoting.
    """
    return _connect.CYAMLUtil_strVector2Str(vec)

def CYAMLUtil_strStrMap2OrderedStr(mapping: "StrStrMap", keys: "StrVector", isFlowStyle: "bool") -> "std::string":
    r"""
    Returns string representing mapping of strings in the order specified in ``keys``.
    No validation is done that all items from mapping have keys in ``keys`` parameter.

    It is valid YAML string only if members of mapping are properly quoted.
    See parameter 'isForEditor' in CTestSpecification::getLocalVariables()
    regarding quoting.

    :type mapping: :py:class:`StrStrMap`
    :param mapping: object containing data to be converted to string
    :type keys: :py:class:`StrVector`
    :param keys: vector with keys of mapping pairs to be added to string in
                    the same order as specified in this vector.
    :type isFlowStyle: boolean
    :param isFlowStyle: if true, result is in YAML flow style, with symbols {,}
    """
    return _connect.CYAMLUtil_strStrMap2OrderedStr(mapping, keys, isFlowStyle)

def CYAMLUtil_strVectorVector2Str(keys: "StrVector", values: "StrVector", isFlowStyle: "bool") -> "std::string":
    r"""
    Returns string representing mapping of strings.
    It is valid YAML string only if members of mapping are properly quoted.

    :type isFlowStyle: boolean
    :param isFlowStyle: if true, result is in YAML flow style, with symbols {,}
    """
    return _connect.CYAMLUtil_strVectorVector2Str(keys, values, isFlowStyle)

def CYAMLUtil_strVector2Sequence(dest: "isys::CTestBaseSPtr &", section: "int", items: "StrVector") -> "void":
    r"""Copies items from StrVector to the given section in CTestBase."""
    return _connect.CYAMLUtil_strVector2Sequence(dest, section, items)

def CYAMLUtil_verifyLimitedScalar(yamlSpec: "std::string const &", msg: "std::string const &") -> "void":
    r"""
    Deprecated: use verifyTestId() instead. This method uses YAML parser, which is
                redundant step and may produce cryptic error messages if input is not
                valid YAML scalar.
    This method may be used to verify, if the given string represents scalar
    with limited set of characters. Examples of such scalars are test IDs
    and tags.
    Exception with error description is thrown, if it is not.
    """
    return _connect.CYAMLUtil_verifyLimitedScalar(yamlSpec, msg)

def CYAMLUtil_getSymbolsAllowedTestId() -> "std::string":
    r""" Returns string containing all symbols (non-alphanum) chars allowed in test ID or group ID."""
    return _connect.CYAMLUtil_getSymbolsAllowedTestId()

def CYAMLUtil_verifyTestId(testID: "std::string const &", msg: "std::string const &") -> "std::string":
    r"""
    This method may be used to verify, if the given string represents scalar
    with limited set of characters. Examples of such scalars are test IDs
    and tags.
    Error description is returned in case of invalid entry, empty string otherwise.
    """
    return _connect.CYAMLUtil_verifyTestId(testID, msg)

def CYAMLUtil_verifyScalar(yamlSpec: "std::string const &") -> "void":
    r"""
    This method may be used to verify, if the given string represents YAML scalar.
    Exception with error description is thrown, if it is not.
    """
    return _connect.CYAMLUtil_verifyScalar(yamlSpec)

def CYAMLUtil_verifyList(yamlSpec: "std::string const &") -> "void":
    r"""
    This method may be used to verify, if the given string represents YAML list.
    Exception with error description is thrown, if it is not.
    """
    return _connect.CYAMLUtil_verifyList(yamlSpec)

def CYAMLUtil_verifyListOfLimitedScalars(yamlSpec: "std::string const &", msg: "std::string const &") -> "void":
    r"""
    This method verifies, if all scalars in the list contain only allowed characters.
    See CLimitedScalarValidator for details.
    """
    return _connect.CYAMLUtil_verifyListOfLimitedScalars(yamlSpec, msg)

def CYAMLUtil_verifyMap(yamlSpec: "std::string const &") -> "void":
    r"""
    This method may be used to verify, if the given string represents YAML map.
    Exception with error description is thrown, if it is not.
    """
    return _connect.CYAMLUtil_verifyMap(yamlSpec)

def CYAMLUtil_isAllowedCharForTestId(c: "char") -> "bool":
    r"""Returns true, if character is valid for testID."""
    return _connect.CYAMLUtil_isAllowedCharForTestId(c)

def CYAMLUtil_replaceInvalidChars(param: "std::string const") -> "std::string":
    r"""Replaces characters, which are invalid in testID or file name with '_'."""
    return _connect.CYAMLUtil_replaceInvalidChars(param)

def CYAMLUtil_join(params: "StrVector", separator: "char") -> "std::string":
    r"""Joins list of strings to single string."""
    return _connect.CYAMLUtil_join(params, separator)

def CYAMLUtil_getCurrentISODate() -> "std::string":
    r"""Returns current date in YYYY-MM-DD format."""
    return _connect.CYAMLUtil_getCurrentISODate()

def CYAMLUtil_getCurrentISOTime() -> "std::string":
    r"""Returns current time in HH-MM-SS format."""
    return _connect.CYAMLUtil_getCurrentISOTime()

class SPtrFactory(object):
    r"""
    This class should be used in TCL/Perl scripts only. It provides access to
    shared pointers as pure pointers. It is important to keep the
    shared ptr object (``cmgrSPtr`` item below) in scope as long as we use
    isystem.connect calls.

    Example in TCL:

    SPtrFactory sptrFactory

    set cmgrSPtr [sptrFactory newConnectionMgr]
    set cmgr [sptrFactory getConnectionMgr $cmgrSPtr]


    Example in Perl:

    $coverageDataSPtr = isystemConnect::CCoverageData2::createInstance($coverageCtrl,
                                                                       $coverageExportFile,
                                                                       1);
    # IMPORTANT: To keep the object available, 'coverageDataSPtr' must be
    # in scope at least as long as 'coverageData'!!!
    $coverageData = isystemConnect::SPtrFactory::cCoverageData2($coverageDataSPtr);
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getConnectionMgr(self, connectionMgrSPtr: "std::shared_ptr< isys::ConnectionMgr > &") -> "isys::ConnectionMgr *":
        r""" Converts shared_ptr to C pointer."""
        return _connect.SPtrFactory_getConnectionMgr(self, connectionMgrSPtr)

    def newConnectionMgr(self) -> "std::shared_ptr< isys::ConnectionMgr >":
        r""" Creates new instance of ConnectionMgr."""
        return _connect.SPtrFactory_newConnectionMgr(self)

    @staticmethod
    def cProfilerData2(sptr: "std::shared_ptr< isys::CProfilerData2 > &") -> "isys::CProfilerData2 *":
        r""" Converts shared_ptr to C pointer."""
        return _connect.SPtrFactory_cProfilerData2(sptr)

    @staticmethod
    def cCoverageData2(sptr: "std::shared_ptr< isys::CCoverageData2 > &") -> "isys::CCoverageData2 *":
        r""" Converts shared_ptr to C pointer."""
        return _connect.SPtrFactory_cCoverageData2(sptr)

    def __init__(self):
        _connect.SPtrFactory_swiginit(self, _connect.new_SPtrFactory())
    __swig_destroy__ = _connect.delete_SPtrFactory

# Register SPtrFactory in _connect:
_connect.SPtrFactory_swigregister(SPtrFactory)

def SPtrFactory_cProfilerData2(sptr: "std::shared_ptr< isys::CProfilerData2 > &") -> "isys::CProfilerData2 *":
    r""" Converts shared_ptr to C pointer."""
    return _connect.SPtrFactory_cProfilerData2(sptr)

def SPtrFactory_cCoverageData2(sptr: "std::shared_ptr< isys::CCoverageData2 > &") -> "isys::CCoverageData2 *":
    r""" Converts shared_ptr to C pointer."""
    return _connect.SPtrFactory_cCoverageData2(sptr)

class CRemoteFileController(object):
    r"""
    This class can be used to access files located on host, where
    winIDEA is running. winIDEA instance is defined by connection manager
    provided in constructor.

    This class is intended to be used when script is running on other
    host than the one running winIDEA.

    **Important:** Complete file is copied to memory, so size of
    file to be read or written is limited by available computer memory.

    Python example: remoteFile.py 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "std::shared_ptr< isys::ConnectionMgr >"):
        _connect.CRemoteFileController_swiginit(self, _connect.new_CRemoteFileController(connectionMgr))
    __swig_destroy__ = _connect.delete_CRemoteFileController

    def exists(self, fileName: "std::string const &") -> "bool":
        r"""
        Returns true, if remote file (on host running winIDEA) exists.

        Python example: remoteFile.py 
        """
        return _connect.CRemoteFileController_exists(self, fileName)

    def remove(self, fileName: "std::string const &") -> "bool":
        r"""
        Deletes remote file (on host running winIDEA).

        :rtype: boolean
        :return: true if the file was deleted, false if it didn't exist.

        Python example: remoteFile.py 
        """
        return _connect.CRemoteFileController_remove(self, fileName)

    def readFromRemote(self, remoteSrcFile: "std::string const &", localDestFile: "std::string const &") -> "void":
        r"""
        Reads remote file and saves it locally.

        :type localDestFile: string
        :param localDestFile: local file used for saving. If the file exists, it
                                 is overwritten.
        :type remoteSrcFile: string
        :param remoteSrcFile: remote file to be copied to local host.

        Python example: remoteFile.py 
        """
        return _connect.CRemoteFileController_readFromRemote(self, remoteSrcFile, localDestFile)

    def writeToRemote(self, localSrcFile: "std::string const &", remoteDestFile: "std::string const &") -> "void":
        r"""
        Writes local file to remote host.

        :type localSrcFile: string
        :param localSrcFile: local file used as source.
        :type remoteDestFile: string
        :param remoteDestFile: remote file used as destination. If the file exists, it
                                 is overwritten.

        Python example: remoteFile.py 
        """
        return _connect.CRemoteFileController_writeToRemote(self, localSrcFile, remoteDestFile)

# Register CRemoteFileController in _connect:
_connect.CRemoteFileController_swigregister(CRemoteFileController)

class CCodeStoreItem(object):
    r"""
    This class describes one memory item. This class should not be
    instantiated by clients. Call CCodeStore.getItem() to get
    instance of this class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, rspConnectionMgr: "isys::SPConnectionMgr const &"):
        _connect.CCodeStoreItem_swiginit(self, _connect.new_CCodeStoreItem(rspConnectionMgr))
    __swig_destroy__ = _connect.delete_CCodeStoreItem

    def getAddress(self) -> "isys::TCodeStoreAddress":
        r""" address of the item"""
        return _connect.CCodeStoreItem_getAddress(self)

    def getLastAddress(self) -> "isys::TCodeStoreAddress":
        r""" last address covered by the item"""
        return _connect.CCodeStoreItem_getLastAddress(self)

    def getSize(self) -> "isys::TCodeStoreAddress":
        r""" size of the item"""
        return _connect.CCodeStoreItem_getSize(self)

    def getAt(self, offset: "isys::TCodeStoreAddress") -> "BYTE":
        r""" item data at offset"""
        return _connect.CCodeStoreItem_getAt(self, offset)

    def getData(self, rvData: "VectorBYTE") -> "void":
        r""" all data stored in this item"""
        return _connect.CCodeStoreItem_getData(self, rvData)

# Register CCodeStoreItem in _connect:
_connect.CCodeStoreItem_swigregister(CCodeStoreItem)

class CCodeStore(object):
    r"""
    This class is a container of multiple memory items.
    Each item is of type CCodeStoreItem

    codeStore_MotorolaSave.py - Python example for saving memory to Motorola S format. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, rspConnectionMgr: "isys::SPConnectionMgr const &"):
        r"""
        Creates a new instance.

        :param rconnectionMgr: ConnectionMgr object
        """
        _connect.CCodeStore_swiginit(self, _connect.new_CCodeStore(rspConnectionMgr))
    __swig_destroy__ = _connect.delete_CCodeStore

    def clear(self) -> "void":
        r"""Clears all items."""
        return _connect.CCodeStore_clear(self)

    def copy(self, rSrc: "CCodeStore") -> "void":
        r"""
        Copies from another code store instance.
        Previous contents are cleared.

        :param source: CCodeStore object to copy from
        """
        return _connect.CCodeStore_copy(self, rSrc)

    def load(self, dwFlags: "DWORD", rstrFileName: "std::string const &", aOffset: "isys::TCodeStoreAddress") -> "void":
        r"""
        Load from a file.

        :type dwFlags: int
        :param dwFlags: for default behavior specify 0 for dwFlags, otherwise use ICodeCache::ESaveLoadFlags
        :type rstrFileName: string
        :param rstrFileName: path to the file to load from
        :type aOffset: int
        :param aOffset: offset to add to the code loaded from the file
        """
        return _connect.CCodeStore_load(self, dwFlags, rstrFileName, aOffset)

    def load1(self, dwFlags: "DWORD", rstrFileName: "std::string const &", aOffset: "isys::TCodeStoreAddress") -> "DWORD":
        r"""
        Load from a file.

        :type dwFlags: int
        :param dwFlags: for default behavior specify 0 for dwFlags, otherwise use ICodeCache::ESaveLoadFlags
        :type rstrFileName: string
        :param rstrFileName: path to the file to load from
        :type aOffset: int
        :param aOffset: offset to add to the code loaded from the file

        :rtype: int
        :return: 
            - Format used in loading the file
        """
        return _connect.CCodeStore_load1(self, dwFlags, rstrFileName, aOffset)

    def save(self, dwFlags: "DWORD", rstrFileName: "std::string const &", aOffset: "isys::TCodeStoreAddress") -> "void":
        r"""
        Save to file.

        :type dwFlags: int
        :param dwFlags: for default behavior specify 0 for dwFlags, otherwise use ICodeCache::ESaveLoadFlags. Note: Gaps in the store are padded with 0h when saving to binary file.
        :type rstrFileName: string
        :param rstrFileName: path to the file to save to
        :type aOffset: int
        :param aOffset: offset to add to the code saved to the file. if format is binary, then the offset determines the position in the store from where the saving starts.
        """
        return _connect.CCodeStore_save(self, dwFlags, rstrFileName, aOffset)

    def insert(self, aAddress: "isys::TCodeStoreAddress", vBuffer: "VectorBYTE") -> "void":
        r"""
        Inserts a new chunk of code.

        :type aAddress: int
        :param aAddress: address at which the new code is inserted
        :type vBuffer: std::vector< BYTE,std::allocator< BYTE > >
        :param vBuffer: code to insert
        """
        return _connect.CCodeStore_insert(self, aAddress, vBuffer)

    def insertWithAccessInfo(self, aAddress: "isys::TCodeStoreAddress", vBuffer: "VectorBYTE") -> "void":
        r"""
        Inserts a new chunk of code, but only bytes, which have valid access.
        Use this method if data was obtaind by method CDataController::readMemory(),
        because only bytes, which have `ACCESS_OK` may be inserted into code cache.

        :type aAddress: int
        :param aAddress: address at which the new code is inserted
        :type vBuffer: std::vector< BYTE,std::allocator< BYTE > >
        :param vBuffer: code to insert in the first `vBuffer.size() / 2` bytes,
                            access info in the last half.
        """
        return _connect.CCodeStore_insertWithAccessInfo(self, aAddress, vBuffer)

    def exclude(self, aAddressExcl: "isys::TCodeStoreAddress", aEndExcl: "isys::TCodeStoreAddress") -> "void":
        r"""
        Excludes a range.

        :type aAddressExcl: int
        :param aAddressExcl: start of range to exclude
        :type aEndExcl: int
        :param aEndExcl: last address of range to exclude
        """
        return _connect.CCodeStore_exclude(self, aAddressExcl, aEndExcl)

    def empty(self) -> "bool":
        r"""
        Returns true if container is empty.

        :rtype: boolean
        :return: 
            - true : container is empty
            - false: container is not empty
        """
        return _connect.CCodeStore_empty(self)

    def numItems(self) -> "int":
        r"""
        Returns number of all items.

        :rtype: int
        :return: 
            - Number of items
        """
        return _connect.CCodeStore_numItems(self)

    def getItem(self, nIndex: "int") -> "isys::SPCodeStoreItem":
        r"""
        Returns item at index nIndex.

        :type nIndex: int
        :param nIndex: index of the element. Must be in range 0 .. numItems()-1

        :rtype: :py:class:`CCodeStoreItem`
        :return: 
            - Pointer to item
        """
        return _connect.CCodeStore_getItem(self, nIndex)

    def findItem(self, aAddress: "isys::TCodeStoreAddress") -> "int":
        r"""
        Finds an item in the requested range.

        :type aAddress: int
        :param aAddress: address which the found item covers

        :rtype: int
        :return: 
            - Index of the item
            - -1 - no item in the range
        """
        return _connect.CCodeStore_findItem(self, aAddress)

    def getBuffer(self, aAddress: "isys::TCodeStoreAddress", vBuffer: "VectorBYTE") -> "isys::TCodeStoreAddress":
        r"""
        Obtains the code from the specified region.

        :type aAddress: int
        :param aAddress: address from which the code should be retrieved
        :type vBuffer: std::vector< BYTE,std::allocator< BYTE > >
        :param vBuffer: buffer which is filled with the code. Caller must preallocate vBuffer to the size that should be retrieved

        :rtype: int
        :return: 
            - number of locations filled
        """
        return _connect.CCodeStore_getBuffer(self, aAddress, vBuffer)

    def getTotal(self) -> "isys::TCodeStoreAddress":
        r"""
        Returns total number of contained locations.

        :rtype: int
        :return: 
            - Number of contained locations
        """
        return _connect.CCodeStore_getTotal(self)

    def getRangeLo(self) -> "isys::TCodeStoreAddress":
        r"""
        Returns lowest loaded location.

        :rtype: int
        :return: 
            - Lowest loaded location. 0 if empty
        """
        return _connect.CCodeStore_getRangeLo(self)

    def getRangeHi(self) -> "isys::TCodeStoreAddress":
        r"""
        Returns highest loaded location.

        :rtype: int
        :return: 
            - Highest loaded location. 0 if empty
        """
        return _connect.CCodeStore_getRangeHi(self)

    def report(self, fileReport: "std::string const &", append: "bool", format: "std::string const &", maxInLine: "DWORD") -> "bool":
        r"""
        Creates a report to file

        :type fileReport: string
        :param fileReport: path to the report file
        :type append: boolean
        :param append: true to append, false to create a new file
        :type format: string
        :param format: for every single item, using %ADDR%, %SIZE%, %EADDR% and %DATA% macros. If empty, the default "A:%ADDR% S:%SIZE% D:%DATA%" is used
        :type maxInLine: int
        :param maxInLine: specifies maximum number of addresses reported in a line. Use 0 to report contiguous ranges in one line

        :rtype: boolean
        :return: 
            - true on success
        """
        return _connect.CCodeStore_report(self, fileReport, append, format, maxInLine)

    def reportDif(self, fileReport: "std::string const &", append: "bool", format: "std::string const &", maxInLine: "DWORD", rCC1: "CCodeStore", rCC2: "CCodeStore") -> "bool":
        r"""
        Creates a difference report to file

        :type fileReport: string
        :param fileReport: path to the report file
        :type append: boolean
        :param append: true to append, false to create a new file
        :type format: string
        :param format: for every single item, using %ADDR%, %SIZE%, %EADDR%, %DIF% and %DATA1%, %DATA2% macros. If empty, the default "A:%ADDR% S:%SIZE%\n  D1:%DATA1%\n  D2:%DATA2%" is used
        :type maxInLine: int
        :param maxInLine: specifies maximum number of addresses reported in a line. Use 0 to report contiguous ranges in one line
        :param rsp1: is the first reference code store from which this difference object was created
        :param rsp2: is the second reference code store from which this difference object was created

        :rtype: boolean
        :return: 
            - true on success
        """
        return _connect.CCodeStore_reportDif(self, fileReport, append, format, maxInLine, rCC1, rCC2)

# Register CCodeStore in _connect:
_connect.CCodeStore_swigregister(CCodeStore)

CANInjectedMsgType_DO_NOT_MODIFY = _connect.CANInjectedMsgType_DO_NOT_MODIFY
r""" do not modify message"""
CANInjectedMsgType_DATA = _connect.CANInjectedMsgType_DATA
r""" data message"""
CANInjectedMsgType_REQUEST = _connect.CANInjectedMsgType_REQUEST
r""" request message"""
CANTriggerMsgType_DO_NOT_MODIFY = _connect.CANTriggerMsgType_DO_NOT_MODIFY
r""" do not modify message"""
CANTriggerMsgType_BOTH = _connect.CANTriggerMsgType_BOTH
r""" both trigger message"""
CANTriggerMsgType_REQUEST = _connect.CANTriggerMsgType_REQUEST
r""" request trigger message"""
CANTriggerMsgType_DATA = _connect.CANTriggerMsgType_DATA
r""" data trigger message"""
class SCANTriggerMsgType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::CANTriggerMsgType") -> "std::string const":
        return _connect.SCANTriggerMsgType_convert(key)

    def __init__(self):
        _connect.SCANTriggerMsgType_swiginit(self, _connect.new_SCANTriggerMsgType())
    __swig_destroy__ = _connect.delete_SCANTriggerMsgType

# Register SCANTriggerMsgType in _connect:
_connect.SCANTriggerMsgType_swigregister(SCANTriggerMsgType)

def SCANTriggerMsgType_convert(key: "isys::CANTriggerMsgType") -> "std::string const":
    return _connect.SCANTriggerMsgType_convert(key)

CANIDLength_DO_NOT_MODIFY = _connect.CANIDLength_DO_NOT_MODIFY
r""" do not modify ID"""
CANIDLength_STANDARD = _connect.CANIDLength_STANDARD
r""" standard ID length 11-bit"""
CANIDLength_EXTENDED = _connect.CANIDLength_EXTENDED
r""" extended ID length 29-bit"""
class SCANIDLength(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::CANIDLength") -> "std::string const":
        return _connect.SCANIDLength_convert(key)

    def __init__(self):
        _connect.SCANIDLength_swiginit(self, _connect.new_SCANIDLength())
    __swig_destroy__ = _connect.delete_SCANIDLength

# Register SCANIDLength in _connect:
_connect.SCANIDLength_swigregister(SCANIDLength)

def SCANIDLength_convert(key: "isys::CANIDLength") -> "std::string const":
    return _connect.SCANIDLength_convert(key)

CANMode_CAN = _connect.CANMode_CAN
r""" CAN"""
CANMode_FD_ISO = _connect.CANMode_FD_ISO
r""" CAN FS ISO"""
CANMode_FD_BOSCH = _connect.CANMode_FD_BOSCH
r""" CAN FD BOSCH"""
class SCANModeConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::CANMode") -> "std::string const":
        return _connect.SCANModeConverter_convert(key)

    def __init__(self):
        _connect.SCANModeConverter_swiginit(self, _connect.new_SCANModeConverter())
    __swig_destroy__ = _connect.delete_SCANModeConverter

# Register SCANModeConverter in _connect:
_connect.SCANModeConverter_swigregister(SCANModeConverter)

def SCANModeConverter_convert(key: "isys::CANMode") -> "std::string const":
    return _connect.SCANModeConverter_convert(key)

CANBaudrate_B_50_KBPS = _connect.CANBaudrate_B_50_KBPS
r""" 50 Kbps"""
CANBaudrate_B_100_KBPS = _connect.CANBaudrate_B_100_KBPS
r""" 1000 KBps"""
CANBaudrate_B_125_KBPS = _connect.CANBaudrate_B_125_KBPS
r""" 125 Kbps"""
CANBaudrate_B_250_KBPS = _connect.CANBaudrate_B_250_KBPS
r""" 250 Kbps"""
CANBaudrate_B_500_KBPS = _connect.CANBaudrate_B_500_KBPS
r""" 5000 Kbps"""
CANBaudrate_B_1_MBPS = _connect.CANBaudrate_B_1_MBPS
r""" 1 Mbps"""
class SCANBaudrateConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::CANBaudrate") -> "std::string const":
        return _connect.SCANBaudrateConverter_convert(key)

    def __init__(self):
        _connect.SCANBaudrateConverter_swiginit(self, _connect.new_SCANBaudrateConverter())
    __swig_destroy__ = _connect.delete_SCANBaudrateConverter

# Register SCANBaudrateConverter in _connect:
_connect.SCANBaudrateConverter_swigregister(SCANBaudrateConverter)

def SCANBaudrateConverter_convert(key: "isys::CANBaudrate") -> "std::string const":
    return _connect.SCANBaudrateConverter_convert(key)

CANFDBaudrate_B_50_KBPS = _connect.CANFDBaudrate_B_50_KBPS
r""" 50 Kbps"""
CANFDBaudrate_B_100_KBPS = _connect.CANFDBaudrate_B_100_KBPS
r""" 100 Kbps"""
CANFDBaudrate_B_125_KBPS = _connect.CANFDBaudrate_B_125_KBPS
r""" 125 Kbps"""
CANFDBaudrate_B_250_KBPS = _connect.CANFDBaudrate_B_250_KBPS
r""" 250 Kbps"""
CANFDBaudrate_B_500_KBPS = _connect.CANFDBaudrate_B_500_KBPS
r""" 500 Kbps"""
CANFDBaudrate_B_1_MBPS = _connect.CANFDBaudrate_B_1_MBPS
r""" 1 Mbps"""
CANFDBaudrate_B_2_MBPS = _connect.CANFDBaudrate_B_2_MBPS
r""" 2 Mbps"""
CANFDBaudrate_B_4_MBPS = _connect.CANFDBaudrate_B_4_MBPS
r""" 4 Mbps"""
CANFDBaudrate_B_8_MBPS = _connect.CANFDBaudrate_B_8_MBPS
r""" 8 Mbps"""
class SCANFDBaudrateConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::CANFDBaudrate") -> "std::string const":
        return _connect.SCANFDBaudrateConverter_convert(key)

    def __init__(self):
        _connect.SCANFDBaudrateConverter_swiginit(self, _connect.new_SCANFDBaudrateConverter())
    __swig_destroy__ = _connect.delete_SCANFDBaudrateConverter

# Register SCANFDBaudrateConverter in _connect:
_connect.SCANFDBaudrateConverter_swigregister(SCANFDBaudrateConverter)

def SCANFDBaudrateConverter_convert(key: "isys::CANFDBaudrate") -> "std::string const":
    return _connect.SCANFDBaudrateConverter_convert(key)

TriState_DO_NOT_MODIFY = _connect.TriState_DO_NOT_MODIFY
r""" do not modify"""
TriState_FALSE_TS = _connect.TriState_FALSE_TS
r""" false selection"""
TriState_TRUE_TS = _connect.TriState_TRUE_TS
r""" true selection"""
class STriStateConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::TriState") -> "std::string const":
        return _connect.STriStateConverter_convert(key)

    def __init__(self):
        _connect.STriStateConverter_swiginit(self, _connect.new_STriStateConverter())
    __swig_destroy__ = _connect.delete_STriStateConverter

# Register STriStateConverter in _connect:
_connect.STriStateConverter_swigregister(STriStateConverter)

def STriStateConverter_convert(key: "isys::TriState") -> "std::string const":
    return _connect.STriStateConverter_convert(key)

AInCompareCondition_DO_NOT_MODIFY = _connect.AInCompareCondition_DO_NOT_MODIFY
r""" do not modify selection"""
AInCompareCondition_LOWER_THAN = _connect.AInCompareCondition_LOWER_THAN
r""" lower than condition"""
AInCompareCondition_HIGHER_THAN = _connect.AInCompareCondition_HIGHER_THAN
r""" higher than condition"""
class AInCompareConditionConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::AInCompareCondition") -> "std::string const":
        return _connect.AInCompareConditionConverter_convert(key)

    def __init__(self):
        _connect.AInCompareConditionConverter_swiginit(self, _connect.new_AInCompareConditionConverter())
    __swig_destroy__ = _connect.delete_AInCompareConditionConverter

# Register AInCompareConditionConverter in _connect:
_connect.AInCompareConditionConverter_swigregister(AInCompareConditionConverter)

def AInCompareConditionConverter_convert(key: "isys::AInCompareCondition") -> "std::string const":
    return _connect.AInCompareConditionConverter_convert(key)

AInSamplingInterval_S_100_NS = _connect.AInSamplingInterval_S_100_NS
r""" 100 nano seconds"""
AInSamplingInterval_S_1_US = _connect.AInSamplingInterval_S_1_US
r""" 1 micro second"""
AInSamplingInterval_S_10_US = _connect.AInSamplingInterval_S_10_US
r""" 10 micro seconds"""
AInSamplingInterval_S_100_US = _connect.AInSamplingInterval_S_100_US
r""" 100 micro seconds"""
AInSamplingInterval_S_1_MS = _connect.AInSamplingInterval_S_1_MS
r""" 1 mili second"""
AInSamplingInterval_S_10_MS = _connect.AInSamplingInterval_S_10_MS
r""" 10 mili seconds"""
AInSamplingInterval_S_100_MS = _connect.AInSamplingInterval_S_100_MS
r""" 100 mili seconds"""
AInSamplingInterval_S_1_S = _connect.AInSamplingInterval_S_1_S
r""" 1 second"""
class AInSamplingIntervalConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::AInSamplingInterval") -> "std::string const":
        return _connect.AInSamplingIntervalConverter_convert(key)

    def __init__(self):
        _connect.AInSamplingIntervalConverter_swiginit(self, _connect.new_AInSamplingIntervalConverter())
    __swig_destroy__ = _connect.delete_AInSamplingIntervalConverter

# Register AInSamplingIntervalConverter in _connect:
_connect.AInSamplingIntervalConverter_swigregister(AInSamplingIntervalConverter)

def AInSamplingIntervalConverter_convert(key: "isys::AInSamplingInterval") -> "std::string const":
    return _connect.AInSamplingIntervalConverter_convert(key)

IODirection_IN_DIR = _connect.IODirection_IN_DIR
r""" input direction"""
IODirection_OUT_DIR = _connect.IODirection_OUT_DIR
r""" output direction"""
class IODirectionConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::IODirection") -> "std::string const":
        return _connect.IODirectionConverter_convert(key)

    def __init__(self):
        _connect.IODirectionConverter_swiginit(self, _connect.new_IODirectionConverter())
    __swig_destroy__ = _connect.delete_IODirectionConverter

# Register IODirectionConverter in _connect:
_connect.IODirectionConverter_swigregister(IODirectionConverter)

def IODirectionConverter_convert(key: "isys::IODirection") -> "std::string const":
    return _connect.IODirectionConverter_convert(key)

IOLevels_VL_1_8V = _connect.IOLevels_VL_1_8V
r""" 1.8 volts"""
IOLevels_VL_2_5V = _connect.IOLevels_VL_2_5V
r""" 2.5 volts"""
IOLevels_VL_3_3V = _connect.IOLevels_VL_3_3V
r""" 3.3 volts"""
IOLevels_VL_5V = _connect.IOLevels_VL_5V
r""" 5 volts"""
class IOLevelsConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::IOLevels") -> "std::string const":
        return _connect.IOLevelsConverter_convert(key)

    def __init__(self):
        _connect.IOLevelsConverter_swiginit(self, _connect.new_IOLevelsConverter())
    __swig_destroy__ = _connect.delete_IOLevelsConverter

# Register IOLevelsConverter in _connect:
_connect.IOLevelsConverter_swigregister(IOLevelsConverter)

def IOLevelsConverter_convert(key: "isys::IOLevels") -> "std::string const":
    return _connect.IOLevelsConverter_convert(key)

IOState_LOW = _connect.IOState_LOW
r""" low state"""
IOState_HIGH = _connect.IOState_HIGH
r""" high state"""
IOState_DO_NOT_MODIFY = _connect.IOState_DO_NOT_MODIFY
r""" do not modify state"""
class IOStateConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::IOState") -> "std::string const":
        return _connect.IOStateConverter_convert(key)

    def __init__(self):
        _connect.IOStateConverter_swiginit(self, _connect.new_IOStateConverter())
    __swig_destroy__ = _connect.delete_IOStateConverter

# Register IOStateConverter in _connect:
_connect.IOStateConverter_swigregister(IOStateConverter)

def IOStateConverter_convert(key: "isys::IOState") -> "std::string const":
    return _connect.IOStateConverter_convert(key)

SPISamplePhase_DO_NOT_MODIFY = _connect.SPISamplePhase_DO_NOT_MODIFY
r""" do not modify phase"""
SPISamplePhase_FIRST_EDGE = _connect.SPISamplePhase_FIRST_EDGE
r""" first edge phase"""
SPISamplePhase_SECOND_EDGE = _connect.SPISamplePhase_SECOND_EDGE
r""" second edge phase"""
class SPISamplePhaseConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::SPISamplePhase") -> "std::string const":
        return _connect.SPISamplePhaseConverter_convert(key)

    def __init__(self):
        _connect.SPISamplePhaseConverter_swiginit(self, _connect.new_SPISamplePhaseConverter())
    __swig_destroy__ = _connect.delete_SPISamplePhaseConverter

# Register SPISamplePhaseConverter in _connect:
_connect.SPISamplePhaseConverter_swigregister(SPISamplePhaseConverter)

def SPISamplePhaseConverter_convert(key: "isys::SPISamplePhase") -> "std::string const":
    return _connect.SPISamplePhaseConverter_convert(key)

SPICSName_DO_NOT_MODIFY = _connect.SPICSName_DO_NOT_MODIFY
r""" do not modify"""
SPICSName_CS0 = _connect.SPICSName_CS0
r""" chip select 0"""
SPICSName_CS1 = _connect.SPICSName_CS1
r""" chip select 1"""
SPICSName_CS2 = _connect.SPICSName_CS2
r""" chip select 2"""
SPICSName_CS3 = _connect.SPICSName_CS3
r""" chip select 3"""
class SPICSNameConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::SPICSName") -> "std::string const":
        return _connect.SPICSNameConverter_convert(key)

    def __init__(self):
        _connect.SPICSNameConverter_swiginit(self, _connect.new_SPICSNameConverter())
    __swig_destroy__ = _connect.delete_SPICSNameConverter

# Register SPICSNameConverter in _connect:
_connect.SPICSNameConverter_swigregister(SPICSNameConverter)

def SPICSNameConverter_convert(key: "isys::SPICSName") -> "std::string const":
    return _connect.SPICSNameConverter_convert(key)

SPIDataStream_DO_NOT_MODIFY = _connect.SPIDataStream_DO_NOT_MODIFY
r""" do not modify stream"""
SPIDataStream_MISO = _connect.SPIDataStream_MISO
r""" MISO data stream"""
SPIDataStream_MOSI = _connect.SPIDataStream_MOSI
r""" MOSI data stream"""
class SPIDataStreamConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::SPIDataStream") -> "std::string const":
        return _connect.SPIDataStreamConverter_convert(key)

    def __init__(self):
        _connect.SPIDataStreamConverter_swiginit(self, _connect.new_SPIDataStreamConverter())
    __swig_destroy__ = _connect.delete_SPIDataStreamConverter

# Register SPIDataStreamConverter in _connect:
_connect.SPIDataStreamConverter_swigregister(SPIDataStreamConverter)

def SPIDataStreamConverter_convert(key: "isys::SPIDataStream") -> "std::string const":
    return _connect.SPIDataStreamConverter_convert(key)

SPIDataEndian_DO_NOT_MODIFY = _connect.SPIDataEndian_DO_NOT_MODIFY
r""" do not modify"""
SPIDataEndian_ISYS_LITTLE_ENDIAN = _connect.SPIDataEndian_ISYS_LITTLE_ENDIAN
r""" little endian"""
SPIDataEndian_ISYS_BIG_ENDIAN = _connect.SPIDataEndian_ISYS_BIG_ENDIAN
r""" big endian"""
class SPIDataEndianConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::SPIDataEndian") -> "std::string const":
        return _connect.SPIDataEndianConverter_convert(key)

    def __init__(self):
        _connect.SPIDataEndianConverter_swiginit(self, _connect.new_SPIDataEndianConverter())
    __swig_destroy__ = _connect.delete_SPIDataEndianConverter

# Register SPIDataEndianConverter in _connect:
_connect.SPIDataEndianConverter_swigregister(SPIDataEndianConverter)

def SPIDataEndianConverter_convert(key: "isys::SPIDataEndian") -> "std::string const":
    return _connect.SPIDataEndianConverter_convert(key)

LINBaudrate_B_2400_BPS = _connect.LINBaudrate_B_2400_BPS
r""" 2400 bps"""
LINBaudrate_B_9600_BPS = _connect.LINBaudrate_B_9600_BPS
r""" 96000 bps"""
LINBaudrate_B_19200_BPS = _connect.LINBaudrate_B_19200_BPS
r""" 19200 bps"""
LINBaudrate_B_20000_BPS = _connect.LINBaudrate_B_20000_BPS
r""" 20000 bps"""
class LINBaudrateConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::LINBaudrate") -> "std::string const":
        return _connect.LINBaudrateConverter_convert(key)

    def __init__(self):
        _connect.LINBaudrateConverter_swiginit(self, _connect.new_LINBaudrateConverter())
    __swig_destroy__ = _connect.delete_LINBaudrateConverter

# Register LINBaudrateConverter in _connect:
_connect.LINBaudrateConverter_swigregister(LINBaudrateConverter)

def LINBaudrateConverter_convert(key: "isys::LINBaudrate") -> "std::string const":
    return _connect.LINBaudrateConverter_convert(key)

IORecordMode_NONE = _connect.IORecordMode_NONE
r""" none record mode"""
IORecordMode_INPUTS = _connect.IORecordMode_INPUTS
r""" inputs record mode"""
IORecordMode_ALL = _connect.IORecordMode_ALL
r""" all record mode"""
class IORecordModeConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::IORecordMode") -> "std::string const":
        return _connect.IORecordModeConverter_convert(key)

    def __init__(self):
        _connect.IORecordModeConverter_swiginit(self, _connect.new_IORecordModeConverter())
    __swig_destroy__ = _connect.delete_IORecordModeConverter

# Register IORecordModeConverter in _connect:
_connect.IORecordModeConverter_swigregister(IORecordModeConverter)

def IORecordModeConverter_convert(key: "isys::IORecordMode") -> "std::string const":
    return _connect.IORecordModeConverter_convert(key)

IOTriggerSignalState_ANY = _connect.IOTriggerSignalState_ANY
r""" any signal state"""
IOTriggerSignalState_LOW = _connect.IOTriggerSignalState_LOW
r""" low signal state"""
IOTriggerSignalState_HIGH = _connect.IOTriggerSignalState_HIGH
r""" high signal state"""
class IOTriggerSignalStateConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::IOTriggerSignalState") -> "std::string const":
        return _connect.IOTriggerSignalStateConverter_convert(key)

    def __init__(self):
        _connect.IOTriggerSignalStateConverter_swiginit(self, _connect.new_IOTriggerSignalStateConverter())
    __swig_destroy__ = _connect.delete_IOTriggerSignalStateConverter

# Register IOTriggerSignalStateConverter in _connect:
_connect.IOTriggerSignalStateConverter_swigregister(IOTriggerSignalStateConverter)

def IOTriggerSignalStateConverter_convert(key: "isys::IOTriggerSignalState") -> "std::string const":
    return _connect.IOTriggerSignalStateConverter_convert(key)

IOPatternType_DO_NOT_MODIFY = _connect.IOPatternType_DO_NOT_MODIFY
r""" do not modify"""
IOPatternType_SINGLE_SHOT = _connect.IOPatternType_SINGLE_SHOT
r""" single shot"""
IOPatternType_CONTINUOUS = _connect.IOPatternType_CONTINUOUS
r""" continuous"""
class IOPatternTypeConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::IOPatternType") -> "std::string const":
        return _connect.IOPatternTypeConverter_convert(key)

    def __init__(self):
        _connect.IOPatternTypeConverter_swiginit(self, _connect.new_IOPatternTypeConverter())
    __swig_destroy__ = _connect.delete_IOPatternTypeConverter

# Register IOPatternTypeConverter in _connect:
_connect.IOPatternTypeConverter_swigregister(IOPatternTypeConverter)

def IOPatternTypeConverter_convert(key: "isys::IOPatternType") -> "std::string const":
    return _connect.IOPatternTypeConverter_convert(key)

PowerSenseShunt_SHUNT_1_OHM = _connect.PowerSenseShunt_SHUNT_1_OHM
r""" 1 ohm"""
PowerSenseShunt_SHUNT_0_26_OHM = _connect.PowerSenseShunt_SHUNT_0_26_OHM
r""" 0.26 ohm"""
PowerSenseShunt_SHUNT_0_11_OHM = _connect.PowerSenseShunt_SHUNT_0_11_OHM
r""" 0.11 ohm"""
class PowerSenseShuntConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::PowerSenseShunt") -> "std::string const":
        return _connect.PowerSenseShuntConverter_convert(key)

    def __init__(self):
        _connect.PowerSenseShuntConverter_swiginit(self, _connect.new_PowerSenseShuntConverter())
    __swig_destroy__ = _connect.delete_PowerSenseShuntConverter

# Register PowerSenseShuntConverter in _connect:
_connect.PowerSenseShuntConverter_swigregister(PowerSenseShuntConverter)

def PowerSenseShuntConverter_convert(key: "isys::PowerSenseShunt") -> "std::string const":
    return _connect.PowerSenseShuntConverter_convert(key)

class DIOBankChannelIndex(object):
    r"""FNet digital input output channel index."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    bankIndex = property(_connect.DIOBankChannelIndex_bankIndex_get, _connect.DIOBankChannelIndex_bankIndex_set, doc=r""" bank index""")
    channelIndex = property(_connect.DIOBankChannelIndex_channelIndex_get, _connect.DIOBankChannelIndex_channelIndex_set, doc=r""" channel index""")

    def __init__(self):
        _connect.DIOBankChannelIndex_swiginit(self, _connect.new_DIOBankChannelIndex())
    __swig_destroy__ = _connect.delete_DIOBankChannelIndex

# Register DIOBankChannelIndex in _connect:
_connect.DIOBankChannelIndex_swigregister(DIOBankChannelIndex)

class PowerSenseParameters(object):
    r"""FNet power sense parameters."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    voltage = property(_connect.PowerSenseParameters_voltage_get, _connect.PowerSenseParameters_voltage_set, doc=r""" voltage""")
    current = property(_connect.PowerSenseParameters_current_get, _connect.PowerSenseParameters_current_set, doc=r""" current""")
    power = property(_connect.PowerSenseParameters_power_get, _connect.PowerSenseParameters_power_set, doc=r""" power""")

    def __init__(self):
        _connect.PowerSenseParameters_swiginit(self, _connect.new_PowerSenseParameters())
    __swig_destroy__ = _connect.delete_PowerSenseParameters

# Register PowerSenseParameters in _connect:
_connect.PowerSenseParameters_swigregister(PowerSenseParameters)

class SFNetGlobals(object):
    r"""FNet global constant."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DO_NOT_MODIFY = _connect.SFNetGlobals_DO_NOT_MODIFY
    r""" do not modify constant"""

    def __init__(self):
        _connect.SFNetGlobals_swiginit(self, _connect.new_SFNetGlobals())
    __swig_destroy__ = _connect.delete_SFNetGlobals

# Register SFNetGlobals in _connect:
_connect.SFNetGlobals_swigregister(SFNetGlobals)

class FNetCommons(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def isHexString(value: "std::string const &") -> "bool":
        return _connect.FNetCommons_isHexString(value)

    def __init__(self):
        _connect.FNetCommons_swiginit(self, _connect.new_FNetCommons())
    __swig_destroy__ = _connect.delete_FNetCommons

# Register FNetCommons in _connect:
_connect.FNetCommons_swigregister(FNetCommons)

def FNetCommons_isHexString(value: "std::string const &") -> "bool":
    return _connect.FNetCommons_isHexString(value)

class CCANOpInjMsgConfig(object):
    r""" CAN inject message configuration class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CCANOpInjMsgConfig_swiginit(self, _connect.new_CCANOpInjMsgConfig())
    __swig_destroy__ = _connect.delete_CCANOpInjMsgConfig
    idLength = property(_connect.CCANOpInjMsgConfig_idLength_get, _connect.CCANOpInjMsgConfig_idLength_set, doc=r""" CAN ID length selection""")
    id = property(_connect.CCANOpInjMsgConfig_id_get, _connect.CCANOpInjMsgConfig_id_set, doc=r""" message id as string, valid input 0x20, 33""")
    fd = property(_connect.CCANOpInjMsgConfig_fd_get, _connect.CCANOpInjMsgConfig_fd_set, doc=r""" CAN FD selection""")
    brs = property(_connect.CCANOpInjMsgConfig_brs_get, _connect.CCANOpInjMsgConfig_brs_set, doc=r""" CAN BRS (bit rate switch) selection""")
    esi = property(_connect.CCANOpInjMsgConfig_esi_get, _connect.CCANOpInjMsgConfig_esi_set, doc=r""" CAN ESI (error state indicator) selection""")
    injectedMsgType = property(_connect.CCANOpInjMsgConfig_injectedMsgType_get, _connect.CCANOpInjMsgConfig_injectedMsgType_set, doc=r""" CAN injected message type""")
    data = property(_connect.CCANOpInjMsgConfig_data_get, _connect.CCANOpInjMsgConfig_data_set, doc=r""" CAN data""")

# Register CCANOpInjMsgConfig in _connect:
_connect.CCANOpInjMsgConfig_swigregister(CCANOpInjMsgConfig)

class CCANOpConfig(object):
    r""" CAN operation configuration class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CCANOpConfig_swiginit(self, _connect.new_CCANOpConfig())
    __swig_destroy__ = _connect.delete_CCANOpConfig
    idLength = property(_connect.CCANOpConfig_idLength_get, _connect.CCANOpConfig_idLength_set, doc=r""" CAN ID length selection""")
    id = property(_connect.CCANOpConfig_id_get, _connect.CCANOpConfig_id_set, doc=r""" message id as string, valid input 0x20, 33""")
    mask = property(_connect.CCANOpConfig_mask_get, _connect.CCANOpConfig_mask_set, doc=r""" mask configuration""")
    triggerMsgType = property(_connect.CCANOpConfig_triggerMsgType_get, _connect.CCANOpConfig_triggerMsgType_set, doc=r""" CAN trigger message type""")

# Register CCANOpConfig in _connect:
_connect.CCANOpConfig_swigregister(CCANOpConfig)

class CFNetController(object):
    r"""FNet controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "isys::ConnectionMgrSPtr"):
        _connect.CFNetController_swiginit(self, _connect.new_CFNetController(connectionMgr))
    __swig_destroy__ = _connect.delete_CFNetController

    def createCounterController(self, *args) -> "CFNetCounterController":
        r"""
        Returns new instance of CFNetCounterController.
        :type identifier: string, optional
        :param identifier: unique network identifier string (example: "Root.COUNTER1")
        """
        return _connect.CFNetController_createCounterController(self, *args)

    def createDIOController(self, identifier: "std::string const &") -> "CFNetDIOController":
        r"""
        Returns new instance of CFNetDIOController.
        :type identifier: string
        :param identifier: unique network identifier string (example: "ADIO.DIO")
        """
        return _connect.CFNetController_createDIOController(self, identifier)

    def createSPIController(self, identifier: "std::string const &") -> "CFNetSPIController":
        r"""
        Returns new instance of CFNetSPIController.
        :type identifier: string
        :param identifier: unique network identifier string (example: "ADIO.SPI1")
        """
        return _connect.CFNetController_createSPIController(self, identifier)

    def createAOutController(self, identifier: "std::string const &") -> "CFNetAOutController":
        r"""
        Returns new instance of CFNetAOutController.
        :type identifier: string
        :param identifier: unique network identifier string (example: "ADIO.AOUT1")
        """
        return _connect.CFNetController_createAOutController(self, identifier)

    def createAInController(self, identifier: "std::string const &") -> "CFNetAInController":
        r"""
        Returns new instance of CFNetAInController.
        :type identifier: string
        :param identifier: unique network identifier string (example: "ADIO.AIN1")
        """
        return _connect.CFNetController_createAInController(self, identifier)

    def createPowerSenseController(self, *args) -> "CFNetPowerSenseController":
        r"""
        Returns new instance of CFNetPowerSenseController.
        :type identifier: string, optional
        :param identifier: unique network identifier string (example: "ADIO.AIN1")
        """
        return _connect.CFNetController_createPowerSenseController(self, *args)

    def createCANController(self, identifier: "std::string const &") -> "CFNetCANController":
        r"""
        Returns new instance of CFNetCANController.
        :type identifier: string
        :param identifier: unique network identifier string (example: "CAN2LIN2.CAN1")
        """
        return _connect.CFNetController_createCANController(self, identifier)

    def createLINController(self, identifier: "std::string const &") -> "CFNetLINController":
        r"""
        Returns new instance of CFNetLINController.
        :type identifier: string
        :param identifier: unique network identifier string (example: "CAN2LIN2.LIN1")
        """
        return _connect.CFNetController_createLINController(self, identifier)

    def injectTrigger(self, triggerIndex: "uint8_t const") -> "void":
        r"""
        Manually generate (inject) selected trigger.
        :type triggerIndex: uint8_t
        :param triggerIndex: index in range from 0 to 10
        """
        return _connect.CFNetController_injectTrigger(self, triggerIndex)

    def getListOfConnectedNodes(self, nodes: "StrVector") -> "void":
        r"""
        Fills list with available FNet nodes.
        :type nodes: std::vector< std::string,std::allocator< std::string > >
        :param nodes: connected nodes list
        """
        return _connect.CFNetController_getListOfConnectedNodes(self, nodes)

    def getNodeAttributes(self, nodeName: "std::string const &", raiseException: "bool"=False) -> "std::string":
        r"""
        Returns string of node attributes.
        :type nodeName: string
        :param nodeName: node name as specified in winIDEA GUI
        :type raiseException: boolean, optional
        :param raiseException: if true, exception is raised if node can't be found, otherwise not
        :rtype: string
        :return: string of node attributes
        """
        return _connect.CFNetController_getNodeAttributes(self, nodeName, raiseException)

    def getTriggerIndex(self, triggerName: "std::string const &") -> "int16_t":
        r"""
        Returns trigger index.
        :type triggerName: string
        :param triggerName: name like in winIDEA GUI window. For example: "TC5", "None", "RunSync"
        :rtype: int
        :return: index number, if no index can be found for the given name, then -1 is returned.
        """
        return _connect.CFNetController_getTriggerIndex(self, triggerName)

    def applyOperation(self) -> "void":
        r"""
        Performs the sequence of: stop, reapply operation configuration, restart FNet operation.
        Raises exception if FNet operation fails.
        """
        return _connect.CFNetController_applyOperation(self)

    def stopOperation(self) -> "void":
        r"""
        Stop FNet operation on all available nodes.
        Raises exception if FNet operation fails.
        """
        return _connect.CFNetController_stopOperation(self)

    def restartOperation(self) -> "void":
        r"""
        Apply FNet configurations and restart internal state of all available nodes, without breaking communication with emulator.
        Raises exception if FNet operation fails.
        """
        return _connect.CFNetController_restartOperation(self)

# Register CFNetController in _connect:
_connect.CFNetController_swigregister(CFNetController)

class CFNetBase(object):
    r"""FNet base class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "isys::ConnectionMgrSPtr", identifier: "std::string const &"):
        _connect.CFNetBase_swiginit(self, _connect.new_CFNetBase(connectionMgr, identifier))
    __swig_destroy__ = _connect.delete_CFNetBase

    def getNodeName(self) -> "std::string":
        r"""Returns node name as specified when creating this object."""
        return _connect.CFNetBase_getNodeName(self)

    def getNetworkName(self) -> "std::string":
        r"""Returns network name as specified when creating this object."""
        return _connect.CFNetBase_getNetworkName(self)

    def getIdentifier(self) -> "std::string":
        r"""
        Returns this node identifier which is composed of a node name and
        network name as specified when creating this object.
        """
        return _connect.CFNetBase_getIdentifier(self)

    def setQualifierEnableRecordOnStart(self, state: "bool") -> "void":
        r"""
        Set Operation qualifier
        :type state: boolean
        :param state: : if true, recording trace data starts at the beginning of debug session,
            otherwise recording is not started
        """
        return _connect.CFNetBase_setQualifierEnableRecordOnStart(self, state)

    def setQualifierEnableOnTriggerIndex(self, triggerIndex: "int8_t") -> "void":
        r"""
        Set Operation qualifier
        :type triggerIndex: int8_t
        :param triggerIndex: enable recording data on trigger source with  index in range from 0 to 10
        """
        return _connect.CFNetBase_setQualifierEnableOnTriggerIndex(self, triggerIndex)

    def setQualifierDisableOnTriggerIndex(self, triggerIndex: "int8_t") -> "void":
        r"""
        Set Operation qualifier
        :param disableOnTriggerIndex: disable recording data on trigger source with  index in range from 0 to 10
        """
        return _connect.CFNetBase_setQualifierDisableOnTriggerIndex(self, triggerIndex)

    def getCfgChannelBaseString(self, channelIndex: "uint32_t const") -> "std::string":
        return _connect.CFNetBase_getCfgChannelBaseString(self, channelIndex)

    def setChannelName(self, channelIndex: "uint32_t const", name: "std::string const &") -> "void":
        return _connect.CFNetBase_setChannelName(self, channelIndex, name)

    def getChannelName(self, channelIndex: "uint32_t const") -> "std::string":
        return _connect.CFNetBase_getChannelName(self, channelIndex)

    def getOpChannelBaseString(self, channelIndex: "uint32_t const") -> "std::string":
        return _connect.CFNetBase_getOpChannelBaseString(self, channelIndex)

    def stripUnits(self, expression: "std::string &") -> "void":
        return _connect.CFNetBase_stripUnits(self, expression)

    def getIOpenBaseUrl(self) -> "std::string":
        return _connect.CFNetBase_getIOpenBaseUrl(self)

    def getIDECtrl(self) -> "isys::CIDEController &":
        return _connect.CFNetBase_getIDECtrl(self)

    def getHILCtrl(self) -> "isys::CHILController &":
        return _connect.CFNetBase_getHILCtrl(self)

# Register CFNetBase in _connect:
_connect.CFNetBase_swigregister(CFNetBase)

class CCounterOperationConfig(object):
    r"""FNet counter configuration class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CCounterOperationConfig_swiginit(self, _connect.new_CCounterOperationConfig())
    __swig_destroy__ = _connect.delete_CCounterOperationConfig
    countOnTimeUs = property(_connect.CCounterOperationConfig_countOnTimeUs_get, _connect.CCounterOperationConfig_countOnTimeUs_set, doc=r""" interval for counter increment in microseconds""")
    incrementEventTriggerIndex = property(_connect.CCounterOperationConfig_incrementEventTriggerIndex_get, _connect.CCounterOperationConfig_incrementEventTriggerIndex_set, doc=r""" timer trigger index in range from 0 to 10""")
    onCounterIncrementTriggerIndex = property(_connect.CCounterOperationConfig_onCounterIncrementTriggerIndex_get, _connect.CCounterOperationConfig_onCounterIncrementTriggerIndex_set, doc=r""" trigger index in range from 0 to 10""")
    startActive = property(_connect.CCounterOperationConfig_startActive_get, _connect.CCounterOperationConfig_startActive_set, doc=r""" if enabled, counter starts at session start""")
    restartOnTriggerIndex = property(_connect.CCounterOperationConfig_restartOnTriggerIndex_get, _connect.CCounterOperationConfig_restartOnTriggerIndex_set, doc=r""" trigger index in range from 0 to 10""")
    suspendOnTriggerIndex = property(_connect.CCounterOperationConfig_suspendOnTriggerIndex_get, _connect.CCounterOperationConfig_suspendOnTriggerIndex_set, doc=r""" trigger index in range from 0 to 10""")
    resumeOnTriggerIndex = property(_connect.CCounterOperationConfig_resumeOnTriggerIndex_get, _connect.CCounterOperationConfig_resumeOnTriggerIndex_set, doc=r""" trigger index in range from 0 to 10""")
    enableCounterLimit = property(_connect.CCounterOperationConfig_enableCounterLimit_get, _connect.CCounterOperationConfig_enableCounterLimit_set, doc=r""" if enabled, configured trigger and action is executed once limit is reached""")
    counterLimit = property(_connect.CCounterOperationConfig_counterLimit_get, _connect.CCounterOperationConfig_counterLimit_set, doc=r""" counter limit value""")
    onLimitTriggerIndex = property(_connect.CCounterOperationConfig_onLimitTriggerIndex_get, _connect.CCounterOperationConfig_onLimitTriggerIndex_set, doc=r""" trigger index in range from 0 to 10""")
    onLimitRestart = property(_connect.CCounterOperationConfig_onLimitRestart_get, _connect.CCounterOperationConfig_onLimitRestart_set, doc=r""" if enabled, counter is restarted once limit is reached""")
    onCounterChangesRecord = property(_connect.CCounterOperationConfig_onCounterChangesRecord_get, _connect.CCounterOperationConfig_onCounterChangesRecord_set, doc=r""" if enabled, this channel counter changes are recorded (respects counter recording qualifier settings)""")

# Register CCounterOperationConfig in _connect:
_connect.CCounterOperationConfig_swigregister(CCounterOperationConfig)

class CFNetCounterOperationController(object):
    r"""FNet counter operation controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, counterCtrl: "CFNetCounterController"):
        _connect.CFNetCounterOperationController_swiginit(self, _connect.new_CFNetCounterOperationController(counterCtrl))
    __swig_destroy__ = _connect.delete_CFNetCounterOperationController

    def enableCounter(self, channelIndex: "uint8_t const", isEnabled: "bool") -> "void":
        r"""
        Enable or disable both, 'count on' checkbox and 'event' trigger dropdown.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 3
        :type isEnabled: boolean
        :param isEnabled: if true, counter is enabled, otherwise disabled
        """
        return _connect.CFNetCounterOperationController_enableCounter(self, channelIndex, isEnabled)

    def configureCounter(self, channelIndex: "uint8_t const", counterConfig: "CCounterOperationConfig") -> "void":
        r"""
        Configure counter according to CCounterOperationConfig().

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 3
        :param conterConfig: counter configuration of CCounterOperationConfig type
        """
        return _connect.CFNetCounterOperationController_configureCounter(self, channelIndex, counterConfig)

# Register CFNetCounterOperationController in _connect:
_connect.CFNetCounterOperationController_swigregister(CFNetCounterOperationController)

class CFNetCounterControlController(object):
    r"""FNet counter control controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, counterCtrl: "CFNetCounterController"):
        _connect.CFNetCounterControlController_swiginit(self, _connect.new_CFNetCounterControlController(counterCtrl))
    __swig_destroy__ = _connect.delete_CFNetCounterControlController

    def isChannelActive(self, channelIndex: "uint8_t const") -> "bool":
        r"""
        Get channel active state.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 3
        :rtype: boolean
        :return: true if counter channel is active, false otherwise
        """
        return _connect.CFNetCounterControlController_isChannelActive(self, channelIndex)

    def resetChannel(self, channelIndex: "uint8_t const") -> "void":
        r"""
        Reset counter value to 0.

        :type channelIndex: uint8_t
        :param channelIndex: counter channel index in range from 0 to 3. Reseting counter changes state to active-enabled.
        """
        return _connect.CFNetCounterControlController_resetChannel(self, channelIndex)

    def resetAllChannels(self) -> "void":
        r"""Resets all counter values to 0."""
        return _connect.CFNetCounterControlController_resetAllChannels(self)

    def resetActiveChannels(self) -> "void":
        r"""Resets all active counter values to 0."""
        return _connect.CFNetCounterControlController_resetActiveChannels(self)

    def suspendChannel(self, channelIndex: "uint8_t const") -> "void":
        r"""
        Suspend (stop) selected counter operation.
        :type channelIndex: uint8_t
        :param channelIndex: counter channel index in range from 0 to 3.
        """
        return _connect.CFNetCounterControlController_suspendChannel(self, channelIndex)

    def suspendAllChannels(self) -> "void":
        r"""Suspend (stop) all counters."""
        return _connect.CFNetCounterControlController_suspendAllChannels(self)

    def resumeChannel(self, channelIndex: "uint8_t const") -> "void":
        r"""
        Resume selected counter operation.
        :type channelIndex: uint8_t
        :param channelIndex: counter channel index in range from 0 to 3.
        """
        return _connect.CFNetCounterControlController_resumeChannel(self, channelIndex)

    def resumeAllChannels(self) -> "void":
        r"""Resume all available counters."""
        return _connect.CFNetCounterControlController_resumeAllChannels(self)

    def getCounterValue(self, channelIndex: "uint8_t const") -> "uint32_t":
        r"""
        Returns counter channel current value.
        :type channelIndex: uint8_t
        :param channelIndex: counter channel index in range from 0 to 3.
        """
        return _connect.CFNetCounterControlController_getCounterValue(self, channelIndex)

    def getTriggerCounterValue(self, triggerIndex: "uint8_t const") -> "uint32_t":
        r"""
        Returns value of a counter of a chosen trigger. This counter is incremented each time
        trigger is injected or asserted by other networks.
        :type triggerIndex: uint8_t
        :param triggerIndex: trigger index in range from 0 to 15.
        """
        return _connect.CFNetCounterControlController_getTriggerCounterValue(self, triggerIndex)

    def resetTriggerCounterValue(self, triggerIndex: "uint8_t const") -> "void":
        r"""
        Reset value of a counter of a chosen trigger.
        :type triggerIndex: uint8_t
        :param triggerIndex: trigger index in range from 0 to 15.
        """
        return _connect.CFNetCounterControlController_resetTriggerCounterValue(self, triggerIndex)

# Register CFNetCounterControlController in _connect:
_connect.CFNetCounterControlController_swigregister(CFNetCounterControlController)

class CFNetCounterController(CFNetBase):
    r"""
    FNet counter controller.



    fnetCounter.py controller usage example. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "isys::ConnectionMgrSPtr", identifier: "std::string const &"):
        r"""
        Instantietes object.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: isystem connect connection manager
        :type identifier: string
        :param identifier: unique network identifier for example "Root.COUNTER1"
        """
        _connect.CFNetCounterController_swiginit(self, _connect.new_CFNetCounterController(connectionMgr, identifier))
    __swig_destroy__ = _connect.delete_CFNetCounterController

    def getMaxChannelsCount(self) -> "uint8_t":
        return _connect.CFNetCounterController_getMaxChannelsCount(self)

    def getTriggerIndex(self, channelIndex: "uint8_t const") -> "std::string":
        return _connect.CFNetCounterController_getTriggerIndex(self, channelIndex)

    def setTriggerIndex(self, channelIndex: "uint8_t const", trigger: "std::string const &") -> "void":
        return _connect.CFNetCounterController_setTriggerIndex(self, channelIndex, trigger)

    def op(self) -> "CFNetCounterOperationController":
        r"""
        Returns shared pointer to counter operation controller.
        :rtype: :py:class:`CFNetCounterOperationController`
        :return: CFNetCounterOperationControllerSPtr
        """
        return _connect.CFNetCounterController_op(self)

    def ctrl(self) -> "CFNetCounterControlController":
        r"""
        Returns shared pointer to counter control controller.
        :rtype: :py:class:`CFNetCounterControlController`
        :return: CFNetCounterControlControllerSPtr
        """
        return _connect.CFNetCounterController_ctrl(self)

# Register CFNetCounterController in _connect:
_connect.CFNetCounterController_swigregister(CFNetCounterController)

class CFNetSPIConfigurationController(object):
    r"""FNet Serial Peripheral Interface configuration controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spiCtrl: "CFNetSPIController"):
        _connect.CFNetSPIConfigurationController_swiginit(self, _connect.new_CFNetSPIConfigurationController(spiCtrl))
    __swig_destroy__ = _connect.delete_CFNetSPIConfigurationController

    def getNetworkDescriptionFile(self, descriptionFiles: "StrVector") -> "void":
        r"""
        Returns a vector of currently specified network description files.
        :type descriptionFiles: std::vector< std::string,std::allocator< std::string > >
        :param descriptionFiles: vector of files
        """
        return _connect.CFNetSPIConfigurationController_getNetworkDescriptionFile(self, descriptionFiles)

    def setNetworkDescriptionFile(self, descriptionFiles: "StrVector") -> "void":
        r"""
        Set network description files by overriding current settings.
        :type descriptionFiles: std::vector< std::string,std::allocator< std::string > >
        :param descriptionFiles: vector of a new description files
        """
        return _connect.CFNetSPIConfigurationController_setNetworkDescriptionFile(self, descriptionFiles)

    def enableSPI(self, isEnabled: "bool") -> "void":
        r"""
        Enable/disable SPI.
        :type isEnabled: boolean
        :param isEnabled: if true SPI is enabled on DIO pins
        """
        return _connect.CFNetSPIConfigurationController_enableSPI(self, isEnabled)

    def configureChipSelectActiveState(self, activeState: "isys::IOState") -> "void":
        r"""
        Set SPI parameters.
        :type activeState: int
        :param activeState: device enable pin active state
        """
        return _connect.CFNetSPIConfigurationController_configureChipSelectActiveState(self, activeState)

    def configureSamplingPhase(self, samplingPhase: "isys::SPISamplePhase") -> "void":
        r"""
        Set SPI parameters.
        :type samplingPhase: int
        :param samplingPhase: sampling edge selection
        """
        return _connect.CFNetSPIConfigurationController_configureSamplingPhase(self, samplingPhase)

    def configureClockIdleState(self, clockIdleState: "isys::IOState") -> "void":
        r"""
        Set SPI parameters.
        :type clockIdleState: int
        :param clockIdleState: clock idle logical state selection
        """
        return _connect.CFNetSPIConfigurationController_configureClockIdleState(self, clockIdleState)

# Register CFNetSPIConfigurationController in _connect:
_connect.CFNetSPIConfigurationController_swigregister(CFNetSPIConfigurationController)

class CSPIOperationConfig(object):
    r"""SPI configuration class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CSPIOperationConfig_swiginit(self, _connect.new_CSPIOperationConfig())
    __swig_destroy__ = _connect.delete_CSPIOperationConfig
    triggerIndex = property(_connect.CSPIOperationConfig_triggerIndex_get, _connect.CSPIOperationConfig_triggerIndex_set, doc=r""" trigger index in range from 0 to 10.""")
    csName = property(_connect.CSPIOperationConfig_csName_get, _connect.CSPIOperationConfig_csName_set, doc=r""" device enable pin selection""")
    stream = property(_connect.CSPIOperationConfig_stream_get, _connect.CSPIOperationConfig_stream_set, doc=r""" data stream type""")
    offset = property(_connect.CSPIOperationConfig_offset_get, _connect.CSPIOperationConfig_offset_set, doc=r""" integer in range from 0 to 1023""")
    size = property(_connect.CSPIOperationConfig_size_get, _connect.CSPIOperationConfig_size_set, doc=r""" integer in range from 1 to 32""")
    bitOrder = property(_connect.CSPIOperationConfig_bitOrder_get, _connect.CSPIOperationConfig_bitOrder_set, doc=r""" type of data encoding""")
    valueHex = property(_connect.CSPIOperationConfig_valueHex_get, _connect.CSPIOperationConfig_valueHex_set, doc=r""" string of a hex value, without '0x'""")
    maskHex = property(_connect.CSPIOperationConfig_maskHex_get, _connect.CSPIOperationConfig_maskHex_set, doc=r""" string of a hex value, without '0x'""")

# Register CSPIOperationConfig in _connect:
_connect.CSPIOperationConfig_swigregister(CSPIOperationConfig)

class CFNetSPIOperationController(object):
    r"""FNet Serial Peripheral Interface operation controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spiCtrl: "CFNetSPIController"):
        _connect.CFNetSPIOperationController_swiginit(self, _connect.new_CFNetSPIOperationController(spiCtrl))
    __swig_destroy__ = _connect.delete_CFNetSPIOperationController

    def enableRecordingAllMessages(self, isEnabled: "bool") -> "void":
        r"""
        Enable recording all SPI messages.
        :type isEnabled: boolean
        :param isEnabled: if true, all messages are recorded regardless of each channel settings
        """
        return _connect.CFNetSPIOperationController_enableRecordingAllMessages(self, isEnabled)

    def enableRecording(self, slotIndex: "uint8_t", isEnabled: "bool") -> "void":
        r"""
        Enable/disable recording SPI stream and triggering actions on selected slot
        :type slotIndex: uint8_t
        :param slotIndex: recording slot index in range from 0 to 3
        :type isEnabled: boolean
        :param isEnabled: if true recording on selected comparator slot is enabled
        """
        return _connect.CFNetSPIOperationController_enableRecording(self, slotIndex, isEnabled)

    def configureComparator(self, slotIndex: "uint8_t", spiOpConfig: "CSPIOperationConfig") -> "void":
        r"""
        Configure chosen SPI comparator slot to raise trigger if conditions are met.
        :type slotIndex: uint8_t
        :param slotIndex: recording slot index in range from 0 to 3
        :type spiOpConfig: :py:class:`CSPIOperationConfig`
        :param spiOpConfig: SPI comparator configuration
        """
        return _connect.CFNetSPIOperationController_configureComparator(self, slotIndex, spiOpConfig)

# Register CFNetSPIOperationController in _connect:
_connect.CFNetSPIOperationController_swigregister(CFNetSPIOperationController)

class CFNetSPIController(CFNetBase):
    r"""
    FNet Serial Peripheral Interface controller.



    fnetSPI.py SPI controller usage example. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "isys::ConnectionMgrSPtr", identifier: "std::string const &"):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: isystem connect connection manager which maintains connection to winIDEA.
                   Connection must be established before this call.
        :type identifier: string
        :param identifier: unique network identifier for example "ADIO.SPI1"
        """
        _connect.CFNetSPIController_swiginit(self, _connect.new_CFNetSPIController(connectionMgr, identifier))
    __swig_destroy__ = _connect.delete_CFNetSPIController

    def cfg(self) -> "CFNetSPIConfigurationController":
        r"""
        Returns shared pointer to SPI configuration controller.
        :rtype: :py:class:`CFNetSPIConfigurationController`
        :return: CFNetSPIConfigurationControllerSPtr
        """
        return _connect.CFNetSPIController_cfg(self)

    def op(self) -> "CFNetSPIOperationController":
        r"""
        Returns shared pointer to SPI operation controller.
        :rtype: :py:class:`CFNetSPIOperationController`
        :return: CFNetSPIOperationControllerSPtr
        """
        return _connect.CFNetSPIController_op(self)

# Register CFNetSPIController in _connect:
_connect.CFNetSPIController_swigregister(CFNetSPIController)

class CFNetAOutConfigurationController(object):
    r"""FNet analog output configuration controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, aoutCtrl: "CFNetAOutController"):
        _connect.CFNetAOutConfigurationController_swiginit(self, _connect.new_CFNetAOutConfigurationController(aoutCtrl))
    __swig_destroy__ = _connect.delete_CFNetAOutConfigurationController

    def showChannel(self, channelIndex: "uint8_t const", isShow: "bool") -> "void":
        r"""
        Show/hide given channel index.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :type isShow: boolean
        :param isShow: if true, channel will be shown in HIL monitor, otherwise not
        """
        return _connect.CFNetAOutConfigurationController_showChannel(self, channelIndex, isShow)

    def setChannelName(self, channelIndex: "uint8_t const", name: "std::string const &") -> "void":
        r"""
        Set channel index name.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :type name: string
        :param name: channel name
        """
        return _connect.CFNetAOutConfigurationController_setChannelName(self, channelIndex, name)

    def getChannelName(self, channelIndex: "uint8_t const") -> "std::string":
        r"""
        Get channel index name.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :rtype: string
        :return: channel name
        """
        return _connect.CFNetAOutConfigurationController_getChannelName(self, channelIndex)

    def setChannelInitialValue(self, channelIndex: "uint8_t const", value: "double const") -> "void":
        r"""
        Set channel initial value after session start.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :type value: float
        :param value: initial value in range from -5 to 5
        """
        return _connect.CFNetAOutConfigurationController_setChannelInitialValue(self, channelIndex, value)

# Register CFNetAOutConfigurationController in _connect:
_connect.CFNetAOutConfigurationController_swigregister(CFNetAOutConfigurationController)

class CFNetAOutOperationController(object):
    r"""FNet analog output operation controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, aoutCtrl: "CFNetAOutController"):
        _connect.CFNetAOutOperationController_swiginit(self, _connect.new_CFNetAOutOperationController(aoutCtrl))
    __swig_destroy__ = _connect.delete_CFNetAOutOperationController

    def setActionTrigger(self, channelIndex: "uint8_t const", actionIndex: "uint8_t const", triggerIndex: "uint8_t const") -> "void":
        r"""
        Set trigger action for AOUT channel.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :type actionIndex: uint8_t
        :param actionIndex: action slot index in range from 0 to 1
        :type triggerIndex: uint8_t
        :param triggerIndex: trigger index in range from 0 to 10
        """
        return _connect.CFNetAOutOperationController_setActionTrigger(self, channelIndex, actionIndex, triggerIndex)

    def setActionTriggerLevel(self, channelIndex: "uint8_t const", actionIndex: "uint8_t const", level: "double const") -> "void":
        r"""
        Set output voltage level once trigger is activated.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :type actionIndex: uint8_t
        :param actionIndex: action slot index in range from 0 to 1
        :type level: float
        :param level: voltage output level once trigger is activated in range from -5 to 5
        """
        return _connect.CFNetAOutOperationController_setActionTriggerLevel(self, channelIndex, actionIndex, level)

# Register CFNetAOutOperationController in _connect:
_connect.CFNetAOutOperationController_swigregister(CFNetAOutOperationController)

class CFNetAOutControlController(object):
    r"""FNet analog output control controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, aoutCtrl: "CFNetAOutController"):
        _connect.CFNetAOutControlController_swiginit(self, _connect.new_CFNetAOutControlController(aoutCtrl))
    __swig_destroy__ = _connect.delete_CFNetAOutControlController

    def writeChannel(self, channelIndex: "uint8_t const", value: "double const") -> "void":
        r"""
        Write channel index analog value.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :type value: float
        :param value: voltage level in range from -5 to 5
        """
        return _connect.CFNetAOutControlController_writeChannel(self, channelIndex, value)

    def readChannel(self, channelIndex: "uint8_t const") -> "double":
        r"""
        Read channel index analog value.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :rtype: float
        :return: channel voltage level
        """
        return _connect.CFNetAOutControlController_readChannel(self, channelIndex)

# Register CFNetAOutControlController in _connect:
_connect.CFNetAOutControlController_swigregister(CFNetAOutControlController)

class CFNetAOutController(CFNetBase):
    r"""
    FNet analog output controller.



    fnetAOut.py controller usage example. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "isys::ConnectionMgrSPtr", identifier: "std::string const &"):
        r"""
        Instantiates object.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: isystem connect connection manager
        :type identifier: string
        :param identifier: unique network identifier for example "ADIO.AOUT"
        """
        _connect.CFNetAOutController_swiginit(self, _connect.new_CFNetAOutController(connectionMgr, identifier))
    __swig_destroy__ = _connect.delete_CFNetAOutController

    def cfg(self) -> "CFNetAOutConfigurationController":
        r"""
        Returns shared pointer to analog output configuration controller.
        :rtype: :py:class:`CFNetAOutConfigurationController`
        :return: CFNetAOutConfigurationControllerSPtr
        """
        return _connect.CFNetAOutController_cfg(self)

    def op(self) -> "CFNetAOutOperationController":
        r"""
        Returns shared pointer to analog output operation controller.
        :rtype: :py:class:`CFNetAOutOperationController`
        :return: CFNetAOutOperationControllerSPtr
        """
        return _connect.CFNetAOutController_op(self)

    def ctrl(self) -> "CFNetAOutControlController":
        r"""
        Returns shared pointer to analog output control controller.
        :rtype: :py:class:`CFNetAOutControlController`
        :return: CFNetAOutControlControllerSPtr
        """
        return _connect.CFNetAOutController_ctrl(self)

# Register CFNetAOutController in _connect:
_connect.CFNetAOutController_swigregister(CFNetAOutController)

AInAverage_AVG_4 = _connect.AInAverage_AVG_4
AInAverage_AVG_8 = _connect.AInAverage_AVG_8
AInAverage_AVG_16 = _connect.AInAverage_AVG_16
class SAInAverage(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key: "isys::AInAverage") -> "std::string const":
        return _connect.SAInAverage_convert(key)

    def __init__(self):
        _connect.SAInAverage_swiginit(self, _connect.new_SAInAverage())
    __swig_destroy__ = _connect.delete_SAInAverage

# Register SAInAverage in _connect:
_connect.SAInAverage_swigregister(SAInAverage)

def SAInAverage_convert(key: "isys::AInAverage") -> "std::string const":
    return _connect.SAInAverage_convert(key)

class CFNetAInConfigurationController(object):
    r"""FNet analog input configuration controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, ainCtrl: "CFNetAInController"):
        _connect.CFNetAInConfigurationController_swiginit(self, _connect.new_CFNetAInConfigurationController(ainCtrl))
    __swig_destroy__ = _connect.delete_CFNetAInConfigurationController

    def showChannel(self, channelIndex: "uint8_t const", isShow: "bool") -> "void":
        r"""
        Show/hide given channel index.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :type isShow: boolean
        :param isShow: if true, channel will be shown in HIL monitor, otherwise not
        """
        return _connect.CFNetAInConfigurationController_showChannel(self, channelIndex, isShow)

    def setChannelName(self, channelIndex: "uint8_t const", name: "std::string const &") -> "void":
        r"""
        Set channel index name.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :type name: string
        :param name: channel name
        """
        return _connect.CFNetAInConfigurationController_setChannelName(self, channelIndex, name)

    def getChannelName(self, channelIndex: "uint8_t const") -> "std::string":
        r"""
        Get channel index name.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :rtype: string
        :return: channel name
        """
        return _connect.CFNetAInConfigurationController_getChannelName(self, channelIndex)

    def setMultiplier(self, channelIndex: "uint8_t const", multiplier: "double const") -> "void":
        r"""
        Set channel multiplier.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :type multiplier: float
        :param multiplier: input value multiplier
        """
        return _connect.CFNetAInConfigurationController_setMultiplier(self, channelIndex, multiplier)

    def getMultiplier(self, channelIndex: "uint8_t const") -> "double":
        r"""
        Get channel multiplier.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :rtype: float
        :return: multiplier
        """
        return _connect.CFNetAInConfigurationController_getMultiplier(self, channelIndex)

    def setAveraging(self, isEnabled: "bool", averageSamples: "isys::AInAverage") -> "void":
        r"""
        Enable/disable averaging.

        :type isEnabled: boolean
        :param isEnabled: if true, analog input values are average values of samples count
        :type averageSamples: int
        :param averageSamples: number of samples to be averaged
        """
        return _connect.CFNetAInConfigurationController_setAveraging(self, isEnabled, averageSamples)

    def getAveraging(self) -> "int64_t":
        r"""
        Returns number of averaged samples for analog inputs.

        :rtype: int
        :return: number of averaged samples
        """
        return _connect.CFNetAInConfigurationController_getAveraging(self)

# Register CFNetAInConfigurationController in _connect:
_connect.CFNetAInConfigurationController_swigregister(CFNetAInConfigurationController)

class CFNetAInOperationController(object):
    r"""FNet analog input operation controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, ainCtrl: "CFNetAInController"):
        _connect.CFNetAInOperationController_swiginit(self, _connect.new_CFNetAInOperationController(ainCtrl))
    __swig_destroy__ = _connect.delete_CFNetAInOperationController

    def enableRecording(self, channelIndex: "uint8_t const", isEnabled: "bool") -> "void":
        r"""
        Enable recording of selected channel.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :type isEnabled: boolean
        :param isEnabled: if true, recording of selected channel is enabled
        """
        return _connect.CFNetAInOperationController_enableRecording(self, channelIndex, isEnabled)

    def setSampligInterval(self, interval: "isys::AInSamplingInterval const") -> "void":
        r"""
        Set analog inputs sampling interval.

        :type interval: int
        :param interval: sampling interval of type AInSamplingInterval
        """
        return _connect.CFNetAInOperationController_setSampligInterval(self, interval)

    def setTriggerAction(self, channelIndex: "uint8_t const", slotIndex: "uint8_t const", triggerIndex: "uint8_t const", condition: "isys::AInCompareCondition const", level: "double const") -> "void":
        r"""
        Set selected channel trigger once compare condition is met.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :type slotIndex: uint8_t
        :param slotIndex: trigger slot index(comparator channel slot) in range from 0 to 1
        :type triggerIndex: uint8_t
        :param triggerIndex: trigger index in range from 0 to 10
        :type condition: int
        :param condition: signal compare operand of type AInCompareCondition
        :type level: float
        :param level: voltage level in range from -5 to 5
        """
        return _connect.CFNetAInOperationController_setTriggerAction(self, channelIndex, slotIndex, triggerIndex, condition, level)

    def disableTriggerAction(self, channelIndex: "uint8_t const", slotIndex: "uint8_t const") -> "void":
        r"""
        Disable selected channel trigger.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :type slotIndex: uint8_t
        :param slotIndex: trigger slot index(comparator channel slot) in range from 0 to 1
        """
        return _connect.CFNetAInOperationController_disableTriggerAction(self, channelIndex, slotIndex)

# Register CFNetAInOperationController in _connect:
_connect.CFNetAInOperationController_swigregister(CFNetAInOperationController)

class CFNetAInControlController(object):
    r"""FNet analog input control controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, ainCtrl: "CFNetAInController"):
        _connect.CFNetAInControlController_swiginit(self, _connect.new_CFNetAInControlController(ainCtrl))
    __swig_destroy__ = _connect.delete_CFNetAInControlController

    def readChannel(self, channelIndex: "uint8_t const") -> "double":
        r"""
        Returns channel analog value.

        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 1
        :rtype: float
        :return: channel analog value
        """
        return _connect.CFNetAInControlController_readChannel(self, channelIndex)

# Register CFNetAInControlController in _connect:
_connect.CFNetAInControlController_swigregister(CFNetAInControlController)

class CFNetAInController(CFNetBase):
    r"""
    FNet analog input controller.



    fnetAIn.py controller usage example. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "isys::ConnectionMgrSPtr", identifier: "std::string const &"):
        r"""
        Instantiates object.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: isystem connect connection manager
        :type identifier: string
        :param identifier: unique network identifier for example "ADIO.AIN1"
        """
        _connect.CFNetAInController_swiginit(self, _connect.new_CFNetAInController(connectionMgr, identifier))
    __swig_destroy__ = _connect.delete_CFNetAInController

    def cfg(self) -> "CFNetAInConfigurationController":
        r"""
        Returns shared pointer to analog input configuration controller.
        :rtype: :py:class:`CFNetAInConfigurationController`
        :return: CFNetAInConfigurationControllerSPtr
        """
        return _connect.CFNetAInController_cfg(self)

    def op(self) -> "CFNetAInOperationController":
        r"""
        Returns shared pointer to analog input operation controller.
        :rtype: :py:class:`CFNetAInOperationController`
        :return: CFNetAInOperationControllerSPtr
        """
        return _connect.CFNetAInController_op(self)

    def ctrl(self) -> "CFNetAInControlController":
        r"""
        Returns shared pointer to analog input control controller.
        :rtype: :py:class:`CFNetAInControlController`
        :return: CFNetAInControlControllerSPtr
        """
        return _connect.CFNetAInController_ctrl(self)

# Register CFNetAInController in _connect:
_connect.CFNetAInController_swigregister(CFNetAInController)

class CFNetPowerSenseConfigurationController(object):
    r"""FNet power sense configuration controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, powerSenseCtrl: "CFNetPowerSenseController"):
        _connect.CFNetPowerSenseConfigurationController_swiginit(self, _connect.new_CFNetPowerSenseConfigurationController(powerSenseCtrl))
    __swig_destroy__ = _connect.delete_CFNetPowerSenseConfigurationController

    def setShuntValue(self, value: "isys::PowerSenseShunt") -> "void":
        r"""
        Set shunt resistor value.
        :param shuntValue: value of a physical shunt resistor in ohms
        """
        return _connect.CFNetPowerSenseConfigurationController_setShuntValue(self, value)

    def setAveraging(self, averageSamples: "isys::AInAverage") -> "void":
        r"""
        Set AIN channels averaging.
        :type averageSamples: int
        :param averageSamples: averaging of AIN channels, used by power measurement module
        """
        return _connect.CFNetPowerSenseConfigurationController_setAveraging(self, averageSamples)

    def enablePowerSense(self, isEnabled: "bool") -> "void":
        r"""
        Enable/disable power measurement mode. If enabled, AIN controller is reconfigured to be
        used for power measurement mode and therefore can't be used for other purposes.
        :type isEnabled: boolean
        :param isEnabled: if true, power measurement mode is enabled
            Note: Multiplication of analog input channels is reconfigured to 1, and is not restored once
                  power sense is disabled.
        """
        return _connect.CFNetPowerSenseConfigurationController_enablePowerSense(self, isEnabled)

# Register CFNetPowerSenseConfigurationController in _connect:
_connect.CFNetPowerSenseConfigurationController_swigregister(CFNetPowerSenseConfigurationController)

class CFNetPowerSenseControlController(object):
    r"""FNet power sense control controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, powerSenseCtrl: "CFNetPowerSenseController"):
        _connect.CFNetPowerSenseControlController_swiginit(self, _connect.new_CFNetPowerSenseControlController(powerSenseCtrl))
    __swig_destroy__ = _connect.delete_CFNetPowerSenseControlController

    def getPower(self) -> "double":
        r"""
        Returns measured power.

        :rtype: float
        :return: measured power in watts
        """
        return _connect.CFNetPowerSenseControlController_getPower(self)

    def getVoltageCurrentPower(self, parameters: "PowerSenseParameters") -> "void":
        r"""
        Power sense parameters - voltage, current and power.

        :type parameters: :py:class:`PowerSenseParameters`
        :param parameters: voltage, current, power parameters
        """
        return _connect.CFNetPowerSenseControlController_getVoltageCurrentPower(self, parameters)

# Register CFNetPowerSenseControlController in _connect:
_connect.CFNetPowerSenseControlController_swigregister(CFNetPowerSenseControlController)

class CFNetPowerSenseController(CFNetBase):
    r"""
    FNet power sense controller.



    fnetPowerSense.py controller usage example. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "isys::ConnectionMgrSPtr", ainIdentifier: "std::string const &"):
        r"""
        Instantiates object.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: isystem connect connection manager
        :param ainIdentifier:unique: network identifier string for analog input network for example "ADIO.AIN"
        """
        _connect.CFNetPowerSenseController_swiginit(self, _connect.new_CFNetPowerSenseController(connectionMgr, ainIdentifier))
    __swig_destroy__ = _connect.delete_CFNetPowerSenseController

    def getAInCtrl(self) -> "isys::CFNetAInController &":
        return _connect.CFNetPowerSenseController_getAInCtrl(self)

    def cfg(self) -> "CFNetPowerSenseConfigurationController":
        r"""
        Returns shared pointer to power sense configuration controller.
        :rtype: :py:class:`CFNetPowerSenseConfigurationController`
        :return: CFNetPowerSenseConfigurationControllerSPtr
        """
        return _connect.CFNetPowerSenseController_cfg(self)

    def ctrl(self) -> "CFNetPowerSenseControlController":
        r"""
        Returns shared pointer to power sense control controller.
        :rtype: :py:class:`CFNetPowerSenseControlController`
        :return: CFNetPowerSenseControlControllerSPtr
        """
        return _connect.CFNetPowerSenseController_ctrl(self)

# Register CFNetPowerSenseController in _connect:
_connect.CFNetPowerSenseController_swigregister(CFNetPowerSenseController)

class CFNetCANConfigurationController(object):
    r"""FNet CAN configuration controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, canCtrl: "CFNetCANController"):
        _connect.CFNetCANConfigurationController_swiginit(self, _connect.new_CFNetCANConfigurationController(canCtrl))
    __swig_destroy__ = _connect.delete_CFNetCANConfigurationController

    def getNetworkDescriptionFile(self, descriptionFiles: "StrVector") -> "void":
        r"""
        Returns a vector of currently specified network description files.

        :type descriptionFiles: std::vector< std::string,std::allocator< std::string > >
        :param descriptionFiles: vector of description files
        """
        return _connect.CFNetCANConfigurationController_getNetworkDescriptionFile(self, descriptionFiles)

    def setNetworkDescriptionFile(self, descriptionFiles: "StrVector") -> "void":
        r"""
        Set network description files by overriding current settings.

        :type descriptionFiles: std::vector< std::string,std::allocator< std::string > >
        :param descriptionFiles: list of new description files to be set
        """
        return _connect.CFNetCANConfigurationController_setNetworkDescriptionFile(self, descriptionFiles)

    def getMode(self) -> "std::string":
        r"""Returns CAN mode."""
        return _connect.CFNetCANConfigurationController_getMode(self)

    def setMode(self, mode: "isys::CANMode const") -> "void":
        r"""
        Set CAN mode type.

        :type mode: int
        :param mode: should be one of isys::CANMode
        """
        return _connect.CFNetCANConfigurationController_setMode(self, mode)

    def enableMsgInjection(self, isEnabled: "bool") -> "void":
        r"""
        Enable/disable CAN message injection

        :type isEnabled: boolean
        :param isEnabled: if ``true``, CAN message can be injected, otherwise not
        """
        return _connect.CFNetCANConfigurationController_enableMsgInjection(self, isEnabled)

    def setArbitrationPhase(self, baudrate: "isys::CANBaudrate", bitSamplingPointPercent: "uint8_t"=70) -> "void":
        r"""
        Set arbitration phase - baudrate and bit sampling point. Settings apply to CANMode.CAN
        :type baudrate: int
        :param baudrate: baudrate selection
        :type bitSamplingPointPercent: uint8_t, optional
        :param bitSamplingPointPercent: bit sampling point(in percent) in range 50-99. Default value is 70.
        """
        return _connect.CFNetCANConfigurationController_setArbitrationPhase(self, baudrate, bitSamplingPointPercent)

    def setFDDataPhase(self, baudrate: "isys::CANFDBaudrate", bitSamplingPointPercent: "uint8_t"=70) -> "void":
        r"""
        Set CAN FD data phase - baudrate and bit sampling point. Only available in CAN_FD_ISO or CAN_FD_BOSCH mode.
        :type baudrate: int
        :param baudrate: baudrate selection
        :type bitSamplingPointPercent: uint8_t, optional
        :param bitSamplingPointPercent: bit sampling point(in percent) in range 50-99. Default value is 70.
        """
        return _connect.CFNetCANConfigurationController_setFDDataPhase(self, baudrate, bitSamplingPointPercent)

# Register CFNetCANConfigurationController in _connect:
_connect.CFNetCANConfigurationController_swigregister(CFNetCANConfigurationController)

class CFNetCANOperationController(object):
    r"""FNet CAN operation controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, canCtrl: "CFNetCANController"):
        _connect.CFNetCANOperationController_swiginit(self, _connect.new_CFNetCANOperationController(canCtrl))
    __swig_destroy__ = _connect.delete_CFNetCANOperationController

    def enableRecordingAllMessages(self, isEnabled: "bool") -> "void":
        r"""
        Enable recording all CAN messages
        :type isEnabled: boolean
        :param isEnabled: if ``true``, all messages are recorded regardless of each channel settings
        """
        return _connect.CFNetCANOperationController_enableRecordingAllMessages(self, isEnabled)

    def enableRecording(self, slotIndex: "uint32_t", isEnabled: "bool") -> "void":
        r"""
        Enable/disable recording CAN stream and triggering actions on a chosen slot
        :type slotIndex: int
        :param slotIndex: recording slot index in range from 0 to 3
        :type isEnabled: boolean
        :param isEnabled: if ``true``, recording on selected comparator slot is enabled
        """
        return _connect.CFNetCANOperationController_enableRecording(self, slotIndex, isEnabled)

    def setTrigger(self, slotIndex: "uint32_t", triggerIndex: "uint32_t") -> "void":
        r"""
        Set trigger that is raised when comparator conditions are met.
        :type slotIndex: int
        :param slotIndex: recording slot index in range from 0 to 3
        :type triggerIndex: int
        :param triggerIndex: trigger index in range from 0 to 10
        """
        return _connect.CFNetCANOperationController_setTrigger(self, slotIndex, triggerIndex)

    def configureComparator(self, slotIndex: "uint32_t", canOpConfig: "CCANOpConfig") -> "void":
        r"""
        Configure chosen CAN comparator slot to raise trigger if conditions are met.
        :type slotIndex: int
        :param slotIndex: recording slot index in range from 0 to 3
        :type canOpConfig: :py:class:`CCANOpConfig`
        :param canOpConfig: CAN comparator configuration
        """
        return _connect.CFNetCANOperationController_configureComparator(self, slotIndex, canOpConfig)

    def enableTriggerOnError(self, isEnabled: "bool") -> "void":
        r"""
        Enable/disable trigger on CAN error
        :type isEnabled: boolean
        :param isEnabled: if ``true``, trigger is raised on CAN error
        """
        return _connect.CFNetCANOperationController_enableTriggerOnError(self, isEnabled)

    def setTriggerOnError(self, triggerIndex: "uint32_t") -> "void":
        r"""
        Set trigger on CAN error
        :type triggerIndex: int
        :param triggerIndex: trigger index in range from 0 to 10
        """
        return _connect.CFNetCANOperationController_setTriggerOnError(self, triggerIndex)

    def enableInjectedMsgRecord(self, isEnabled: "bool") -> "void":
        r"""
        Enable/disable recording CAN injected messages
        :type isEnabled: boolean
        :param isEnabled:: if ``true``, CAN injected messages will be recorded
        """
        return _connect.CFNetCANOperationController_enableInjectedMsgRecord(self, isEnabled)

    def setActionTrigger(self, slotIndex: "uint32_t", triggerIndex: "uint32_t") -> "void":
        r"""
        Set action trigger index when conditions are met.
        :type slotIndex: int
        :param slotIndex: comparator slot index in range from 0 to 3
        :param triggerIndextrigger: index in range from 0 to 10
        """
        return _connect.CFNetCANOperationController_setActionTrigger(self, slotIndex, triggerIndex)

    def configureInjectedMsgAction(self, slotIndex: "uint32_t", msgConfig: "CCANOpInjMsgConfig") -> "void":
        r"""
        Configure chosen CAN action slot to inject message once action trigger is raised.
        :type slotIndex: int
        :param slotIndex: action slot index in range from 0 to 3
        :type msgConfig: :py:class:`CCANOpInjMsgConfig`
        :param msgConfig: CAN injected message configuration
        """
        return _connect.CFNetCANOperationController_configureInjectedMsgAction(self, slotIndex, msgConfig)

# Register CFNetCANOperationController in _connect:
_connect.CFNetCANOperationController_swigregister(CFNetCANOperationController)

class CFNetCANControlController(object):
    r"""FNet CAN control controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, canCtrl: "CFNetCANController"):
        _connect.CFNetCANControlController_swiginit(self, _connect.new_CFNetCANControlController(canCtrl))
    __swig_destroy__ = _connect.delete_CFNetCANControlController

    def injectMsg(self, msgConfig: "CCANOpInjMsgConfig") -> "void":
        r"""
        Manually generate(inject) CAN message on CAN bus with specified parameters
         :type msgConfig: :py:class:`CCANOpInjMsgConfig`
         :param msgConfig: message configuration and data
        """
        return _connect.CFNetCANControlController_injectMsg(self, msgConfig)

# Register CFNetCANControlController in _connect:
_connect.CFNetCANControlController_swigregister(CFNetCANControlController)

class CFNetCANController(CFNetBase):
    r"""
    FNet CAN controller.



    fnetCAN.py controller usage example. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "isys::ConnectionMgrSPtr", identifier: "std::string const &"):
        r"""
        Instantiates object.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: isystem connect connection manager
        :type identifier: string
        :param identifier: unique network identifier for example "CAN2LIN2.CAN1"
        """
        _connect.CFNetCANController_swiginit(self, _connect.new_CFNetCANController(connectionMgr, identifier))
    __swig_destroy__ = _connect.delete_CFNetCANController

    def convertInjectedMessageTypeToBool(self, message: "isys::CANInjectedMsgType") -> "bool":
        return _connect.CFNetCANController_convertInjectedMessageTypeToBool(self, message)

    def cfg(self) -> "CFNetCANConfigurationController":
        r"""
        Returns shared pointer to CAN configuration controller.
        :rtype: :py:class:`CFNetCANConfigurationController`
        :return: CFNetCANConfigurationControllerSPtr
        """
        return _connect.CFNetCANController_cfg(self)

    def op(self) -> "CFNetCANOperationController":
        r"""
        Returns shared pointer to CAN operation controller.
        :rtype: :py:class:`CFNetCANOperationController`
        :return: CFNetCANOperationControllerSPtr
        """
        return _connect.CFNetCANController_op(self)

    def ctrl(self) -> "CFNetCANControlController":
        r"""
        Returns shared pointer to CAN control controller.
        :rtype: :py:class:`CFNetCANControlController`
        :return: CFNetCANControlControllerSPtr
        """
        return _connect.CFNetCANController_ctrl(self)

# Register CFNetCANController in _connect:
_connect.CFNetCANController_swigregister(CFNetCANController)

class CFNetDIOConfigurationController(object):
    r"""FNet digital input/output configuration controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, dioCtrl: "CFNetDIOController"):
        _connect.CFNetDIOConfigurationController_swiginit(self, _connect.new_CFNetDIOConfigurationController(dioCtrl))
    __swig_destroy__ = _connect.delete_CFNetDIOConfigurationController

    def setInputBankConfiguration(self, bankIndex: "uint8_t", voltage: "isys::IOLevels") -> "void":
        r"""
        Configure specific bank as input with given parameter.
        :type bankIndex: uint8_t
        :param bankIndex: bank index in range from 0 to 3
        :type voltage: int
        :param voltage: voltage level for input logical high state
        """
        return _connect.CFNetDIOConfigurationController_setInputBankConfiguration(self, bankIndex, voltage)

    def setOutputBankConfiguration(self, bankIndex: "uint8_t", voltage: "isys::IOLevels", initialState: "isys::IOState") -> "void":
        r"""
        Configure specific bank as output with given parameter.
        :type bankIndex: uint8_t
        :param bankIndex: bank index in range from 0 to 3
        :type voltage: int
        :param voltage: voltage level for output logical high state
        :type initialState: int
        :param initialState: initial logical state
        """
        return _connect.CFNetDIOConfigurationController_setOutputBankConfiguration(self, bankIndex, voltage, initialState)

    def showBank(self, bankIndex: "uint8_t", isShow: "bool") -> "void":
        r"""
        Show or hide chosen bank in winIDEA HIL Monitor.
        :type bankIndex: uint8_t
        :param bankIndex: bank index in range from 0 to 3
        :type isShow: boolean
        :param isShow: if true, bank is shown, otherwise not
        """
        return _connect.CFNetDIOConfigurationController_showBank(self, bankIndex, isShow)

    def showChannel(self, bankIndex: "uint8_t", channelIndex: "uint8_t", isShow: "bool") -> "void":
        r"""
        Show or hide chosen channel in winIDEA HIL Monitor.
        :type bankIndex: uint8_t
        :param bankIndex: bank index in range from 0 to 3
        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 7
        :type isShow: boolean
        :param isShow: if true, channel is shown, otherwise not
        """
        return _connect.CFNetDIOConfigurationController_showChannel(self, bankIndex, channelIndex, isShow)

    def setChannelName(self, bankIndex: "uint8_t", channelIndex: "uint8_t", name: "std::string const &") -> "void":
        r"""
        Set a new name for specified channel and bank.
        :type bankIndex: uint8_t
        :param bankIndex: bank index in range from 0 to 3
        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 7
        :type name: string
        :param name: new channel name
        """
        return _connect.CFNetDIOConfigurationController_setChannelName(self, bankIndex, channelIndex, name)

    def getChannelName(self, bankIndex: "uint8_t", channelIndex: "uint8_t") -> "std::string":
        r"""
        Returns current name of a chosen channel.
        :type bankIndex: uint8_t
        :param bankIndex: bank index in range from 0 to 3
        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 7
        """
        return _connect.CFNetDIOConfigurationController_getChannelName(self, bankIndex, channelIndex)

    def getBankAndChannelIndex(self, channelName: "std::string const &", bankChannelIndex: "DIOBankChannelIndexVector") -> "void":
        r"""
        Returns vector of BankChannelIndex structures.
        :type channelName: string
        :param channelName: channel name
        :type bankChannelIndex: std::vector< isys::DIOBankChannelIndex,std::allocator< isys::DIOBankChannelIndex > >
        :param bankChannelIndex: vector of BankChannelIndex structures.
        """
        return _connect.CFNetDIOConfigurationController_getBankAndChannelIndex(self, channelName, bankChannelIndex)

# Register CFNetDIOConfigurationController in _connect:
_connect.CFNetDIOConfigurationController_swigregister(CFNetDIOConfigurationController)

class CFNetDIOOperationController(object):
    r"""FNet digital input/output operation controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, dioCtrl: "CFNetDIOController"):
        _connect.CFNetDIOOperationController_swiginit(self, _connect.new_CFNetDIOOperationController(dioCtrl))
    __swig_destroy__ = _connect.delete_CFNetDIOOperationController

    def setRecordMode(self, mode: "isys::IORecordMode") -> "void":
        r"""
        Set record mode.
        :type mode: int
        :param mode: recording mode
        """
        return _connect.CFNetDIOOperationController_setRecordMode(self, mode)

    def setTrigger(self, comparatorIndex: "uint8_t", triggerIndex: "uint8_t") -> "void":
        r"""
        Set trigger.
        :type comparatorIndex: uint8_t
        :param comparatorIndex: comparator index in range from 0 to 3
        :type triggerIndex: uint8_t
        :param triggerIndex: trigger index in range from 0 to 10
        """
        return _connect.CFNetDIOOperationController_setTrigger(self, comparatorIndex, triggerIndex)

    def setTriggerSignalState(self, comparatorIndex: "uint8_t", bankIndex: "uint8_t", channelIndex: "uint8_t", state: "isys::IOTriggerSignalState") -> "void":
        r"""
        Set comparator signal value/mask to activate trigger.
        :type comparatorIndex: uint8_t
        :param comparatorIndex: comparator index in range from 0 to 3
        :type bankIndex: uint8_t
        :param bankIndex: bank index in range from 0 to 3
        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 7
        :type state: int
        :param state: trigger channel state comparator configuration
        """
        return _connect.CFNetDIOOperationController_setTriggerSignalState(self, comparatorIndex, bankIndex, channelIndex, state)

    def setActionTrigger(self, slotIndex: "uint8_t", actionTriggerIndex: "uint8_t") -> "void":
        r"""
        Set trigger to execute action on a specified slot.
        :type slotIndex: uint8_t
        :param slotIndex: action slot index in range from 0 to 3
        :type actionTriggerIndex: uint8_t
        :param actionTriggerIndex: trigger index in range from 0 to 10
        """
        return _connect.CFNetDIOOperationController_setActionTrigger(self, slotIndex, actionTriggerIndex)

    def setAction(self, slotIndex: "uint8_t", state: "isys::IOState", bankIndex: "uint8_t", channelIndex: "uint8_t") -> "void":
        r"""
        Set action that takes place on trigger activation.
        :type slotIndex: uint8_t
        :param slotIndex: action slot index in range from 0 to 3
        :type state: int
        :param state: DIO pin state that is set on specified trigger
        :type bankIndex: uint8_t
        :param bankIndex: bank index in range from 0 to 3
        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 7
        """
        return _connect.CFNetDIOOperationController_setAction(self, slotIndex, state, bankIndex, channelIndex)

    def setPatternChannels(self, slotIndex: "uint8_t", channels: "DIOBankChannelIndexVector") -> "void":
        r"""
        Set channels that outputs specified DIO pattern.
        :type slotIndex: uint8_t
        :param slotIndex: pattern slot index in range from 0 to 3
        :type channels: std::vector< isys::DIOBankChannelIndex,std::allocator< isys::DIOBankChannelIndex > >
        :param channels: vector of channels, where each item is a TYPE of BankChannelIndex
            Note that selected channels(bank) must be set to output.
            Example: bank 0 channel 1 would resolve to D0_1
        """
        return _connect.CFNetDIOOperationController_setPatternChannels(self, slotIndex, channels)

    def setPattern(self, slotIndex: "uint8_t", patternType: "isys::IOPatternType", pattern: "std::string") -> "void":
        r"""
        Set DIO pattern, a sequence of frames, separated by ';'.Each frame consists
        of state(binary)and duration(default us), separated by ','.
        :type slotIndex: uint8_t
        :param slotIndex: pattern slot index in range from 0 to 3
        :type patternType: int
        :param patternType: type of pattern that is executed on trigger
        :type pattern: string
        :param pattern: pattern string
            binary state - length must fit number of specified pattern channels. For example,
            if 3 channels are specified, binary state must be 3 digits long: "01x"
            duration - duration of this binary state. By default in "us", but "ns", "us", "ms"
            and "s" units are also supported. Example pattern string:"001,140; xx0,10; 1xx,50ms; 001,100us"
        """
        return _connect.CFNetDIOOperationController_setPattern(self, slotIndex, patternType, pattern)

    def setPatternTriggers(self, slotIndex: "uint8_t", startActive: "isys::TriState", startOnTriggerIndex: "uint8_t", stopOnTriggerIndex: "uint8_t") -> "void":
        r"""
        Set chosen pattern slot activation and start/stop trigger index. Only non 'DO_NOT_MODIFY'
        settings are altered.
        :type slotIndex: uint8_t
        :param slotIndex: pattern slot index in range from 0 to 4
        :type startActive: int
        :param startActive: if set, pattern is active on session start
        :type startOnTriggerIndex: uint8_t
        :param startOnTriggerIndex: start pattern on trigger index in range from 0 to 10
        :type stopOnTriggerIndex: uint8_t
        :param stopOnTriggerIndex: stop pattern on trigger index in range from 0 to 10
        """
        return _connect.CFNetDIOOperationController_setPatternTriggers(self, slotIndex, startActive, startOnTriggerIndex, stopOnTriggerIndex)

# Register CFNetDIOOperationController in _connect:
_connect.CFNetDIOOperationController_swigregister(CFNetDIOOperationController)

class CFNetDIOControlController(object):
    r"""FNet digital input/output control controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, dioCtrl: "CFNetDIOController"):
        _connect.CFNetDIOControlController_swiginit(self, _connect.new_CFNetDIOControlController(dioCtrl))
    __swig_destroy__ = _connect.delete_CFNetDIOControlController

    def setChannelState(self, bankIndex: "uint8_t", channelIndex: "uint8_t", state: "isys::IOState") -> "void":
        r"""
        Set pin state of chosen channel of chosen bank.
        :type bankIndex: uint8_t
        :param bankIndex: bank index in range from 0 to 3
        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 7
        :type state: int
        :param state: new channel state
            You can only set pin state if bank is configured as output, otherwise
            this function call is ignored.
        """
        return _connect.CFNetDIOControlController_setChannelState(self, bankIndex, channelIndex, state)

    def toggleChannelState(self, bankIndex: "uint8_t", channelIndex: "uint8_t") -> "void":
        r"""
        Toggle pin state for selected channel/bank.
        :type bankIndex: uint8_t
        :param bankIndex: bank index in range from 0 to 3
        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 7
            You can only set pin state if bank is configured as output, otherwise
            this function call is ignored.
        """
        return _connect.CFNetDIOControlController_toggleChannelState(self, bankIndex, channelIndex)

    def setBankChannelsState(self, bankIndex: "uint8_t", channelsStates: "std::string") -> "void":
        r"""
        Set multiple channels states of a chosen chosen bank. Individual channels are set one by one,
        hence a very short delay might be present between setting output states.
        :type bankIndex: uint8_t
        :param bankIndex: bank index in range from 0 to 3
        :type channelsStates: string
        :param channelsStates: string of a channel states to be set, where '0' sets channel to
            LOW state, '1' sets channel to HIGH state and 'x' does not change channel state.
            Example string: '0x1xxxx0' sets channel 0 and 7 to LOW, channel 2 to HIGH and leave others unchanged.
        """
        return _connect.CFNetDIOControlController_setBankChannelsState(self, bankIndex, channelsStates)

    def getChannelState(self, bankIndex: "uint8_t", channelIndex: "uint8_t") -> "isys::IOState":
        r"""
        Returns pin state of a chosen channel of a chosen bank.
        :type bankIndex: uint8_t
        :param bankIndex: bank index in range from 0 to 3
        :type channelIndex: uint8_t
        :param channelIndex: channel index in range from 0 to 7
        :rtype: int
        :return: pin state of type IOState
        """
        return _connect.CFNetDIOControlController_getChannelState(self, bankIndex, channelIndex)

    def getBankChannelsState(self, bankIndex: "uint8_t") -> "std::string":
        r"""
        Get all channels states of a chosen chosen bank as a string of eight (8 channels per bank)
        '1' and '0', where '0' corresponds to LOW state and '1' to HIGH. Channel 0 corresponds to first character in string, channel 7 as last.
        :type bankIndex: uint8_t
        :param bankIndex: bank index in range from 0 to 3
            Note: Pins are read one by one, not all at once.
            Example: '10100000' would mean that channels 0 and 2 are set to HIGH state, while others are LOW.
        """
        return _connect.CFNetDIOControlController_getBankChannelsState(self, bankIndex)

# Register CFNetDIOControlController in _connect:
_connect.CFNetDIOControlController_swigregister(CFNetDIOControlController)

class CFNetDIOController(CFNetBase):
    r"""
    FNet digital input/output controller.



    fnetDIO.py controller usage example. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "isys::ConnectionMgrSPtr", identifier: "std::string const &"):
        r"""
        Instantiates object.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: isystem connect connection manager
        :type identifier: string
        :param identifier: unique network identifier for example "ADIO.DIO"
        """
        _connect.CFNetDIOController_swiginit(self, _connect.new_CFNetDIOController(connectionMgr, identifier))
    __swig_destroy__ = _connect.delete_CFNetDIOController

    def cfg(self) -> "CFNetDIOConfigurationController":
        r"""
        Returns shared pointer to DIO configuration controller.
        :rtype: :py:class:`CFNetDIOConfigurationController`
        :return: CFNetDIOConfigurationControllerSPtr
        """
        return _connect.CFNetDIOController_cfg(self)

    def op(self) -> "CFNetDIOOperationController":
        r"""
        Returns shared pointer to DIO operation controller.
        :rtype: :py:class:`CFNetDIOOperationController`
        :return: CFNetDIOOperationControllerSPtr
        """
        return _connect.CFNetDIOController_op(self)

    def ctrl(self) -> "CFNetDIOControlController":
        r"""
        Returns shared pointer to DIO control controller.
        :rtype: :py:class:`CFNetDIOControlController`
        :return: CFNetDIOControlControllerSPtr
        """
        return _connect.CFNetDIOController_ctrl(self)

    def getBankBaseString(self, bankIndex: "uint8_t") -> "std::string":
        return _connect.CFNetDIOController_getBankBaseString(self, bankIndex)

    def getMappedChannelIndex(self, bankIndex: "uint8_t const", channelIndex: "uint8_t const") -> "uint32_t":
        return _connect.CFNetDIOController_getMappedChannelIndex(self, bankIndex, channelIndex)

    def getMaxNumberOfBanks(self) -> "uint8_t":
        return _connect.CFNetDIOController_getMaxNumberOfBanks(self)

    def getMaxNumberOfChannels(self) -> "uint8_t":
        return _connect.CFNetDIOController_getMaxNumberOfChannels(self)

# Register CFNetDIOController in _connect:
_connect.CFNetDIOController_swigregister(CFNetDIOController)

class CLINOperationConfig(object):
    r"""LIN configuration class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CLINOperationConfig_swiginit(self, _connect.new_CLINOperationConfig())
    __swig_destroy__ = _connect.delete_CLINOperationConfig
    triggerIndex = property(_connect.CLINOperationConfig_triggerIndex_get, _connect.CLINOperationConfig_triggerIndex_set, doc=r""" trigger index in range from 0 to 10.""")
    idValueHex = property(_connect.CLINOperationConfig_idValueHex_get, _connect.CLINOperationConfig_idValueHex_set, doc=r""" string of a hex value, without '0x'""")
    maskHex = property(_connect.CLINOperationConfig_maskHex_get, _connect.CLINOperationConfig_maskHex_set, doc=r""" string of a hex value, without '0x'""")

# Register CLINOperationConfig in _connect:
_connect.CLINOperationConfig_swigregister(CLINOperationConfig)

class CFNetLINConfigurationController(object):
    r"""FNet LIN configuration controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, linCtrl: "CFNetLINController"):
        _connect.CFNetLINConfigurationController_swiginit(self, _connect.new_CFNetLINConfigurationController(linCtrl))
    __swig_destroy__ = _connect.delete_CFNetLINConfigurationController

    def getNetworkDescriptionFile(self, descriptionFiles: "StrVector") -> "void":
        r"""
        Returns a vector of currently specified network description files.

        :type descriptionFiles: std::vector< std::string,std::allocator< std::string > >
        :param descriptionFiles: vector of description files
        """
        return _connect.CFNetLINConfigurationController_getNetworkDescriptionFile(self, descriptionFiles)

    def setNetworkDescriptionFile(self, descriptionFiles: "StrVector") -> "void":
        r"""
        Set network description files by overriding current settings.

        :type descriptionFiles: std::vector< std::string,std::allocator< std::string > >
        :param descriptionFiles: vector of new description files to be set
        """
        return _connect.CFNetLINConfigurationController_setNetworkDescriptionFile(self, descriptionFiles)

    def setBaudrate(self, baudrate: "isys::LINBaudrate") -> "void":
        r"""
        Set LIN baudrate.

        :type baudrate: int
        :param baudrate: LIN baudrate selection
        """
        return _connect.CFNetLINConfigurationController_setBaudrate(self, baudrate)

# Register CFNetLINConfigurationController in _connect:
_connect.CFNetLINConfigurationController_swigregister(CFNetLINConfigurationController)

class CFNetLINOperationController(object):
    r"""FNet LIN operation controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, linCtrl: "CFNetLINController"):
        _connect.CFNetLINOperationController_swiginit(self, _connect.new_CFNetLINOperationController(linCtrl))
    __swig_destroy__ = _connect.delete_CFNetLINOperationController

    def enableRecordingAllMessages(self, isEnabled: "bool") -> "void":
        r"""
        Enable recording all LIN messages
        :type isEnabled: boolean
        :param isEnabled: if ``true``, all messages are recorded regardless of each channel settings
        """
        return _connect.CFNetLINOperationController_enableRecordingAllMessages(self, isEnabled)

    def enableRecording(self, slotIndex: "uint32_t", isEnabled: "bool") -> "void":
        r"""
        Enable/disable recording LIN stream and triggering actions on a chosen slot
        :type slotIndex: int
        :param slotIndex: recording slot index in range from 0 to 3
        :type isEnabled: boolean
        :param isEnabled: if ``true``, recording on selected comparator slot is enabled
        """
        return _connect.CFNetLINOperationController_enableRecording(self, slotIndex, isEnabled)

    def configureComparator(self, slotIndex: "uint8_t", linOpConfig: "CLINOperationConfig") -> "void":
        r"""
        Configure chosen LIN comparator slot to raise trigger if conditions are met.
        :type slotIndex: uint8_t
        :param slotIndex: recording slot index in range from 0 to 3
        :type linOpConfig: :py:class:`CLINOperationConfig`
        :param linOpConfig: SPI comparator configuration
        """
        return _connect.CFNetLINOperationController_configureComparator(self, slotIndex, linOpConfig)

    def enableTriggerOnWakeUp(self, isEnabled: "bool") -> "void":
        r"""
        Enable/disable trigger on LIN wake up detection
        :type isEnabled: boolean
        :param isEnabled: if true, trigger is raised on LIN wake up sequence
        """
        return _connect.CFNetLINOperationController_enableTriggerOnWakeUp(self, isEnabled)

    def setTriggerOnWakeUp(self, triggerIndex: "uint8_t") -> "void":
        r"""
        Set trigger on LIN wake up sequence
        :type triggerIndex: uint8_t
        :param triggerIndex: trigger index in range from 0 to 10
        """
        return _connect.CFNetLINOperationController_setTriggerOnWakeUp(self, triggerIndex)

# Register CFNetLINOperationController in _connect:
_connect.CFNetLINOperationController_swigregister(CFNetLINOperationController)

class CFNetLINController(CFNetBase):
    r"""
    FNet LIN controller.



    fnetLIN.py controller usage example. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: "isys::ConnectionMgrSPtr", identifier: "std::string const &"):
        r"""
        Instantiates object.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: isystem connect connection manager
        :type identifier: string
        :param identifier: unique network identifier for example "CAN2LIN2.LIN1"
        """
        _connect.CFNetLINController_swiginit(self, _connect.new_CFNetLINController(connectionMgr, identifier))
    __swig_destroy__ = _connect.delete_CFNetLINController

    def cfg(self) -> "CFNetLINConfigurationController":
        r"""
        Returns shared pointer to LIN configuration controller.
        :rtype: :py:class:`CFNetLINConfigurationController`
        :return: CFNetLINConfigurationControllerSPtr
        """
        return _connect.CFNetLINController_cfg(self)

    def op(self) -> "CFNetLINOperationController":
        r"""
        Returns shared pointer to LIN operation controller.
        :rtype: :py:class:`CFNetLINOperationController`
        :return: CFNetLINOperationControllerSPtr
        """
        return _connect.CFNetLINController_op(self)

# Register CFNetLINController in _connect:
_connect.CFNetLINController_swigregister(CFNetLINController)

class SVersion(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Major = property(_connect.SVersion_Major_get, _connect.SVersion_Major_set)
    Minor = property(_connect.SVersion_Minor_get, _connect.SVersion_Minor_set)
    Build = property(_connect.SVersion_Build_get, _connect.SVersion_Build_set)
    BuildSub = property(_connect.SVersion_BuildSub_get, _connect.SVersion_BuildSub_set)
    SCCRev = property(_connect.SVersion_SCCRev_get, _connect.SVersion_SCCRev_set)

    def __init__(self, byMajor: "uint8_t"=0, byMinor: "uint8_t"=0, wBuild: "uint16_t"=0, byBuildSub: "uint8_t"=0, dwSCCRev: "uint32_t"=0):
        _connect.SVersion_swiginit(self, _connect.new_SVersion(byMajor, byMinor, wBuild, byBuildSub, dwSCCRev))

    def toString(self, bAddSCCRev: "bool"=False) -> "std::string":
        r"""Returns string representation of this class, for example "9.17.110"."""
        return _connect.SVersion_toString(self, bAddSCCRev)

    def Compare(self, *args) -> "int":
        return _connect.SVersion_Compare(self, *args)
    __swig_destroy__ = _connect.delete_SVersion

# Register SVersion in _connect:
_connect.SVersion_swigregister(SVersion)

ACCESS_OK = _connect.ACCESS_OK
ACCESS_FAIL = _connect.ACCESS_FAIL
class CAddress(object):
    r"""Struct containing address info. used original for iOPEN"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_aAddress = property(_connect.CAddress_m_aAddress_get, _connect.CAddress_m_aAddress_set, doc=r""" offset""")
    m_iArea = property(_connect.CAddress_m_iArea_get, _connect.CAddress_m_iArea_set, doc=r"""
    area as specified in CDebugInterface::GetRegisterAreaInfo,
    -1 for register, -2 for number
    """)
    m_byProcess = property(_connect.CAddress_m_byProcess_get, _connect.CAddress_m_byProcess_set, doc=r""" index of the (virtual) process""")
    m_byReserved = property(_connect.CAddress_m_byReserved_get, _connect.CAddress_m_byReserved_set, doc=r""" reserved, should be zero""")

    def __init__(self):
        _connect.CAddress_swiginit(self, _connect.new_CAddress())
    __swig_destroy__ = _connect.delete_CAddress

# Register CAddress in _connect:
_connect.CAddress_swigregister(CAddress)

class SValue(object):
    r""" Contains union of possible values."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MAX_INT_BITS = _connect.SValue_MAX_INT_BITS
    MAX_FLT_BITS = _connect.SValue_MAX_FLT_BITS

    def __init__(self):
        _connect.SValue_swiginit(self, _connect.new_SValue())
    __swig_destroy__ = _connect.delete_SValue

# Register SValue in _connect:
_connect.SValue_swigregister(SValue)

class SType(object):
    r""" Contains type info and size."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    tUndefined = _connect.SType_tUndefined
    r""" udefined type"""
    tUnsigned = _connect.SType_tUnsigned
    r""" unsigned integral type"""
    tSigned = _connect.SType_tSigned
    r""" signed integral type"""
    tFloat = _connect.SType_tFloat
    r""" floating point type"""
    tAddress = _connect.SType_tAddress
    r""" address type"""
    tCompound = _connect.SType_tCompound
    r""" compound type, for example struct"""
    m_byType = property(_connect.SType_m_byType_get, _connect.SType_m_byType_set, doc=r""" type of variable, see SType::EType for possible values""")
    m_byBitSize = property(_connect.SType_m_byBitSize_get, _connect.SType_m_byBitSize_set, doc=r""" size of variable in bits""")

    def __init__(self):
        _connect.SType_swiginit(self, _connect.new_SType())
    __swig_destroy__ = _connect.delete_SType

# Register SType in _connect:
_connect.SType_swigregister(SType)

class SType2(SType):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    t2Regular = _connect.SType2_t2Regular
    r""" no extra type information available"""
    t2BitField = _connect.SType2_t2BitField
    r""" this is a bit field, m_dw1 specifies size and m_dw2 offset within container integer"""
    t2Enum = _connect.SType2_t2Enum
    t2Struct = _connect.SType2_t2Struct
    t2Union = _connect.SType2_t2Union
    t2Class = _connect.SType2_t2Class
    t2Pointer = _connect.SType2_t2Pointer
    t2Reference = _connect.SType2_t2Reference
    t2Array = _connect.SType2_t2Array
    r""" m_dw1 = dimension"""
    t2Function = _connect.SType2_t2Function
    m_byType2 = property(_connect.SType2_m_byType2_get, _connect.SType2_m_byType2_set)
    m_byReserved = property(_connect.SType2_m_byReserved_get, _connect.SType2_m_byReserved_set)
    m_dw1 = property(_connect.SType2_m_dw1_get, _connect.SType2_m_dw1_set)
    m_dw2 = property(_connect.SType2_m_dw2_get, _connect.SType2_m_dw2_set)

    def __init__(self):
        _connect.SType2_swiginit(self, _connect.new_SType2())
    __swig_destroy__ = _connect.delete_SType2

# Register SType2 in _connect:
_connect.SType2_swigregister(SType2)

endianLittle = _connect.endianLittle
endianBig = _connect.endianBig
class CCPUInfo(object):
    r""" Contains CPU family and variant."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cpu_8051 = _connect.CCPUInfo_cpu_8051
    cpu_RISCV = _connect.CCPUInfo_cpu_RISCV
    cpu_ARC = _connect.CCPUInfo_cpu_ARC
    cpu_PowerPC = _connect.CCPUInfo_cpu_PowerPC
    cpu_ARM = _connect.CCPUInfo_cpu_ARM
    cpu_V850 = _connect.CCPUInfo_cpu_V850
    cpu_TPU = _connect.CCPUInfo_cpu_TPU
    cpu_TriCore = _connect.CCPUInfo_cpu_TriCore
    cpu_GTM = _connect.CCPUInfo_cpu_GTM
    cpu_SPT = _connect.CCPUInfo_cpu_SPT
    cpu_Num = _connect.CCPUInfo_cpu_Num
    cpu_Generic = _connect.CCPUInfo_cpu_Generic
    m_wCPU = property(_connect.CCPUInfo_m_wCPU_get, _connect.CCPUInfo_m_wCPU_set, doc=r""" Contains CPU family.""")
    v8051_8051 = _connect.CCPUInfo_v8051_8051
    v8051_Num = _connect.CCPUInfo_v8051_Num
    vPowerPC_4xx = _connect.CCPUInfo_vPowerPC_4xx
    vPowerPC_5xx = _connect.CCPUInfo_vPowerPC_5xx
    vPowerPC_6xx = _connect.CCPUInfo_vPowerPC_6xx
    vPowerPC_7xx = _connect.CCPUInfo_vPowerPC_7xx
    vPowerPC_8xx = _connect.CCPUInfo_vPowerPC_8xx
    vPowerPC_G5 = _connect.CCPUInfo_vPowerPC_G5
    vPowerPC_G3 = _connect.CCPUInfo_vPowerPC_G3
    vPowerPC_Num = _connect.CCPUInfo_vPowerPC_Num
    svPowerPC_e200z0 = _connect.CCPUInfo_svPowerPC_e200z0
    svPowerPC_e200z0H = _connect.CCPUInfo_svPowerPC_e200z0H
    svPowerPC_e200z1 = _connect.CCPUInfo_svPowerPC_e200z1
    svPowerPC_e200z210 = _connect.CCPUInfo_svPowerPC_e200z210
    svPowerPC_e200z215 = _connect.CCPUInfo_svPowerPC_e200z215
    svPowerPC_e200z225 = _connect.CCPUInfo_svPowerPC_e200z225
    svPowerPC_e200z3 = _connect.CCPUInfo_svPowerPC_e200z3
    svPowerPC_e200z335 = _connect.CCPUInfo_svPowerPC_e200z335
    svPowerPC_e200z4 = _connect.CCPUInfo_svPowerPC_e200z4
    svPowerPC_e200z420 = _connect.CCPUInfo_svPowerPC_e200z420
    svPowerPC_e200z4201n3 = _connect.CCPUInfo_svPowerPC_e200z4201n3
    svPowerPC_e200z425 = _connect.CCPUInfo_svPowerPC_e200z425
    svPowerPC_e200z6 = _connect.CCPUInfo_svPowerPC_e200z6
    svPowerPC_e200z6vle = _connect.CCPUInfo_svPowerPC_e200z6vle
    svPowerPC_e200z650 = _connect.CCPUInfo_svPowerPC_e200z650
    svPowerPC_e200z7early = _connect.CCPUInfo_svPowerPC_e200z7early
    svPowerPC_e200z7 = _connect.CCPUInfo_svPowerPC_e200z7
    svPowerPC_e200z720 = _connect.CCPUInfo_svPowerPC_e200z720
    svPowerPC_e200z7260 = _connect.CCPUInfo_svPowerPC_e200z7260
    svPowerPC_e200z75x = _connect.CCPUInfo_svPowerPC_e200z75x
    vARM_v3 = _connect.CCPUInfo_vARM_v3
    vARM_v4T = _connect.CCPUInfo_vARM_v4T
    vARM_v5TE = _connect.CCPUInfo_vARM_v5TE
    vARM_v5TEJ = _connect.CCPUInfo_vARM_v5TEJ
    vARM_v6 = _connect.CCPUInfo_vARM_v6
    vARM_v7A = _connect.CCPUInfo_vARM_v7A
    vARM_v7R = _connect.CCPUInfo_vARM_v7R
    vARM_v7M = _connect.CCPUInfo_vARM_v7M
    vARM_v6M = _connect.CCPUInfo_vARM_v6M
    vARM_v8A = _connect.CCPUInfo_vARM_v8A
    vARM_v8R = _connect.CCPUInfo_vARM_v8R
    vARM_v8M = _connect.CCPUInfo_vARM_v8M
    vARM_Num = _connect.CCPUInfo_vARM_Num
    svARM_CortexMask = _connect.CCPUInfo_svARM_CortexMask
    svARM_64 = _connect.CCPUInfo_svARM_64
    svARM_CortexM = _connect.CCPUInfo_svARM_CortexM
    svARM_CortexM0 = _connect.CCPUInfo_svARM_CortexM0
    svARM_CortexM1 = _connect.CCPUInfo_svARM_CortexM1
    svARM_CortexM3 = _connect.CCPUInfo_svARM_CortexM3
    svARM_CortexM4 = _connect.CCPUInfo_svARM_CortexM4
    svARM_CortexM7 = _connect.CCPUInfo_svARM_CortexM7
    svARM_CortexM23 = _connect.CCPUInfo_svARM_CortexM23
    svARM_CortexM33 = _connect.CCPUInfo_svARM_CortexM33
    svARM_CortexR = _connect.CCPUInfo_svARM_CortexR
    svARM_CortexR4 = _connect.CCPUInfo_svARM_CortexR4
    svARM_CortexR5 = _connect.CCPUInfo_svARM_CortexR5
    svARM_CortexR7 = _connect.CCPUInfo_svARM_CortexR7
    svARM_CortexR8 = _connect.CCPUInfo_svARM_CortexR8
    svARM_CortexR52 = _connect.CCPUInfo_svARM_CortexR52
    svARM_CortexR82 = _connect.CCPUInfo_svARM_CortexR82
    svARM_CortexA = _connect.CCPUInfo_svARM_CortexA
    svARM_CortexA5 = _connect.CCPUInfo_svARM_CortexA5
    svARM_CortexA7 = _connect.CCPUInfo_svARM_CortexA7
    svARM_CortexA8 = _connect.CCPUInfo_svARM_CortexA8
    svARM_CortexA9 = _connect.CCPUInfo_svARM_CortexA9
    svARM_CortexA12 = _connect.CCPUInfo_svARM_CortexA12
    svARM_CortexA15 = _connect.CCPUInfo_svARM_CortexA15
    svARM_CortexA17 = _connect.CCPUInfo_svARM_CortexA17
    svARM_CortexA32 = _connect.CCPUInfo_svARM_CortexA32
    svARM_CortexA34 = _connect.CCPUInfo_svARM_CortexA34
    svARM_CortexA35 = _connect.CCPUInfo_svARM_CortexA35
    svARM_CortexA53 = _connect.CCPUInfo_svARM_CortexA53
    svARM_CortexA55 = _connect.CCPUInfo_svARM_CortexA55
    svARM_CortexA57 = _connect.CCPUInfo_svARM_CortexA57
    svARM_CortexA65 = _connect.CCPUInfo_svARM_CortexA65
    svARM_CortexA72 = _connect.CCPUInfo_svARM_CortexA72
    svARM_CortexA73 = _connect.CCPUInfo_svARM_CortexA73
    svARM_CortexA75 = _connect.CCPUInfo_svARM_CortexA75
    svARM_CortexA76 = _connect.CCPUInfo_svARM_CortexA76
    svARM_CortexA77 = _connect.CCPUInfo_svARM_CortexA77
    svARM_CortexA78 = _connect.CCPUInfo_svARM_CortexA78
    sARMv8_EL0 = _connect.CCPUInfo_sARMv8_EL0
    r""" v8"""
    sARMv8_EL1 = _connect.CCPUInfo_sARMv8_EL1
    sARMv8_EL2 = _connect.CCPUInfo_sARMv8_EL2
    sARMv8_EL3 = _connect.CCPUInfo_sARMv8_EL3
    sARMv8_ELMask = _connect.CCPUInfo_sARMv8_ELMask
    sARMv8_Secure = _connect.CCPUInfo_sARMv8_Secure
    sARMv7_PL0 = _connect.CCPUInfo_sARMv7_PL0
    r""" v7"""
    sARMv7_PL1 = _connect.CCPUInfo_sARMv7_PL1
    sARMv7_PL2 = _connect.CCPUInfo_sARMv7_PL2
    sARMv7_ELMask = _connect.CCPUInfo_sARMv7_ELMask
    sARMv7_Secure = _connect.CCPUInfo_sARMv7_Secure
    vV850_V850 = _connect.CCPUInfo_vV850_V850
    vV850_V850E3v5 = _connect.CCPUInfo_vV850_V850E3v5
    vV850_RH850G4 = _connect.CCPUInfo_vV850_RH850G4
    vV850_Num = _connect.CCPUInfo_vV850_Num
    veTPU = _connect.CCPUInfo_veTPU
    vTPU_Num = _connect.CCPUInfo_vTPU_Num
    veGTM = _connect.CCPUInfo_veGTM
    vGTM_Num = _connect.CCPUInfo_vGTM_Num
    vTriCore13 = _connect.CCPUInfo_vTriCore13
    vTriCore16 = _connect.CCPUInfo_vTriCore16
    vTriCore16E = _connect.CCPUInfo_vTriCore16E
    vTriCore16P = _connect.CCPUInfo_vTriCore16P
    vTriCore162P = _connect.CCPUInfo_vTriCore162P
    vTriCore18 = _connect.CCPUInfo_vTriCore18
    vTriCore_Num = _connect.CCPUInfo_vTriCore_Num
    vRX = _connect.CCPUInfo_vRX
    vRX_Num = _connect.CCPUInfo_vRX_Num
    vRISCV_RV32I = _connect.CCPUInfo_vRISCV_RV32I
    vRISCV_RV32E = _connect.CCPUInfo_vRISCV_RV32E
    vRISCV_RV64I = _connect.CCPUInfo_vRISCV_RV64I
    vRISCV_RV128I = _connect.CCPUInfo_vRISCV_RV128I
    vRISCV_Num = _connect.CCPUInfo_vRISCV_Num
    vARC_EV7x = _connect.CCPUInfo_vARC_EV7x
    vARC_Num = _connect.CCPUInfo_vARC_Num
    vSPT_v1 = _connect.CCPUInfo_vSPT_v1
    vSPT_v2 = _connect.CCPUInfo_vSPT_v2
    vSPT_v2_5 = _connect.CCPUInfo_vSPT_v2_5
    vSPT_v2_8 = _connect.CCPUInfo_vSPT_v2_8
    vSPT_v3 = _connect.CCPUInfo_vSPT_v3
    vSPT_Num = _connect.CCPUInfo_vSPT_Num
    m_wVariant = property(_connect.CCPUInfo_m_wVariant_get, _connect.CCPUInfo_m_wVariant_set, doc=r""" Contains CPU variant ID.""")
    m_wSubVariant = property(_connect.CCPUInfo_m_wSubVariant_get, _connect.CCPUInfo_m_wSubVariant_set, doc=r""" Contains CPU subvariant ID.""")
    EEndianOverride_Default = _connect.CCPUInfo_EEndianOverride_Default
    EEndianOverride_Little = _connect.CCPUInfo_EEndianOverride_Little
    EEndianOverride_Big = _connect.CCPUInfo_EEndianOverride_Big
    m_eEndianOverride = property(_connect.CCPUInfo_m_eEndianOverride_get, _connect.CCPUInfo_m_eEndianOverride_set)
    fRISCV_M = _connect.CCPUInfo_fRISCV_M
    fRISCV_A = _connect.CCPUInfo_fRISCV_A
    fRISCV_F = _connect.CCPUInfo_fRISCV_F
    fRISCV_D = _connect.CCPUInfo_fRISCV_D
    fRISCV_Q = _connect.CCPUInfo_fRISCV_Q
    fRISCV_L = _connect.CCPUInfo_fRISCV_L
    fRISCV_C = _connect.CCPUInfo_fRISCV_C
    fRISCV_B = _connect.CCPUInfo_fRISCV_B
    fRISCV_J = _connect.CCPUInfo_fRISCV_J
    fRISCV_T = _connect.CCPUInfo_fRISCV_T
    fRISCV_P = _connect.CCPUInfo_fRISCV_P
    fRISCV_PULP = _connect.CCPUInfo_fRISCV_PULP
    fRISCV_V = _connect.CCPUInfo_fRISCV_V
    fRISCV_N = _connect.CCPUInfo_fRISCV_N
    fRISCV_H = _connect.CCPUInfo_fRISCV_H
    fRISCV_ZiCSR = _connect.CCPUInfo_fRISCV_ZiCSR
    fRISCV_Zifencei = _connect.CCPUInfo_fRISCV_Zifencei
    fRISCV_Zam = _connect.CCPUInfo_fRISCV_Zam
    fRISCV_Ztso = _connect.CCPUInfo_fRISCV_Ztso
    MAX_FEATURES = _connect.CCPUInfo_MAX_FEATURES
    m_adwFeatures = property(_connect.CCPUInfo_m_adwFeatures_get, _connect.CCPUInfo_m_adwFeatures_set)

    def SetFeature(self, nFeature: "int", bSet: "bool") -> "void":
        return _connect.CCPUInfo_SetFeature(self, nFeature, bSet)

    def IsFeature(self, nFeature: "int") -> "bool":
        return _connect.CCPUInfo_IsFeature(self, nFeature)

    def __init__(self):
        _connect.CCPUInfo_swiginit(self, _connect.new_CCPUInfo())
    __swig_destroy__ = _connect.delete_CCPUInfo

# Register CCPUInfo in _connect:
_connect.CCPUInfo_swigregister(CCPUInfo)

mempMode0 = _connect.mempMode0
mempMode1 = _connect.mempMode1
mempNum = _connect.mempNum
mempISANum = _connect.mempISANum
mempISAMask = _connect.mempISAMask
mempISA0 = _connect.mempISA0
mempISA1 = _connect.mempISA1
mempISA2 = _connect.mempISA2
mempISA3 = _connect.mempISA3
cpumodeAll = _connect.cpumodeAll
maCODE31 = _connect.maCODE31
r""" CODE memory space"""
maDATA31 = _connect.maDATA31
r""" DATA memory space"""
maIDATA31 = _connect.maIDATA31
r""" IDATA memory space"""
maBDATA31 = _connect.maBDATA31
r""" BDATA memory space"""
maXDATA31 = _connect.maXDATA31
r""" XDATA memory space"""
maPDATA31 = _connect.maPDATA31
r""" PDATA memory space"""
maSFR31 = _connect.maSFR31
r""" SFR memory space"""
mempModePowerPCVLE = _connect.mempModePowerPCVLE
mempISA_PPC_PPC = _connect.mempISA_PPC_PPC
mempISA_PPC_VLE = _connect.mempISA_PPC_VLE
maVirtualPowerPC = _connect.maVirtualPowerPC
r""" default memory space"""
maPPhysicalPowerPC = _connect.maPPhysicalPowerPC
r""" for SDK compatibility"""
maSPRPowerPC = _connect.maSPRPowerPC
r""" Special Purpose Registers, use mtspr"""
maDCRPowerPC = _connect.maDCRPowerPC
r""" Device Control Registers, use mtdcr"""
maTLBPowerPC = _connect.maTLBPowerPC
r""" TLB Entries, use tlbre/tlbwe"""
maPMRPowerPC = _connect.maPMRPowerPC
r""" Performance Monitor registers"""
mempModeARMThumb = _connect.mempModeARMThumb
mempISA_ARM_A32 = _connect.mempISA_ARM_A32
mempISA_ARM_T = _connect.mempISA_ARM_T
mempISA_ARM_A64 = _connect.mempISA_ARM_A64
cpumodeUser = _connect.cpumodeUser
cpumodeFIQ = _connect.cpumodeFIQ
cpumodeIRQ = _connect.cpumodeIRQ
cpumodeSupervisor = _connect.cpumodeSupervisor
cpumodeAbortMode = _connect.cpumodeAbortMode
cpumodeSystem = _connect.cpumodeSystem
cpumodeUndefined = _connect.cpumodeUndefined
maVirtualARM = _connect.maVirtualARM
r""" current virtual access"""
maIPA_ARM = _connect.maIPA_ARM
r""" non-secure intermediate PA"""
maCPARM = _connect.maCPARM
r""" Coprocessor access"""
maVFPARM = _connect.maVFPARM
r""" floating point, 32-bit MAU"""
maSP_ARM = _connect.maSP_ARM
r""" secure physical (same value as old maPhysicalARM)"""
maNP_ARM = _connect.maNP_ARM
r""" non-secure physical"""
maEL1S_ARM = _connect.maEL1S_ARM
r""" virtual EL1 secure"""
maEL1N_ARM = _connect.maEL1N_ARM
r""" virtual EL1 non-secure"""
maEL2N_ARM = _connect.maEL2N_ARM
r""" virtual EL2 non-secure"""
maEL3S_ARM = _connect.maEL3S_ARM
r""" virtual EL3 secure"""
maSCP_ARM = _connect.maSCP_ARM
r""" CP_ARM secure"""
maNCP_ARM = _connect.maNCP_ARM
r""" CP_ARM non-secure"""
maCPARM_Index = _connect.maCPARM_Index
maPL1S_ARM = _connect.maPL1S_ARM
r""" virtual PL1 secure"""
maPL1N_ARM = _connect.maPL1N_ARM
r""" virtual PL1 non-secure"""
maPL2N_ARM = _connect.maPL2N_ARM
r""" virtual PL2 non-secure"""
maPhysicalV850 = _connect.maPhysicalV850
r""" default memory area"""
maSysRegV850 = _connect.maSysRegV850
r""" system register access"""
maSCMTPU = _connect.maSCMTPU
maSPRAMTPU = _connect.maSPRAMTPU
maVirtualGTM = _connect.maVirtualGTM
maVirtualTriCore = _connect.maVirtualTriCore
r""" default memory area"""
maPhysicalTriCore = _connect.maPhysicalTriCore
r""" for SDK compatibility"""
maCerberusTricore = _connect.maCerberusTricore
r""" reserved"""
maVirtualSPT = _connect.maVirtualSPT
maOP_RAM = _connect.maOP_RAM
maTW_RAM = _connect.maTW_RAM
maVirtualRISCV = _connect.maVirtualRISCV
maVFPRISCV = _connect.maVFPRISCV
maVirtualARC = _connect.maVirtualARC
ICONNECT_E_CONNECT_FAILED = _connect.ICONNECT_E_CONNECT_FAILED
r""" The server is not reachable on the specified IP address and port"""
ICONNECT_E_VERSION_CONFLICT = _connect.ICONNECT_E_VERSION_CONFLICT
r""" The client and server versions are incompatible"""
ICONNECT_E_ALREADY_CONNECTED = _connect.ICONNECT_E_ALREADY_CONNECTED
r""" The iCONNECT object is already attached"""
ICONNECT_E_NOT_CONNECTED = _connect.ICONNECT_E_NOT_CONNECTED
r""" The iCONNECT object is not attached"""
ICONNECT_E_FILE_NOT_FOUND = _connect.ICONNECT_E_FILE_NOT_FOUND
r""" File not found"""
ICONNECT_E_CAN_NOT_ACCESS = _connect.ICONNECT_E_CAN_NOT_ACCESS
r""" Evaluation required a memory access which could not be performed"""
ICONNECT_E_BAD_ID = _connect.ICONNECT_E_BAD_ID
r""" Expression could not be evaluated"""
ICONNECT_E_NOT_SIMPLE_TYPE = _connect.ICONNECT_E_NOT_SIMPLE_TYPE
r""" Expression does not evaluate to a simple type"""
ICONNECT_E_ERROR = _connect.ICONNECT_E_ERROR
r""" Error occurred while performing the requested operation"""
ICONNECT_E_NO_BREAKPOINT = _connect.ICONNECT_E_NO_BREAKPOINT
r""" No breakpoint was found at the specified address"""
ICONNECT_E_NOT_AVAILABLE = _connect.ICONNECT_E_NOT_AVAILABLE
r""" The requested operation is not available"""
ICONNECT_E_SIZE = _connect.ICONNECT_E_SIZE
r""" Parameter size invalid"""
ICONNECT_E_ALREADY_EXISTS = _connect.ICONNECT_E_ALREADY_EXISTS
r""" Creation failed because an object with same name already exists"""
ICONNECT_E_TIMEOUT = _connect.ICONNECT_E_TIMEOUT
r""" timeout occurred in processing the operation"""
ICONNECT_E_LICENSE = _connect.ICONNECT_E_LICENSE
r""" license for the current operation is not available"""
ICONNECT_E_BUSY = _connect.ICONNECT_E_BUSY
r""" The requested operation is unavailable because the called object is busy"""
ICONNECT_E_MSG_FAIL = _connect.ICONNECT_E_MSG_FAIL
r""" Internal usage. The call failed with an error message."""
ICONNECT_E_ROUTING = _connect.ICONNECT_E_ROUTING
r""" Error occurred while routing the message from ser/des to winIDEA iConnect implementation"""
ICONNECT_E_UMI_FAIL = _connect.ICONNECT_E_UMI_FAIL
r""" UMI operation failed. LSB byte of the error code contains monitor error code"""
ICONNECT_UMI_EXC_ERR_MASK = _connect.ICONNECT_UMI_EXC_ERR_MASK
r""" these 8 bits holds UMI monitor fpcXXX operation result"""
ICONNECT_S_SIZE = _connect.ICONNECT_S_SIZE
r""" Function succeeded but could not return all the data due to output buffer size limitation"""
ICONNECT_S_MSG_FAIL = _connect.ICONNECT_S_MSG_FAIL
r"""
    Internal Usage. The call failed with an error message box.
    There is no exact return code.
    Call GetLastError() for more information.
    """
ICONNECT_S_MSG_WARN = _connect.ICONNECT_S_MSG_WARN
r""" The call passed with a warning"""
ICONNECT_S_STATUS_1 = _connect.ICONNECT_S_STATUS_1
r""" Status of a document is neither idle, nor default busy"""
ICONNECT_S_STATUS_2 = _connect.ICONNECT_S_STATUS_2
r""" Status of a document is neither idle, nor default busy"""
ICONNECT_S_STATUS_3 = _connect.ICONNECT_S_STATUS_3
r""" Status of a document is neither idle, nor default busy"""
ICONNECT_S_STATUS_4 = _connect.ICONNECT_S_STATUS_4
r""" Status of a document is neither idle, nor default busy"""
ICONNECT_S_STATUS_FLAGSMASK = _connect.ICONNECT_S_STATUS_FLAGSMASK
r"""
    these 8 bits can return information on the status, if dsReturnFlags is specified in the Document(daStatus call)
    the encoded values are document specific (e.g. IConnectIDE::EStatusFlagsAnalyzer)
    """
class IConnect(object):
    r"""
    The IConnect interface provides functions that control connection
    to winIDEA.

    If you use the CIConnectClient class you don't need to use this
    interface.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    dfCloseServerIfLastClient = _connect.IConnect_dfCloseServerIfLastClient
    r""" server will exit if this is the last client attached"""
    dfCloseServerUnconditional = _connect.IConnect_dfCloseServerUnconditional
    r""" server will exit unconditionally. In this case (and if shared memory connection is used), Detach becomes a blocking call until server exits"""
    dfCloseServerMask = _connect.IConnect_dfCloseServerMask
    dfCloseAutoSaveDefault = _connect.IConnect_dfCloseAutoSaveDefault
    r""" upon exiting prompt by default"""
    dfCloseAutoSaveAll = _connect.IConnect_dfCloseAutoSaveAll
    r""" upon exiting save all"""
    dfCloseAutoSaveNone = _connect.IConnect_dfCloseAutoSaveNone
    r""" upon exiting discard all"""
    dfCloseAutoSaveMask = _connect.IConnect_dfCloseAutoSaveMask

    def Detach(self, dwDetachFlags: "DWORD"=0) -> "unsigned long":
        r"""
        Closes the interprocess channel to winIDEA. After that, all
        IConnectXX function calls other then IConnect::Attach will fail.

        :param dwDetachFlag: ORed IConnect::EDetachFlags
        """
        return _connect.IConnect_Detach(self, dwDetachFlags)
    lfStartNever = _connect.IConnect_lfStartNever
    lfStartIfRequired = _connect.IConnect_lfStartIfRequired
    r""" Starts winIDEA if an instance isn't running yet"""
    lfStartAlways = _connect.IConnect_lfStartAlways
    r""" Always launch a new instance"""
    lfStartExisting = _connect.IConnect_lfStartExisting
    r""" Find an existing instance, do not launch new"""
    lfStartEnumerate = _connect.IConnect_lfStartEnumerate
    r""" When used, all instances of winIDEA with pszID on pszIPAddress will be enumerated"""
    lfStartMask = _connect.IConnect_lfStartMask
    r""" mask for **lfStart** values"""
    lfWaitDefault = _connect.IConnect_lfWaitDefault
    r""" Currently one second"""
    lfWait30ms = _connect.IConnect_lfWait30ms
    r""" 30 milliseconds"""
    lfWait100ms = _connect.IConnect_lfWait100ms
    r""" 100 milliseconds"""
    lfWait300ms = _connect.IConnect_lfWait300ms
    r""" 300 milliseconds"""
    lfWait1s = _connect.IConnect_lfWait1s
    r""" 1 second"""
    lfWait3s = _connect.IConnect_lfWait3s
    r""" 3 seconds"""
    lfWait10s = _connect.IConnect_lfWait10s
    r""" 10 seconds"""
    lfWait30s = _connect.IConnect_lfWait30s
    r""" 30 seconds"""
    lfWaitMask = _connect.IConnect_lfWaitMask
    r""" mask for **lfWait** values"""
    lfUseIPCDiscovery = _connect.IConnect_lfUseIPCDiscovery
    r""" locally running winIDEA instances will be discovered using local IPC discovery"""
    lfShowDefault = _connect.IConnect_lfShowDefault
    r""" No special provision."""
    lfShowMinimized = _connect.IConnect_lfShowMinimized
    r""" winIDEA is started minimized"""
    lfShowMaximized = _connect.IConnect_lfShowMaximized
    r""" winIDEA is started maximized"""
    lfShowHidden = _connect.IConnect_lfShowHidden
    r""" winIDEA is started hidden"""
    lfShowMask = _connect.IConnect_lfShowMask
    r""" mask for **lfShow** values"""
    lfSLaunch = _connect.IConnect_lfSLaunch
    r""" original SLaunch type"""
    lfSLaunch1_1_1 = _connect.IConnect_lfSLaunch1_1_1
    r""" members added in version EVersion::ver1_1_1 are valid"""
    lfSLaunchMask = _connect.IConnect_lfSLaunchMask
    r""" mask for **lfSLaunch** values"""
    lfSLaunchLatest = _connect.IConnect_lfSLaunchLatest
    r""" use in source to indicate latest version used"""
    __swig_destroy__ = _connect.delete_IConnect

# Register IConnect in _connect:
_connect.IConnect_swigregister(IConnect)

class IConnectIDE(object):
    r"""
    The IConnectIDE interface provides access to IDE functions exported
    by winIDEA.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxDocument = _connect.IConnectIDE_ndxDocument
    ndxWorkspace = _connect.IConnectIDE_ndxWorkspace
    ndxApplication = _connect.IConnectIDE_ndxApplication
    ndxNum = _connect.IConnectIDE_ndxNum
    ffIsOpen = _connect.IConnectIDE_ffIsOpen
    r""" returns S_OK if the window is open, or S_FALSE if it isn't"""
    ffClose = _connect.IConnectIDE_ffClose
    r""" close"""
    ffCloseAll = _connect.IConnectIDE_ffCloseAll
    r""" close all"""
    ffCloseDiscard = _connect.IConnectIDE_ffCloseDiscard
    r""" close, discard changes"""
    ffSave = _connect.IConnectIDE_ffSave
    r""" save existing to its original name"""
    ffSaveAs = _connect.IConnectIDE_ffSaveAs
    r""" save existing to *pszFileName*"""
    ffSaveAsPrompt = _connect.IConnectIDE_ffSaveAsPrompt
    r""" save using *SaveAs* prompt"""
    ffSaveAll = _connect.IConnectIDE_ffSaveAll
    ffSaveAsOverwrite = _connect.IConnectIDE_ffSaveAsOverwrite
    r""" save existing to *pszFileName*, overwrite an existing file if it exists"""
    ffSaveCopyAsOverwrite = _connect.IConnectIDE_ffSaveCopyAsOverwrite
    r""" save existing to *pszFileName*, overwrite an existing file if it exists, exiting file name remains the same"""
    ffNew = _connect.IConnectIDE_ffNew
    r"""
    create new with *pszFileName*. If already exists,
    *ICONNECT_E_ERROR* is returned. Add also
    one of *dtText*, *dtAnalyzer*,
    *dtCodeCoverage*, or *dtDataCoverage*
    to specify type. If none is specified,
    *dtText* is assumed.
    """
    ffNewPrompt = _connect.IConnectIDE_ffNewPrompt
    r""" create new, prompt for name"""
    ffOpen = _connect.IConnectIDE_ffOpen
    r""" open *pszFileName*"""
    ffOpenPrompt = _connect.IConnectIDE_ffOpenPrompt
    r""" prompt to open"""
    ffOpenOrNew = _connect.IConnectIDE_ffOpenOrNew
    r"""
    if a file already exists, the behavior is identical to ffOpen
    otherwise to ffNew
    """
    ffActionMask = _connect.IConnectIDE_ffActionMask
    r""" mask for **ffXXX** values"""
    ffCreateObjectOnly = _connect.IConnectIDE_ffCreateObjectOnly
    r""" only document object should be created. No GUI. valid with ffNew, ffOpen, ffOpenOrNew"""
    dmMarkSet = _connect.IConnectIDE_dmMarkSet
    r""" puts a marker on the line specified with *dwParameter*"""
    dmMarkClear = _connect.IConnectIDE_dmMarkClear
    r""" clears the marker"""
    dmMarkPos = _connect.IConnectIDE_dmMarkPos
    r""" positions the document on the specified line"""
    dmMarkMask = _connect.IConnectIDE_dmMarkMask
    r""" mask for **dmXXX** values"""
    dfFocus = _connect.IConnectIDE_dfFocus
    r"""
    Focus the file window. Use *dwParameter* to
    specify the line number to be displayed.
    """
    dfSpecialWindow = _connect.IConnectIDE_dfSpecialWindow
    r"""
    not a document window, but a special one
    defined by **dwXXX** mask
    **pszFileName**
    is ignored
    """
    dtText = _connect.IConnectIDE_dtText
    r""" Text type"""
    dtAnalyzer = _connect.IConnectIDE_dtAnalyzer
    r""" Analyzer type"""
    dtCodeCoverage = _connect.IConnectIDE_dtCodeCoverage
    r""" Code Coverage type"""
    dtDataCoverage = _connect.IConnectIDE_dtDataCoverage
    dtMask = _connect.IConnectIDE_dtMask
    r""" mask for **dtXXX** values"""
    dwTerminal = _connect.IConnectIDE_dwTerminal
    r"""
    terminal window, supports *daStart*,
    *daStop* and *daStatus* actions
    """
    dwDisassembly = _connect.IConnectIDE_dwDisassembly
    r""" disassembly window, supports *dmMarkPos*"""
    dwBreakpoints = _connect.IConnectIDE_dwBreakpoints
    r""" breakpoint window. dwParameter specifies the BP Index to focus"""
    dwMask = _connect.IConnectIDE_dwMask
    r""" mask for **dwXXX** values"""
    daStart = _connect.IConnectIDE_daStart
    r"""
    start the document action. There exists only one action
    per document type. Can be used with documents of type *dtAnalyzer*,
    *dtCodeCoverage*, and *dtDataCoverage*.
    """
    daStop = _connect.IConnectIDE_daStop
    r"""
     stop the document action (for example trace recording).
    c dwParameter specifies document specific type of stop. For analyzer documents see
     IConnectIDE::EAnalyzerStopParameter.
    """
    daStatus = _connect.IConnectIDE_daStatus
    r"""
    probe status. S_OK = idle, S_FALSE = busy, ICONNECT_S_STATUS_[1..4] document specific busy state.
    If dsReturnFlags is specified in the call, additional status bits can be encoded in the return value
    Can be used with documents of type *dtAnalyzer*,
    *dtCodeCoverage*, and *dtDataCoverage*.  It makes sense to use it
    between *daStart* and *daStop* actions to see, if the
    action already stopped for some other reason.
    """
    daResume = _connect.IConnectIDE_daResume
    r"""
    resume the document action, currently works only
    with code coverage.
    """
    daSelect = _connect.IConnectIDE_daSelect
    r"""
    select a property of the document. Currently
    only valid with documents of type *dtAnalyzer* and *dtCodeCoverage*
    *pszParameter* is used as trigger/rangeset name. A NULL/empty valua specifies
    default (full) configuration.
    """
    daExport = _connect.IConnectIDE_daExport
    r"""
    Export the document to a different format. Currently
    only valid with documents of type ``dtAnalyzer`` and
    ``dtCodeCoverage``. ``pszParameter`` specifies the file
    to export to.  ``dwParameter`` specifies the export format
    and scope to use. The values follow the document specific
    export format list starting with 0. If 0xFFFFFFFF is used the
    currently set export format is used. See
    IConnectIDE::EDocumentExportParameter for scope flags.
    """
    daExportV = _connect.IConnectIDE_daExportV
    r"""
    Same effect as ``daExport``, but the associated
    viewer is launched after export. This option is deprecated.
    """
    daSetExportFormat = _connect.IConnectIDE_daSetExportFormat
    r"""
    Sets the default export format
    only valid with documents of type *dtAnalyzer* and *dtCodeCoverage*
    *pszParameter* specifies the format name. For analyzer these formats are supported: /trace/*name* and /profiler/*name*
    *dwParameter* currently not used. should be zero.
    """
    daDeactivate = _connect.IConnectIDE_daDeactivate
    r"""
    stop the active document action (stop HW sampling)
    after this the document status will remain busy until
    all data is valid.
    """
    daReset = _connect.IConnectIDE_daReset
    r"""
    reset/clear document data. ``dwParameter`` specifies which
    data should be reset
    using IConnectIDE::EDocumentResetParameter.
    """
    daStart1 = _connect.IConnectIDE_daStart1
    r"""
    start the alternate document action. The action depends on
    document type. Can be used with documents of type *dtAnalyzer* where the re-analysis is started on previously acquired data.
    """
    daAbort = _connect.IConnectIDE_daAbort
    r""" abort current blocking action (for example trace loading from file)"""
    daDirty = _connect.IConnectIDE_daDirty
    r""" set (``dwParameter`` = 1) or clear (``dwParameter`` = 0) dirty flag"""
    daMask = _connect.IConnectIDE_daMask
    r""" mask for **daXXX** values"""
    deFormatMask = _connect.IConnectIDE_deFormatMask
    r""" use this mask to select the export format"""
    deScopeAll = _connect.IConnectIDE_deScopeAll
    r""" export entire document"""
    deScopeSelection = _connect.IConnectIDE_deScopeSelection
    r""" export selection only"""
    deScopeMask = _connect.IConnectIDE_deScopeMask
    r""" mask to use for scope selection"""
    drContent = _connect.IConnectIDE_drContent
    r""" deletes document content"""
    drItem = _connect.IConnectIDE_drItem
    r""" action applies to the aspect given in drItemMask"""
    drItemMask = _connect.IConnectIDE_drItemMask
    r""" index of the document aspect"""
    drConfigAll = _connect.IConnectIDE_drConfigAll
    r""" action applies to all configuration"""
    drConfigSelected = _connect.IConnectIDE_drConfigSelected
    r""" action applies to the selected aspect (trigger, rangeset,...)"""
    drConfigPresetInit = _connect.IConnectIDE_drConfigPresetInit
    r""" Initializes preset configuration"""
    drConfigPresetApply = _connect.IConnectIDE_drConfigPresetApply
    r""" Applies preset configuration"""
    drConfigMask = _connect.IConnectIDE_drConfigMask
    r""" config. flags selection mask"""
    dsReturnFlags = _connect.IConnectIDE_dsReturnFlags
    r""" return value will encode additional info using ICONNECT_S_STATUS_FLAGSMASK"""
    dsDomainMask = _connect.IConnectIDE_dsDomainMask
    r""" enumerated domain mask"""
    dsDomainDefault = _connect.IConnectIDE_dsDomainDefault
    r""" return status from default domain. For Analyzer: Deprecated. Returned values in IConnectIDE::EStatusFlagsAnalyzer."""
    dsDomainSession = _connect.IConnectIDE_dsDomainSession
    r""" return status from session domain. For Analyzer: Returned values in IConnectIDE::EStatusFlagsAnalyzerSession."""
    dsDomainDocument = _connect.IConnectIDE_dsDomainDocument
    r""" return status from document domain. Returned values in IConnectIDE::EStatusFlagsDocument."""
    sfasRecorderMask = _connect.IConnectIDE_sfasRecorderMask
    r""" recorder status mask"""
    sfasRecorderIdle = _connect.IConnectIDE_sfasRecorderIdle
    r""" recorder is idle. No samples are recorded."""
    sfasRecorderWaiting = _connect.IConnectIDE_sfasRecorderWaiting
    r""" recorder is waiting for trigger. Samples are recorded into circular trace buffer."""
    sfasRecorderSampling = _connect.IConnectIDE_sfasRecorderSampling
    r""" trigger was detected. Samples are recorded into trace buffer."""
    sfasLoading = _connect.IConnectIDE_sfasLoading
    r""" data is being uploaded from the emulator HW to the PC"""
    sfasAnalyzing = _connect.IConnectIDE_sfasAnalyzing
    r""" data is being analyzed"""
    sfasError = _connect.IConnectIDE_sfasError
    r"""
    if this bit is set, error in trace stream was detected
    Possible sources are: OCT bottleneck, stream decoder error
    """
    sfasOverrun = _connect.IConnectIDE_sfasOverrun
    r"""
    if this bit is set, session was terminated
    automatically when buffer was full
    """
    sfadSerializing = _connect.IConnectIDE_sfadSerializing
    r""" document file is being opened or saved"""
    sfadNoData = _connect.IConnectIDE_sfadNoData
    r""" document the contains no data"""
    sfadIsDirty = _connect.IConnectIDE_sfadIsDirty
    r""" document is dirty"""
    sfadCanStart = _connect.IConnectIDE_sfadCanStart
    r""" document action start is available"""
    sfaErrorsInBuffer = _connect.IConnectIDE_sfaErrorsInBuffer
    r"""
    if this bit is set, some recordings are incomplete
    due to OCT bottleneck
    """
    sfaBufferOverrun = _connect.IConnectIDE_sfaBufferOverrun
    r"""
    if this bit is set, session was terminated
    automatically when buffer was full
    """
    sfaLoading = _connect.IConnectIDE_sfaLoading
    r""" if this bit is set, the buffer is being loaded"""
    sfaRecordingError = _connect.IConnectIDE_sfaRecordingError
    r""" recording error has occurred"""
    sfaWaiting = _connect.IConnectIDE_sfaWaiting
    r""" the analyzer is waiting for trigger to occur"""
    sfaEmpty = _connect.IConnectIDE_sfaEmpty
    r""" the analyzer recording contains no samples"""
    sfaOpening = _connect.IConnectIDE_sfaOpening
    r""" document file is being opened"""
    asStopActionMask = _connect.IConnectIDE_asStopActionMask
    r""" stop action mask"""
    asStopSamplingOrAnalyzingAndWait = _connect.IConnectIDE_asStopSamplingOrAnalyzingAndWait
    r""" Stop sampling or analyzing and wait until status is idle. This option is deprecated."""
    asSampling = _connect.IConnectIDE_asSampling
    r""" Stop sampling. The analyzer will no longer record any samples."""
    asUploading = _connect.IConnectIDE_asUploading
    r""" Stop uploading trace data from emulator to PC."""
    asAnalyzing = _connect.IConnectIDE_asAnalyzing
    r""" Stop analyzing of the uploaded data"""
    asSerializing = _connect.IConnectIDE_asSerializing
    r""" Abort analyzer document save/load operation."""

    def Document(self, dwDocumentFlags: "DWORD", pszFileName: "LPCSTR", pszParameter: "LPCSTR"=None, dwParameter: "DWORD"=0) -> "unsigned long":
        r"""
        Manages document files and windows in winIDEA. The following rules
        apply to parameters:

        - flags *dtText*, *dtAnalyzer*, *dtCodeCoverage*, and
          *dtDataCoverage* are valid only with flag *ffNew*.

        - type of document opened with *ffOpen* is determined with file's
          extension.

        **Examples:**

        **Open a file and position to line 23:**

        Document(IConnectIDE::ffOpen, "demoFile.txt");
        Document(IConnectIDE::dfFocus, "demoFile.txt", NULL, 23);


        **Open a terminal, connect, then save:**

        Document(IConnectIDE::dfSpecialWindow + IConnectIDE::dwTerminal + IConnectIDE::daStart, "");
        Document(IConnectIDE::dfSpecialWindow + IConnectIDE::dwTerminal + IConnectIDE::daStop, "");
        Document(IConnectIDE::dfSpecialWindow + IConnectIDE::dwTerminal + IConnectIDE::ffSaveAs, "", "myFile");


        :rtype: int
        :return: 

        - S_FALSE - Indicates busy state when querying status (dwDocumentFlags
        = daStatus). For other operations it means that the operation failed.

        - ICONNECT_E_FILE_NOT_FOUND - File not found
        - ICONNECT_E_NOT_AVAILABLE - The requested operation is not available
        - ICONNECT_E_ERROR - An error occurred performing the requested operation
        - E_NOTIMPL - The requested document or window type is not supported

        :type pszParameter: string, optional
        :param pszParameter: Parameter to the requested
             action. Currently used with:
             - *ffSaveAs* - file name
             - *daSelect* - trigger name.
             Triggers must already be defined in the
             active workspace. File path. It is used as document ID,
             so it has to be defined.
             If this path is
             relative, winIDEA will consider
             the workspace file directory as
             the root. see IConnectIDE::EDocumentFlags
             and IConnectIDE::EFileFlags.
             This parameters defines action -
             what has to happen with the
             document.
        :type dwParameter: int, optional
        :param dwParameter: Parameter for the requested action.
             Currently used with:
             - *dfFocus* - line number to display
             - *dmMarkSet* - line number, where
               mark should be set
             - ``daReset`` - which part of document to reset,
               see IConnectIDE::EDocumentResetParameter.
        """
        return _connect.IConnectIDE_Document(self, dwDocumentFlags, pszFileName, pszParameter, dwParameter)

    def Workspace(self, dwFileFlags: "DWORD", pszWorkspaceName: "LPCSTR") -> "unsigned long":
        r"""
        Controls a workspace in winIDEA.

        :rtype: int
        :return: 
            - S_FALSE - The specified workspace is already open
            - ICONNECT_E_ERROR - An error occurred performing the requested operation

        :type dwFileFlags: int
        :param dwFileFlags: see IConnectIDE::EFileFlags
        :type pszWorkspaceName: string
        :param pszWorkspaceName: Workspace file path. If this path
             is relative, winIDEA will consider
             the workspace file directory as the
             root. This parameter must be
             specified in case of the following
             flags: ``ffSaveAs, ffNew, and
             ffOpen``
        """
        return _connect.IConnectIDE_Workspace(self, dwFileFlags, pszWorkspaceName)
    afWindowActivate = _connect.IConnectIDE_afWindowActivate
    r""" activate the application"""
    afWindowMinimize = _connect.IConnectIDE_afWindowMinimize
    r""" minimize"""
    afWindowRestore = _connect.IConnectIDE_afWindowRestore
    r""" restore size"""
    afWindowMaximize = _connect.IConnectIDE_afWindowMaximize
    r""" maximize"""
    afWindowMove = _connect.IConnectIDE_afWindowMove
    r""" move to pApplication->m_Rect"""
    afWindowMask = _connect.IConnectIDE_afWindowMask
    r""" mask for application values"""
    afHookMsgBoxSet = _connect.IConnectIDE_afHookMsgBoxSet
    r""" hook message box when called over iConnect. (default)"""
    afHookMsgBoxClr = _connect.IConnectIDE_afHookMsgBoxClr
    r""" display regular message box"""
    afHookMsgBoxGet = _connect.IConnectIDE_afHookMsgBoxGet
    r""" gets the hook state, returns ICONNECT_S_STATUS_1 for not hooked, ICONNECT_S_STATUS_2 for iConnect only hook, ICONNECT_S_STATUS_3 for all hooked"""
    afHookMsgBoxAll = _connect.IConnectIDE_afHookMsgBoxAll
    r""" hook all message box calls. revert to default with afHookMsgBoxClr"""
    afHookMsgBoxAllClr = _connect.IConnectIDE_afHookMsgBoxAllClr
    r""" revert from hooking all message box calls"""
    afHookMsgBoxMask = _connect.IConnectIDE_afHookMsgBoxMask
    r""" mask for Hook settings"""
    afiOPEN_Disconnect = _connect.IConnectIDE_afiOPEN_Disconnect
    r""" disconnect the iOPEN interface. Equivalent to winIDEA/Tools/Disconnect"""
    afiOPEN_Mask = _connect.IConnectIDE_afiOPEN_Mask
    r""" mask for iOPEN settings"""
    __swig_destroy__ = _connect.delete_IConnectIDE

# Register IConnectIDE in _connect:
_connect.IConnectIDE_swigregister(IConnectIDE)

class IConnectDebug(object):
    r"""
    The IConnectDebug interface provides access to debug functions
    exported by winIDEA.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetInfo = _connect.IConnectDebug_ndxGetInfo
    ndxGetAddress = _connect.IConnectDebug_ndxGetAddress
    ndxGetSymbol = _connect.IConnectDebug_ndxGetSymbol
    ndxGetSourceAddress = _connect.IConnectDebug_ndxGetSourceAddress
    ndxGetAddressSource = _connect.IConnectDebug_ndxGetAddressSource
    ndxReadMemory = _connect.IConnectDebug_ndxReadMemory
    ndxWriteMemory = _connect.IConnectDebug_ndxWriteMemory
    ndxReadRegister = _connect.IConnectDebug_ndxReadRegister
    ndxWriteRegister = _connect.IConnectDebug_ndxWriteRegister
    ndxReadValue = _connect.IConnectDebug_ndxReadValue
    ndxWriteValue = _connect.IConnectDebug_ndxWriteValue
    ndxEvaluate = _connect.IConnectDebug_ndxEvaluate
    ndxModify = _connect.IConnectDebug_ndxModify
    ndxGetStatus = _connect.IConnectDebug_ndxGetStatus
    ndxSetBreakpoint = _connect.IConnectDebug_ndxSetBreakpoint
    ndxRunControl = _connect.IConnectDebug_ndxRunControl
    ndxNum = _connect.IConnectDebug_ndxNum
    fMonitor = _connect.IConnectDebug_fMonitor
    r""" Use regular memory access"""
    fRealTime = _connect.IConnectDebug_fRealTime
    r""" Use real time access"""
    fMemMask = _connect.IConnectDebug_fMemMask
    r""" mask for fMonitor and fRealTime values"""
    fCore = _connect.IConnectDebug_fCore
    r""" CPU core register or memory access"""
    fSFR = _connect.IConnectDebug_fSFR
    r"""
    Special function register, used only in ReadRegister()
    and WriteRegister(), ignored in other functions
    """
    fSoC = _connect.IConnectDebug_fSoC
    r""" SoC bus access, memory area is the bus index to access"""
    fModule = _connect.IConnectDebug_fModule
    r""" SoC module access, memory area is the module index to access"""
    fRegMask = _connect.IConnectDebug_fRegMask
    fCacheNever = _connect.IConnectDebug_fCacheNever
    r""" do not cache the access"""
    fCacheDefault = _connect.IConnectDebug_fCacheDefault
    r""" cache according to server settings"""
    fCacheStop = _connect.IConnectDebug_fCacheStop
    r""" cache while the CPU is stopped"""
    fCacheCode = _connect.IConnectDebug_fCacheCode
    r""" get code from cached download"""
    fCacheMask = _connect.IConnectDebug_fCacheMask
    r""" mask for **fCacheXXX** values"""
    fNoRefresh = _connect.IConnectDebug_fNoRefresh
    r""" do not refresh winIDEA GUI after write operation"""
    fDirect = _connect.IConnectDebug_fDirect
    r""" access memory directly, bypass any programmable devices"""
    fAccessFlagsMask = _connect.IConnectDebug_fAccessFlagsMask
    r""" higher bits used by individual functions specifically"""
    gafExpression = _connect.IConnectDebug_gafExpression
    r"""
    No enumeration, address of any
    L-value expression can be retrieved
    """
    gafVariables = _connect.IConnectDebug_gafVariables
    r""" enum variables (data objects)"""
    gafLabels = _connect.IConnectDebug_gafLabels
    r""" enum global code labels"""
    gafFunctions = _connect.IConnectDebug_gafFunctions
    r""" enum function objects"""
    gafEnumMask = _connect.IConnectDebug_gafEnumMask
    r""" mask for **gafXXX** values"""
    gafEnumIndexMask = _connect.IConnectDebug_gafEnumIndexMask
    r"""
    mask for enum index. Set this, if there
    is more than one symbol with the same name
    """
    gafEnumIndexOfs = _connect.IConnectDebug_gafEnumIndexOfs
    r"""
    bit offset of the enum index, can be used as
    shift count.
    """
    gafType2 = _connect.IConnectDebug_gafType2
    r""" valid only with gafExpression, if set pType is interpreted as SType2"""
    gafUseFile = _connect.IConnectDebug_gafUseFile
    r""" enum specific partition only"""
    gafFileMask = _connect.IConnectDebug_gafFileMask
    r""" which partition to use"""
    gafFileOfs = _connect.IConnectDebug_gafFileOfs
    r""" bit offset of the partition"""
    efDefaultMemAreaDisplay = _connect.IConnectDebug_efDefaultMemAreaDisplay
    r""" if set, setting in winIDEA is used for mem area display"""
    efNoMemAreaDisplay = _connect.IConnectDebug_efNoMemAreaDisplay
    r"""
    if set, memory area is not displayed with pointers and
    addresses. It changed from 0x01000000 to 0x01000100, eventually 0x00000100
    """
    efVagueFloatEqual = _connect.IConnectDebug_efVagueFloatEqual
    r""" if vague, 1e-5 tolerance is considered equal"""
    efIgnorePointerAssignType = _connect.IConnectDebug_efIgnorePointerAssignType
    r""" if set, pointer type compatibility is not checked on assignements to pointer type"""
    efType2 = _connect.IConnectDebug_efType2
    r""" if set pType is interpreted as SType2"""
    efAllowTernaryOperator = _connect.IConnectDebug_efAllowTernaryOperator
    r""" the ? and : are valid in expression"""

    def GetAddress(self, dwGetAddressFlags: "DWORD", pszExpression: "LPCSTR", pbyMemArea: "BYTE *", paAddress: "uint32_t *", paSizeMAUs: "uint32_t *", pType: "SType") -> "unsigned long":
        r"""
        Returns address and size of an object, like a global symbol,
        function, etc.

        :rtype: int
        :return: 
            - ICONNECT_E_CAN_NOT_ACCESS - Evaluation required a memory access which
              could not be performed.
            - ICONNECT_E_BAD_ID - Expression could not be evaluated
            - S_FALSE - File or enum index out of range

        :type dwGetAddressFlags: int
        :param dwGetAddressFlags:

            | 31 | 30-24 | 23-16 | 15-12 | 11-8 | 7-0
            |-

            | Use File | File Index | Enum Index | Enum Source
            | Reserved SBZ | EAccessFlags
            |

            - **EAccessFlags** used if required to resolve the expression.
              See IConnectDebug::EAccessFlags.
            - **Enum Source** - see IConnectDebug::EGetAddressFlags, **gafXXX** flags
            - **Enum Index** - Index of the enumerated symbol to return.
            - **File index** - Index of the symbol (download) file to use. Used only
              if **Use File** flag is set.

        :type paSizeMAUs: int
        :param paSizeMAUs: Pointer to an ADDRESS type variable that
             will receive the size of the object. Pointer to an ADDRESS type variable that
             will receive the address of the object. Pointer to a BYTE type variable that will
             receive the memory area of the object. An expression that describes
             a location in memory (an L-value).
             If symbol enumeration is used,
             the name of the global symbol.
        :type pType: :py:class:`SType`
        :param pType: Pointer to a SType type variable that
             will receive the type of the object.
        """
        return _connect.IConnectDebug_GetAddress(self, dwGetAddressFlags, pszExpression, pbyMemArea, paAddress, paSizeMAUs, pType)
    sVariables = _connect.IConnectDebug_sVariables
    r""" Global variables (data objects)"""
    sLabels = _connect.IConnectDebug_sLabels
    r""" Global code labels"""
    sFunctions = _connect.IConnectDebug_sFunctions
    r""" High level functions"""
    sLines = _connect.IConnectDebug_sLines
    r""" Source lines"""
    sConstants = _connect.IConnectDebug_sConstants
    r""" Global constants"""
    sSourceCode = _connect.IConnectDebug_sSourceCode
    r""" Source line text"""
    sScopeExact = _connect.IConnectDebug_sScopeExact
    r""" return symbol whose starting address matches aAddress exactly"""
    sScopeNarrow = _connect.IConnectDebug_sScopeNarrow
    r""" return symbol which spans over aAddress. For structured types or arrays the narrow scope is returned, e.g. A.B[3].C"""
    sScopeWide = _connect.IConnectDebug_sScopeWide
    r""" return symbol which spans over aAddress. For structured types or arrays the wide scope is returned, e.g. A"""
    sScopeMask = _connect.IConnectDebug_sScopeMask

    def GetSymbol(self, dwSymbolFlags: "DWORD", byMemArea: "BYTE", aAddress: "uint32_t", pszName: "LPSTR", dwNameLen: "DWORD") -> "unsigned long":
        r"""
        Returns the name of the symbol on the specified address.

        :rtype: int
        :return: S_FALSE - No symbol on the specified
                    address. **pszName** is set to empty string.

        :type pszName: string
        :param pszName: Pointer to a char buffer that will
             receive the name of the symbol. Address of the object. Memory area of the object. Specifies symbol classes to consider.
             See IConnectDebug::ESymbolFlags
        :type dwNameLen: int
        :param dwNameLen: Length of the **pszName** buffer.
        """
        return _connect.IConnectDebug_GetSymbol(self, dwSymbolFlags, byMemArea, aAddress, pszName, dwNameLen)
    sExact = _connect.IConnectDebug_sExact
    r""" match address or line position exactly"""
    sAbsolutePath = _connect.IConnectDebug_sAbsolutePath
    r""" pszFileName in absolute path"""
    sReportSize = _connect.IConnectDebug_sReportSize
    r""" for GetSourceAddress function. If specified address and size are reported for every location"""

    def GetSourceAddress(self, dwSourceFlags: "DWORD", pszFileName: "LPCSTR", dwLine: "DWORD", paAddress: "uint32_t *", pdwNumAddresses: "DWORD *") -> "unsigned long":
        r"""
        Returns the address(es) of a source line.

        :rtype: int
        :return: S_FALSE - Address for the given source line not found.

        :type paAddress: int
        :param paAddress: Pointer to an array of ADDRESS
             type variables that will receive
             the addresses to which the source
             line translates. Line number. Name of the file. IConnectDebug::ESourceFlags.
        :type pdwNumAddresses: int
        :param pdwNumAddresses: Points to a DWORD type variable that:
             - on input specifies the size of the paAddresses array,
             - on output, the number of entries placed into the
               paAddresses array.
        """
        return _connect.IConnectDebug_GetSourceAddress(self, dwSourceFlags, pszFileName, dwLine, paAddress, pdwNumAddresses)

    def GetAddressSource(self, dwSourceFlags: "DWORD", aAddress: "uint32_t", pszFileName: "LPSTR", dwFileNameLen: "DWORD", pdwLine: "DWORD *") -> "unsigned long":
        r"""
        Returns the source (line number and file name) matching to an address.

        :rtype: int
        :return: S_FALSE - Source line not found for the specified address

        :type dwFileNameLen: int
        :param dwFileNameLen: Length of the array pointed to
             by **pszFileName**. Pointer to char array buffer
             that will receive the file name. See IConnectDebug::ESourceFlags.
        :type pdwLine: int
        :param pdwLine: Pointer to DWORD type variable
             that will receive the line number.
        """
        return _connect.IConnectDebug_GetAddressSource(self, dwSourceFlags, aAddress, pszFileName, dwFileNameLen, pdwLine)

    def ReadMemory(self, dwAccessFlags: "DWORD", byMemArea: "BYTE", aAddress: "uint32_t", aNumMAUs: "uint32_t", pbyBuf: "BYTE *", byBytesPerMAU: "BYTE", pbyAccessInfo: "BYTE *") -> "unsigned long":
        r"""
        Reads memory from the target system.

        :rtype: int
        :return: 
            - ICONNECT_E_CAN_NOT_ACCESS - Memory can not be accessed. This can be caused
              by bad memory area specification, out of range address, unavailability of
              the requested access mode (real-time) or the CPU is not in a mode that allows
              memory access.
            - ICONNECT_E_SIZE - The byBytesPerMAU value is incorrect for the specified
              memory area.

        :type byBytesPerMAU: BYTE
        :param byBytesPerMAU: Number of BYTE type locations required to
              fit one MAU (memory addressable unit). The number of bytes
              required for every MAU is:


              | MAU Size | Bytes Required per MAU|
          ------------------------------------
          | 1 - 8    | 1  |
          | 9 - 16   | 2  |
          | 17 - 32  | 4  |


          winIDEA will check this parameter and return ICONNECT_E_SIZE in
          case of mismatch.

        :type pbyBuf: BYTE
        :param pbyBuf: The buffer to receive the read out data. Note that
              for memory areas with MAU size other than 8 bits (PIC Program,
              ARM CP, etc), the pbyBuf must be large enough to accommodate all
              data. Data is placed in consecutive locations in the buffer,
              i.e. the MAU from aAddress is placed first, MAU from aAddress+1
              is placed next etc.

          Within a MAU the byte ordering is LSB. For the 14 bit
          maProgramPIC16XX area a read from address 10 would yield the
          following format:


              ADDR = 10              ADDR = 11               ADDR = 12
          ====================   =====================   ====================
          (7-0)      xx(13-8)    (7-0)       xx(13-8)    (7-0)      xx(13-8)
          pbyBuf[0]  pbyBuf[1]   pbyBuf[2]   pbyBuf[3]   pbyBuf[4]  pbyBuf[5]



        :type byBytesPerMAU: BYTE
        :param byBytesPerMAU: Number of MAUs (memory addressable units)
             to read. Address of the memory location of the
             first access. Memory space. Definitions for individual
             CPUs are provided in MemArea.h Use IConnectDebug::EAccessFlags
        :type pbyAccessInfo: BYTE
        :param pbyAccessInfo: The buffer to receive information about
             access to every individual location.
             One byte must be allocated per MAU. If
             this parameter is NULL, no access
             information will be returned.
        """
        return _connect.IConnectDebug_ReadMemory(self, dwAccessFlags, byMemArea, aAddress, aNumMAUs, pbyBuf, byBytesPerMAU, pbyAccessInfo)

    def WriteMemory(self, dwAccessFlags: "DWORD", byMemArea: "BYTE", aAddress: "uint32_t", aNumMAUs: "uint32_t", pbyBuf: "BYTE const *", byBytesPerMAU: "BYTE", pbyAccessInfo: "BYTE *") -> "unsigned long":
        r"""
        Writes memory to the target system.

        :rtype: int
        :return: 
            - ICONNECT_E_CAN_NOT_ACCESS - Memory can not be accessed. This can be caused
              by bad memory area specification, out of range address, unavailability of
              the requested access mode (real-time) or the CPU is not in a mode that allows
              memory access.
            - ICONNECT_E_SIZE - The byBytesPerMAU value is incorrect for the specified
              memory area.

        :type byBytesPerMAU: BYTE
        :param byBytesPerMAU: Number of BYTE type locations required to
              fit one MAU (memory addressable unit). The number of bytes
              required for every MAU is:


              | MAU Size | Bytes Required per MAU|
          ------------------------------------
          | 1 - 8    | 1  |
          | 9 - 16   | 2  |
          | 17 - 32  | 4  |


          winIDEA will check this parameter and return ICONNECT_E_SIZE in
          case of mismatch.
          If byBytesPerMAU==1 is requested on non-1 byte per MAU area and the requested aNumMAUs
          is a multiple of it, the request is accepted and processed

        :type pbyBuf: BYTE
        :param pbyBuf: The buffer to receive the read out data. Note that
              for memory areas with MAU size other than 8 bits (PowerPC SPR,
              ARM CP, etc), the pbyBuf must be large enough to accommodate all
              data. Data is placed in consecutive locations in the buffer,
              i.e. the MAU from aAddress is placed first, MAU from aAddress+1
              is placed next etc.

          Within a MAU the byte ordering is LSB.

        :type byBytesPerMAU: BYTE
        :param byBytesPerMAU: Number of MAUs (memory addressable units)
             to read. Address of the memory location of the
             first access. Memory space. Definitions for individual
             CPUs are provided in MemArea.h Use IConnectDebug::EAccessFlags, except
             **fCacheXXX**.
        :type pbyAccessInfo: BYTE
        :param pbyAccessInfo: The buffer to receive information about
             access to every individual location.
             One byte must be allocated per MAU. If
             this parameter is NULL, no access
             information will be returned.
        """
        return _connect.IConnectDebug_WriteMemory(self, dwAccessFlags, byMemArea, aAddress, aNumMAUs, pbyBuf, byBytesPerMAU, pbyAccessInfo)

    def ReadRegister(self, dwAccessFlags: "DWORD", pszRegisterName: "LPCSTR", pValue: "SValue", pType: "SType") -> "unsigned long":
        r"""
        Reads the specified register.

        :rtype: int
        :return: 
            - ICONNECT_E_BAD_ID - The specified register does not exist.
            - ICONNECT_E_SIZE - The specified register is to long to fit SValue.
            - ICONNECT_E_CAN_NOT_ACCESS - The register can not be accessed in the current CPU
              mode.

        :type pValue: :py:class:`SValue`
        :param pValue: Pointer to a SValue type
             variable that will receive the
             value. Name of the register to read. See IConnectDebug::EAccessFlags
             for available flags, except
             **fCacheCode**
        :type pType: :py:class:`SType`
        :param pType: Contains the type info
             of pValue.
        """
        return _connect.IConnectDebug_ReadRegister(self, dwAccessFlags, pszRegisterName, pValue, pType)

    def WriteRegister(self, dwAccessFlags: "DWORD", pszRegisterName: "LPCSTR", pValue: "SValue", pType: "SType") -> "unsigned long":
        r"""
        Writes the specified register.

        :rtype: int
        :return: 
            - ICONNECT_E_BAD_ID - The specified register does not exist.
            - ICONNECT_S_SIZE - The specified value is to long to fit register.
            - ICONNECT_E_CAN_NOT_ACCESS - The register can not be accessed in the current CPU
              mode.

        :type pValue: :py:class:`SValue`
        :param pValue: Stores a value to be written
             to the register. Name of the register to write to. See IConnectDebug::EAccessFlags
             for available flags, except
             **fCacheCode**
        :type pType: :py:class:`SType`
        :param pType: Contains the type info
             of pValue.
        """
        return _connect.IConnectDebug_WriteRegister(self, dwAccessFlags, pszRegisterName, pValue, pType)

    def ReadValue(self, dwAccessFlags: "DWORD", byMemArea: "BYTE", aAddress: "uint32_t", pValue: "SValue", pType: "SType") -> "unsigned long":
        r"""
        Reads a value from the target system. This function resembles
        ReadMemory but additionally it formats the value according to the
        type specified (including endian conversions).

        :rtype: int
        :return: S_FALSE - symbol not found

        :type pValue: :py:class:`SValue`
        :param pValue: Pointer to a SValue type variable
             that will receive the value. Address of the memory location of the
             first access. Memory space. Definitions for individual
             CPUs are provided in MemArea.h Use IConnectDebug::EAccessFlags, except
             **fCore**, and **fSFR**.
        :type pType: :py:class:`SType`
        :param pType: Pointer to a SType type variable
             containing the type info of pValue.
        """
        return _connect.IConnectDebug_ReadValue(self, dwAccessFlags, byMemArea, aAddress, pValue, pType)

    def WriteValue(self, dwAccessFlags: "DWORD", byMemArea: "BYTE", aAddress: "uint32_t", pValue: "SValue", pType: "SType") -> "unsigned long":
        r"""
        Writes a value to the target system. This function resembles
        WriteMemory but additionally it formats the value according to
        the type specified (including endian conversions).

        :type pValue: :py:class:`SValue`
        :param pValue: Pointer to a SValue type variable
             containing the value to write. Address of the memory location of the
             first access. Memory space. Definitions for individual
             CPUs are provided in MemArea.h Use IConnectDebug::EAccessFlags, except
             **fCore**, **fSFR**, and
             **fCacheXXX**.
        :type pType: :py:class:`SType`
        :param pType: Pointer to a SType type variable
             containing the type info of pValue.
        """
        return _connect.IConnectDebug_WriteValue(self, dwAccessFlags, byMemArea, aAddress, pValue, pType)

    def Evaluate(self, dwAccessFlags: "DWORD", pszExpression: "LPCSTR", pszResult: "LPSTR", dwResultLen: "DWORD", pValue: "SValue", pType: "SType") -> "unsigned long":
        r"""
        Evaluates an expression. Result is placed in **pszResult**
        and/or **pValue/pType**

        :rtype: int
        :return: 
            - ICONNECT_E_CAN_NOT_ACCESS - Evaluation of the expression
                  required memory access which could not be performed.
            - ICONNECT_E_BAD_ID  - Expression could not be evaluated

        :type pValue: :py:class:`SValue`
        :param pValue: Pointer to a SValue type variable that
             will receive the value. If this
             parameter is NULL no simple type value
             is returned. If this parameter is non
             NULL and the pszExpression doesn't
             evaluate to a simple type, the function
             will fail. See IConnectDebug::SValue Length of the pszResult buffer. Pointer to a char buffer that
             will receive the result of the
             evaluation. If this parameter is
             NULL no string value is returned. Any C syntax expression. Use IConnectDebug::EAccessFlags and
             IConnectDebug::EEvaluate flags.
             IConnectDebug::EAccessFlags determine
             what kind of memory access is permitted
             if required to resolve the expression,
             while IConnectDebug::EEvaluate flags
             define result format.
        :type pType: :py:class:`SType`
        :param pType: Pointer to a variable that will receive
             the type.
        """
        return _connect.IConnectDebug_Evaluate(self, dwAccessFlags, pszExpression, pszResult, dwResultLen, pValue, pType)
    mfModifyToResult = _connect.IConnectDebug_mfModifyToResult
    r""" if set, pValue and pType are ignored, pszResult must specify the new value"""
    mfModifyNoReadBack = _connect.IConnectDebug_mfModifyNoReadBack
    r""" if set, read-back of the new value is not performed"""

    def Modify(self, dwModifyFlags: "DWORD", pszExpression: "LPCSTR", pszResult: "LPSTR", dwResultLen: "DWORD", pValue: "SValue", pType: "SType") -> "unsigned long":
        r"""
        Modifies **pszExpression** to **pValue** or **pszResult**, if
        **mfModifyToResult** is set. Result is returned in **pszResult** unless NULL
        or 0 == dwResultLen. The expression must evaluate to a *lvalue*.

        **Example 1:**

        To set the value of **iCounter** to 42, we can use **pValue** parameter:

        SValue valueData;
        SType valueType;
        valueData.m_INT16 = 42;
        valueType.m_byType = SType::tSigned;
        valueType.m_byBitSize = 16;

        Modify(IConnectDebug::fMonitor, "iCounter", NULL, 0, &valueData, &valueType);


        **Example 2:**

        To modify **counters[3]** according to the following statement:
          counters[3] = counters[0] + counters[1];
        we can set the following:

          pszExpression = "counters[3]";
          pszResult = "counters[0] + counters[1]";



        :rtype: int
        :return: 
            - ICONNECT_E_CAN_NOT_ACCESS - Evaluation of the expression
              required memory access which could not be performed.
            - ICONNECT_E_BAD_ID - Expression could not be evaluated

        :type pValue: :py:class:`SValue`
        :param pValue: Pointer to a SValue type variable
             containing the value to write to
             **pszExpression**. This parameter is not
             used if **mfModifyToResult** flag is used. Maximum length of the pszResult buffer returned.
             This value can be zero, even when
             **pszResult** is non-NULL (used with the
             **mfModifyToResult** flag) Pointer to a char buffer that will
             receive the result of the evaluation. If
             this parameter is NULL no string value is
             returned. In case of an error, the
             **pszResult** will contain the error string. Any C syntax expression that evaluates
             to a lvalue. Same as Evaluate with addition of
             **mfModifyToResult**. If set, pValue
               and pType are ignored, pszResult must
               specify the new value
        :type pType: :py:class:`SType`
        :param pType: Pointer to a SType type variable
             containing the type info of **pValue**. This
             parameter is not used if **mfModifyToResult**
             flag is used.
        """
        return _connect.IConnectDebug_Modify(self, dwModifyFlags, pszExpression, pszResult, dwResultLen, pValue, pType)
    tCPU = _connect.IConnectDebug_tCPU
    r""" Status of the CPU"""
    tMask = _connect.IConnectDebug_tMask
    r""" mask for **tXXX** values"""
    rCurrent = _connect.IConnectDebug_rCurrent
    r""" last status obtained by winIDEA"""
    rRefresh = _connect.IConnectDebug_rRefresh
    r""" status refresh is forced"""
    rMask = _connect.IConnectDebug_rMask
    r""" mask for **rXXX** values"""
    sWantStopReason = _connect.IConnectDebug_sWantStopReason
    r""" report stop reason in m_byStatus"""
    bAddress = _connect.IConnectDebug_bAddress
    r""" Use the aAddress as breakpoint address"""
    bSymbol = _connect.IConnectDebug_bSymbol
    r""" Use the pszAddress as breakpoint address"""
    bSource = _connect.IConnectDebug_bSource
    r""" Use the pszAddress and dwLine as breakpoint address"""
    bAddrMask = _connect.IConnectDebug_bAddrMask
    r""" mask for address type values"""
    bHW = _connect.IConnectDebug_bHW
    r"""
    it's a HW BP (set/enable/disable apply)
    if bSet is used, the bHW_XXXX flags are considered
    """
    bSet = _connect.IConnectDebug_bSet
    r""" Set a breakpoint"""
    bClear = _connect.IConnectDebug_bClear
    r""" Clear a breakpoint"""
    bEnable = _connect.IConnectDebug_bEnable
    r""" Enable a breakpoint"""
    bDisable = _connect.IConnectDebug_bDisable
    r""" Disable a breakpoint"""
    bAll = _connect.IConnectDebug_bAll
    r"""
    Use in combination with bClear, bDisable, bEnable and
    bReapply. When used, it applies to all configured
    breakpoints.
    """
    bReapply = _connect.IConnectDebug_bReapply
    r""" reapplies BP if it is active currently"""
    bSetMask = _connect.IConnectDebug_bSetMask
    r""" mask for breakpoint action values"""
    bHW_accAny = _connect.IConnectDebug_bHW_accAny
    r""" any access to the symbol/address"""
    bHW_accRD = _connect.IConnectDebug_bHW_accRD
    r""" read access to the symbol/address"""
    bHW_accWR = _connect.IConnectDebug_bHW_accWR
    r""" write access to the symbol/address"""
    bHW_accRW = _connect.IConnectDebug_bHW_accRW
    r""" read or write access to the symbol/address"""
    bHW_accFetch = _connect.IConnectDebug_bHW_accFetch
    r""" instruction fetch from the symbol/address"""
    bHW_accMask = _connect.IConnectDebug_bHW_accMask
    r""" mask to extract access"""
    bHW_EntireObject = _connect.IConnectDebug_bHW_EntireObject
    r""" cover entire object specified in symbol"""
    bHW_SizeDefault = _connect.IConnectDebug_bHW_SizeDefault
    r""" default access size"""
    bHW_Size1 = _connect.IConnectDebug_bHW_Size1
    r""" access size is 1 MAU"""
    bHW_Size2 = _connect.IConnectDebug_bHW_Size2
    r""" access size is 2 MAU"""
    bHW_Size4 = _connect.IConnectDebug_bHW_Size4
    r""" access size is 4 MAU"""
    bHW_Size8 = _connect.IConnectDebug_bHW_Size8
    r""" access size is 8 MAU"""
    bHW_SizeMask = _connect.IConnectDebug_bHW_SizeMask
    r""" mask to extract access size"""
    bHW_DataMask = _connect.IConnectDebug_bHW_DataMask
    r""" data mask - the bits set determine which byte of dwLine is used for data value comparison (00 = no data, FF = all)"""
    bHW_DataLSB0 = _connect.IConnectDebug_bHW_DataLSB0
    r""" LSB0 data byte is considered"""
    bHW_DataLSB1 = _connect.IConnectDebug_bHW_DataLSB1
    r""" LSB1 data byte is considered"""
    bHW_DataLSB2 = _connect.IConnectDebug_bHW_DataLSB2
    r""" LSB2 data byte is considered"""
    bHW_DataLSB3 = _connect.IConnectDebug_bHW_DataLSB3
    r""" LSB3 data byte is considered"""
    bHW_DataLSB4 = _connect.IConnectDebug_bHW_DataLSB4
    r""" LSB4 data byte is considered"""
    bHW_DataLSB5 = _connect.IConnectDebug_bHW_DataLSB5
    r""" LSB5 data byte is considered"""
    bHW_DataLSB6 = _connect.IConnectDebug_bHW_DataLSB6
    r""" LSB6 data byte is considered"""
    bHW_DataLSB7 = _connect.IConnectDebug_bHW_DataLSB7
    r""" LSB7 data byte is considered"""

    def SetBreakpoint(self, dwBreakpointFlags: "DWORD", byMemArea: "BYTE", aAddress: "uint32_t", pszAddress: "LPCSTR", dwLine: "DWORD") -> "unsigned long":
        r"""
        Controls breakpoint setting.

        :rtype: int
        :return: 
            - S_FALSE - Breakpoint could not be set - probably already exists.
            - ICONNECT_E_BAD_ID - The pszAddress does not evaluate to a location.
            - ICONNECT_E_ERROR - Breakpoint could not be set.
            - ICONNECT_E_NO_BREAKPOINT - No breakpoint was found at the specified address.

        :type pszAddress: string
        :param pszAddress: Determines the address of the breakpoint:
             - If **bSymbol** flag is
               used this string is interpreted as a
               symbol (function name, code label).
             - If **bSource** flag is used, this
               string is interpreted as file name. Determines the address of the
             breakpoint. This value is used only if
             **bAddress** flag is used. Determines the address space of the
             breakpoint. This value is used only if
             **bAddress** flag is used. Determines the breakpoint
             operation. See
             IConnectDebug::EBreakpointFlags
        :type dwLine: int
        :param dwLine: If **bSource** flag is used, **dwLine**
             specifies the line number.
             If **bHW** flag is used, **dwLine**
             specifies the access data value
        """
        return _connect.IConnectDebug_SetBreakpoint(self, dwBreakpointFlags, byMemArea, aAddress, pszAddress, dwLine)
    rNothing = _connect.IConnectDebug_rNothing
    r""" do nothing"""
    rReset = _connect.IConnectDebug_rReset
    r""" Reset the CPU"""
    rResetAndRun = _connect.IConnectDebug_rResetAndRun
    r""" Reset the CPU, then runs immediately"""
    rDownload = _connect.IConnectDebug_rDownload
    r""" Download the executable"""
    rStop = _connect.IConnectDebug_rStop
    r""" Stop the CPU"""
    rRun = _connect.IConnectDebug_rRun
    r""" Run the CPU"""
    rStep = _connect.IConnectDebug_rStep
    r"""
    Execute a single step instruction or high level step
    depending on context
    """
    rStepOver = _connect.IConnectDebug_rStepOver
    r""" rStep, do not enter subroutine calls"""
    rStepInst = _connect.IConnectDebug_rStepInst
    r""" Execute a single instruction step"""
    rStepOverInst = _connect.IConnectDebug_rStepOverInst
    r""" rStepInst, do not enter subroutine calls"""
    rStepHigh = _connect.IConnectDebug_rStepHigh
    r""" Execute a high level step"""
    rStepOverHigh = _connect.IConnectDebug_rStepOverHigh
    r""" rStepHigh, do not enter function calls"""
    rRunUntil = _connect.IConnectDebug_rRunUntil
    r""" Run until aAddress"""
    rRunUntilReturn = _connect.IConnectDebug_rRunUntilReturn
    r""" Run until current function returns"""
    rGoto = _connect.IConnectDebug_rGoto
    r""" Preset execution point to aAddress"""
    rSnapshot = _connect.IConnectDebug_rSnapshot
    r""" refresh the IDE"""
    rVerify = _connect.IConnectDebug_rVerify
    r""" perform verify, S_OK/ICONNECT_E_ERROR/ICONNECT_E_NOT_AVAILABLE return"""
    rDownloadNoCode = _connect.IConnectDebug_rDownloadNoCode
    r""" Download without code - initialize target and load symbols"""
    rAttach = _connect.IConnectDebug_rAttach
    r""" hot-attach to the target"""
    rDetach = _connect.IConnectDebug_rDetach
    r""" hot-detach from the target"""
    rSlowRunOff = _connect.IConnectDebug_rSlowRunOff
    r""" switch slow run off. Return: S_OK on success, S_FALSE if already configured, E_NOTIMPL if not implemented, ICONNECT_E_NOT_AVAILABLE if changing is currently not available"""
    rSlowRunOn = _connect.IConnectDebug_rSlowRunOn
    r""" switch slow run on   Return: S_OK on success, S_FALSE if already configured, E_NOTIMPL if not implemented, ICONNECT_E_NOT_AVAILABLE if changing is currently not available"""
    rRunMask = _connect.IConnectDebug_rRunMask
    r""" mask for **rXXX** values"""
    rWaitForStop = _connect.IConnectDebug_rWaitForStop
    r""" wait for CPU to stop after the current command."""
    rWaitTimeout10s = _connect.IConnectDebug_rWaitTimeout10s
    r""" wait 10s for stop"""
    rWaitTimeout1s = _connect.IConnectDebug_rWaitTimeout1s
    r""" wait 1s for stop"""
    rWaitTimeout100s = _connect.IConnectDebug_rWaitTimeout100s
    r""" wait 100s for stop"""
    rWaitTimeoutInf = _connect.IConnectDebug_rWaitTimeoutInf
    r""" wait infinitely for stop"""
    rWaitTimeoutMask = _connect.IConnectDebug_rWaitTimeoutMask
    r""" mask for **rWaitTimeoutXXX** values"""
    rPollingOff = _connect.IConnectDebug_rPollingOff
    r""" disable periodic polling"""
    rPollingOn = _connect.IConnectDebug_rPollingOn
    r""" enable periodic polling (default)"""
    rPollingMask = _connect.IConnectDebug_rPollingMask
    r""" mask for **rPollingXXX** values"""
    rTristateOff = _connect.IConnectDebug_rTristateOff
    r""" switch tristate mode off (connect debugger to target)"""
    rTristateOn = _connect.IConnectDebug_rTristateOn
    r""" switch tristate mode on  (disconnect debugger from target)"""
    rTristateMask = _connect.IConnectDebug_rTristateMask
    r""" mask for **rTristateXXX** values"""
    rTargetHWConnectOff = _connect.IConnectDebug_rTargetHWConnectOff
    r""" physically disconnect from target"""
    rTargetHWConnectOn = _connect.IConnectDebug_rTargetHWConnectOn
    r""" physically connect to target"""
    rTargetHWConnectMask = _connect.IConnectDebug_rTargetHWConnectMask
    r""" mask for **rTargetHWConnectXXX** values"""

    def RunControl(self, dwRunControlFlags: "DWORD", byMemArea: "BYTE", aAddress: "uint32_t") -> "unsigned long":
        r"""
        Performs a run control operation. Note that
        **IConnectDebug::rRun**, **IConnectDebug::rRunUntil** and
        **IConnectDebug::rRunUntilReturn** functions are
        'non-blocking' - when they return the CPU might still be running.
        rWaitForStop flag yields blocking operation'. If the wait expires, ICONNECT_E_TIMEOUT is returned

        :rtype: int
        :return: ICONNECT_E_NOT_AVAILABLE - The requested operation is not available.
                    ICONNECT_E_TIMEOUT - wait expired

        :type byMemArea: BYTE
        :param byMemArea: Determines the address space of
             the breakpoint. Specifies which register domain
             to access. See
             IConnectDebug::ERunControlFlags
        :type aAddress: int
        :param aAddress: Address used by **IConnectDebug::rRunUntil**
             and **IConnectDebug::rGoto** commands.
        """
        return _connect.IConnectDebug_RunControl(self, dwRunControlFlags, byMemArea, aAddress)
    __swig_destroy__ = _connect.delete_IConnectDebug

# Register IConnectDebug in _connect:
_connect.IConnectDebug_swigregister(IConnectDebug)

class IConnectProfiler(object):
    r"""
    The IConnectProfiler interface provides access to real-time
    measurement functions exported by winIDEA.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetInfo = _connect.IConnectProfiler_ndxGetInfo
    ndxStartConfig = _connect.IConnectProfiler_ndxStartConfig
    ndxAddArea = _connect.IConnectProfiler_ndxAddArea
    ndxActivate = _connect.IConnectProfiler_ndxActivate
    ndxGetStatus = _connect.IConnectProfiler_ndxGetStatus
    ndxGetStatistics = _connect.IConnectProfiler_ndxGetStatistics
    ndxGetHistory = _connect.IConnectProfiler_ndxGetHistory
    ndxNum = _connect.IConnectProfiler_ndxNum
    cfTimeStampCycles = _connect.IConnectProfiler_cfTimeStampCycles
    cfTimeStampTime = _connect.IConnectProfiler_cfTimeStampTime
    r""" Default time resolution."""
    cfTimeStampM0 = _connect.IConnectProfiler_cfTimeStampM0
    r""" magnitude 0 - seconds level resolution"""
    cfTimeStampM1 = _connect.IConnectProfiler_cfTimeStampM1
    r""" magnitude 1 - 100 ms  level resolution"""
    cfTimeStampM2 = _connect.IConnectProfiler_cfTimeStampM2
    r""" magnitude 2 -  10 ms  level resolution"""
    cfTimeStampM3 = _connect.IConnectProfiler_cfTimeStampM3
    r""" magnitude 3 -   1 ms  level resolution"""
    cfTimeStampM4 = _connect.IConnectProfiler_cfTimeStampM4
    r""" magnitude 4 - 100 us  level resolution"""
    cfTimeStampM5 = _connect.IConnectProfiler_cfTimeStampM5
    r""" magnitude 5 -  10 us  level resolution"""
    cfTimeStampM6 = _connect.IConnectProfiler_cfTimeStampM6
    r""" magnitude 6 -   1 us  level resolution"""
    cfTimeStampM7 = _connect.IConnectProfiler_cfTimeStampM7
    r""" magnitude 7 - 100 ns  level resolution"""
    cfTimeStampM8 = _connect.IConnectProfiler_cfTimeStampM8
    r""" magnitude 8 -  10 ns  level resolution"""
    cfTimeStampM9 = _connect.IConnectProfiler_cfTimeStampM9
    r""" magnitude 9 -   1 ns  level resolution"""
    cfTimeStampMask = _connect.IConnectProfiler_cfTimeStampMask
    r""" mask for **cfXXX** values"""

    def StartConfig(self, dwStartConfigFlags: "DWORD", pStartingPoint: "SProfilerStartingPoint") -> "unsigned long":
        r"""
        Begins configuration for a new session of the profiler. Once a profiler is
        configured, it can be activated any number of times.

        :type dwStartConfigFlags: int
        :param dwStartConfigFlags: See IConnectProfiler::EConfigFlags,
             which define wanted resolution. The actual resolution selected
             depends on hardware.
        :type pStartingPoint: :py:class:`SProfilerStartingPoint`
        :param pStartingPoint: Specifies the condition that
             triggers the profiler after it
             has been activated.
        """
        return _connect.IConnectProfiler_StartConfig(self, dwStartConfigFlags, pStartingPoint)
    afValueTypeMask = _connect.IConnectProfiler_afValueTypeMask
    r""" lower 4 bits used as by EProfilerDataValueType"""
    afTypeFunction = _connect.IConnectProfiler_afTypeFunction
    r""" The (execution) area is a high level function"""
    afTypeRoutine = _connect.IConnectProfiler_afTypeRoutine
    r""" The (execution) area is a low level routine"""
    afTypeVariable = _connect.IConnectProfiler_afTypeVariable
    r""" The (data) area is variable specified by its name"""
    afTypeRegion = _connect.IConnectProfiler_afTypeRegion
    r"""
    The (data) area is a region of memory
    specified by address and size
    """
    afTypeSingleData = _connect.IConnectProfiler_afTypeSingleData
    r"""
    Area is the 'single data' (OTM style)
    object. if CPUs single data resource is
    configurable, byMemArea/aAddress and aSize
    should be specified
    """
    afTypeSingleData1 = _connect.IConnectProfiler_afTypeSingleData1
    r"""
    Area is the 'single data' 1 (IT<DQM style)
    object. Index is set in aAddress
    """
    afAreaMask = _connect.IConnectProfiler_afAreaMask
    r""" the mask"""
    afFunctionIncludeLines = _connect.IConnectProfiler_afFunctionIncludeLines
    r"""
    valid with afTypeFunction - includes
    function lines of the specified function
    """
    afDataTaskID = _connect.IConnectProfiler_afDataTaskID
    r"""
    valid with afTypeVariable, afTypeRegion,
    identifies that the specified area is the task
    ID object
    """
    afDataSingleData = _connect.IConnectProfiler_afDataSingleData
    r""" obsolete"""

    def AddArea(self, dwAreaFlags: "DWORD", pszName: "LPCSTR", byMemArea: "BYTE"=0, aAddress: "uint32_t"=0, aSize: "uint32_t"=0, dwNumExits: "DWORD"=0, paExits: "uint32_t *"=None) -> "unsigned long":
        r"""
        Adds an area to the current profiler configuration. When adding function, and it does
        not exist, error is NOT reported by this function, but when
        IConnectProfiler::Activate() is called.

        :rtype: int
        :return: ICONNECT_E_BAD_ID - The area could not be added. Either an area with that
            name already exists, or parameters are not valid.

        :type dwNumExits: int, optional
        :param dwNumExits: Specifies the number of exits for
             *afTypeRoutine*. Specifies the MAU size for
             *afTypeRegion*. Specifies the entry point for
             *afTypeRoutine* or starting address
             for *afTypeRegion*.
             for encoded *afTypeSingleData* it's the ID Specifies mem area for
             *afTypeRoutine* or starting address
             for *afTypeRegion*. Specifies the name of the area. For
             *afTypeFunction* and
             *afTypeVariable*, this name is used
             to obtain the address. For
             *afTypeRoutine* and
             *afTypeRegion* the name will be
             displayed in the profiler window. Specifies the location of a *DWORD*
             type variable that will accept the handle
             of the new area. This handle is
             subsequently used in calls to
             *GetStatistics* and
             *GetHistory*. see IConnectProfiler::EAreaFlags
        :type paExits: int, optional
        :param paExits: Points to an array of *ADDRESS* type
             objects, each specifying an exit point
             from *afTypeRoutine* object. The array
             must contain *dwNumExits* elements.
        """
        return _connect.IConnectProfiler_AddArea(self, dwAreaFlags, pszName, byMemArea, aAddress, aSize, dwNumExits, paExits)
    aStart = _connect.IConnectProfiler_aStart
    r""" Activates (arms) the profiler"""
    aStop = _connect.IConnectProfiler_aStop
    r"""
    Deactivates the profiler - note that the
    profiler deactivates automatically when the trace
    buffer is filled.
    """
    aStartStopMask = _connect.IConnectProfiler_aStartStopMask
    r""" mask for **XXX** values"""

    def Activate(self, dwActivateFlags: "DWORD") -> "unsigned long":
        r"""
        Activates or deactivates the profiler. When activating the profiler, the configured
        areas are evaluated at this time. Activation can fail if an area symbol does not
        evaluate or number of resulting monitoring points exceeds hardware capabilities.

        :rtype: int
        :return: ICONNECT_E_ERROR - The requested operation could not be performed. Either the
            configuration is invalid or the profiler is not available.
        :rtype: int
        :return: S_FALSE - Activate(aStop) was called but the profiler is not active

        :type dwActivateFlags: int
        :param dwActivateFlags: see IConnectProfiler::EActivateFlags
        """
        return _connect.IConnectProfiler_Activate(self, dwActivateFlags)
    gsfNumRecorded = _connect.IConnectProfiler_gsfNumRecorded
    r""" m_dwNumAvailable specifies the number of recorded samples"""
    gsfNumAnalyzed = _connect.IConnectProfiler_gsfNumAnalyzed
    r""" m_dwNumAvailable specifies the number of analyzed samples"""
    gsfNumMask = _connect.IConnectProfiler_gsfNumMask
    rfByHandle = _connect.IConnectProfiler_rfByHandle
    r"""
    retrieve data for the area specified by
    *dwHandle* only
    """
    rfAllAreas = _connect.IConnectProfiler_rfAllAreas
    r""" retrieve data for all areas"""
    rfFilterTask = _connect.IConnectProfiler_rfFilterTask
    r"""
    include only data within specified task; use
    with *rfByHandle* or *rfAllAreas*
    """
    rfFilterValue = _connect.IConnectProfiler_rfFilterValue
    r"""
    include data results for a specific value of a
    data area only; use with *rfByHandle*.
    """
    rfType0 = _connect.IConnectProfiler_rfType0
    r""" default formating of results"""
    rfType_Mask = _connect.IConnectProfiler_rfType_Mask
    r""" Mask for result type"""

    def GetHistory(self, dwResultFlags: "DWORD", dwHandle: "DWORD", dwTask: "DWORD", dwValue: "DWORD", dwHistoryBase: "DWORD", pdwNumHistories: "DWORD *", pHistories: "SProfilerHistory") -> "unsigned long":
        r"""
        Retrieves history of invocations for specified area(s).

        :type pdwNumHistories: int
        :param pdwNumHistories: On input, specifies the size of
             array *pHistories* points to
             (i.e. the maximum number of
             histories to retrieve). On output,
             specifies the number of histories
             placed into *pHistories*. Specifies the zero based offset of the
             history. Use this in consecutive calls to *GetHistory*:

             SProfilerHistory aHistories[0x100];
             for (DWORD dwHistoryBase = 0; ; )
             {
               DWORD dwNumHistories = 0x100;
               pIConnectProfiler->GetHistory(IConnectProfiler::rfAllAreas, 0, 0, 0,
                                             dwHistoryBase, &dwNumHistories, aHistories);
               if (0 == dwNumHistories)
                 break;
               ProcessHistories(dwNumHistories, aHistories);
               dwHistoryBase += dwNumHistories;
             }
              Data value for which the statistics
             should be retrieved. Used with
             *rfFilterValue*. Task ID for which the statistics
             should be retrieved; used with
             *rfFilterTask*. Handle of the area for which the
             statistics should be retrieved; used
             with *rfByHandle*. See IConnectProfiler::EResultFlags
        :type pHistories: :py:class:`SProfilerHistory`
        :param pHistories: Specifies the location of
             array of *SProfilerHistory*
             objects that will receive the
             history results.
        """
        return _connect.IConnectProfiler_GetHistory(self, dwResultFlags, dwHandle, dwTask, dwValue, dwHistoryBase, pdwNumHistories, pHistories)
    __swig_destroy__ = _connect.delete_IConnectProfiler

# Register IConnectProfiler in _connect:
_connect.IConnectProfiler_swigregister(IConnectProfiler)

class IConnectProfiler2(IConnectProfiler):
    r"""
    IConnectProfiler2 extends the IConnectProfiler with functions which obtain
    the list of result areas.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetResultInfo = _connect.IConnectProfiler2_ndxGetResultInfo
    ndxGetResultArea = _connect.IConnectProfiler2_ndxGetResultArea
    ndxNum = _connect.IConnectProfiler2_ndxNum
    grafByHandle = _connect.IConnectProfiler2_grafByHandle
    r""" return area info of the area specified in pResultAreaInfo->m_dwHandle"""
    grafByName = _connect.IConnectProfiler2_grafByName
    r""" return area info of the area specified in pResultAreaInfo->m_szName"""
    grafByAddress = _connect.IConnectProfiler2_grafByAddress
    r""" return area info of the area specified in pResultAreaInfo->m_aAddress"""
    grafByMask = _connect.IConnectProfiler2_grafByMask
    grafTypeExec = _connect.IConnectProfiler2_grafTypeExec
    r""" requesting exec area - for grafByAddressOnly"""
    grafTypeData = _connect.IConnectProfiler2_grafTypeData
    r""" requesting data area - for grafByAddressOnly"""
    grafTypeMask = _connect.IConnectProfiler2_grafTypeMask
    __swig_destroy__ = _connect.delete_IConnectProfiler2

# Register IConnectProfiler2 in _connect:
_connect.IConnectProfiler2_swigregister(IConnectProfiler2)
IID_IConnectProfiler2 = cvar.IID_IConnectProfiler2

class IConnectProject(object):
    r"""
    The IConnectProject interface provides access to build manager
    functions exported by winIDEA.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetInfo = _connect.IConnectProject_ndxGetInfo
    ndxOperation = _connect.IConnectProject_ndxOperation
    ndxGetStatus = _connect.IConnectProject_ndxGetStatus
    ndxOption = _connect.IConnectProject_ndxOption
    ndxNum = _connect.IConnectProject_ndxNum
    ofCustom = _connect.IConnectProject_ofCustom
    r""" run custom operation specified by pszOperation"""
    ofCompile = _connect.IConnectProject_ofCompile
    r"""
    compile the file specified by pszParameters (the file
    must be included in the active project)
    """
    ofLink = _connect.IConnectProject_ofLink
    r""" link the active project"""
    ofMake = _connect.IConnectProject_ofMake
    r""" make the active project"""
    ofBuild = _connect.IConnectProject_ofBuild
    r""" build the active project"""
    ofDependencies = _connect.IConnectProject_ofDependencies
    r""" update dependencies"""
    ofIsUpToDate = _connect.IConnectProject_ofIsUpToDate
    r""" returns S_OK if up to date, or S_FALSE otherwise"""
    ofSetTarget = _connect.IConnectProject_ofSetTarget
    r""" Set target to pszParameters"""
    ofExport = _connect.IConnectProject_ofExport
    r""" Export project configuration to file given in pszParameters"""
    ofImport = _connect.IConnectProject_ofImport
    r""" Import project configuration from file given in pszParameters"""
    ofStop = _connect.IConnectProject_ofStop
    r""" stop the current operation"""
    ofOperationMask = _connect.IConnectProject_ofOperationMask
    r""" mask for **ofXXX** values"""
    ofSuppressPostLinkActions = _connect.IConnectProject_ofSuppressPostLinkActions
    r""" do not perform any automatic post-link actions"""

    def Operation(self, dwOperationFlags: "DWORD", pszOperation: "LPCSTR", pszParameters: "LPCSTR") -> "unsigned long":
        r"""
        Invokes a build manager operation.

        :type dwOperationFlags: int
        :param dwOperationFlags: specifies the operation to execute. See
                   IConnectProject::EOperationFlags

        :type pszOperation: string
        :param pszOperation: Identifies the custom operation to
                   perform. The specified operation must be defined as custom
                   operation in winIDEA. This parameter is ignored if
                   *ofCustom* flag is not set.

        :type pszParameters: string
        :param pszParameters: specifies the additional parameters for the requested operation.

        :rtype: int
        :return: 
             - ICONNECT_E_NOT_AVAILABLE  - the requested operation is not available
             - ICONNECT_E_FILE_NOT_FOUND - the specified file is not a part of the active project
             - E_NOTIMPL - the requested operation is not implemented
        """
        return _connect.IConnectProject_Operation(self, dwOperationFlags, pszOperation, pszParameters)
    ofaGet = _connect.IConnectProject_ofaGet
    r""" retrieves an option value"""
    ofaEnum = _connect.IConnectProject_ofaEnum
    r"""
    enumerates project items, for example project files,
    include directories, etc. The lower 16
    bits of dwOptionFlags (ofaEnumIndexMask) should
    contain the index number of the option.
    If the index is larger than the entity size, the function
    will return S_FALSE.

    """
    ofaSet = _connect.IConnectProject_ofaSet
    r""" sets an option value"""
    ofaAdd = _connect.IConnectProject_ofaAdd
    r""" adds an option value (e.g. a project file)"""
    ofaRmv = _connect.IConnectProject_ofaRmv
    r""" removes an option (e.g. a project file)"""
    ofaMov = _connect.IConnectProject_ofaMov
    r"""
    Moves an option to a different location (e.g. move a
    project file to a different group)
    """
    ofaMask = _connect.IConnectProject_ofaMask
    r""" mask for **ofaXXX** values"""
    ofaRelativePaths = _connect.IConnectProject_ofaRelativePaths
    r""" return relative file paths"""
    ofaEnumIndexMask = _connect.IConnectProject_ofaEnumIndexMask
    r""" mask to use on index for ofaEnum"""

    def Option(self, dwOptionFlags: "DWORD", pszScope: "LPCSTR", pszOption: "LPCSTR", pszValue: "LPSTR", dwValueLen: "DWORD") -> "unsigned long":
        r"""
        Sets or retrieves a build manager configuration option.

        For description of parameters, see CProjectController.
        """
        return _connect.IConnectProject_Option(self, dwOptionFlags, pszScope, pszOption, pszValue, dwValueLen)
    __swig_destroy__ = _connect.delete_IConnectProject

# Register IConnectProject in _connect:
_connect.IConnectProject_swigregister(IConnectProject)
IID_IConnectProject = cvar.IID_IConnectProject

class IConnectDebug2(IConnectDebug):
    r"""
    This interface extends debug functionality of IConnectDebug with some advanced
    operations.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetInfo2 = _connect.IConnectDebug2_ndxGetInfo2
    ndxBatchAccess = _connect.IConnectDebug2_ndxBatchAccess
    ndxWriteRunWaitRead = _connect.IConnectDebug2_ndxWriteRunWaitRead
    ndxDownload = _connect.IConnectDebug2_ndxDownload
    ndxCore = _connect.IConnectDebug2_ndxCore
    ndxSetBreakpointCond = _connect.IConnectDebug2_ndxSetBreakpointCond
    r""" set conditional breakpoint"""
    ndxCodeCacheOp = _connect.IConnectDebug2_ndxCodeCacheOp
    ndxStackUsage = _connect.IConnectDebug2_ndxStackUsage
    ndxGetAddress64 = _connect.IConnectDebug2_ndxGetAddress64
    ndxGetSymbol64 = _connect.IConnectDebug2_ndxGetSymbol64
    ndxGetSourceAddress64 = _connect.IConnectDebug2_ndxGetSourceAddress64
    ndxGetAddressSource64 = _connect.IConnectDebug2_ndxGetAddressSource64
    ndxReadMemory64 = _connect.IConnectDebug2_ndxReadMemory64
    ndxWriteMemory64 = _connect.IConnectDebug2_ndxWriteMemory64
    ndxReadValue64 = _connect.IConnectDebug2_ndxReadValue64
    ndxWriteValue64 = _connect.IConnectDebug2_ndxWriteValue64
    ndxGetStatus64 = _connect.IConnectDebug2_ndxGetStatus64
    ndxRunControl64 = _connect.IConnectDebug2_ndxRunControl64
    ndxSetBreakpointCond64 = _connect.IConnectDebug2_ndxSetBreakpointCond64
    r""" set conditional breakpoint"""
    ndxNum = _connect.IConnectDebug2_ndxNum

    def BatchAccess(self, dwBatchAccessFlags: "DWORD", pBatchAccessHeader: "SBatchAccessHeader", pBatchAccessItems: "SBatchAccessItem", pBatchAccessItemResults: "SBatchAccessItemResult") -> "unsigned long":
        r"""
        Performs multiple memory accesses, using deterministic delays.

        :type dwBatchAccessFlags: int
        :param dwBatchAccessFlags: see SBatchAccessHeader::EFlags, flags that
                                      start with prefix 'fl'
        :type pBatchAccessHeader: :py:class:`SBatchAccessHeader`
        :param pBatchAccessHeader: see SBatchAccessHeader
        :type pBatchAccessItems: :py:class:`SBatchAccessItem`
        :param pBatchAccessItems:  pointer to an array of items defining the type
                                      and time of an individual access. Size of
                                      array is given in ``pBatchAccessHeader-``>m_dwNumItems.

        :type pBatchAccessItemResults: :py:class:`SBatchAccessItemResult`
        :param pBatchAccessItemResults:  pointer to an array of objects that will
                                            receive the results of every individual
                                            access. Size of array is given
                                            in ``pBatchAccessHeader-``>m_dwNumItems.

        :rtype: int
        :return: 
                - E_NOTIMPL: Batch access is not implemented
                - E_FAIL: One of the accesses failed
                - S_FALSE: The specified time restrictions could not be kept
        """
        return _connect.IConnectDebug2_BatchAccess(self, dwBatchAccessFlags, pBatchAccessHeader, pBatchAccessItems, pBatchAccessItemResults)
    dIndexMask = _connect.IConnectDebug2_dIndexMask
    r""" lower 8 bits of dwDownloadFlags can be used as index into the list"""
    dActionMask = _connect.IConnectDebug2_dActionMask
    r""" mask for actions"""
    daDownload = _connect.IConnectDebug2_daDownload
    r""" download this file now"""
    daDLFromList = _connect.IConnectDebug2_daDLFromList
    r"""
    download an existing file from list. The file is
    identified by ``pszFileName``. if ``pszFileName`` is empty,
    lower 8 bits of ``dwDownloadFlags`` are used as
    index into the list. The file given in ``pszFileName``
    is compared to existing file names, and if match
    is not found, it is converted to abs. path and compared again.
    """
    daAddToList = _connect.IConnectDebug2_daAddToList
    r""" add a new DL file to the download file list"""
    daGet = _connect.IConnectDebug2_daGet
    r"""
    obtain info from the list. lower 8 bits of
    ``dwDownloadFlags`` are used as index into the list
    """
    daRemove = _connect.IConnectDebug2_daRemove
    r""" remove a file from the list. lower 8 bits of ``dwDownloadFlags`` are used as index into the list"""
    daRemoveAll = _connect.IConnectDebug2_daRemoveAll
    r""" remove all files from the list"""
    dListMask = _connect.IConnectDebug2_dListMask
    r""" mask for download list selection bits"""
    dListMain = _connect.IConnectDebug2_dListMain
    r""" use primary download list"""
    dListTarget = _connect.IConnectDebug2_dListTarget
    r""" use target download list"""
    dRealTime = _connect.IConnectDebug2_dRealTime
    r"""
    use real-time memory access to download. To be used
    with ``daDownload`` or ``daDLFromList`` flags.
    """
    dAbsolutePath = _connect.IConnectDebug2_dAbsolutePath
    r"""
    return absolute path in ``daGet``. With ``daAddToList``,
    the specified path is not converted into workspace
    relative path. Has no effect with other flags.
    """
    cLaunch = _connect.IConnectDebug2_cLaunch
    r""" launch the instance for the specified core"""
    cPrimaryIs0 = _connect.IConnectDebug2_cPrimaryIs0
    r""" primary core index is given by byCore == 0"""

    def Core(self, dwCoreFlags: "DWORD", byCore: "BYTE", pszCoreID: "LPSTR", dwCoreIDLen: "DWORD") -> "unsigned long":
        return _connect.IConnectDebug2_Core(self, dwCoreFlags, byCore, pszCoreID, dwCoreIDLen)

    def SetBreakpointCond(self, dwBreakpointFlags: "DWORD", byMemArea: "BYTE", aAddress: "uint32_t", pszAddress: "LPCSTR", dwLine: "DWORD", dwCondCount: "DWORD", pszCondExpression: "LPCSTR") -> "unsigned long":
        r"""
        Controls conditional breakpoint setting.

        :rtype: int
        :return: 
            - S_FALSE - Breakpoint could not be set - probably already exists.
            - ICONNECT_E_BAD_ID - The pszAddress does not evaluate to a location.
            - ICONNECT_E_ERROR - Breakpoint could not be set.
            - ICONNECT_E_NO_BREAKPOINT - No breakpoint was found at the specified address.

        :type dwCondCount: int
        :param dwCondCount: specifies the number of times the condition expression
             must be non-zero for BP to hit.
             if set to zero, the BP will hit on first occurrence If **bSource** flag is used, **dwLine**
             specifies the line number. Determines the address of the breakpoint:
             - If **bSymbol** flag is
               used this string is interpreted as a
               symbol (function name, code label).
             - If **bSource** flag is used, this
               string is interpreted as file name. Determines the address of the
             breakpoint. This value is used only if
             **bAddress** flag is used. Determines the address space of the
             breakpoint. This value is used only if
             **bAddress** flag is used. Determines the breakpoint
             operation. See
             IConnectDebug::EBreakpointFlags
        :type pszCondExpression: string
        :param pszCondExpression: the expression to evaluate on each hit
             if NULL or empty, only dwCondCount applies
        """
        return _connect.IConnectDebug2_SetBreakpointCond(self, dwBreakpointFlags, byMemArea, aAddress, pszAddress, dwLine, dwCondCount, pszCondExpression)
    ccOpRead = _connect.IConnectDebug2_ccOpRead
    r""" read from target. pICodeCache on entry specifies the regions to read"""
    ccOpWrite = _connect.IConnectDebug2_ccOpWrite
    r""" write to target"""
    ccOpLoad = _connect.IConnectDebug2_ccOpLoad
    r""" read from file"""
    ccOpSave = _connect.IConnectDebug2_ccOpSave
    r""" save to file"""
    ccOpGet = _connect.IConnectDebug2_ccOpGet
    r""" use source and return. if pszFileName is not empty, code for pszFileName is returned"""
    ccOpVerify = _connect.IConnectDebug2_ccOpVerify
    r""" perform download verify, return dif. if pszFileName is not empty, operation is performed only on it"""
    ccOpVerifySave = _connect.IConnectDebug2_ccOpVerifySave
    r""" same as ccOpVerify. The dif result is saved to file specified in pszParam"""
    ccOpMask = _connect.IConnectDebug2_ccOpMask
    r""" mask for operation"""
    ccSrcLoaded = _connect.IConnectDebug2_ccSrcLoaded
    r""" code put into target at download time"""
    ccSrcInFiles = _connect.IConnectDebug2_ccSrcInFiles
    r""" code contained in download files"""
    ccSrcFiltered = _connect.IConnectDebug2_ccSrcFiltered
    r""" code contained in download files, minus exclusions"""
    ccSrcMask = _connect.IConnectDebug2_ccSrcMask
    ccSaveFormatMotorolaS37 = _connect.IConnectDebug2_ccSaveFormatMotorolaS37
    r""" with ccOpSave operation, specifies Motorola S37 output"""
    ccSaveFormatIntelHex = _connect.IConnectDebug2_ccSaveFormatIntelHex
    r""" use Intel hex format"""
    ccSaveFormatBinary = _connect.IConnectDebug2_ccSaveFormatBinary
    r""" use binary format"""
    ccSaveFormatMask = _connect.IConnectDebug2_ccSaveFormatMask
    ccSaveBytes10 = _connect.IConnectDebug2_ccSaveBytes10
    r""" when saving save 0x10 bytes per line"""
    ccSaveBytes20 = _connect.IConnectDebug2_ccSaveBytes20
    r""" when saving save 0x20 bytes per line"""
    ccSaveBytes40 = _connect.IConnectDebug2_ccSaveBytes40
    r""" when saving save 0x40 bytes per line"""
    ccSaveBytes80 = _connect.IConnectDebug2_ccSaveBytes80
    r""" when saving save 0x80 bytes per line"""
    ccSaveBytesMask = _connect.IConnectDebug2_ccSaveBytesMask
    ccNoData = _connect.IConnectDebug2_ccNoData
    r""" for Load, GetLoaded, GetInFile operations - data is not required"""

    def GetAddress64(self, dwGetAddressFlags: "DWORD", pszExpression: "LPCSTR", pbyMemArea: "BYTE *", paAddress: "ADDRESS_64 *", paSizeMAUs: "ADDRESS_64 *", pType: "SType") -> "unsigned long":
        return _connect.IConnectDebug2_GetAddress64(self, dwGetAddressFlags, pszExpression, pbyMemArea, paAddress, paSizeMAUs, pType)

    def GetSymbol64(self, dwSymbolFlags: "DWORD", byMemArea: "BYTE", aAddress: "ADDRESS_64", pszName: "LPSTR", dwNameLen: "DWORD") -> "unsigned long":
        return _connect.IConnectDebug2_GetSymbol64(self, dwSymbolFlags, byMemArea, aAddress, pszName, dwNameLen)

    def GetSourceAddress64(self, dwSourceFlags: "DWORD", pszFileName: "LPCSTR", dwLine: "DWORD", paAddress: "ADDRESS_64 *", pdwNumAddresses: "DWORD *") -> "unsigned long":
        return _connect.IConnectDebug2_GetSourceAddress64(self, dwSourceFlags, pszFileName, dwLine, paAddress, pdwNumAddresses)

    def GetAddressSource64(self, dwSourceFlags: "DWORD", aAddress: "ADDRESS_64", pszFileName: "LPSTR", dwFileNameLen: "DWORD", pdwLine: "DWORD *") -> "unsigned long":
        return _connect.IConnectDebug2_GetAddressSource64(self, dwSourceFlags, aAddress, pszFileName, dwFileNameLen, pdwLine)

    def ReadMemory64(self, dwAccessFlags: "DWORD", byMemArea: "BYTE", aAddress: "ADDRESS_64", aNumMAUs: "ADDRESS_64", pbyBuf: "BYTE *", byBytesPerMAU: "BYTE", pbyAccessInfo: "BYTE *") -> "unsigned long":
        return _connect.IConnectDebug2_ReadMemory64(self, dwAccessFlags, byMemArea, aAddress, aNumMAUs, pbyBuf, byBytesPerMAU, pbyAccessInfo)

    def WriteMemory64(self, dwAccessFlags: "DWORD", byMemArea: "BYTE", aAddress: "ADDRESS_64", aNumMAUs: "ADDRESS_64", pbyBuf: "BYTE const *", byBytesPerMAU: "BYTE", pbyAccessInfo: "BYTE *") -> "unsigned long":
        return _connect.IConnectDebug2_WriteMemory64(self, dwAccessFlags, byMemArea, aAddress, aNumMAUs, pbyBuf, byBytesPerMAU, pbyAccessInfo)

    def ReadValue64(self, dwAccessFlags: "DWORD", byMemArea: "BYTE", aAddress: "ADDRESS_64", pValue: "SValue", pType: "SType") -> "unsigned long":
        return _connect.IConnectDebug2_ReadValue64(self, dwAccessFlags, byMemArea, aAddress, pValue, pType)

    def WriteValue64(self, dwAccessFlags: "DWORD", byMemArea: "BYTE", aAddress: "ADDRESS_64", pValue: "SValue", pType: "SType") -> "unsigned long":
        r"""
        Writes a value to the target system. This function resembles
        WriteMemory but additionally it formats the value according to
        the type specified (including endian conversions).

        :type pValue: :py:class:`SValue`
        :param pValue: Pointer to a SValue type variable
             containing the value to write. Address of the memory location of the
             first access. Memory space. Definitions for individual
             CPUs are provided in MemArea.h Use IConnectDebug::EAccessFlags, except
             **fCore**, **fSFR**, and
             **fCacheXXX**.
        :type pType: :py:class:`SType`
        :param pType: Pointer to a SType type variable
             containing the type info of pValue.
        """
        return _connect.IConnectDebug2_WriteValue64(self, dwAccessFlags, byMemArea, aAddress, pValue, pType)

    def RunControl64(self, dwRunControlFlags: "DWORD", byMemArea: "BYTE", aAddress: "ADDRESS_64") -> "unsigned long":
        r"""
        Obtains status of the CPU.

        :type byMemArea: BYTE
        :param byMemArea: Determines the address space of
             the breakpoint. Specifies which register domain
             to access. See
             IConnectDebug::ERunControlFlags
        :type aAddress: int
        :param aAddress: Address used by **IConnectDebug::rRunUntil**
             and **IConnectDebug::rGoto** commands.
        """
        return _connect.IConnectDebug2_RunControl64(self, dwRunControlFlags, byMemArea, aAddress)

    def SetBreakpointCond64(self, dwBreakpointFlags: "DWORD", byMemArea: "BYTE", aAddress: "ADDRESS_64", pszAddress: "LPCSTR", dwLine: "DWORD", dwCondCount: "DWORD", pszCondExpression: "LPCSTR") -> "unsigned long":
        return _connect.IConnectDebug2_SetBreakpointCond64(self, dwBreakpointFlags, byMemArea, aAddress, pszAddress, dwLine, dwCondCount, pszCondExpression)
    __swig_destroy__ = _connect.delete_IConnectDebug2

# Register IConnectDebug2 in _connect:
_connect.IConnectDebug2_swigregister(IConnectDebug2)

class IConnectIDE2(IConnectIDE):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxService = _connect.IConnectIDE2_ndxService
    ndxNum = _connect.IConnectIDE2_ndxNum
    sfiDebug = _connect.IConnectIDE2_sfiDebug
    sfiMask = _connect.IConnectIDE2_sfiMask
    sfOut1_TypeFlat = _connect.IConnectIDE2_sfOut1_TypeFlat
    r""" flat memory structure"""
    sfOut1_TypeIBuffer = _connect.IConnectIDE2_sfOut1_TypeIBuffer
    r""" pDataOut1 points to an IBuffer*, dwSizeOut1 is ignored SBZ, pdwSizeOut1Ret SB NULL"""
    sfOut1_TypeMask = _connect.IConnectIDE2_sfOut1_TypeMask
    r""" mask for Out1 type"""

    def Service(self, dwServiceFlags: "DWORD", rguidService: "GUID const &", dwSizeIn: "DWORD", pDataIn: "void const *", dwSizeOut: "DWORD", pDataOut: "void *", pdwSizeOutRet: "DWORD *"=None) -> "unsigned long":
        return _connect.IConnectIDE2_Service(self, dwServiceFlags, rguidService, dwSizeIn, pDataIn, dwSizeOut, pDataOut, pdwSizeOutRet)
    __swig_destroy__ = _connect.delete_IConnectIDE2

# Register IConnectIDE2 in _connect:
_connect.IConnectIDE2_swigregister(IConnectIDE2)

class IConnectIDE3(IConnectIDE2):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetInfo = _connect.IConnectIDE3_ndxGetInfo
    ndxGetConsole = _connect.IConnectIDE3_ndxGetConsole
    ndxConsoleOutput = _connect.IConnectIDE3_ndxConsoleOutput
    ndxConsoleInput = _connect.IConnectIDE3_ndxConsoleInput
    ndxOption = _connect.IConnectIDE3_ndxOption
    ndxService1 = _connect.IConnectIDE3_ndxService1
    ndxService2 = _connect.IConnectIDE3_ndxService2
    ndxNum = _connect.IConnectIDE3_ndxNum
    gcOutput = _connect.IConnectIDE3_gcOutput
    gcInput = _connect.IConnectIDE3_gcInput
    gcExisting = _connect.IConnectIDE3_gcExisting
    gcNew = _connect.IConnectIDE3_gcNew
    gcExistingOrNew = _connect.IConnectIDE3_gcExistingOrNew
    coSTDOUT = _connect.IConnectIDE3_coSTDOUT
    coSTDERR = _connect.IConnectIDE3_coSTDERR

    def ConsoleOutput(self, dwConsoleOutputFlags: "DWORD", dwConsoleHandle: "DWORD", pszOutput: "LPCSTR") -> "unsigned long":
        r""" output a string to console"""
        return _connect.IConnectIDE3_ConsoleOutput(self, dwConsoleOutputFlags, dwConsoleHandle, pszOutput)
    ciSTDIN = _connect.IConnectIDE3_ciSTDIN

    def ConsoleInput(self, dwConsoleInputFlags: "DWORD", dwConsoleHandle: "DWORD", pszInput: "LPSTR", dwInputLen: "DWORD") -> "unsigned long":
        r""" get a string from console"""
        return _connect.IConnectIDE3_ConsoleInput(self, dwConsoleInputFlags, dwConsoleHandle, pszInput, dwInputLen)

    def Option(self, dwOptionFlags: "DWORD", pszScope: "LPCSTR", pszOption: "LPCSTR", pValue: "SOptionValue") -> "unsigned long":
        r"""
        Sets or gets a configuration option.

        :type dwOptionFlags: int
        :param dwOptionFlags: as per EOptionFlags along with SOptionValue
                                 defined in i_Option.h

        :type pszScope: string
        :param pszScope: defines the destination. It may be file name in
                            case of documents or CLSID in case of plugins.

        :type pszOption: string
        :param pszOption: option URL if dwOptionFlags contain one of ofValString. ofValInt,
                             ofValFloat, or ofValStringInt. If ofValBuffer is used, it should contain
                             destination, eg "/IDE/", the rest of option URL is in SOptionValue.m_pszStringIn.
        """
        return _connect.IConnectIDE3_Option(self, dwOptionFlags, pszScope, pszOption, pValue)

    def Service1(self, dwServiceFlags: "DWORD", rguidService: "GUID const &", dwSizeIn: "DWORD", pDataIn: "void const *", dwSizeIn1: "DWORD", pDataIn1: "void const *", dwSizeOut: "DWORD", pDataOut: "void *", dwSizeOut1: "DWORD", pDataOut1: "void *", pdwSizeOut1Ret: "DWORD *"=None) -> "unsigned long":
        r"""
        Extension to IConnectIDE2::Service
        Adds scope
        Adds another input and output parameter

        :type pDataOut1: void
        :param pDataOut1: pointer to service output data - typically a variable number of data items specific to the service size of data pointed to by pDataOut. This should be sizeof the service specific type pointer to service output data - typically an instance of service specific type size of data pointed to by pDataOut. This should be sizeof the service specific type pointer to service input data - typically a variable number of data items specific to the service size of data pointed to by pDataIn1. pointer to service input data - typically an instance of service specific type size of data pointed to by pDataIn. This should be sizeof the service specific type GUID of service to perform per EService enum
        :type pdwSizeOut1Ret: int, optional
        :param pdwSizeOut1Ret: number of bytes returned which the server wanted to return
        """
        return _connect.IConnectIDE3_Service1(self, dwServiceFlags, rguidService, dwSizeIn, pDataIn, dwSizeIn1, pDataIn1, dwSizeOut, pDataOut, dwSizeOut1, pDataOut1, pdwSizeOut1Ret)

    def Service2(self, dwServiceFlags: "DWORD", pszScope: "LPCSTR", rguidService: "GUID const &", dwSizeIn: "DWORD", pDataIn: "void const *", dwSizeIn1: "DWORD", pDataIn1: "void const *", dwSizeOut: "DWORD", pDataOut: "void *", dwSizeOut1: "DWORD", pDataOut1: "void *", pdwSizeOut1Ret: "DWORD *"=None) -> "unsigned long":
        r"""
        Extension to IConnectIDE3::Service1
        Adds scope

        :type pDataOut1: void
        :param pDataOut1: pointer to service output data - typically a variable number of data items specific to the service size of data pointed to by pDataOut. This should be sizeof the service specific type pointer to service output data - typically an instance of service specific type size of data pointed to by pDataOut. This should be sizeof the service specific type pointer to service input data - typically a variable number of data items specific to the service size of data pointed to by pDataIn1. pointer to service input data - typically an instance of service specific type size of data pointed to by pDataIn. This should be sizeof the service specific type GUID of service to perform plugin name per EService enum
        :type pdwSizeOut1Ret: int, optional
        :param pdwSizeOut1Ret: number of bytes returned which the server wanted to return
        """
        return _connect.IConnectIDE3_Service2(self, dwServiceFlags, pszScope, rguidService, dwSizeIn, pDataIn, dwSizeIn1, pDataIn1, dwSizeOut, pDataOut, dwSizeOut1, pDataOut1, pdwSizeOut1Ret)
    __swig_destroy__ = _connect.delete_IConnectIDE3

# Register IConnectIDE3 in _connect:
_connect.IConnectIDE3_swigregister(IConnectIDE3)

indxCoverage = _connect.indxCoverage
indxTest = _connect.indxTest
indxHIL = _connect.indxHIL
indxUMI = _connect.indxUMI
indxAnalyzer = _connect.indxAnalyzer
class SCoverageRange(object):
    r"""Defines range of addresses used by coverage."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_aAddress = property(_connect.SCoverageRange_m_aAddress_get, _connect.SCoverageRange_m_aAddress_set, doc=r""" first address of the reported range""")
    m_aEnd = property(_connect.SCoverageRange_m_aEnd_get, _connect.SCoverageRange_m_aEnd_set, doc=r""" last address of the reported range""")

    def __init__(self):
        _connect.SCoverageRange_swiginit(self, _connect.new_SCoverageRange())
    __swig_destroy__ = _connect.delete_SCoverageRange

# Register SCoverageRange in _connect:
_connect.SCoverageRange_swigregister(SCoverageRange)
IID_IConnectCoverage = cvar.IID_IConnectCoverage
IID_IConnectTest = cvar.IID_IConnectTest
IID_IConnectHIL = cvar.IID_IConnectHIL
IID_IConnectAnalyzer = cvar.IID_IConnectAnalyzer

class IConnectCoverage(object):
    r"""This interface provides access to winIDEA coverage functionality."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetLastError = _connect.IConnectCoverage_ndxGetLastError
    ndxGetInfo = _connect.IConnectCoverage_ndxGetInfo
    ndxSetConfig = _connect.IConnectCoverage_ndxSetConfig
    ndxActivate = _connect.IConnectCoverage_ndxActivate
    ndxGetStatus = _connect.IConnectCoverage_ndxGetStatus
    ndxGetCoverageRanges = _connect.IConnectCoverage_ndxGetCoverageRanges
    ndxGetCoverageBitmap = _connect.IConnectCoverage_ndxGetCoverageBitmap
    ndxGetCoverageStatistics = _connect.IConnectCoverage_ndxGetCoverageStatistics
    ndxNum = _connect.IConnectCoverage_ndxNum
    efError = _connect.IConnectCoverage_efError
    efWarning = _connect.IConnectCoverage_efWarning
    errorOK = _connect.IConnectCoverage_errorOK
    r""" no error was stored for GetLastError"""
    errorInternal = _connect.IConnectCoverage_errorInternal
    r""" internal error"""
    errorNotImplemented = _connect.IConnectCoverage_errorNotImplemented
    r""" functionality not implemented"""
    errorInvalidParameter = _connect.IConnectCoverage_errorInvalidParameter
    r""" a passed parameter is invalid"""
    errorInvalidRangeset = _connect.IConnectCoverage_errorInvalidRangeset
    r""" there is no active rangeset"""
    errorUnsuportedCoverageType = _connect.IConnectCoverage_errorUnsuportedCoverageType
    r""" this coverage type doesn't support this functionality"""

    def GetLastError(self, pszFileName: "LPCSTR", dwErrorFlags: "DWORD", pdwErrorCode: "DWORD *", pszError: "LPSTR", dwErrorLen: "DWORD") -> "unsigned long":
        r"""
        Gets the last error code and it's string description. Call this method,
        when other methods of this interface do not return S_OK, to get detailed
        error code and description.

        :type pszFileName: string
        :param pszFileName: file name of the code coverage document
        :type dwErrorFlags: int
        :param dwErrorFlags: flags that modify the behavior of the function. Should be 0.
        :type pdwErrorCode: int
        :param pdwErrorCode: returned error code, see IConnectCoverage::EErrorCode
        :type pszError: string
        :param pszError: buffer for the error description string
        :type dwErrorLen: int
        :param dwErrorLen: length of the error string buffer

        """
        return _connect.IConnectCoverage_GetLastError(self, pszFileName, dwErrorFlags, pdwErrorCode, pszError, dwErrorLen)
    ifGetCapabilities = _connect.IConnectCoverage_ifGetCapabilities
    r"""
    Coverage capabilities will be returned -
    IConnectCoverage::EInfoCapabilities
    """
    ifGetType = _connect.IConnectCoverage_ifGetType
    r"""
    Coverage type will be returned -
    IConnectCoverage::EInfoType
    """
    icAvailable = _connect.IConnectCoverage_icAvailable
    r""" coverage is available"""
    icBranches = _connect.IConnectCoverage_icBranches
    r""" branch coverage available"""
    itHardware = _connect.IConnectCoverage_itHardware
    r""" hardware coverage"""
    itOffline = _connect.IConnectCoverage_itOffline
    r""" offline coverage"""

    def GetInfo(self, pszFileName: "LPCSTR", dwInfoFlags: "DWORD", pdwInfo: "DWORD *") -> "unsigned long":
        r"""
        Gets information about the coverage system.

        :type dwInfoFlags: int
        :param dwInfoFlags: Defines requested information, see IConnectCoverage::EInfoFlags file name of the code coverage document
        :type pdwInfo: int
        :param pdwInfo: On return contains information requested by dwInfoFlags, see
             IConnectCoverage::EInfoCapabilities and
             IConnectCoverage::EInfoType
        """
        return _connect.IConnectCoverage_GetInfo(self, pszFileName, dwInfoFlags, pdwInfo)
    cfNOP = _connect.IConnectCoverage_cfNOP
    r""" reserved"""
    cfSetConfigScope = _connect.IConnectCoverage_cfSetConfigScope
    r""" see IConnectCoverage::EConfigScope"""
    cfSetConfigLevel = _connect.IConnectCoverage_cfSetConfigLevel
    r""" see IConnectCoverage::EConfigLevel"""
    cfSetConfigOperation = _connect.IConnectCoverage_cfSetConfigOperation
    r""" see IConnectCoverage::EConfigOperation"""
    cfAddRangeset = _connect.IConnectCoverage_cfAddRangeset
    r""" create a new rangeset, name in pszParameter"""
    cfSetRangesetScope = _connect.IConnectCoverage_cfSetRangesetScope
    r""" see IConnectCoverage::ERangesetScope"""
    cfAddRangesetExcludeFolder = _connect.IConnectCoverage_cfAddRangesetExcludeFolder
    r""" add pszParameter to the list of exclude folders"""
    cfAddRangesetExcludeModule = _connect.IConnectCoverage_cfAddRangesetExcludeModule
    r""" add pszParameter to the list of exclude modules"""
    cfAddRangesetExcludeFunction = _connect.IConnectCoverage_cfAddRangesetExcludeFunction
    r""" add pszParameter to the list of exclude functions"""
    cfAddRangesetExcludeItem = _connect.IConnectCoverage_cfAddRangesetExcludeItem
    r""" add pszParameter to the list of exclude items"""
    cfAddRangesetIncludeFolder = _connect.IConnectCoverage_cfAddRangesetIncludeFolder
    r""" add pszParameter to the list of include folders"""
    cfAddRangesetIncludeModule = _connect.IConnectCoverage_cfAddRangesetIncludeModule
    r""" add pszParameter to the list of include modules"""
    cfAddRangesetIncludeFunction = _connect.IConnectCoverage_cfAddRangesetIncludeFunction
    r""" add pszParameter to the list of include functions"""
    cfAddRangesetIncludeItem = _connect.IConnectCoverage_cfAddRangesetIncludeItem
    r""" add pszParameter to the list of include items"""
    cfSetActiveRangeset = _connect.IConnectCoverage_cfSetActiveRangeset
    r""" activate the rangeset named pszParameter"""
    cfSetActiveRangesetByIndex = _connect.IConnectCoverage_cfSetActiveRangesetByIndex
    r""" activate the rangeset number dwParameter"""
    cfClearConfiguration = _connect.IConnectCoverage_cfClearConfiguration
    r""" clear the configuration"""
    cfgsAllDownloaded = _connect.IConnectCoverage_cfgsAllDownloaded
    r""" include all downloaded code"""
    cfgsEntireMemory = _connect.IConnectCoverage_cfgsEntireMemory
    r""" entire memory"""
    cfgsUseRangeset = _connect.IConnectCoverage_cfgsUseRangeset
    r""" use a rangeset"""
    cfglStatementCoverage = _connect.IConnectCoverage_cfglStatementCoverage
    r""" enable statement coverage"""
    cfglDecisionCoverage = _connect.IConnectCoverage_cfglDecisionCoverage
    r""" enable decision coverage"""
    cfgoAutoStartWithCPU = _connect.IConnectCoverage_cfgoAutoStartWithCPU
    r""" start coverage when the CPU starts"""
    cfgoAutoUpdateOnStop = _connect.IConnectCoverage_cfgoAutoUpdateOnStop
    r""" update on stop"""
    rssAllDownloadedCode = _connect.IConnectCoverage_rssAllDownloadedCode
    r""" all downloaded code minus excludes"""
    rssEntireMemory = _connect.IConnectCoverage_rssEntireMemory
    r""" all memory minus excludes"""
    rssRegions = _connect.IConnectCoverage_rssRegions
    r""" only the include regions"""

    def SetConfig(self, pszFileName: "LPCSTR", dwConfigFlags: "DWORD", pszParameter: "LPCSTR"=None, dwParameter: "DWORD"=0) -> "unsigned long":
        r"""
         This method sets the coverage configuration parameters.
        :type pszParameter: string, optional
        :param pszParameter: set depending on the value of dwConfigFlags set to one of values defined by IConnectCoverage::EConfigFlags file name of the code coverage document
        :type dwParameter: int, optional
        :param dwParameter: set depending on the value of dwConfigFlags
        """
        return _connect.IConnectCoverage_SetConfig(self, pszFileName, dwConfigFlags, pszParameter, dwParameter)
    afStart = _connect.IConnectCoverage_afStart
    r""" starts coverage"""
    afStop = _connect.IConnectCoverage_afStop
    r""" stops coverage"""
    afResume = _connect.IConnectCoverage_afResume
    r""" resumes stopped coverage"""

    def Activate(self, pszFileName: "LPCSTR", dwActivateFlags: "DWORD") -> "unsigned long":
        r"""
         Changes state of code coverage.
        :type pszFileName: string
        :param pszFileName: file name of the code coverage document
        :type dwActivateFlags: int
        :param dwActivateFlags: activate command, see IConnectCoverage::EActivateFlags
        """
        return _connect.IConnectCoverage_Activate(self, pszFileName, dwActivateFlags)
    sfActivationStatus = _connect.IConnectCoverage_sfActivationStatus
    r"""
    requests status described by
    IConnectCoverage::EActivationStatus
    """
    asInactive = _connect.IConnectCoverage_asInactive
    r""" coverage is not running"""
    asActive = _connect.IConnectCoverage_asActive
    r""" coverage is running"""

    def GetStatus(self, pszFileName: "LPCSTR", dwStatusFlags: "DWORD", pdwStatus: "DWORD *") -> "unsigned long":
        r"""
        Returns current coverage status.

        :type dwStatusFlags: int
        :param dwStatusFlags: defines requested status, see IConnectCoverage::EStatusFlags file name of the code coverage document
        :type pdwStatus: int
        :param pdwStatus: on return contains coverage status, see
             IConnectCoverage::EActivationStatus
        """
        return _connect.IConnectCoverage_GetStatus(self, pszFileName, dwStatusFlags, pdwStatus)
    crfActiveRanges = _connect.IConnectCoverage_crfActiveRanges
    r""" active ranges in address related format"""
    crfResolveRange = _connect.IConnectCoverage_crfResolveRange
    r""" ranges of the resolved symbol, pass the symbol type in dwParameter and its name on pszParameter"""
    crtFolder = _connect.IConnectCoverage_crtFolder
    r""" the provided string argument refers to a folder or folders"""
    crtModule = _connect.IConnectCoverage_crtModule
    r""" the provided string argument refers to a module or modules"""
    crtFunction = _connect.IConnectCoverage_crtFunction
    r""" the provided string argument refers to a function or funtions"""
    crtItem = _connect.IConnectCoverage_crtItem
    r""" the provided string argument refers to an item or items"""

    def GetCoverageRanges(self, pszFileName: "LPCSTR", dwRangesFlags: "DWORD", pdwRangeCount: "DWORD *", pRanges: "SCoverageRange", pszParameter: "LPCSTR"=None, dwParameter: "DWORD"=0) -> "unsigned long":
        r"""
        Returns all ranges that were defined by method SetConfig().

        :type pszParameter: string, optional
        :param pszParameter: set depending on the value of dwRangesFlags points to array of coverage ranges defines the number of items in **pRanges** array see IConnectCoverage::ECoverageRangesFlags file name of the code coverage document
        :type dwParameter: int, optional
        :param dwParameter: set depending on the value of dwRangesFlags
        """
        return _connect.IConnectCoverage_GetCoverageRanges(self, pszFileName, dwRangesFlags, pdwRangeCount, pRanges, pszParameter, dwParameter)
    cbfBitmap0 = _connect.IConnectCoverage_cbfBitmap0
    r""" for every location one BYTE is used as result, using EBitmap0Data encoding"""
    cbfBitmap1 = _connect.IConnectCoverage_cbfBitmap1
    r""" for every location one SBitmap1 object is used as result"""
    cbfBitmapMask = _connect.IConnectCoverage_cbfBitmapMask
    r""" mask for Bitmap format encoding"""
    cbfDefault = _connect.IConnectCoverage_cbfDefault
    r""" deprecated, use cbfBitmap0 instead"""
    bm0_Executed = _connect.IConnectCoverage_bm0_Executed
    r""" statement coverage"""
    bm0_Condition = _connect.IConnectCoverage_bm0_Condition
    r""" this address holds a conditional instruction"""
    bm0_ConditionTrue = _connect.IConnectCoverage_bm0_ConditionTrue
    r""" instruction's condition on this address evaluated true"""
    bm0_ConditionFalse = _connect.IConnectCoverage_bm0_ConditionFalse
    r""" instruction's condition on this address evaluated false"""
    modeBranch = _connect.IConnectCoverage_modeBranch
    r""" kept for backwards compatibility"""
    modeBranchTaken = _connect.IConnectCoverage_modeBranchTaken
    r""" kept for backwards compatibility"""
    modeBranchNotTaken = _connect.IConnectCoverage_modeBranchNotTaken
    r""" kept for backwards compatibility"""

    def GetCoverageBitmap(self, pszFileName: "LPCSTR", dwCoverageBitmapFlags: "DWORD", aAddress: "uint32_t", aEnd: "uint32_t", dwBitmapSize: "DWORD", pbyBitmap: "BYTE *") -> "unsigned long":
        r"""
        Returns coverage results as an array of bytes, where each byte contains
        coverage results.

        :type pbyBitmap: BYTE
        :param pbyBitmap: pointer to an user allocated buffer that has at
                             least one byte per MAU (aEnd - aAddress + 1 <=
                             dwBitampSize). Each byte of the bitmap has
                             information for a single MAU. See
                             IConnectCoverage::ECoverageMode for information
                             about the bits used.

        :type dwBitmapSize: int
        :param dwBitmapSize: size of the bitmap buffer, it should be
             (aEnd - aAddress + 1) for cbfBitmap0
             (aEnd - aAddress + 1) * sizeof(SBitmap1) for cbfBitmap1 end of the range queried, inclusive beginning of the range queried see IConnectCoverage::ECoverageBitmapFlags for supported values file name of the code coverage document
        :type pbyBitmap: BYTE
        :param pbyBitmap: pointer to a buffer to hold the query data
        """
        return _connect.IConnectCoverage_GetCoverageBitmap(self, pszFileName, dwCoverageBitmapFlags, aAddress, aEnd, dwBitmapSize, pbyBitmap)
    csftBytes = _connect.IConnectCoverage_csftBytes
    r""" total number of bytes in the queried range"""
    csftBytesExec = _connect.IConnectCoverage_csftBytesExec
    r""" query the number of executed bytes"""
    csftConditions = _connect.IConnectCoverage_csftConditions
    r""" query the number of Conditions"""
    csftConditionsExec = _connect.IConnectCoverage_csftConditionsExec
    r""" query the number of executed Conditions"""
    csftConditionsTrue = _connect.IConnectCoverage_csftConditionsTrue
    r""" query the number of Conditions evaluating true"""
    csftConditionsFalse = _connect.IConnectCoverage_csftConditionsFalse
    r""" query the number of Conditions evaluating false"""
    csftConditionsBoth = _connect.IConnectCoverage_csftConditionsBoth
    r""" query the number of Conditions that evaluated both ways"""
    csftBranches = _connect.IConnectCoverage_csftBranches
    r""" deprecated, use csftConditions"""
    csftBranchesExec = _connect.IConnectCoverage_csftBranchesExec
    r""" deprecated, use csftConditionsExec"""
    csftBranchesTaken = _connect.IConnectCoverage_csftBranchesTaken
    r""" deprecated, use csftConditionsTrue"""
    csftBranchesNotTaken = _connect.IConnectCoverage_csftBranchesNotTaken
    r""" deprecated, use csftConditionsFalse"""
    csftBranchesBoth = _connect.IConnectCoverage_csftBranchesBoth
    r""" deprecated, use csftConditionsBoth"""
    csftCountMin = _connect.IConnectCoverage_csftCountMin
    csftCountMax = _connect.IConnectCoverage_csftCountMax
    csftLines = _connect.IConnectCoverage_csftLines
    r""" total number of lines in the queried range"""
    csftLinesExec = _connect.IConnectCoverage_csftLinesExec
    r""" query the number of executed lines"""

    def GetCoverageStatistics(self, pszFileName: "LPCSTR", dwCoverageStatisticsFlags: "DWORD", aAddress: "uint32_t", aEnd: "uint32_t", pdwData: "DWORD *") -> "unsigned long":
        r"""
         This method retrieves coverage statistics results.
        :type aEnd: int
        :param aEnd: end of the range queried, inclusive beginning of the range queried see IConnectCoverage::ECoverageStatisticsFlags for
             supported values file name of the code coverage document
        :type pdwData: int
        :param pdwData: pointer to a DWORD that will get the query result
        """
        return _connect.IConnectCoverage_GetCoverageStatistics(self, pszFileName, dwCoverageStatisticsFlags, aAddress, aEnd, pdwData)
    __swig_destroy__ = _connect.delete_IConnectCoverage

# Register IConnectCoverage in _connect:
_connect.IConnectCoverage_swigregister(IConnectCoverage)

class IConnectTest(object):
    r"""This interface defines methods for unit testing without code instrumentation."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetLastError = _connect.IConnectTest_ndxGetLastError
    ndxCreateTestCase = _connect.IConnectTest_ndxCreateTestCase
    ndxDestroyTestCase = _connect.IConnectTest_ndxDestroyTestCase
    ndxCreateParameter = _connect.IConnectTest_ndxCreateParameter
    ndxCreateReturnValue = _connect.IConnectTest_ndxCreateReturnValue
    ndxCreateVariable = _connect.IConnectTest_ndxCreateVariable
    ndxDestroyVariable = _connect.IConnectTest_ndxDestroyVariable
    ndxCreateStub = _connect.IConnectTest_ndxCreateStub
    ndxDestroyStub = _connect.IConnectTest_ndxDestroyStub
    ndxCreateStubParameter = _connect.IConnectTest_ndxCreateStubParameter
    ndxCreateStubReturnValue = _connect.IConnectTest_ndxCreateStubReturnValue
    ndxEvaluateExpression = _connect.IConnectTest_ndxEvaluateExpression
    ndxModifyExpression = _connect.IConnectTest_ndxModifyExpression
    ndxControl = _connect.IConnectTest_ndxControl
    ndxGetStatus = _connect.IConnectTest_ndxGetStatus
    ndxCreateRealtimeStub = _connect.IConnectTest_ndxCreateRealtimeStub
    ndxCreateUserStub = _connect.IConnectTest_ndxCreateUserStub
    ndxGetInfo = _connect.IConnectTest_ndxGetInfo
    ndxCreateVariableEx = _connect.IConnectTest_ndxCreateVariableEx
    ndxCreateTestCaseEx = _connect.IConnectTest_ndxCreateTestCaseEx
    ndxDeleteVariableEx = _connect.IConnectTest_ndxDeleteVariableEx
    ndxSetTestCaseTimeOut = _connect.IConnectTest_ndxSetTestCaseTimeOut
    ndxCreateStubEx = _connect.IConnectTest_ndxCreateStubEx
    ndxNum = _connect.IConnectTest_ndxNum
    efError = _connect.IConnectTest_efError
    efWarning = _connect.IConnectTest_efWarning
    errorOK = _connect.IConnectTest_errorOK
    errorInvalidTransition = _connect.IConnectTest_errorInvalidTransition
    errorInvalidTestCase = _connect.IConnectTest_errorInvalidTestCase
    errorInvalidTestVariable = _connect.IConnectTest_errorInvalidTestVariable
    errorInvalidTestStub = _connect.IConnectTest_errorInvalidTestStub
    errorInvalidTestCasePointer = _connect.IConnectTest_errorInvalidTestCasePointer
    errorInvalidTestVariablePointer = _connect.IConnectTest_errorInvalidTestVariablePointer
    errorInvalidTestStubPointer = _connect.IConnectTest_errorInvalidTestStubPointer
    errorCannotCreateTestCase = _connect.IConnectTest_errorCannotCreateTestCase
    errorCannotCreateTestVariable = _connect.IConnectTest_errorCannotCreateTestVariable
    errorCannotCreateTestStub = _connect.IConnectTest_errorCannotCreateTestStub
    errorTestCaseInitFailed = _connect.IConnectTest_errorTestCaseInitFailed
    errorInternal = _connect.IConnectTest_errorInternal
    errorExpressionEvaluationFailed = _connect.IConnectTest_errorExpressionEvaluationFailed
    errorExpressionModificationFailed = _connect.IConnectTest_errorExpressionModificationFailed
    errorSymbolsNotLoaded = _connect.IConnectTest_errorSymbolsNotLoaded
    errorFunctionNotFound = _connect.IConnectTest_errorFunctionNotFound
    errorTestCaseSymbolNotAFunction = _connect.IConnectTest_errorTestCaseSymbolNotAFunction
    errorCannotSetStubBreakpoint = _connect.IConnectTest_errorCannotSetStubBreakpoint
    errorInvalidControlFlags = _connect.IConnectTest_errorInvalidControlFlags
    errorCannotUpdateStatus = _connect.IConnectTest_errorCannotUpdateStatus
    errorResumeFailed = _connect.IConnectTest_errorResumeFailed
    errorVariableTypeNotRecognized = _connect.IConnectTest_errorVariableTypeNotRecognized
    errorInvalidParameterIndex = _connect.IConnectTest_errorInvalidParameterIndex
    errorCannotClearStubBreakpoint = _connect.IConnectTest_errorCannotClearStubBreakpoint
    errorNotImplemented = _connect.IConnectTest_errorNotImplemented
    errorInvalidStatusFlags = _connect.IConnectTest_errorInvalidStatusFlags
    errorCannotSaveRegisters = _connect.IConnectTest_errorCannotSaveRegisters
    errorUnsupportedArchitecture = _connect.IConnectTest_errorUnsupportedArchitecture
    errorTestCaseCleanFailed = _connect.IConnectTest_errorTestCaseCleanFailed
    errorAdjustBeforeStartFailed = _connect.IConnectTest_errorAdjustBeforeStartFailed
    errorInvalidTestVariableName = _connect.IConnectTest_errorInvalidTestVariableName
    errorInvalidFlagValue = _connect.IConnectTest_errorInvalidFlagValue
    errorCannotSetExitBreakpoint = _connect.IConnectTest_errorCannotSetExitBreakpoint
    errorCannotAccessMemory = _connect.IConnectTest_errorCannotAccessMemory
    errorLicense = _connect.IConnectTest_errorLicense
    errorCallFrameAlocation = _connect.IConnectTest_errorCallFrameAlocation
    errorCannotSetExceptionBreakPoint = _connect.IConnectTest_errorCannotSetExceptionBreakPoint

    def GetLastError(self, dwErrorFlags: "DWORD", pdwErrorCode: "DWORD *", pszError: "LPSTR", dwErrorLen: "DWORD") -> "unsigned long":
        r"""
        Gets the last error code and it's string description. Call this method,
        when other methods of this interface do not return S_OK, to get detailed
        error code and description.

        :type dwErrorFlags: int
        :param dwErrorFlags: flags that modify the behavior of the function
        :type pdwErrorCode: int
        :param pdwErrorCode: error code
        :type pszError: string
        :param pszError: buffer for the error string
        :type dwErrorLen: int
        :param dwErrorLen: length of the error string buffer

        """
        return _connect.IConnectTest_GetLastError(self, dwErrorFlags, pdwErrorCode, pszError, dwErrorLen)

    def CreateTestCase(self, pdwTestCase: "DWORD *", pszFunctionName: "LPCSTR") -> "unsigned long":
        r"""
        Creates a new test case.

        :type pdwTestCase: int
        :param pdwTestCase: contains a new test case handle on return
        :type pszFunctionName: string
        :param pszFunctionName: name of the function to be tested
        """
        return _connect.IConnectTest_CreateTestCase(self, pdwTestCase, pszFunctionName)

    def DestroyTestCase(self, dwTestCase: "DWORD") -> "unsigned long":
        r"""
        Deletes test case created by CreateTestCase().

        :type dwTestCase: int
        :param dwTestCase: test case handle as returned by CreateTestCase()
        """
        return _connect.IConnectTest_DestroyTestCase(self, dwTestCase)

    def CreateParameter(self, *args) -> "unsigned long":
        r"""
        Creates a name for a parameter that can be used for accessing it.
        If the variable name with this name already exists, it is hidden
        by the created variable.

        :type dwTestCase: int
        :param dwTestCase: test case handle as returned by CreateTestCase()
        :type dwIndex: int
        :param dwIndex: zero based index of the parameter
        :type pszName: string
        :param pszName: name of the parameter to be created
        """
        return _connect.IConnectTest_CreateParameter(self, *args)

    def CreateReturnValue(self, dwTestCase: "DWORD", pszName: "LPCSTR") -> "unsigned long":
        r"""
        Creates a name for the function return value that can be used
        for accessing it during evaluation and modification.
        If the variable name with this name already exists, it is hidden
        by the created variable.

        :type dwTestCase: int
        :param dwTestCase: test case handle as returned by CreateTestCase()
        :type pszName: string
        :param pszName: name of the variable to be created
        """
        return _connect.IConnectTest_CreateReturnValue(self, dwTestCase, pszName)

    def CreateVariable(self, pdwVariable: "DWORD *", pszName: "LPCSTR", pszType: "LPCSTR") -> "unsigned long":
        r"""
        Creates temporary variable, which can be used as a function parameter.
        If the variable name with this name already exists, it is hidden
        by the created variable.

        :type pdwVariable: int
        :param pdwVariable: variable handle as returned by CreateVariable()
        :type pszName: string
        :param pszName: name of the variable to be created
        :type pszType: string
        :param pszType: type of the variable. This should be one of the existing
                           types in the application under test.
        """
        return _connect.IConnectTest_CreateVariable(self, pdwVariable, pszName, pszType)

    def DestroyVariable(self, dwVariable: "DWORD") -> "unsigned long":
        r"""
        Destroys variable created by CreateVariable().

        :type dwVariable: int
        :param dwVariable: variable handle as returned by CreateVariable().
        """
        return _connect.IConnectTest_DestroyVariable(self, dwVariable)

    def CreateStub(self, pdwStub: "DWORD *", pszFunctionName: "LPCSTR") -> "unsigned long":
        r"""
        Creates stub for function called by function under test. Since no
        code instrumentation is allowed, only breakpoint is set at the given
        function. When the function is called, the test case execution stops,
        and then the test framework can define next actions. Usually it will
        simulate desired side effects of a stubbed function (for example set
        global variables), and then continue execution of the
        function under test.


        This method must be called BEFORE test case is initialized by method
        ``Control(controlTestCaseInit)``.

        :type pdwStub: int
        :param pdwStub: contains a new stub handle on return
        :type pszFunctionName: string
        :param pszFunctionName: name of the stubbed function
        """
        return _connect.IConnectTest_CreateStub(self, pdwStub, pszFunctionName)

    def DestroyStub(self, dwStub: "DWORD") -> "unsigned long":
        r"""
        Destroys a stub

        :type dwStub: int
        :param dwStub: stub handle as returned by CreateStub(), CreateRealtimeStub() or CreateUserStub().
        """
        return _connect.IConnectTest_DestroyStub(self, dwStub)

    def CreateStubParameter(self, dwStub: "DWORD", dwIndex: "DWORD", pszName: "LPCSTR") -> "unsigned long":
        r"""
        This method assigns a name to stub parameter at the given position.
        This could be done only with regular stubs. This is not supported in
        real-time or user stubs.
        The assigned name may be used in expressions by EvaluateExpression()
        and ModifyExpression().
        This function can be called anytime after the stub is setup and before
        it is hit.

        :type dwStub: int
        :param dwStub: stub handle as returned by CreateStub()
        :type dwIndex: int
        :param dwIndex: 0 - based parameter index
        :type pszName: string
        :param pszName: name assigned to parameter
        """
        return _connect.IConnectTest_CreateStubParameter(self, dwStub, dwIndex, pszName)

    def CreateStubReturnValue(self, dwStub: "DWORD", pszName: "LPCSTR") -> "unsigned long":
        r"""
        This method assigns a name to stub return value.
        This could be done only with regular stubs. This is not supported in
        real-time or user stubs.
        The assigned name may be used in expressions by EvaluateExpression() and
        ModifyExpression() to define value returned to the function under test.
        This function can be called anytime after the stub is setup and before
        it is hit.

        :type dwStub: int
        :param dwStub: stub handle as returned by CreateStub()
        :type pszName: string
        :param pszName: name assigned to return value
        """
        return _connect.IConnectTest_CreateStubReturnValue(self, dwStub, pszName)
    efVagueFloatEqual = _connect.IConnectTest_efVagueFloatEqual
    r"""
    Floating point values are compared for
    equality with precision 10e-5.
    """
    efIgnoreLocalScope = _connect.IConnectTest_efIgnoreLocalScope
    r""" Ignore variables in local scope in evaluation"""
    efUseRealTimeAccess = _connect.IConnectTest_efUseRealTimeAccess
    r""" perform access using real-time access"""
    efModifyParameter = _connect.IConnectTest_efModifyParameter
    r""" used in modify call when modifying a function parameter"""

    def EvaluateExpression(self, dwEvaluateFlags: "DWORD", pszExpression: "LPCSTR", pszResult: "LPSTR", dwResultLen: "DWORD") -> "unsigned long":
        r"""
        Evaluates the given expression and returns result as a string.
        This method is similar to IConnectDebug::Evaluate(). The
        difference is in variable scope, since this method takes into
        account also variables created by CreateVariable() or
        CreateParameter(), return value, and stub related data.

        :type dwEvaluateFlags: int
        :param dwEvaluateFlags: modifies the behavior of the evaluate function.
                   See IConnectTest::EEvaluateFlags
        :type pszExpression: string
        :param pszExpression: the expression to be evaluated
        :type pszResult: string
        :param pszResult: pointer to string, which will contain evaluation result
        :type dwResultLen: int
        :param dwResultLen: the length of allocated array pointed to by pszResult

        :rtype: int
        :return: result in string form. Numbers may be returned in hex or decimal
            format, depending on setting in winIDEA's Watch window.
        """
        return _connect.IConnectTest_EvaluateExpression(self, dwEvaluateFlags, pszExpression, pszResult, dwResultLen)

    def ModifyExpression(self, dwModifyFlags: "DWORD", pszExpression: "LPCSTR", pszResult: "LPSTR", dwResultLen: "DWORD", pszValue: "LPCSTR") -> "unsigned long":
        r"""
        Modifies expression to the given value. Expression must be an lvalue.

        :type dwModifyFlags: int
        :param dwModifyFlags: modifies the behavior of the modify function.
                   See IConnectTest::EEvaluateFlags
        :type pszExpression: string
        :param pszExpression: lvalue to be modified
        :type pszResult: string
        :param pszResult: result of evaluated pszValue is stored here. May be
                             NULL, if we don't need the evaluation result.
        :type dwResultLen: int
        :param dwResultLen: the length of allocated array pointed to by pszResult
        :type pszValue: string
        :param pszValue: the value to be assigned to pszExpression
        """
        return _connect.IConnectTest_ModifyExpression(self, dwModifyFlags, pszExpression, pszResult, dwResultLen, pszValue)
    controlReset = _connect.IConnectTest_controlReset
    r"""
    Clean the active test case from the target if any
    and destroy all test cases, variables and stubs.
    """
    controlTestCaseInit = _connect.IConnectTest_controlTestCaseInit
    r""" Initialize a test case, from offline status"""
    controlTestCaseClean = _connect.IConnectTest_controlTestCaseClean
    r""" Cleanup the test case from the target make it offline"""
    controlTestCaseRun = _connect.IConnectTest_controlTestCaseRun
    r"""
    Run a test case or resume an initialized, paused,
    stopped or at stub test case; no effect if the test
    case is offline;
    """
    controlTestCaseAbort = _connect.IConnectTest_controlTestCaseAbort
    r"""
    Abort the the test case, no matter it's status;
    it has no effect if the test case is not initialized
    """
    controlTestCasePause = _connect.IConnectTest_controlTestCasePause
    r"""
    Pause a running test case; valid only if the test
    case is initialized and running
    """
    controlTestCaseSetDebugMode = _connect.IConnectTest_controlTestCaseSetDebugMode
    r""" Indicates execution in debug mode. Optimizations should be disabled"""
    controlTestBatchBegin = _connect.IConnectTest_controlTestBatchBegin
    r""" a series of test case runs will follow"""
    controlTestBatchEnd = _connect.IConnectTest_controlTestBatchEnd
    r""" a series of test case runs has ended"""
    controlPersistentVariablesInit = _connect.IConnectTest_controlPersistentVariablesInit
    r"""
    Initialize persistent variables; only possible from
    from offline status
    """
    controlPersistentVariablesClean = _connect.IConnectTest_controlPersistentVariablesClean
    r"""
    Cleanup persistent variables; only possible from
    offline status or ended status
    """
    controlPersistentVariablesApply = _connect.IConnectTest_controlPersistentVariablesApply
    r"""
    Apply changes on persistent variables; only possible from
    offline status or ended status
    """
    controlSystemTest = _connect.IConnectTest_controlSystemTest
    r""" indicates that this is a system test"""
    controlSystemTestInit = _connect.IConnectTest_controlSystemTestInit
    r""" Initialize a system test case, from offline status"""
    controlSystemTestClean = _connect.IConnectTest_controlSystemTestClean
    r""" Cleanup the system test case from the target make it offline"""
    controlSystemTestRun = _connect.IConnectTest_controlSystemTestRun
    r""" Run the initialized system test"""
    controlSystemTestStop = _connect.IConnectTest_controlSystemTestStop
    r""" stop the running system test"""

    def Control(self, dwControlFlags: "DWORD", dwHandle: "DWORD") -> "unsigned long":
        r"""
         This method modifies the state of the test case.

        :rtype: int
        :return: S_OK for success,
                    ICONNECT_S_STATUS_1 if the tested function is void and return value was created

        :type dwControlFlags: int
        :param dwControlFlags: defines action to be performed.
             See IConnectTest::EControlFlags for valid values.
        :type dwHandle: int
        :param dwHandle: handle, depending on the control flags
        """
        return _connect.IConnectTest_Control(self, dwControlFlags, dwHandle)
    sfQueryTestCase = _connect.IConnectTest_sfQueryTestCase
    r"""
    On return *pdwStatus will hold the handle of
    the test case now active.
    dwHandle is ignored and should be zero.
    """
    sfQueryStub = _connect.IConnectTest_sfQueryStub
    r"""
    On return *pdwStatus will hold the handle of
    the stub now  active.
    dwHandle is ignored and should be zero.
    """
    sfTestCase = _connect.IConnectTest_sfTestCase
    r"""
    On return *pdwStatus will hold the status of
    the test case. See also IConnectTest::EState
    for possible values.
    dwHandle specifies the test case to be queried.
    """
    sfStub = _connect.IConnectTest_sfStub
    r"""
    On return *pdwStatus will hold the status of
    the stub. See also IConnectTest::EStubState
    for possible values.
    dwHandle specifies the stub to be queried.
    """
    sfException = _connect.IConnectTest_sfException
    r"""
    On return *pdwStatus will hold the status of
    the exception.
    dwHandle specifies the exception to be queried.
    """
    stateOffline = _connect.IConnectTest_stateOffline
    r""" No test case is currently active"""
    stateInitialized = _connect.IConnectTest_stateInitialized
    r""" The test case has been initialized"""
    stateRunning = _connect.IConnectTest_stateRunning
    r""" The test case is in progress"""
    stateEnded = _connect.IConnectTest_stateEnded
    r""" The test case finished execution"""
    stateStub = _connect.IConnectTest_stateStub
    r""" The test case stopped at a stub"""
    stateUnexpectedStop = _connect.IConnectTest_stateUnexpectedStop
    r""" The test case stopped at an unexpected point"""
    stateAborted = _connect.IConnectTest_stateAborted
    r""" The test case was aborted by the user"""
    statePaused = _connect.IConnectTest_statePaused
    r""" The test case was paused by the user"""
    statePersistentReady = _connect.IConnectTest_statePersistentReady
    r""" Persistent variables initialized"""
    stateSystemTest = _connect.IConnectTest_stateSystemTest
    r""" The system test is ready to run"""
    stateStop = _connect.IConnectTest_stateStop
    r""" System test is stopped"""
    stateException = _connect.IConnectTest_stateException
    r""" The test case is stopped in exception handler"""
    stateTimeOut = _connect.IConnectTest_stateTimeOut
    r""" TestCase timed out"""
    stateStubNotActive = _connect.IConnectTest_stateStubNotActive
    r""" The stub is not active"""
    stateStubActive = _connect.IConnectTest_stateStubActive
    r""" The stub is active"""

    def GetStatus(self, dwStatusFlags: "DWORD", dwHandle: "DWORD", pdwStatus: "DWORD *") -> "unsigned long":
        r"""
         Provides status information
        :type dwHandle: int
        :param dwHandle: handle to a test object (test case, variable,
             stub, call), its meaning depends on the flags
             passed to the function the function operation and the meaning of
             the other parameters depend on this, for
             more information see IConnectTest::EStatusFlags
        :type pdwStatus: int
        :param pdwStatus: contains data on return
        """
        return _connect.IConnectTest_GetStatus(self, dwStatusFlags, dwHandle, pdwStatus)

    def CreateRealtimeStub(self, pdwStub: "DWORD *", pszFunctionName: "LPCSTR") -> "unsigned long":
        r"""Obsolete"""
        return _connect.IConnectTest_CreateRealtimeStub(self, pdwStub, pszFunctionName)

    def CreateUserStub(self, pdwStub: "DWORD *", pszFunctionName: "LPCSTR", pszUserFunctionName: "LPCSTR") -> "unsigned long":
        r"""
        Creates stub for function called by function under test. User stubs
        are used to replace a function with another. Both functions have to have
        the same parameters and return value. When setting up the stub,
        code will be patched to achieve this behavior. This could be used to
        test parts of the code with alternative implementations of functions.


        This method must be called BEFORE test case is initialized by method
        ``Control(controlTestCaseInit)``.

        :type pdwStub: int
        :param pdwStub: contains a new stub handle on return
        :type pszFunctionName: string
        :param pszFunctionName: name of the stubbed function
        """
        return _connect.IConnectTest_CreateUserStub(self, pdwStub, pszFunctionName, pszUserFunctionName)
    infoSupported = _connect.IConnectTest_infoSupported
    r"""
    Queries if the currently selected
    processor architecture in winIDEA
    is supported by iTest.
    """

    def GetInfo(self, dwInfoFlags: "DWORD", pdwInfo: "DWORD *", pszInfo: "LPSTR", dwInfoLen: "DWORD") -> "unsigned long":
        r"""
        Gets information about the iTest module and the TestManager.

        This method can be called independently of the status of the TestManager

        :type dwInfoFlags: int
        :param dwInfoFlags: specifies the type of information that is being queried
        :param dwInfo: returns numeric information
        :type pszInfo: string
        :param pszInfo: returns string information to a user allocated buffer
        :type dwInfoLen: int
        :param dwInfoLen: length of the user allocated buffer
        """
        return _connect.IConnectTest_GetInfo(self, dwInfoFlags, pdwInfo, pszInfo, dwInfoLen)
    cveRegularVariable = _connect.IConnectTest_cveRegularVariable
    r""" The function will behave as CreateVariable"""
    cvePersistentVariable = _connect.IConnectTest_cvePersistentVariable
    r"""
    The variable created will be persistent
    accross test cases. To initialize persistent
    variables call the control function using the
    flag
    """
    dveRegularVariable = _connect.IConnectTest_dveRegularVariable
    r""" The function will behave as DeleteVariable"""
    dvePersistentVariable = _connect.IConnectTest_dvePersistentVariable
    r""" The persistent variable will be deleted"""

    def CreateVariableEx(self, dwCreateVariableExFlags: "DWORD", pdwVariable: "DWORD *", pszName: "LPCSTR", pszType: "LPCSTR") -> "unsigned long":
        r"""
        Creates temporary variable, which can be used as a function parameter.
        If the variable name with this name already exists, it is hidden
        by the created variable.

        :type pdwVariable: int
        :param pdwVariable: variable handle as returned by CreateVariable()
        :type pszName: string
        :param pszName: name of the variable to be created
        :type pszType: string
        :param pszType: type of the variable. This should be one of the existing
                           types in the application under test.
        """
        return _connect.IConnectTest_CreateVariableEx(self, dwCreateVariableExFlags, pdwVariable, pszName, pszType)

    def DeleteVariableEx(self, dwDeleteVariableExFlags: "DWORD", pszName: "LPCSTR") -> "unsigned long":
        r"""
        Delete temporary variable, which can be used as a function parameter.
        If the variable name with this name already exists, it is hidden
        by the created variable.

        :param pdwVariable: variable handle as returned by CreateVariable()
        :type pszName: string
        :param pszName: name of the variable to be created
        :param pszType: type of the variable. This should be one of the existing
                           types in the application under test.
        """
        return _connect.IConnectTest_DeleteVariableEx(self, dwDeleteVariableExFlags, pszName)

    def SetTestCaseTimeOut(self, dwTimeOut: "DWORD"=0) -> "unsigned long":
        r"""
        Set a timeout for a testcase

        :param time: when to timeout in ms
        """
        return _connect.IConnectTest_SetTestCaseTimeOut(self, dwTimeOut)
    sfeAutoBreakpoints = _connect.IConnectTest_sfeAutoBreakpoints
    r""" Breakpoints are automatically set on stubbed function"""
    sfeCustomBreakpoints = _connect.IConnectTest_sfeCustomBreakpoints
    r""" Client has to set break point on location of stubbed function manually."""

    def CreateStubEx(self, dwStubFlags: "DWORD", pszFunctionName: "LPCSTR", pdwStub: "DWORD *") -> "unsigned long":
        r"""
        Creates stub for function called by function under test. Since no
        code instrumentation is allowed, breakpoint is set
        automatically or manually (depending on flags) at the given
        function. When the function is called, the test case execution stops,
        and then the test framework can define next actions. Usually it will
        simulate desired side effects of a stubbed function (for example set
        global variables), and then continue execution of the
        function under test.


        This method must be called BEFORE test case is initialized by method
        ``Control(controlTestCaseInit)``.

        :type pdwStub: int
        :param pdwStub: contains a new stub handle on return
        :type pszFunctionName: string
        :param pszFunctionName: name of the stubbed function
        :type dwStubFlags: int
        :param dwStubFlags: flags used for specified stub
        """
        return _connect.IConnectTest_CreateStubEx(self, dwStubFlags, pszFunctionName, pdwStub)
    __swig_destroy__ = _connect.delete_IConnectTest

# Register IConnectTest in _connect:
_connect.IConnectTest_swigregister(IConnectTest)

class IHILChannel(object):
    r"""This interface provides information about a HIL channel."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self) -> "LPCSTR":
        r""" Returns name of the channel ."""
        return _connect.IHILChannel_Name(self)
    mc_fl_Available = _connect.IHILChannel_mc_fl_Available
    r""" the channel is available (on hardware and not disabled)"""

    def Flags(self) -> "DWORD":
        r""" Various channel Info ."""
        return _connect.IHILChannel_Flags(self)
    mc_cit_DIN = _connect.IHILChannel_mc_cit_DIN
    r""" channel type is a digital input"""
    mc_cit_DOUT = _connect.IHILChannel_mc_cit_DOUT
    r""" channel type is digital out"""
    mc_cit_AIN = _connect.IHILChannel_mc_cit_AIN
    r""" channel type is analog input"""
    mc_cit_AOUT = _connect.IHILChannel_mc_cit_AOUT
    r""" channel type is analog out"""

    def Type(self) -> "DWORD":
        r""" Returns the channel type. `mc_cit_` items encode channel type."""
        return _connect.IHILChannel_Type(self)

    def Index(self) -> "DWORD":
        r""" Returns the index in the type group ."""
        return _connect.IHILChannel_Index(self)
    psUnit = _connect.IHILChannel_psUnit
    r""" the unit of measure (e.g. V, W,...)"""
    psQualifiedName = _connect.IHILChannel_psQualifiedName
    r""" fully qualified name (e.g. AIN.AIN0)"""

    def PropertyStr(self, eProperty: "IHILChannel::EPropertyStr") -> "LPCSTR":
        return _connect.IHILChannel_PropertyStr(self, eProperty)
    piDefault = _connect.IHILChannel_piDefault

    def PropertyInt(self, eProperty: "IHILChannel::EPropertyInt") -> "DWORD":
        return _connect.IHILChannel_PropertyInt(self, eProperty)
    pfAMin = _connect.IHILChannel_pfAMin
    r""" minimum value for an analog channel"""
    pfAMax = _connect.IHILChannel_pfAMax
    r""" maximum value for an analog channel"""

    def PropertyFlt(self, eProperty: "IHILChannel::EPropertyFlt") -> "double":
        return _connect.IHILChannel_PropertyFlt(self, eProperty)
    __swig_destroy__ = _connect.delete_IHILChannel

# Register IHILChannel in _connect:
_connect.IHILChannel_swigregister(IHILChannel)

class IHILInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Channels(self) -> "IHILChannels *":
        r""" Returns the list of Channels as IVector <IHILChannel>."""
        return _connect.IHILInfo_Channels(self)
    __swig_destroy__ = _connect.delete_IHILInfo

# Register IHILInfo in _connect:
_connect.IHILInfo_swigregister(IHILInfo)

class IConnectHIL(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxRead = _connect.IConnectHIL_ndxRead
    ndxWrite = _connect.IConnectHIL_ndxWrite
    ndxGetInfo = _connect.IConnectHIL_ndxGetInfo
    ndxAction = _connect.IConnectHIL_ndxAction
    ndxNum = _connect.IConnectHIL_ndxNum
    cPathSeparator = _connect.IConnectHIL_cPathSeparator
    r""" nested parameter type path separator"""
    cValueSeparator = _connect.IConnectHIL_cValueSeparator
    r""" parameter path and corresponding value separator"""
    cPathValuePairSeparator = _connect.IConnectHIL_cPathValuePairSeparator
    r""" multiple parameter separator"""

    def Read(self, dwFlags: "DWORD", dwGenParam: "DWORD", pszPaths: "LPCSTR", pszValues: "LPSTR", dwValuesSize: "DWORD") -> "unsigned long":
        r"""
        Reads a number of HIL parameters


        :type pszValues: string
        :param pszValues: pointer to buffer receiving the values paths of parameters to read SBZ SBZ
        :type dwValuesSize: int
        :param dwValuesSize: size of the pszValues
        """
        return _connect.IConnectHIL_Read(self, dwFlags, dwGenParam, pszPaths, pszValues, dwValuesSize)

    def Write(self, dwFlags: "DWORD", dwGenParam: "DWORD", pszValues: "LPCSTR") -> "unsigned long":
        r"""
        Writes a number of HIL parameters


        :type dwGenParam: int
        :param dwGenParam: SBZ SBZ
        :type pszValues: string
        :param pszValues: paths of parameters to write, with values
        """
        return _connect.IConnectHIL_Write(self, dwFlags, dwGenParam, pszValues)
    afNone = _connect.IConnectHIL_afNone
    afActionString = _connect.IConnectHIL_afActionString
    r""" Action.pszCommand specifies the command string"""

    def Action(self, dwFlags: "DWORD", dwGenParam: "DWORD", dwAction: "DWORD", pszPath: "LPCSTR", pszCommand: "LPCSTR", pszCommandParam: "LPCSTR") -> "unsigned long":
        r"""
        Performs action on specified path


        :type pszCommand: string
        :param pszCommand: Command to perform Scope on which to perform action Action to perform SBZ SBZ
        :type pszCommandParam: string
        :param pszCommandParam: Parameters to pass with pszCommand
        """
        return _connect.IConnectHIL_Action(self, dwFlags, dwGenParam, dwAction, pszPath, pszCommand, pszCommandParam)
    __swig_destroy__ = _connect.delete_IConnectHIL

# Register IConnectHIL in _connect:
_connect.IConnectHIL_swigregister(IConnectHIL)

class IConnectUMI(object):
    r"""This interface defines methods for controlling UMI devices"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxOperation = _connect.IConnectUMI_ndxOperation
    ndxNum = _connect.IConnectUMI_ndxNum
    wOpWrite = _connect.IConnectUMI_wOpWrite
    r""" write the data/file"""
    wOpRead = _connect.IConnectUMI_wOpRead
    r""" read the data"""
    wOpFlush = _connect.IConnectUMI_wOpFlush
    r""" program the device from the intermediate cache"""
    wOpErase = _connect.IConnectUMI_wOpErase
    r""" erase the specified region"""
    wOpVerify = _connect.IConnectUMI_wOpVerify
    r""" device contents are compared to cache"""
    wOpBlankCheck = _connect.IConnectUMI_wOpBlankCheck
    r""" device contents are compared to the empty value"""
    wOpSecure = _connect.IConnectUMI_wOpSecure
    r""" secure the device/sector"""
    wOpUnsecure = _connect.IConnectUMI_wOpUnsecure
    r""" unsecure secure the device/sector"""
    wOpSecureCheck = _connect.IConnectUMI_wOpSecureCheck
    r""" check if security is set on device/sector"""
    wOpReadHASH = _connect.IConnectUMI_wOpReadHASH
    r""" read the murmur hash of the data"""
    wOpReadPgmState = _connect.IConnectUMI_wOpReadPgmState
    r""" reads current device programed state"""
    wOpGetLastError = _connect.IConnectUMI_wOpGetLastError
    r""" reads last error message"""
    wOpFill = _connect.IConnectUMI_wOpFill
    r""" fill device with empty value"""
    wOpGetID = _connect.IConnectUMI_wOpGetID
    r""" get device ID"""
    wOpMask = _connect.IConnectUMI_wOpMask
    r""" mask to extract the operation mode from dwFlags"""
    wScopeDevice = _connect.IConnectUMI_wScopeDevice
    r""" the operation scope is entire device, otherwise aAddress and aSize are used"""
    wCheckIfOpAvailable = _connect.IConnectUMI_wCheckIfOpAvailable
    r""" check only of operation is available"""
    wProgDevice = _connect.IConnectUMI_wProgDevice
    r""" program the data into device immediately"""
    wProgCache = _connect.IConnectUMI_wProgCache
    r""" program the data into intermediate cache"""
    wProgMask = _connect.IConnectUMI_wProgMask
    r""" mask to extract the program mode from dwFlags"""
    wOverrideSafety = _connect.IConnectUMI_wOverrideSafety
    r""" perform operation even if it is disabled in configuration (e.g. Erase)"""
    wFileFormatAuto = _connect.IConnectUMI_wFileFormatAuto
    r""" auto detect file format"""
    wFileFormatBin = _connect.IConnectUMI_wFileFormatBin
    r""" binary format"""
    wFileFormatS = _connect.IConnectUMI_wFileFormatS
    r""" Motorola S"""
    wFileFormatHex = _connect.IConnectUMI_wFileFormatHex
    r""" Intel Hex"""
    wFileFormatMask = _connect.IConnectUMI_wFileFormatMask
    r""" mask to extract the format from dwFlags"""

    def Operation(self, dwFlags: "DWORD", dwDevice: "DWORD", aAddress: "uint32_t", aSize: "uint32_t", pbyData: "BYTE *", pszFileName: "LPCSTR") -> "unsigned long":
        r"""
        Writes data to the device or intermediate cache


        :type pbyData: BYTE
        :param pbyData: pointer to the buffer to be written, read, receive HASH or file to load size of the data to write/read/hash/erase/secure, ignored if file is programmed address to write/read/hash/erase/secure or offset to add to the address in the file index of the UMI device EOperationFlags
        :type pszFileName: string
        :param pszFileName: path to the file to program
        """
        return _connect.IConnectUMI_Operation(self, dwFlags, dwDevice, aAddress, aSize, pbyData, pszFileName)
    HASH_SIZE = _connect.IConnectUMI_HASH_SIZE
    __swig_destroy__ = _connect.delete_IConnectUMI

# Register IConnectUMI in _connect:
_connect.IConnectUMI_swigregister(IConnectUMI)
IID_IConnectUMI = cvar.IID_IConnectUMI

indxEclipse = _connect.indxEclipse
class SInfo(object):
    r"""This struct conatins general target info."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_dwNumRegisters = property(_connect.SInfo_m_dwNumRegisters_get, _connect.SInfo_m_dwNumRegisters_set, doc=r""" the number of registers on the target""")

    def __init__(self):
        _connect.SInfo_swiginit(self, _connect.new_SInfo())
    __swig_destroy__ = _connect.delete_SInfo

# Register SInfo in _connect:
_connect.SInfo_swigregister(SInfo)
IID_IConnectEclipse = cvar.IID_IConnectEclipse

class SRegisterInfo(object):
    r"""This structure contains information about register."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_szRegName = property(_connect.SRegisterInfo_m_szRegName_get, _connect.SRegisterInfo_m_szRegName_set, doc=r""" register name, for example 'R0'""")
    m_Type = property(_connect.SRegisterInfo_m_Type_get, _connect.SRegisterInfo_m_Type_set, doc=r""" register type, usually unsignd int""")

    def __init__(self):
        _connect.SRegisterInfo_swiginit(self, _connect.new_SRegisterInfo())
    __swig_destroy__ = _connect.delete_SRegisterInfo

# Register SRegisterInfo in _connect:
_connect.SRegisterInfo_swigregister(SRegisterInfo)

class IDisassemblyLine(object):
    r"""This interface provides information about one disassmbly line."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Address(self) -> "ADDRESS_64":
        r""" Returns address of disassembly line."""
        return _connect.IDisassemblyLine_Address(self)

    def OpCode(self) -> "LPCSTR":
        r""" Returns disassembly op code."""
        return _connect.IDisassemblyLine_OpCode(self)

    def OpCodeArgs(self) -> "LPCSTR":
        r""" Returns disassembly op code arguments."""
        return _connect.IDisassemblyLine_OpCodeArgs(self)

    def FileName(self) -> "LPCSTR":
        r""" Returns the name of the source file, which generated this disassembly line."""
        return _connect.IDisassemblyLine_FileName(self)

    def LineNumber(self) -> "DWORD":
        r""" Returns the source line number in the source file, which generated this disassembly line."""
        return _connect.IDisassemblyLine_LineNumber(self)

    def FunctionName(self) -> "LPCSTR":
        r""" Returns the name of the function, to which this disassembly line belongs to"""
        return _connect.IDisassemblyLine_FunctionName(self)

    def FunctionOffset(self) -> "ADDRESS_64":
        
        return _connect.IDisassemblyLine_FunctionOffset(self)

    def IsBranch(self) -> "bool":
        r""" Returns true if the op-code is a branch"""
        return _connect.IDisassemblyLine_IsBranch(self)

    def IsCall(self) -> "bool":
        r""" Returns true if the op-code is a call"""
        return _connect.IDisassemblyLine_IsCall(self)

    def IsIndirect(self) -> "bool":
        r""" Returns true if the op-code is an indirect branch. BranchTarget is not valid"""
        return _connect.IDisassemblyLine_IsIndirect(self)

    def IsConditional(self) -> "bool":
        r""" Returns true if the op-code is conditional"""
        return _connect.IDisassemblyLine_IsConditional(self)

    def Length(self) -> "BYTE":
        r""" Returns the length of the op-code"""
        return _connect.IDisassemblyLine_Length(self)

    def BranchTarget(self) -> "ADDRESS_64":
        r""" Returns the (direct)branch target address"""
        return _connect.IDisassemblyLine_BranchTarget(self)

    def Flags(self) -> "uint16_t":
        r""" Returns instruction NDisassemble::EINST_Flags."""
        return _connect.IDisassemblyLine_Flags(self)

    def INST_TYPE(self) -> "uint16_t":
        r""" Returns instruction NDisassemble::EINST_TYPE."""
        return _connect.IDisassemblyLine_INST_TYPE(self)

    def INST_TYPE_CPU(self) -> "uint16_t":
        r""" Returns instruction NDisassemble::EINST_TYPE_CPU."""
        return _connect.IDisassemblyLine_INST_TYPE_CPU(self)
    __swig_destroy__ = _connect.delete_IDisassemblyLine

# Register IDisassemblyLine in _connect:
_connect.IDisassemblyLine_swigregister(IDisassemblyLine)

class IDisassemblyBlock(object):
    r"""
    This interface provides disassembly information. To get one block
    of disassembly information, call IConnectEclipse::GetDisassemblySrc()
    or IConnectEclipse::GetDisassemblyAdr().


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Lines(self) -> "iEclipse::IDisassemblyLines *":
        r""" Returns the vector of disassembly lines: IVector <iEclipse::IDisassemblyLine>."""
        return _connect.IDisassemblyBlock_Lines(self)
    __swig_destroy__ = _connect.delete_IDisassemblyBlock

# Register IDisassemblyBlock in _connect:
_connect.IDisassemblyBlock_swigregister(IDisassemblyBlock)

class IVariable(object):
    r"""This interface provides information about a program variable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self) -> "LPCSTR":
        r"""
        Returns variable name without any decoration (module, partition, ...),
        for example 'iCounter'.
        """
        return _connect.IVariable_Name(self)

    def QualifiedName(self) -> "LPCSTR":
        r"""
        Returns variable qualified name used for display. This name is not fully
        qualified, but depends on setting in winiDEA (for example just enough decorated
        to be unique).
        """
        return _connect.IVariable_QualifiedName(self)

    def TypeName(self) -> "LPCSTR":
        r""" Returns variable type name."""
        return _connect.IVariable_TypeName(self)

    def NumBytes(self) -> "DWORD":
        r""" Reserved, currently always returns 0."""
        return _connect.IVariable_NumBytes(self)
    tSimple = _connect.IVariable_tSimple
    r""" simple type"""
    tPointer = _connect.IVariable_tPointer
    r""" pointer"""
    tReference = _connect.IVariable_tReference
    r""" reference"""
    tArray = _connect.IVariable_tArray
    r""" array"""
    tStruct = _connect.IVariable_tStruct
    r""" structure"""
    tUnion = _connect.IVariable_tUnion
    r""" union"""
    tClass = _connect.IVariable_tClass
    r""" class"""
    tFunction = _connect.IVariable_tFunction
    r""" function"""

    def Type(self) -> "BYTE":
        r""" Returns variable type, as enumeration type IVariable::EType."""
        return _connect.IVariable_Type(self)

    def ArrayDimension(self) -> "DWORD":
        r""" Returns array dimension for arrays, 0 for all other variables."""
        return _connect.IVariable_ArrayDimension(self)

    def Module(self) -> "WORD":
        r""" Returns index of the module, where the variable is located."""
        return _connect.IVariable_Module(self)

    def Scope(self) -> "LPCSTR":
        r"""
         Returns variable scope - e.g. class name.
        Since: 9.11.26
        """
        return _connect.IVariable_Scope(self)

    def ArrayFirstElement(self) -> "LONG":
        r"""
         Returns first element index. 0 for C arrays.
        Since: 9.12.102
        """
        return _connect.IVariable_ArrayFirstElement(self)

    def MemArea(self) -> "BYTE":
        r"""
         Returns the memory area
        Since: 9.12.171
        """
        return _connect.IVariable_MemArea(self)

    def Address(self) -> "ADDRESS_64":
        r"""
         Returns the starting address
        Since: 9.12.171
        """
        return _connect.IVariable_Address(self)

    def Size(self) -> "ADDRESS_64":
        r"""
         Returns the size
        Since: 9.12.171
        """
        return _connect.IVariable_Size(self)

    def GetIType(self) -> "iEclipse::IType *":
        r"""
         Returns extended type info
        Since: 9.12.268
        """
        return _connect.IVariable_GetIType(self)
    __swig_destroy__ = _connect.delete_IVariable

# Register IVariable in _connect:
_connect.IVariable_swigregister(IVariable)

class ICallee(object):
    r"""This interface provides information about a callee - a function called from a certain point."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def CallSite(self) -> "ADDRESS_64":
        r""" Address of call instruction."""
        return _connect.ICallee_CallSite(self)

    def DirectCall(self) -> "bool":
        r""" true if the call is a direct call."""
        return _connect.ICallee_DirectCall(self)

    def Callee(self) -> "ADDRESS_64":
        r""" Address of the called function."""
        return _connect.ICallee_Callee(self)
    __swig_destroy__ = _connect.delete_ICallee

# Register ICallee in _connect:
_connect.ICallee_swigregister(ICallee)

class ICaller(object):
    r"""This interface provides information about a caller - a function/address which calls a certain point/function."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def CallSite(self) -> "ADDRESS_64":
        r""" Address of call instruction."""
        return _connect.ICaller_CallSite(self)
    __swig_destroy__ = _connect.delete_ICaller

# Register ICaller in _connect:
_connect.ICaller_swigregister(ICaller)

class IFunction(object):
    r"""This interface provides information about a function."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self) -> "LPCSTR":
        r"""
        Returns function name without any decoration (module, partition, ...),
        for example 'max'.
        """
        return _connect.IFunction_Name(self)

    def Scope(self) -> "LPCSTR":
        r""" Returns function scope - e.g. class name."""
        return _connect.IFunction_Scope(self)

    def ReturnTypeName(self) -> "LPCSTR":
        r""" Returns function's return type."""
        return _connect.IFunction_ReturnTypeName(self)

    def Module(self) -> "WORD":
        r""" Returns index of the module, where the function is located."""
        return _connect.IFunction_Module(self)

    def Parameters(self) -> "iEclipse::IVariables *":
        r"""
         Returns the list of parameters.
        Since: 9.10.100
        """
        return _connect.IFunction_Parameters(self)

    def Variables(self) -> "iEclipse::IVariables *":
        r"""
         Returns the list of local variables.
        Since: 9.12.98
        """
        return _connect.IFunction_Variables(self)

    def QualifiedName(self) -> "LPCSTR":
        r"""
        Returns function qualified name used for display. This name is not fully
        qualified, but depends on setting in winiDEA (for example just enough decorated
        to be unique).

        Since: 9.12.163
        """
        return _connect.IFunction_QualifiedName(self)

    def MemArea(self) -> "BYTE":
        r"""
         Returns the memory area
        Since: 9.12.171
        """
        return _connect.IFunction_MemArea(self)

    def Address(self) -> "ADDRESS_64":
        r"""
         Returns the starting address
        Since: 9.12.171
        """
        return _connect.IFunction_Address(self)

    def Size(self) -> "ADDRESS_64":
        r"""
         Returns the size
        Since: 9.12.171
        """
        return _connect.IFunction_Size(self)

    def SignatureName(self) -> "LPCSTR":
        r"""
         Returns the signature name - qualified with parameters
        Since: 9.12.194
        """
        return _connect.IFunction_SignatureName(self)

    def HasVarParams(self) -> "bool":
        r"""
         Returns true if function accepts variable number of parameters
        Since: 9.12.270
        """
        return _connect.IFunction_HasVarParams(self)

    def Callees(self) -> "iEclipse::ICallees *":
        r"""
         Returns the list of callees
        Since: 9.12.272
        """
        return _connect.IFunction_Callees(self)

    def Callers(self) -> "iEclipse::ICallers *":
        r"""
         Returns the list of callers
        Since: 9.12.272
        """
        return _connect.IFunction_Callers(self)
    __swig_destroy__ = _connect.delete_IFunction

# Register IFunction in _connect:
_connect.IFunction_swigregister(IFunction)

class IType(object):
    r"""
    This interface provides information about a type.
    Since: 9.11.15
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def TypeName(self) -> "LPCSTR":
        r""" Returns name of type."""
        return _connect.IType_TypeName(self)

    def Type(self) -> "SType2 const *":
        r""" Returns type of type."""
        return _connect.IType_Type(self)
    __swig_destroy__ = _connect.delete_IType

# Register IType in _connect:
_connect.IType_swigregister(IType)

class ITypedef(object):
    r"""
    This interface provides information about a typedef.
    Since: 9.11.15
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self) -> "LPCSTR":
        r""" Returns name of typedef"""
        return _connect.ITypedef_Name(self)

    def TypeName(self) -> "LPCSTR":
        r""" Returns name of type"""
        return _connect.ITypedef_TypeName(self)
    __swig_destroy__ = _connect.delete_ITypedef

# Register ITypedef in _connect:
_connect.ITypedef_swigregister(ITypedef)

class IMacro(object):
    r"""
    This interface provides information about a Macro.
    Since: 9.12.128
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self) -> "LPCSTR":
        r""" Returns name of Macro"""
        return _connect.IMacro_Name(self)

    def Value(self) -> "LPCSTR":
        r""" Returns value of macro"""
        return _connect.IMacro_Value(self)
    __swig_destroy__ = _connect.delete_IMacro

# Register IMacro in _connect:
_connect.IMacro_swigregister(IMacro)

class IInstruction(object):
    r"""
    This interface provides information about an instruction
    Since: 9.12.171
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    flFlowSequential = _connect.IInstruction_flFlowSequential
    r""" sequential instruction"""
    flFlowDirectJump = _connect.IInstruction_flFlowDirectJump
    r""" a direct change of flow. m_aJumpTarget is valid"""
    flFlowIndirectJump = _connect.IInstruction_flFlowIndirectJump
    r""" an indirect change of flow"""
    flFlowMask = _connect.IInstruction_flFlowMask
    flConditional = _connect.IInstruction_flConditional
    r""" instruction is conditional"""
    flCall = _connect.IInstruction_flCall
    r""" call to a routine which will return and resume execution after this instruction"""
    flRelative = _connect.IInstruction_flRelative
    r""" valid for flFlowDirectJump - if code is offset, the m_aJumpTarget will be offset too. original m_aJumpTarget is NOT relative to m_aAddress, but is already real jump target"""
    flWrite = _connect.IInstruction_flWrite
    r""" execution of opcode will generate a write access"""
    flRead = _connect.IInstruction_flRead
    r""" execution of opcode will generate a read access"""

    def OpCode(self) -> "LPCSTR":
        r""" returns op-code string. A tab character is used to separate op-code from arguments"""
        return _connect.IInstruction_OpCode(self)

    def Address(self) -> "ADDRESS_64":
        r""" returns Address of instruction"""
        return _connect.IInstruction_Address(self)

    def JumpTarget(self) -> "ADDRESS_64":
        r""" returns JumpTarget of instruction"""
        return _connect.IInstruction_JumpTarget(self)

    def Size(self) -> "DWORD":
        r""" returns length of instrution in MAUs"""
        return _connect.IInstruction_Size(self)

    def Flags(self) -> "DWORD":
        r""" returns flXXXX masked flags"""
        return _connect.IInstruction_Flags(self)

    def MemAccessSize(self) -> "DWORD":
        r""" for flWrite|flRead size of access in MAUs"""
        return _connect.IInstruction_MemAccessSize(self)
    __swig_destroy__ = _connect.delete_IInstruction

# Register IInstruction in _connect:
_connect.IInstruction_swigregister(IInstruction)

class IStackFrame(object):
    r"""This interface provides information about a stack frame."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Address(self) -> "ADDRESS_64":
        r""" Returns address of a stack frame."""
        return _connect.IStackFrame_Address(self)

    def MemoryArea(self) -> "BYTE":
        r""" Returns memory area of a stack frame."""
        return _connect.IStackFrame_MemoryArea(self)

    def FileName(self) -> "LPCSTR":
        r""" Returns name of file, where the execution point is located."""
        return _connect.IStackFrame_FileName(self)

    def LineNumber(self) -> "DWORD":
        r""" Returns the source code line number, where the execution point is located."""
        return _connect.IStackFrame_LineNumber(self)

    def FunctionName(self) -> "LPCSTR":
        r""" Returns the name of a function. Deprecated: use Function()"""
        return _connect.IStackFrame_FunctionName(self)

    def Variables(self) -> "iEclipse::IVariables *":
        r""" Returns local variables of this stack frame."""
        return _connect.IStackFrame_Variables(self)

    def Arguments(self) -> "iEclipse::IVariables *":
        r""" Returns function arguments. Deprecated: use Function()"""
        return _connect.IStackFrame_Arguments(self)

    def Function(self) -> "iEclipse::IFunction *":
        r"""
         Returns function information. Can return NULL if no function is found at the call site Address
        Since: 9.11.35
        """
        return _connect.IStackFrame_Function(self)

    def Partition(self) -> "DWORD":
        r"""
         Returns Partition index.
        Since: 9.12.34
        """
        return _connect.IStackFrame_Partition(self)
    __swig_destroy__ = _connect.delete_IStackFrame

# Register IStackFrame in _connect:
_connect.IStackFrame_swigregister(IStackFrame)

class IStackFrameInfo(object):
    r"""This interface provides access to stack frames."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def StackFrames(self) -> "iEclipse::IStackFrames *":
        r""" Returns a list of the current stack frames."""
        return _connect.IStackFrameInfo_StackFrames(self)
    __swig_destroy__ = _connect.delete_IStackFrameInfo

# Register IStackFrameInfo in _connect:
_connect.IStackFrameInfo_swigregister(IStackFrameInfo)

class IExpressionType(object):
    r"""
    This interface provides information about expressions. Use method
    IEclipse::GetExpressionType() to get instance of this interface.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Expression(self) -> "iEclipse::IVariable *":
        r""" Returns information about expression."""
        return _connect.IExpressionType_Expression(self)

    def Children(self) -> "iEclipse::IVariables *":
        r"""
        Returns children of an expression as IVector <iEclipse::IVariable>.
             For example, if expression refers
             to structure, members of the structure are returned.
        """
        return _connect.IExpressionType_Children(self)
    __swig_destroy__ = _connect.delete_IExpressionType

# Register IExpressionType in _connect:
_connect.IExpressionType_swigregister(IExpressionType)

class IModule(object):
    r"""This interface provides information about a module."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self) -> "LPCSTR":
        r""" Returns the name of a module, for example 'main.c'."""
        return _connect.IModule_Name(self)

    def Path(self) -> "LPCSTR":
        r""" Returns the path of the module and module name, for example 'src\common\main.c'."""
        return _connect.IModule_Path(self)
    __swig_destroy__ = _connect.delete_IModule

# Register IModule in _connect:
_connect.IModule_swigregister(IModule)

class IGlobals(object):
    r"""
    This interface provides information about global members of a progem.
    Use method IConnectEclipse::GetGlobals() to get isntance of object with
    this interface. Only information requested by flags of function
    IConnectEclipse::GetGlobals() is available. For example:

    IConnectEclipse::GetGlobals(gvfVariables, ...)

    After this call only IGlobals::Variables() will return data, other
    calls will return empty vectors.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Variables(self) -> "iEclipse::IVariables *":
        r""" Returns the list of global variables."""
        return _connect.IGlobals_Variables(self)

    def Labels(self) -> "iEclipse::IVariables *":
        r""" Returns the list of global labels."""
        return _connect.IGlobals_Labels(self)

    def Modules(self) -> "iEclipse::IModules *":
        r""" Returns the list of modules (source files, which generate code)."""
        return _connect.IGlobals_Modules(self)

    def Functions(self) -> "iEclipse::IFunctions *":
        r""" Returns the list of functions."""
        return _connect.IGlobals_Functions(self)

    def Types(self) -> "iEclipse::ITypes *":
        r"""
         Returns the list of types
        Since: 9.11.15
        """
        return _connect.IGlobals_Types(self)

    def Typedefs(self) -> "iEclipse::ITypedefs *":
        r"""
         Returns the list of typedefs
        Since: 9.11.15
        """
        return _connect.IGlobals_Typedefs(self)

    def Macros(self) -> "iEclipse::IMacros *":
        r"""
         Returns the list of macros
        Since: 9.12.128
        """
        return _connect.IGlobals_Macros(self)

    def Instructions(self) -> "iEclipse::IInstructions *":
        r"""
         Returns the list of instructions
        Since: 9.12.171
        """
        return _connect.IGlobals_Instructions(self)
    __swig_destroy__ = _connect.delete_IGlobals

# Register IGlobals in _connect:
_connect.IGlobals_swigregister(IGlobals)

class IPartition(object):
    r"""
    This interface provides information about partition. Partitions are
    download files (for example elf files). Call method IConnectEclipse::GetConfiguration
    to get instance of interface IConfiguration, which provides information
    about partitions.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self) -> "LPCSTR":
        r""" Returns partition name."""
        return _connect.IPartition_Name(self)

    def Path(self) -> "LPCSTR":
        r""" Returns partition path."""
        return _connect.IPartition_Path(self)
    __swig_destroy__ = _connect.delete_IPartition

# Register IPartition in _connect:
_connect.IPartition_swigregister(IPartition)

class IConfiguration(object):
    r"""
    This interface provides info about program configuration. Call
    method IEclipse::GetConfiguration() to get instance of this interface.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Partitions(self) -> "iEclipse::IPartitions *":
        r"""
        Returns vector of all partitions (download files) in the program
        as IVector <iEclipse::IPartition>.
        """
        return _connect.IConfiguration_Partitions(self)
    __swig_destroy__ = _connect.delete_IConfiguration

# Register IConfiguration in _connect:
_connect.IConfiguration_swigregister(IConfiguration)

class ISFRValueMap(object):
    r"""This interface provides value of a SFR."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def String(self) -> "LPCSTR":
        r""" Returns SFR's value as a string, for example names of bits."""
        return _connect.ISFRValueMap_String(self)

    def Value(self) -> "DWORD":
        r""" Returns SFR's value."""
        return _connect.ISFRValueMap_Value(self)

    def Description(self) -> "LPCSTR":
        r""" Returns description for this value."""
        return _connect.ISFRValueMap_Description(self)
    __swig_destroy__ = _connect.delete_ISFRValueMap

# Register ISFRValueMap in _connect:
_connect.ISFRValueMap_swigregister(ISFRValueMap)

class ISFR(object):
    r"""This interface provides information about SFR."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Handle(self) -> "DWORD":
        r"""
        Returns SFR handle. Use this handle to obtain value in calls
             to IConnectEclipse::SFRValue().
        """
        return _connect.ISFR_Handle(self)

    def HasValue(self) -> "BOOL":
        r""" If FALSE is returned, it's a SFR group."""
        return _connect.ISFR_HasValue(self)

    def Name(self) -> "LPCSTR":
        r""" Returns name of a SFR or SFR group."""
        return _connect.ISFR_Name(self)

    def BitSize(self) -> "DWORD":
        r""" Returns size of a SFR in bits."""
        return _connect.ISFR_BitSize(self)
    pRead = _connect.ISFR_pRead
    r""" we can read the register"""
    pWrite = _connect.ISFR_pWrite
    r""" we can write to the register"""
    pSubReg = _connect.ISFR_pSubReg
    r""" sub-field of a parent register"""
    pFloat = _connect.ISFR_pFloat
    r""" it is a floating point register"""

    def Properties(self) -> "DWORD":
        r""" Returns SFR properties. See enumeration ISFR::EProperties."""
        return _connect.ISFR_Properties(self)

    def ValueMaps(self) -> "iEclipse::ISFRValueMaps *":
        r""" Returns mappings of values to descriptive strings."""
        return _connect.ISFR_ValueMaps(self)

    def SFRs(self) -> "iEclipse::ISFRs *":
        r""" If this is a SFR group, this method returns its children as IVector <iEclipse::ISFR>."""
        return _connect.ISFR_SFRs(self)

    def Description(self) -> "LPCSTR":
        r""" Returns SFR description string."""
        return _connect.ISFR_Description(self)

    def Address(self) -> "ADDRESS_64":
        r""" Returns SFR address."""
        return _connect.ISFR_Address(self)

    def BitOffset(self) -> "DWORD":
        r""" Returns SFR bit offset from parent."""
        return _connect.ISFR_BitOffset(self)
    __swig_destroy__ = _connect.delete_ISFR

# Register ISFR in _connect:
_connect.ISFR_swigregister(ISFR)

class ICPUSFR(object):
    r"""
    This interface provides SFRs. Call method IEclipse::GetCPUSFR() to get
    instance of this interface.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def CPUName(self) -> "LPCSTR":
        r""" Returns name of a CPU."""
        return _connect.ICPUSFR_CPUName(self)

    def SFRs(self) -> "iEclipse::ISFRs *":
        r""" Returns the list of SFRs as IVector <iEclipse::ISFR>."""
        return _connect.ICPUSFR_SFRs(self)

    def Property(self) -> "isys::IProperty *":
        r""" Returns the list of requested properties as IVector <iEclipse::IProperty>."""
        return _connect.ICPUSFR_Property(self)
    __swig_destroy__ = _connect.delete_ICPUSFR

# Register ICPUSFR in _connect:
_connect.ICPUSFR_swigregister(ICPUSFR)
sName = cvar.sName
iBitsPerMAU = cvar.iBitsPerMAU
iStart = cvar.iStart
iEnd = cvar.iEnd

class IConnectEclipse(object):
    r"""
    This interface is intended for iSystem's implementation of Eclipse
    debugger. It is accessible only from C++ and Java wrapper of
    isystem.connect.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetInfo = _connect.IConnectEclipse_ndxGetInfo
    ndxGetRegisterInfo = _connect.IConnectEclipse_ndxGetRegisterInfo
    ndxGetDisassemblySrc = _connect.IConnectEclipse_ndxGetDisassemblySrc
    ndxGetDisassemblyAdr = _connect.IConnectEclipse_ndxGetDisassemblyAdr
    ndxGetStackFrameInfo = _connect.IConnectEclipse_ndxGetStackFrameInfo
    ndxSetStackFrameContext = _connect.IConnectEclipse_ndxSetStackFrameContext
    ndxGetExpressionType = _connect.IConnectEclipse_ndxGetExpressionType
    ndxGetGlobals = _connect.IConnectEclipse_ndxGetGlobals
    ndxGetConfiguration = _connect.IConnectEclipse_ndxGetConfiguration
    ndxGetCPUSFR = _connect.IConnectEclipse_ndxGetCPUSFR
    ndxSFRValue = _connect.IConnectEclipse_ndxSFRValue
    ndxRemoteFileOperation = _connect.IConnectEclipse_ndxRemoteFileOperation
    ndxNum = _connect.IConnectEclipse_ndxNum

    def GetInfo(self, dwFlags: "DWORD", pInfo: "SInfo") -> "unsigned long":
        r"""
        Obtains general info about the target, not provided with other methods.

        :type dwFlags: int
        :param dwFlags: must be zero
        """
        return _connect.IConnectEclipse_GetInfo(self, dwFlags, pInfo)

    def GetRegisterInfo(self, dwFlags: "DWORD", dwRegister: "DWORD", pInfo: "SRegisterInfo") -> "unsigned long":
        r"""
        Provides info about a register. Only main registers can be accessed
        by this method. Use GetCPUSFR() and SFRValue() to access SFRs.

        :type dwFlags: int
        :param dwFlags: must be zero
        :type dwRegister: int
        :param dwRegister: register index. Call GetInfo() to get the number
                   of registers on the target. Index should be in range [0 .. SInfo.m_dwNumRegisters - 1]

        :rtype: int
        :return: E_INVALIDARG if nRegister is too large
        """
        return _connect.IConnectEclipse_GetRegisterInfo(self, dwFlags, dwRegister, pInfo)
    dfSymNone = _connect.IConnectEclipse_dfSymNone
    r""" values only, for example 'bl 400002D4'"""
    dfSymSymbols = _connect.IConnectEclipse_dfSymSymbols
    r""" symbols only, for example 'bl targetInit'"""
    dfSymSymbolsAndValues = _connect.IConnectEclipse_dfSymSymbolsAndValues
    r""" symbols with values, for example 'bl targetInit (400002D4)'"""
    dfSymMask = _connect.IConnectEclipse_dfSymMask
    r""" mask"""
    dfNextNone = _connect.IConnectEclipse_dfNextNone
    r""" no NextInstruction is required"""
    dfNextImm = _connect.IConnectEclipse_dfNextImm
    r""" NextInstruction for immediate encoded targets required"""
    dfNextAll = _connect.IConnectEclipse_dfNextAll
    r""" NextInstruction for all instructions requires"""
    dfNextMask = _connect.IConnectEclipse_dfNextMask
    r""" mask"""
    sfiActiveFrameOnly = _connect.IConnectEclipse_sfiActiveFrameOnly
    r"""
    if this flag is set, then only the active frame
    is returned. This speeds up stack retrieval
    signifcantly.
    """
    sfiAbsolutePath = _connect.IConnectEclipse_sfiAbsolutePath
    r""" return absolute paths in IStackFrame"""

    def SetStackFrameContext(self, dwFlags: "DWORD", dwContext: "DWORD") -> "unsigned long":
        r"""
        Sets active stack frame. Variables of the selected stack frame are
        available for evaluator (methods DataController::evaluate() and
        DataController::mofify()).

        :type dwFlags: int
        :param dwFlags: reserved, should be 0
        :type dwContext: int
        :param dwContext: index of the stack frame to be selected
        """
        return _connect.IConnectEclipse_SetStackFrameContext(self, dwFlags, dwContext)
    gvfVariables = _connect.IConnectEclipse_gvfVariables
    r""" retrieve global variables"""
    gvfLabels = _connect.IConnectEclipse_gvfLabels
    r""" retrieve labels"""
    gvfModules = _connect.IConnectEclipse_gvfModules
    r""" retrieve modules (source files, which generate code)"""
    gvfFunctions = _connect.IConnectEclipse_gvfFunctions
    r""" retrieve functions"""
    gvfTypes = _connect.IConnectEclipse_gvfTypes
    r""" retrieve types"""
    gvfTypedefs = _connect.IConnectEclipse_gvfTypedefs
    r""" retrieve typedefs"""
    gvfMacros = _connect.IConnectEclipse_gvfMacros
    r""" retrieve typedefs"""
    gvfInstructions = _connect.IConnectEclipse_gvfInstructions
    r""" retrieve instructions"""
    gvfMask = _connect.IConnectEclipse_gvfMask
    r""" the mask for gvf flags"""
    gvfSortAddress = _connect.IConnectEclipse_gvfSortAddress
    r""" sort returned items by address"""
    gvfSortName = _connect.IConnectEclipse_gvfSortName
    r""" sort returned items by name"""
    gvfSortMask = _connect.IConnectEclipse_gvfSortMask
    r""" the mask for gvfSort flags"""
    gvfPartitionSpecify = _connect.IConnectEclipse_gvfPartitionSpecify
    r""" use dwPartition"""
    gvfPartitionDefault = _connect.IConnectEclipse_gvfPartitionDefault
    r""" use winIDEA default debug partition"""
    gvfPartitionCurrent = _connect.IConnectEclipse_gvfPartitionCurrent
    r""" use winIDEA current partition"""
    gvfPartitionMask = _connect.IConnectEclipse_gvfPartitionMask
    r""" mask for gvfPartition flags"""
    gcsSFRs = _connect.IConnectEclipse_gcsSFRs
    r""" provide SFRs in the rpICPUSFR, via ICPUSFR::SFRs"""
    gcsGPRs = _connect.IConnectEclipse_gcsGPRs
    r""" provide GPRs in the rpICPUSFR, via ICPUSFR::Property /GPRs"""
    gcsAreas = _connect.IConnectEclipse_gcsAreas
    r""" provide SFRs in the rpICPUSFR, via ICPUSFR::Property /Areas"""
    svRead = _connect.IConnectEclipse_svRead
    r""" read value"""
    svWrite = _connect.IConnectEclipse_svWrite
    r""" set value"""
    svWriteThenRead = _connect.IConnectEclipse_svWriteThenRead
    r""" sometime the read value is not the same as the written one"""
    svNoRefresh = _connect.IConnectEclipse_svNoRefresh
    r""" do not refresh IDE after write"""
    svErrorInfo = _connect.IConnectEclipse_svErrorInfo
    r""" provide error info"""

    def SFRValue(self, dwFlags: "DWORD", dwHandle: "DWORD", rValue: "SValue", pszError: "LPSTR", dwErrorLen: "DWORD") -> "unsigned long":
        r"""
        Reads and writes values of SFRs.

        :type dwFlags: int
        :param dwFlags: see ESFRValue for possible values. Flags svNoRefresh and
                   svErrorInfo may be ORed with other flags.
        :type dwHandle: int
        :param dwHandle: handle of the SFR. Use method GetCPUSFR() to get handles
                   of SFRs.
        """
        return _connect.IConnectEclipse_SFRValue(self, dwFlags, dwHandle, rValue, pszError, dwErrorLen)
    rfoExists = _connect.IConnectEclipse_rfoExists
    r""" check existence. S_OK if exists, S_FALSE if not"""
    rfoDelete = _connect.IConnectEclipse_rfoDelete
    r""" Delete the file. S_OK if successful, S_FALSE if it didn't exist, E_FAIL if operation failed"""
    rfoRead = _connect.IConnectEclipse_rfoRead
    r""" reads the file, contents returned in pIBuffer"""
    rfoWrite = _connect.IConnectEclipse_rfoWrite
    r""" writes the file, contents passed in pIBuffer"""
    rfoOpMask = _connect.IConnectEclipse_rfoOpMask
    r""" mask to extrace operation from dwFlags"""

    def RemoteFileOperation(self, dwFlags: "DWORD", pszFileName: "char const *", rdwP1: "DWORD &", rdwP2: "DWORD &", pIBuffer: "IBuffer *") -> "unsigned long":
        r"""
        Operates on a file

        :type dwFlags: int
        :param dwFlags: see rfoXXXX for possible values.
        :type pszFileName: string
        :param pszFileName: path to the file as seen by the server side
        :param dwP1: reserved SBZ
        :param dwP2: reserved SBZ
        :type pIBuffer: IBuffer
        :param pIBuffer: buffer object, must be allocated by the caller for Read (empty, filled by server) and Write Operations
        """
        return _connect.IConnectEclipse_RemoteFileOperation(self, dwFlags, pszFileName, rdwP1, rdwP2, pIBuffer)
    __swig_destroy__ = _connect.delete_IConnectEclipse

# Register IConnectEclipse in _connect:
_connect.IConnectEclipse_swigregister(IConnectEclipse)

class CPropertyWrapper(object):
    r"""Wrapper for IProperty interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pIProperty: "isys::IProperty *"):
        _connect.CPropertyWrapper_swiginit(self, _connect.new_CPropertyWrapper(pIProperty))

    def IsValid(self) -> "bool":
        r"""
        Returns true, if this object contains valid data (pointer to wrapped
        interface is not NULL).
        """
        return _connect.CPropertyWrapper_IsValid(self)

    def Find(self, pszKey: "LPCSTR") -> "isys::IProperty *":
        r""" Returns pointer to sub-property pszKey or NULL if not found."""
        return _connect.CPropertyWrapper_Find(self, pszKey)

    def Key(self) -> "LPCSTR":
        r""" Returns key of this property."""
        return _connect.CPropertyWrapper_Key(self)

    def Value(self) -> "LPCSTR":
        r""" Returns value of this property."""
        return _connect.CPropertyWrapper_Value(self)

    def PropertyValue(self, pszKey: "LPCSTR") -> "LPCSTR":
        r""" Returns value of a sub-property pszKey or NULL if not found."""
        return _connect.CPropertyWrapper_PropertyValue(self, pszKey)

    def NumProperties(self) -> "DWORD":
        r""" Returns the number of sub-properties."""
        return _connect.CPropertyWrapper_NumProperties(self)

    def Property(self, dwIndex: "DWORD") -> "CPropertyWrapper":
        r""" Returns wrapper for sub-property, can be invalid."""
        return _connect.CPropertyWrapper_Property(self, dwIndex)
    __swig_destroy__ = _connect.delete_CPropertyWrapper

# Register CPropertyWrapper in _connect:
_connect.CPropertyWrapper_swigregister(CPropertyWrapper)

class IMenuItem(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    tItem = _connect.IMenuItem_tItem
    tMenu = _connect.IMenuItem_tMenu
    tSeparator = _connect.IMenuItem_tSeparator

    def Type(self) -> "isys::IMenuItem::EType":
        return _connect.IMenuItem_Type(self)

    def Name(self) -> "LPCSTR":
        r""" Returns tItem or tMenu name."""
        return _connect.IMenuItem_Name(self)

    def Command(self) -> "DWORD":
        r""" Returns the command for the tItem."""
        return _connect.IMenuItem_Command(self)
    stateEnabled = _connect.IMenuItem_stateEnabled
    r""" Returns the state for the tItem."""
    stateChecked = _connect.IMenuItem_stateChecked
    stateDialogBox = _connect.IMenuItem_stateDialogBox
    r""" command will open dialog box"""

    def State(self) -> "DWORD":
        return _connect.IMenuItem_State(self)

    def MenuItems(self) -> "isys::IMenuItems *":
        r""" Returns the men subitems."""
        return _connect.IMenuItem_MenuItems(self)
    __swig_destroy__ = _connect.delete_IMenuItem

# Register IMenuItem in _connect:
_connect.IMenuItem_swigregister(IMenuItem)

class IMenuStructure(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Root(self) -> "isys::IMenuItems *":
        return _connect.IMenuStructure_Root(self)

    def RootItem(self) -> "isys::IMenuItem *":
        return _connect.IMenuStructure_RootItem(self)
    __swig_destroy__ = _connect.delete_IMenuStructure

# Register IMenuStructure in _connect:
_connect.IMenuStructure_swigregister(IMenuStructure)

class SVariantData(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_ulSize = property(_connect.SVariantData_m_ulSize_get, _connect.SVariantData_m_ulSize_set, doc=r""" size of the data structure""")

    def __init__(self):
        _connect.SVariantData_swiginit(self, _connect.new_SVariantData())
    __swig_destroy__ = _connect.delete_SVariantData

# Register SVariantData in _connect:
_connect.SVariantData_swigregister(SVariantData)

ofValNone = _connect.ofValNone
r""" operation other than set or get is performed"""
ofValString = _connect.ofValString
r""" single option, string type value"""
ofValInt = _connect.ofValInt
r""" single option, integer type value"""
ofValFloat = _connect.ofValFloat
r""" single option, float type value"""
ofValStringInt = _connect.ofValStringInt
r""" single option, string type, but string is int encoded for int types. No enum or TRUE/FALSE are used"""
ofValBuffer = _connect.ofValBuffer
r""" all options. pszOption not used, pszString is source/destination"""
ofValNode = _connect.ofValNode
r""" all options. pszOption is URL to the data node to be ser-des'd. JSON encode"""
ofValMask = _connect.ofValMask
ofDestIDE = _connect.ofDestIDE
r""" destination is the global IDE"""
ofDestDocument = _connect.ofDestDocument
r""" destination is a document"""
ofDestIOPEN = _connect.ofDestIOPEN
r""" destination is isystem.open plugin"""
ofDestPlugin = _connect.ofDestPlugin
r""" destination is isystem.plugin plugin"""
ofDestHIL = _connect.ofDestHIL
r""" destination is isystem.hil plugin"""
ofDestAuto = _connect.ofDestAuto
r""" destination is decoded from first /<dest>/ item"""
ofDestMask = _connect.ofDestMask
r""" destination mask"""
ofSet = _connect.ofSet
r""" set the option"""
ofGet = _connect.ofGet
r""" retrieve the option"""
ofAdd = _connect.ofAdd
r""" Add an item to a dynamic data, at index SOptionValue.m_dwInteger (-1 for append)"""
ofRemove = _connect.ofRemove
r""" remove an item from dynamic data, at index SOptionValue.m_dwInteger (-1 to remove all)"""
ofGetSize = _connect.ofGetSize
r""" return size of dynamic data in SOptionValue.m_dwInteger"""
ofCall = _connect.ofCall
r"""
    pszOption specifies the function path, SOptionValue.m_pszStringIn the input parameters, SOptionValue.m_pszStringOut the output parameters
    in/out parameters are encoded as a sequence of <name1>:<value1>, .., <nameN>:<valueN>
    """
ofGetType = _connect.ofGetType
r""" return type of container (IDataDescriptor::EContainer) in SOptionValue.m_dwInteger"""
ofGetEnum = _connect.ofGetEnum
r"""
    return enum values in SOptionValue.m_pszStringOut, format "<name1>":<value1>, .., "<nameN>":<valueN>>
    SOptionValue.m_dwInteger will be set to 1 if the URL is an enum, 0 otherwise
    """
ofMask = _connect.ofMask
r""" mask to extract set/get/add/remove option"""
ofCommit = _connect.ofCommit
r"""
    commit the options configured - this should be
    the ultimate call after a one or more ofSet calls. This
    flag should be ORed wit hone of ofDest... flags.
    Parameters ``pszScope`` and ``pszOption`` of IConnectIDE3::Option()
    may be NULL, while ``pValue`` should be initialized to 0, except
    out buffer, which receives error description in case of error.
    """
ofGetDescriptor = _connect.ofGetDescriptor
r""" get the data descriptor. returned in SOptionValue.m_pIDescriptor"""
ofGetMenu = _connect.ofGetMenu
r""" get the menu structure"""
ofGetObjectMask = _connect.ofGetObjectMask
r""" mask for getting objects (descriptor, menu)"""
ofUseDescriptor = _connect.ofUseDescriptor
r""" use the SOptionValue.m_pIDescriptor on input"""
ofReservedBit0 = _connect.ofReservedBit0
ofReservedBit1 = _connect.ofReservedBit1
ofReservedMask = _connect.ofReservedMask
r""" mask for reserved bits which can be used for internal purpose"""
ofExact = _connect.ofExact
r""" set this option exactly - no side effects (adjusting other options) should take place"""
OPTION_URL_DestIDE = _connect.OPTION_URL_DestIDE
r"""
    Example for using data creation

    SOptionValue OV; SVariantData_SetSize_ZeroInit(OV);
    // create a copy of data for "Analyzer Setup"
    LPCSTR pszDataName = "Analyzer Setup";
    pIXXX->Option(ofDataCreate | ofGetDescriptor, pszDataName, &OV);
    // remember descriptor
    IDescriptor * pID = OV.m_pIDescriptor;

    // manipulate data
    // ensure descriptor from copy of data
    OV.m_pIDescriptor = pID;
    pIXXX->Option(ofUseDescriptor | ofSet | ofValInt, "...", &OV);
    ...

    // release descriptor
    pID->Release();

    // apply data
    pIXXX->Option(ofDataApply,    pszDataName, &OV);

    // discard data
    pIXXX->Option(ofDataDestroy,  pszDataName, &OV);
    """
OPTION_URL_DestDocument = _connect.OPTION_URL_DestDocument
OPTION_URL_DestIOPEN = _connect.OPTION_URL_DestIOPEN
OPTION_URL_DestPlugin = _connect.OPTION_URL_DestPlugin
OPTION_URL_DestHIL = _connect.OPTION_URL_DestHIL
oseDataChanged = _connect.oseDataChanged
oseDescChanged = _connect.oseDescChanged
class SOptionValue(SVariantData):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_cPathSeparator = property(_connect.SOptionValue_m_cPathSeparator_get, _connect.SOptionValue_m_cPathSeparator_set, doc=r""" separator between variable and struct element names, if 0, assumed .""")
    m_cValueSeparator = property(_connect.SOptionValue_m_cValueSeparator_get, _connect.SOptionValue_m_cValueSeparator_set, doc=r""" separator between option and its value, if 0, assumed  :""")
    m_cOptionSeparator = property(_connect.SOptionValue_m_cOptionSeparator_get, _connect.SOptionValue_m_cOptionSeparator_set, doc=r""" separator between value and the next option, if 0, assumed""")
    m_bySideEffects = property(_connect.SOptionValue_m_bySideEffects_get, _connect.SOptionValue_m_bySideEffects_set, doc=r""" [out] uses EOptionSideEffects to specify any side effect of a ofSet operation""")
    m_pszStringIn = property(_connect.SOptionValue_m_pszStringIn_get, _connect.SOptionValue_m_pszStringIn_set, doc=r""" ofValString or ofValBuffer on input""")
    m_dwStringOutSize = property(_connect.SOptionValue_m_dwStringOutSize_get, _connect.SOptionValue_m_dwStringOutSize_set, doc=r""" size of buffer pointed to by m_pszStringOut""")
    cn_dwStringOutUsesIAString = _connect.SOptionValue_cn_dwStringOutUsesIAString

    def UsesIAString(self) -> "bool":
        return _connect.SOptionValue_UsesIAString(self)

    def HasStringOut(self) -> "bool":
        return _connect.SOptionValue_HasStringOut(self)
    m_dwInteger = property(_connect.SOptionValue_m_dwInteger_get, _connect.SOptionValue_m_dwInteger_set, doc=r""" ofValInt""")
    m_dFloat = property(_connect.SOptionValue_m_dFloat_get, _connect.SOptionValue_m_dFloat_set, doc=r""" ofValFloat""")

    def __init__(self):
        _connect.SOptionValue_swiginit(self, _connect.new_SOptionValue())
    __swig_destroy__ = _connect.delete_SOptionValue

# Register SOptionValue in _connect:
_connect.SOptionValue_swigregister(SOptionValue)

DD_INF_SEPARATOR = _connect.DD_INF_SEPARATOR
DD_INF_TOKEN_LEADER = _connect.DD_INF_TOKEN_LEADER
DD_INF_FILE_FILTER = _connect.DD_INF_FILE_FILTER
DD_INF_FILE_DEFEXT = _connect.DD_INF_FILE_DEFEXT
DD_INF_GUI = _connect.DD_INF_GUI
DD_INF_VALUE_FORMAT = _connect.DD_INF_VALUE_FORMAT
DD_INF_OPTIONS_ID = _connect.DD_INF_OPTIONS_ID
DD_INF_GUI_DATA = _connect.DD_INF_GUI_DATA
DD_INF_GUI_SHORT = _connect.DD_INF_GUI_SHORT
DD_INF_FILE_FOLDER = _connect.DD_INF_FILE_FOLDER
DD_INF_HELP = _connect.DD_INF_HELP
DD_INF_KEY_ALT = _connect.DD_INF_KEY_ALT
DD_INF_RGB_T = _connect.DD_INF_RGB_T
DD_INF_RGB_B = _connect.DD_INF_RGB_B
DD_INF_GUI_SHORTCUT = _connect.DD_INF_GUI_SHORTCUT
optDisabled = _connect.optDisabled
r""" this item is currently not available"""
optRDOnly = _connect.optRDOnly
r""" this item can not be modified"""
optHidden = _connect.optHidden
r""" not shown in dumps"""
optNoSerialize = _connect.optNoSerialize
r""" do not serialize this item"""
optHex = _connect.optHex
r""" integer preferred display is hex. string with this flag indicates that it has binary content which should be hex encoded for display/serdes"""
optBitField = _connect.optBitField
r""" the data consumes only a part of the specified underlying type. bitoffset and bitsize are given with optBitFieldOffs and optBitFiledSize. values within underlying type are treated as 'value'. e.g. values for offset 2 are {0, 1, 2, 3,...}"""
optValueSet = _connect.optValueSet
r""" this data object is immediately followed by a bool which will be set to true following any ofSet operation"""
optBitMask = _connect.optBitMask
r""" same as optBitField, but the values within underlying type are treated as 'mask'. e.g. values for offset 2 are {0, 4, 8, C,...}"""
optBitFieldMask = _connect.optBitFieldMask
r""" for probing if bit extraction is applicable"""
optReserved16 = _connect.optReserved16
optReserved17 = _connect.optReserved17
optReserved18 = _connect.optReserved18
optDebug = _connect.optDebug
r""" used or debugging"""
optBitFieldSize_Pos = _connect.optBitFieldSize_Pos
r""" for optBitField, size of the field starts at this bit in the options"""
optBitFieldSize_Num = _connect.optBitFieldSize_Num
r""" for optBitField, this many bits are used for bitfield size (e.g. supports 64 bits)"""
optBitFieldOffs_Pos = _connect.optBitFieldOffs_Pos
r""" for optBitField, offs of the field starts at this bit in the options"""
optBitFieldOffs_Num = _connect.optBitFieldOffs_Num
r""" for optBitField, this many bits are used for bitfield offs (e.g. supports 64 bits)"""
optKindDefault = _connect.optKindDefault
r""" no special meaning"""
optKindFilePath = _connect.optKindFilePath
r"""
    the string value is a file path, allow file browsing.
    DD_INF_FILE_FILTER parameter in Info is the file type string for dialog selection. e.g. "Readme File"DD_INF_FILE_FILTER"Text files(*.txt)|*.txt|All files (*.*)|*.*||"
    DD_INF_FILE_DEFEXT parameter in Info is the file default extension. e.g. "Readme File"DD_INF_FILE_FILTER"Text files(*.txt)|*.txt|All files (*.*)|*.*||"DD_INF_FILE_DEFEXT"txt"
    use optMiscValMask to obtain a reference path to which this path should be kept relative
    """
optKindFilePath_Open = _connect.optKindFilePath_Open
r""" create file open dialog, if not set create file save dialog"""
optKindFilePath_Overwrite = _connect.optKindFilePath_Overwrite
r""" display overwrite prompt"""
optKindFilePath_RelMask = _connect.optKindFilePath_RelMask
r""" relative path mask"""
optKindFilePath_RelWorkspace = _connect.optKindFilePath_RelWorkspace
r""" keep path relative to workspace"""
optKindFilePath_RelEXE = _connect.optKindFilePath_RelEXE
r""" keep path relative to executable"""
optKindFilePath_RelMacro = _connect.optKindFilePath_RelMacro
r""" attempt relative conversion to a macro"""
optKindSymbol = _connect.optKindSymbol
r""" the string value is a symbol expression, allow symbol browsing"""
optKindColor = _connect.optKindColor
r""" the 32-bit int is a RGB value, allow color browsing"""
optKindFont = _connect.optKindFont
r""" the string value is a font face, allow font browsing"""
optKindFolder = _connect.optKindFolder
r"""
    the string value is a folder path, allow folder browsing.
    use optMiscValMask to obtain a reference path to which this path should be kept relative
    """
optKindUser = _connect.optKindUser
r""" reserved for user extensions"""
optKindMask = _connect.optKindMask
r""" mask to extract the 'kind'"""
optMiscValMask = _connect.optMiscValMask
r""" mask to extract the Kind specific options"""

def BitFieldSize(ulOptions: "uint32_t") -> "unsigned char":
    return _connect.BitFieldSize(ulOptions)

def BitFieldOffs(ulOptions: "uint32_t") -> "unsigned char":
    return _connect.BitFieldOffs(ulOptions)
class IEnumMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Value(self) -> "int":
        return _connect.IEnumMap_Value(self)

    def Name(self) -> "char const *":
        return _connect.IEnumMap_Name(self)

    def Info(self) -> "char const *":
        return _connect.IEnumMap_Info(self)

    def Options(self) -> "uint32_t":
        return _connect.IEnumMap_Options(self)
    __swig_destroy__ = _connect.delete_IEnumMap

# Register IEnumMap in _connect:
_connect.IEnumMap_swigregister(IEnumMap)

class IItemDescriptor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self) -> "char const *":
        return _connect.IItemDescriptor_Name(self)

    def DataDescriptor(self) -> "DataDescriptor::IDataDescriptor const *":
        return _connect.IItemDescriptor_DataDescriptor(self)

    def Dimension(self) -> "uint32_t":
        r""" 0 for no array"""
        return _connect.IItemDescriptor_Dimension(self)

    def ArrayIndex(self) -> "DataDescriptor::IEnumMaps const *":
        r"""
        a static array can have symbolic array indexes
        Valid only for arrays 0 != Dimension(), returns NULL otherwise.
        """
        return _connect.IItemDescriptor_ArrayIndex(self)

    def Info(self) -> "char const *":
        r""" text description"""
        return _connect.IItemDescriptor_Info(self)

    def Options(self) -> "uint32_t":
        r""" additional info EOptions"""
        return _connect.IItemDescriptor_Options(self)

    def EnumOptions(self, pIEnumMap: "IEnumMap") -> "uint32_t":
        r""" returns Options of the pIEnumMap"""
        return _connect.IItemDescriptor_EnumOptions(self, pIEnumMap)

    def Offset(self) -> "uint32_t":
        r""" offset from start of structure"""
        return _connect.IItemDescriptor_Offset(self)

    def Data(self) -> "void *":
        r""" pointer to start of variable in memory"""
        return _connect.IItemDescriptor_Data(self)
    __swig_destroy__ = _connect.delete_IItemDescriptor

# Register IItemDescriptor in _connect:
_connect.IItemDescriptor_swigregister(IItemDescriptor)

class IDataDescriptor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    tbool = _connect.IDataDescriptor_tbool
    tBOOL = _connect.IDataDescriptor_tBOOL
    tINT = _connect.IDataDescriptor_tINT
    tUINT = _connect.IDataDescriptor_tUINT
    tFLOAT = _connect.IDataDescriptor_tFLOAT
    tENUM = _connect.IDataDescriptor_tENUM
    tSTRUCT = _connect.IDataDescriptor_tSTRUCT
    tSTRING = _connect.IDataDescriptor_tSTRING
    r""" char [Size]"""
    tstdString = _connect.IDataDescriptor_tstdString
    r""" std::string"""
    tIDataBase = _connect.IDataDescriptor_tIDataBase
    r""" IDataBase *"""

    def Type(self) -> "DataDescriptor::IDataDescriptor::EType":
        return _connect.IDataDescriptor_Type(self)

    def Size(self) -> "uint32_t":
        r""" size in MAUs"""
        return _connect.IDataDescriptor_Size(self)

    def Struct(self) -> "DataDescriptor::IItemDescriptors const *":
        return _connect.IDataDescriptor_Struct(self)

    def Enum(self) -> "DataDescriptor::IEnumMaps const *":
        r"""
        Returns mapping of available enum values.
        Valid only when type is tENUM.
        Returns NULL othervise.
        """
        return _connect.IDataDescriptor_Enum(self)
    cNone = _connect.IDataDescriptor_cNone
    r""" regular data object as specified in EType"""
    cIDArray = _connect.IDataDescriptor_cIDArray
    r""" EType defines the type of object kept in an IDArray* container"""

    def Container(self) -> "DataDescriptor::IDataDescriptor::EContainer":
        r""" type of the container keeping the elements"""
        return _connect.IDataDescriptor_Container(self)
    __swig_destroy__ = _connect.delete_IDataDescriptor

# Register IDataDescriptor in _connect:
_connect.IDataDescriptor_swigregister(IDataDescriptor)

class IDescriptor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VariableDescriptors(self) -> "DataDescriptor::IItemDescriptors const *":
        return _connect.IDescriptor_VariableDescriptors(self)
    __swig_destroy__ = _connect.delete_IDescriptor

# Register IDescriptor in _connect:
_connect.IDescriptor_swigregister(IDescriptor)

cDefaultPathSeparator = _connect.cDefaultPathSeparator
cDefaultValueSeparator = _connect.cDefaultValueSeparator
cDefaultOptionSeparator = _connect.cDefaultOptionSeparator

def PathSeparator(c: "char") -> "char":
    return _connect.PathSeparator(c)

def ValueSeparator(c: "char") -> "char":
    return _connect.ValueSeparator(c)

def OptionSeparator(c: "char") -> "char":
    return _connect.OptionSeparator(c)
class ICodeCache(object):
    r"""This interface maintains multiple memory item"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    cfNoData = _connect.ICodeCache_cfNoData
    r""" do not copy data"""
    cfData = _connect.ICodeCache_cfData
    r""" copy data"""
    dtEqual = _connect.ICodeCache_dtEqual
    r""" this part was in both and was equal"""
    dtNotIn1 = _connect.ICodeCache_dtNotIn1
    r""" this part was not in first ICodeCache"""
    dtNotIn2 = _connect.ICodeCache_dtNotIn2
    r""" this part was not in second ICodeCache"""
    dtDif = _connect.ICodeCache_dtDif
    r""" this part was in both, but content differs"""
    dfReportEqual = _connect.ICodeCache_dfReportEqual
    r""" report locations with equal contents"""
    dfReportNotIn1 = _connect.ICodeCache_dfReportNotIn1
    r""" report locations that are not in first ICodeCache"""
    dfReportNotIn2 = _connect.ICodeCache_dfReportNotIn2
    r""" report locations that are not in second ICodeCache"""
    dfReportDif = _connect.ICodeCache_dfReportDif
    r""" report locations with different contents"""
    dfReportAllDif = _connect.ICodeCache_dfReportAllDif
    r""" report all differing locations and missing in one or other"""
    dfReportAll = _connect.ICodeCache_dfReportAll
    r""" report everything"""
    sfAddressSize4 = _connect.ICodeCache_sfAddressSize4
    r""" save 32-bit addresses"""
    sfAddressSize8 = _connect.ICodeCache_sfAddressSize8
    r""" save 64-bit addresses"""
    sfAddressMask = _connect.ICodeCache_sfAddressMask
    sfData = _connect.ICodeCache_sfData
    r""" serialize data"""
    sfMAUSize = _connect.ICodeCache_sfMAUSize
    r""" serialize also MAUSize - not included per default in legacy saves"""
    lFormatAuto = _connect.ICodeCache_lFormatAuto
    r""" automatically detect file type"""
    lFormatMotorolaS = _connect.ICodeCache_lFormatMotorolaS
    r""" use MotorolaS format"""
    lFormatIntelHex = _connect.ICodeCache_lFormatIntelHex
    r""" use Intel hex format"""
    lFormatBinary = _connect.ICodeCache_lFormatBinary
    r""" use binary format"""
    lFormatELF = _connect.ICodeCache_lFormatELF
    r""" use ELF format"""
    lFormatMask = _connect.ICodeCache_lFormatMask
    lAllowOverlap = _connect.ICodeCache_lAllowOverlap
    r""" tolerate overlaps when loading"""
    lSaveBytes10 = _connect.ICodeCache_lSaveBytes10
    r""" when saving save 0x10 bytes per line"""
    lSaveBytes20 = _connect.ICodeCache_lSaveBytes20
    r""" when saving save 0x20 bytes per line"""
    lSaveBytes40 = _connect.ICodeCache_lSaveBytes40
    r""" when saving save 0x40 bytes per line"""
    lSaveBytes80 = _connect.ICodeCache_lSaveBytes80
    r""" when saving save 0x80 bytes per line"""
    lSaveBytesMask = _connect.ICodeCache_lSaveBytesMask
    lOptionELF_Addr_PH_Virtual = _connect.ICodeCache_lOptionELF_Addr_PH_Virtual
    r""" use ELF ProgramHeader virtual as load address"""
    lOptionELF_Addr_PH_Physical = _connect.ICodeCache_lOptionELF_Addr_PH_Physical
    r""" use ELF ProgramHeader physical as load address"""
    lOptionELF_Addr_Mask = _connect.ICodeCache_lOptionELF_Addr_Mask
    r""" mask for Elf Address"""
    lOptionELF_IgnoreZeros = _connect.ICodeCache_lOptionELF_IgnoreZeros
    r""" ignore headers with zero content"""
    lOptionMask = _connect.ICodeCache_lOptionMask
    E_OPEN = _connect.ICodeCache_E_OPEN
    E_FORMAT = _connect.ICodeCache_E_FORMAT
    E_OVERLAPPING = _connect.ICodeCache_E_OVERLAPPING
    E_ADDRESSRANGE = _connect.ICodeCache_E_ADDRESSRANGE
    E_NOTSUPPORTED = _connect.ICodeCache_E_NOTSUPPORTED
    rfTypeNormal = _connect.ICodeCache_rfTypeNormal
    r""" report contents"""
    rfTypeDif = _connect.ICodeCache_rfTypeDif
    r""" the object contains dif between m_pICC1 and m_pICC2 - report dif"""
    rfTypeMask = _connect.ICodeCache_rfTypeMask
    r""" mask for report type"""
    rfAppend = _connect.ICodeCache_rfAppend
    r""" append to file rather than overwrite"""
    rfAlign = _connect.ICodeCache_rfAlign
    r""" align addresses to m_dwMaxMAUsPerLine"""

    def Report(self, dwFlags: "DWORD", pszFileName: "LPCSTR", rReport: "ICodeCache::SReport const &") -> "unsigned long":
        return _connect.ICodeCache_Report(self, dwFlags, pszFileName, rReport)

    def Offset(self, aOffset: "TCC_ADDRESS") -> "void":
        r"""
        offset all records


        :type aOffset: TCC_ADDRESS
        :param aOffset: amount to offset
        """
        return _connect.ICodeCache_Offset(self, aOffset)
    EParam_AI_OK = _connect.ICodeCache_EParam_AI_OK
    EParam_AI_FAIL = _connect.ICodeCache_EParam_AI_FAIL

    def SetParam(self, eParam: "ICodeCache::EParam", dwValue: "DWORD") -> "void":
        return _connect.ICodeCache_SetParam(self, eParam, dwValue)
    __swig_destroy__ = _connect.delete_ICodeCache

# Register ICodeCache in _connect:
_connect.ICodeCache_swigregister(ICodeCache)

class SBatchAccessHeader(object):
    r""" Defines the number, type and timeframe of access to perform."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flWantTimeStamp = _connect.SBatchAccessHeader_flWantTimeStamp
    r""" return time stamp of every access"""
    flAbortIfTooSlow = _connect.SBatchAccessHeader_flAbortIfTooSlow
    r""" if interval and item times can not be kept, abort batch"""
    flRealTime = _connect.SBatchAccessHeader_flRealTime
    r""" use real-time access"""
    flStopResume = _connect.SBatchAccessHeader_flStopResume
    r""" stop to perform the operation then resume"""
    baDomainDefault = _connect.SBatchAccessHeader_baDomainDefault
    r""" execute the access in the default domain"""
    baDomainHost = _connect.SBatchAccessHeader_baDomainHost
    r""" execute the access in the PC host domain"""
    baDomainEmulator = _connect.SBatchAccessHeader_baDomainEmulator
    r""" execute the access in the emulator domain"""
    baDomainMask = _connect.SBatchAccessHeader_baDomainMask
    m_dwFlags = property(_connect.SBatchAccessHeader_m_dwFlags_get, _connect.SBatchAccessHeader_m_dwFlags_set, doc=r""" flags""")
    m_dwNumItems = property(_connect.SBatchAccessHeader_m_dwNumItems_get, _connect.SBatchAccessHeader_m_dwNumItems_set, doc=r"""
    number of items in arrays ``pBatchAccessItems`` and
    ``pBatchAccessItemResult`` given as parameters
    to IConnectDebug2::BatchAccess()
    """)
    m_dwNumRuns = property(_connect.SBatchAccessHeader_m_dwNumRuns_get, _connect.SBatchAccessHeader_m_dwNumRuns_set, doc=r""" how many times should the batch be repeated""")
    m_qwStartAtTime = property(_connect.SBatchAccessHeader_m_qwStartAtTime_get, _connect.SBatchAccessHeader_m_qwStartAtTime_set, doc=r""" absolute time for batch start. 0 for immediate start""")
    m_qwRunInterval = property(_connect.SBatchAccessHeader_m_qwRunInterval_get, _connect.SBatchAccessHeader_m_qwRunInterval_set, doc=r""" microseconds for interval repeat. 0 for immediate repeat""")

    def __init__(self):
        _connect.SBatchAccessHeader_swiginit(self, _connect.new_SBatchAccessHeader())
    __swig_destroy__ = _connect.delete_SBatchAccessHeader

# Register SBatchAccessHeader in _connect:
_connect.SBatchAccessHeader_swigregister(SBatchAccessHeader)

class SBatchAccessItem(object):
    r"""Defines the type and time of an individual access."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MAX_DATA_SIZE = _connect.SBatchAccessItem_MAX_DATA_SIZE
    flRead = _connect.SBatchAccessItem_flRead
    r""" read by default"""
    flWrite = _connect.SBatchAccessItem_flWrite
    r""" write by default"""
    flTimeOffsetRel = _connect.SBatchAccessItem_flTimeOffsetRel
    r""" if set, the m_qwTimeOffset is considered to previous item (in case of first item to the begin of interval)"""
    flAccessSizeAuto = _connect.SBatchAccessItem_flAccessSizeAuto
    r""" access size enforcement. flAccessSizeAuto lets the debugger pick the most appropriate size"""
    flAccessSize1MAU = _connect.SBatchAccessItem_flAccessSize1MAU
    r""" access size enforcement"""
    flAccessSize2MAU = _connect.SBatchAccessItem_flAccessSize2MAU
    r""" access size enforcement"""
    flAccessSize4MAU = _connect.SBatchAccessItem_flAccessSize4MAU
    r""" access size enforcement"""
    flAccessSize8MAU = _connect.SBatchAccessItem_flAccessSize8MAU
    r""" access size enforcement"""
    flAccessSizeMask = _connect.SBatchAccessItem_flAccessSizeMask
    m_byFlags = property(_connect.SBatchAccessItem_m_byFlags_get, _connect.SBatchAccessItem_m_byFlags_set, doc=r""" flags""")
    m_bySize = property(_connect.SBatchAccessItem_m_bySize_get, _connect.SBatchAccessItem_m_bySize_set, doc=r""" MAU Size""")
    m_byMemArea = property(_connect.SBatchAccessItem_m_byMemArea_get, _connect.SBatchAccessItem_m_byMemArea_set, doc=r""" memory area""")
    m_byReserved = property(_connect.SBatchAccessItem_m_byReserved_get, _connect.SBatchAccessItem_m_byReserved_set, doc=r""" reserved, should be 0""")
    m_aAddress = property(_connect.SBatchAccessItem_m_aAddress_get, _connect.SBatchAccessItem_m_aAddress_set, doc=r""" address""")
    m_abyData = property(_connect.SBatchAccessItem_m_abyData_get, _connect.SBatchAccessItem_m_abyData_set, doc=r""" data""")
    m_qwTimeOffset = property(_connect.SBatchAccessItem_m_qwTimeOffset_get, _connect.SBatchAccessItem_m_qwTimeOffset_set, doc=r"""
    time offset in microsec from the beginning of the interval (flag flTimeOffsetRel is not set) or
    prev item (flag flTimeOffsetRel is set). 0 for immediately after prev item.
    """)

    def __init__(self):
        _connect.SBatchAccessItem_swiginit(self, _connect.new_SBatchAccessItem())
    __swig_destroy__ = _connect.delete_SBatchAccessItem

# Register SBatchAccessItem in _connect:
_connect.SBatchAccessItem_swigregister(SBatchAccessItem)

class SBatchAccessItemResult(object):
    r"""
    Pointer to an array of objects that will receive the results of
    every individual access.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    resOK = _connect.SBatchAccessItemResult_resOK
    r""" access OK"""
    resAccess = _connect.SBatchAccessItemResult_resAccess
    r""" access failure"""
    resTimeout = _connect.SBatchAccessItemResult_resTimeout
    r""" access not performed due to to timeout"""
    m_byResult = property(_connect.SBatchAccessItemResult_m_byResult_get, _connect.SBatchAccessItemResult_m_byResult_set, doc=r""" result""")
    m_abyData = property(_connect.SBatchAccessItemResult_m_abyData_get, _connect.SBatchAccessItemResult_m_abyData_set, doc=r""" result data""")
    m_qwTimeStamp = property(_connect.SBatchAccessItemResult_m_qwTimeStamp_get, _connect.SBatchAccessItemResult_m_qwTimeStamp_set, doc=r""" absolute time stamp, microseconds""")

    def __init__(self):
        _connect.SBatchAccessItemResult_swiginit(self, _connect.new_SBatchAccessItemResult())
    __swig_destroy__ = _connect.delete_SBatchAccessItemResult

# Register SBatchAccessItemResult in _connect:
_connect.SBatchAccessItemResult_swigregister(SBatchAccessItemResult)

class SProfilerStartingPoint(object):
    r"""Specifies the trigger condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    eAnything = _connect.SProfilerStartingPoint_eAnything
    r""" start immediately"""
    eExecution = _connect.SProfilerStartingPoint_eExecution
    r""" execution from a specified address"""
    m_aAddress = property(_connect.SProfilerStartingPoint_m_aAddress_get, _connect.SProfilerStartingPoint_m_aAddress_set, doc=r""" used for eRead, eWrite, eRW""")
    m_byEvent = property(_connect.SProfilerStartingPoint_m_byEvent_get, _connect.SProfilerStartingPoint_m_byEvent_set, doc=r""" trigger event, see SProfilerStartingPoint::EEvent""")
    m_byMemArea = property(_connect.SProfilerStartingPoint_m_byMemArea_get, _connect.SProfilerStartingPoint_m_byMemArea_set, doc=r""" memory area of ``m_aAddress``""")

    def __init__(self):
        _connect.SProfilerStartingPoint_swiginit(self, _connect.new_SProfilerStartingPoint())
    __swig_destroy__ = _connect.delete_SProfilerStartingPoint

# Register SProfilerStartingPoint in _connect:
_connect.SProfilerStartingPoint_swigregister(SProfilerStartingPoint)

acquTrace = _connect.acquTrace
acquDAQ = _connect.acquDAQ
acquSampling = _connect.acquSampling
acquInspector = _connect.acquInspector
acquNetwork = _connect.acquNetwork
acquIOM = _connect.acquIOM
acq_NUM = _connect.acq_NUM
edaqFastest = _connect.edaqFastest
edaqNormal = _connect.edaqNormal
edaqSlow = _connect.edaqSlow
vtState = _connect.vtState
r""" a state variable - limited number of states"""
vtLSB_Exit_Entry = _connect.vtLSB_Exit_Entry
r""" deprecated."""
vtZero_Exit_Entry = _connect.vtZero_Exit_Entry
r""" zero indicates exit from current area (activation/deactivation)"""
vtRegular = _connect.vtRegular
r""" regular variable. history is not kept for every individual value"""
vtSampling = _connect.vtSampling
r""" sampling variable, shows count % for each state"""
pdvdHex = _connect.pdvdHex
pdvdDec = _connect.pdvdDec
pdvdBin = _connect.pdvdBin
hValueInvalid = _connect.hValueInvalid
r""" invalid value handle"""
hpInvalid = _connect.hpInvalid
r""" invalid handle"""
plNone = _connect.plNone
r""" non context object"""
plTask = _connect.plTask
r""" task level context"""
plIRQ_Lowest = _connect.plIRQ_Lowest
r""" lowest level IRQ"""
plIRQ_Highest = _connect.plIRQ_Highest
r""" highest level IRQ"""
plApplication = _connect.plApplication
r""" application"""
plRunnable = _connect.plRunnable
r""" runnable object"""
plSignal = _connect.plSignal
r""" special OS signaling / EProfilerOSSignal"""
plSpecial = _connect.plSpecial
r""" special"""
plNum = _connect.plNum
possUnknown = _connect.possUnknown
r""" unknown signal"""
possContextRET = _connect.possContextRET
r""" return from current context to previously preempted context"""
possContextRET_OS = _connect.possContextRET_OS
r""" return from current context to OS scheduler"""
class SProfilerHistory(object):
    r"""
    Contains profiler history.

    *SProfilerHistory::m_dwValue* will hold values as by *EValue* enum for all
    execution areas (*afTypeFunction*, *afTypeRoutine*) and for data areas
    (*afTypeVariable*, *afTypeRegion*) of type *vtState*,
    *vtLSB_Exit_Entry*, *vtZero_Exit_Entry* if history is obtained with
    *rfFilterValue*. For *vtRegular* or data areas obtained without
    *rfFilterValue*, the value holds the value written to the object.

    The first item for any history will always be on time 0. This item is inserted
    explicitly. If histories for all areas are retrieved, the first item will have handle
    value *hpInvalid*.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_dwHandle = property(_connect.SProfilerHistory_m_dwHandle_get, _connect.SProfilerHistory_m_dwHandle_set, doc=r""" handle of the area for which this history is for""")
    m_dwValue = property(_connect.SProfilerHistory_m_dwValue_get, _connect.SProfilerHistory_m_dwValue_set, doc=r"""
    contains information about recorded event:
    - for functions see SProfilerHistory::EValue
    - for variables it contains:
      - variable's value, if *IConnectProfiler::rfAllAreas* flag is used
      - state, if *IConnectProfiler::rfFilterValue | IConnectProfiler::rfByHandle*
        is used; when the value changes to filter value, *m_dwValue* is set to
        *valExecActive | 1* (0x80000001), when it changes to other value,
        *m_dwValue* is set to *valExecInactive (0)*
    """)
    m_qwTime = property(_connect.SProfilerHistory_m_qwTime_get, _connect.SProfilerHistory_m_qwTime_set, doc=r""" hit time in nanoseconds""")
    valExecEntry = _connect.SProfilerHistory_valExecEntry
    r""" the area (function) entered"""
    valExecSuspend = _connect.SProfilerHistory_valExecSuspend
    r""" the area (function) called another function"""
    valExecResume = _connect.SProfilerHistory_valExecResume
    r""" the area (function) resumed from another function call"""
    valExecExit = _connect.SProfilerHistory_valExecExit
    r""" the area (function) exited"""

    def __init__(self):
        _connect.SProfilerHistory_swiginit(self, _connect.new_SProfilerHistory())
    __swig_destroy__ = _connect.delete_SProfilerHistory

# Register SProfilerHistory in _connect:
_connect.SProfilerHistory_swigregister(SProfilerHistory)

UNKNOWN_TASK_ID = _connect.UNKNOWN_TASK_ID
class SProfilerEncode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    eNone = _connect.SProfilerEncode_eNone
    r""" no special encoding"""
    eStop_Start_Id_LSB = _connect.SProfilerEncode_eStop_Start_Id_LSB
    r"""
    a series of data
    stop bit located at first MSB bit
    start bit located at second MSB bit
    ID is encoded in m_byParam1 bits starting at third MSB bit
    data encoding is LSB
    """
    eStop_Start_MSB_Id = _connect.SProfilerEncode_eStop_Start_MSB_Id
    r"""
    a series of data
    stop bit located at first MSB bit
    start bit located at second MSB bit
    ID is encoded in m_byParam1 bits located in LSB bits of the stop packet
    data encoding is MSB
    """
    eSync_Toggle_MSB_Id = _connect.SProfilerEncode_eSync_Toggle_MSB_Id
    r"""
    a series of data
    MSB 10 = start, 11 = stop, 00 & 01 toggle for data values
    ID is encoded in m_byParam1 bits located in LSB bits of the stop packet
    data encoding is MSB
    """
    eMSB_Id = _connect.SProfilerEncode_eMSB_Id
    r"""
    a single data packet,
    ID is encoded in m_byParam1 bits located in LSB bits of the stop packet
    """
    eNum = _connect.SProfilerEncode_eNum
    m_byEncode = property(_connect.SProfilerEncode_m_byEncode_get, _connect.SProfilerEncode_m_byEncode_set, doc=r""" EEncode""")
    m_byParam1 = property(_connect.SProfilerEncode_m_byParam1_get, _connect.SProfilerEncode_m_byParam1_set, doc=r""" additional parameter1 for encoding""")
    m_byParam2 = property(_connect.SProfilerEncode_m_byParam2_get, _connect.SProfilerEncode_m_byParam2_set, doc=r""" additional parameter2 for encoding""")
    m_byParam3 = property(_connect.SProfilerEncode_m_byParam3_get, _connect.SProfilerEncode_m_byParam3_set, doc=r""" additional parameter3 for encoding. SBZ""")

    def __init__(self):
        _connect.SProfilerEncode_swiginit(self, _connect.new_SProfilerEncode())
    __swig_destroy__ = _connect.delete_SProfilerEncode

# Register SProfilerEncode in _connect:
_connect.SProfilerEncode_swigregister(SProfilerEncode)

class SMSID(object):
    r""" Describes application status."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_bValid = property(_connect.SMSID_m_bValid_get, _connect.SMSID_m_bValid_set, doc=r""" true if other settings are to be considered/valid""")
    m_bSecure = property(_connect.SMSID_m_bSecure_get, _connect.SMSID_m_bSecure_set, doc=r""" true if the device level is secure""")
    m_bVMID = property(_connect.SMSID_m_bVMID_get, _connect.SMSID_m_bVMID_set, doc=r""" consider m_nVMID in identifying the app?""")
    m_bAppID = property(_connect.SMSID_m_bAppID_get, _connect.SMSID_m_bAppID_set, doc=r""" consider m_nAppID in identifying the app?""")
    ELevel_App = _connect.SMSID_ELevel_App
    r""" App inside OS inside VM"""
    ELevel_VM = _connect.SMSID_ELevel_VM
    r""" virtual machine. an OS or app"""
    ELevel_HV = _connect.SMSID_ELevel_HV
    r""" hypervisor"""
    ELevel_Sys = _connect.SMSID_ELevel_Sys
    r""" bare metal"""
    m_eLevel = property(_connect.SMSID_m_eLevel_get, _connect.SMSID_m_eLevel_set)
    m_nVMID = property(_connect.SMSID_m_nVMID_get, _connect.SMSID_m_nVMID_set, doc=r""" virtual machine ID""")
    m_nAppID = property(_connect.SMSID_m_nAppID_get, _connect.SMSID_m_nAppID_set, doc=r""" Application/ContextID""")

    def __init__(self):
        _connect.SMSID_swiginit(self, _connect.new_SMSID())
    __swig_destroy__ = _connect.delete_SMSID

# Register SMSID in _connect:
_connect.SMSID_swigregister(SMSID)

lfSet = _connect.lfSet
r""" set the line"""
lfGet = _connect.lfGet
r""" get the line state"""
lVcc = _connect.lVcc
r""" Vcc line"""
lRESET = _connect.lRESET
r""" (H)RESET line"""
lSRESET = _connect.lSRESET
r""" SRESET line"""
lBREAK = _connect.lBREAK
r""" CPU break/stop/halt input"""
lTRISTATE = _connect.lTRISTATE
r""" set entire debug port to tristate (lslHigh to set tristate, lslLow to clear)"""
lJTAG_TCK = _connect.lJTAG_TCK
r""" JTAG TCK line"""
lJTAG_TRST = _connect.lJTAG_TRST
r""" JTAG TRST line"""
lJTAG_TMS = _connect.lJTAG_TMS
r""" JTAG TMS line"""
lJTAG_TDI = _connect.lJTAG_TDI
r""" JTAG TDI line"""
lJTAG_TDO = _connect.lJTAG_TDO
r""" JTAG TDO line"""
lslLow = _connect.lslLow
r""" logical 0"""
lslHigh = _connect.lslHigh
r""" logical 1"""
class SLine_IN(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_dwFlags = property(_connect.SLine_IN_m_dwFlags_get, _connect.SLine_IN_m_dwFlags_set, doc=r""" ELineFlags""")
    m_dwLine = property(_connect.SLine_IN_m_dwLine_get, _connect.SLine_IN_m_dwLine_set, doc=r""" ELine""")
    m_dwState = property(_connect.SLine_IN_m_dwState_get, _connect.SLine_IN_m_dwState_set, doc=r""" new line state, 0 for low, 1 for high""")

    def __init__(self):
        _connect.SLine_IN_swiginit(self, _connect.new_SLine_IN())
    __swig_destroy__ = _connect.delete_SLine_IN

# Register SLine_IN in _connect:
_connect.SLine_IN_swigregister(SLine_IN)
SERVICE_Line = cvar.SERVICE_Line

class SLine_OUT(object):
    r"""Structure for line output parameters."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_dwState = property(_connect.SLine_OUT_m_dwState_get, _connect.SLine_OUT_m_dwState_set, doc=r""" state of the line""")

    def __init__(self):
        _connect.SLine_OUT_swiginit(self, _connect.new_SLine_OUT())
    __swig_destroy__ = _connect.delete_SLine_OUT

# Register SLine_OUT in _connect:
_connect.SLine_OUT_swigregister(SLine_OUT)

JTAG_flTestLogicReset_RTI = _connect.JTAG_flTestLogicReset_RTI
r""" Assert nTRST briefly then go to Run-Test-Idle"""
JTAG_flInvertOrder = _connect.JTAG_flInvertOrder
r""" Scan entire bit stream in reverse bit order."""
JTAG_flShortTDO_TDI = _connect.JTAG_flShortTDO_TDI
r""" connect TDO to TDI in Shift-DR scan"""
JTAG_flPAUSE_EXIT2 = _connect.JTAG_flPAUSE_EXIT2
r""" from EXIT1 -> PAUSE x N -> EXIT2 -> UPDATE, rather than EXIT1 -> UPDATE. do not use with JTAG_EXIT_P. Upper 16 bits of SScan_IN::m_dwScanFlags specify the PAUSE loop count"""
JTAG_flOverridePrePostFix = _connect.JTAG_flOverridePrePostFix
r""" override default prefix and postfix, use as specified in the command"""
JTAG_flIgnoreTDI = _connect.JTAG_flIgnoreTDI
r""" default TDI"""
JTAG_flIgnoreTDO = _connect.JTAG_flIgnoreTDO
r""" Don't read in any data"""
JTAG_SCAN_IR = _connect.JTAG_SCAN_IR
r""" IR scan"""
JTAG_SCAN_DR = _connect.JTAG_SCAN_DR
r""" DR scan"""
JTAG_SCAN_MASK = _connect.JTAG_SCAN_MASK
JTAG_EXIT_RTI = _connect.JTAG_EXIT_RTI
r""" return to run-test-idle"""
JTAG_EXIT_SDRS = _connect.JTAG_EXIT_SDRS
r""" return to select DR scan"""
JTAG_EXIT_P = _connect.JTAG_EXIT_P
r""" return to Pause IR or DR"""
JTAG_EXIT_MASK = _connect.JTAG_EXIT_MASK
r""" Used as mask to extract the above flags."""
JTAG_flRTI_IR = _connect.JTAG_flRTI_IR
r""" Scan IR and return to Run-Test-Idle"""
JTAG_flRTI_DR = _connect.JTAG_flRTI_DR
r""" Scan DR and return to Run-Test-Idle"""
JTAG_flSDRS_IR = _connect.JTAG_flSDRS_IR
r""" Scan IR and return to Select-DR-Scan"""
JTAG_flSDRS_DR = _connect.JTAG_flSDRS_DR
r""" Scan DR and return to Select-DR-Scan"""
JTAG_flP_IR = _connect.JTAG_flP_IR
r""" Scan IR and return to Pause IR"""
JTAG_flP_DR = _connect.JTAG_flP_DR
r""" Scan DR and return to Pause DR"""
JTAG_flResetByTRSTPin = _connect.JTAG_flResetByTRSTPin
r""" Assert nTRST briefly in JTAGReset function"""
JTAG_flResetByTMS_RTI = _connect.JTAG_flResetByTMS_RTI
r""" go to Run-Test-Idle by scanning"""
class SScan_IN(object):
    r"""Structure for scan input parameters."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_dwFlags = property(_connect.SScan_IN_m_dwFlags_get, _connect.SScan_IN_m_dwFlags_set, doc=r""" reserved, should be 0""")
    m_dwScanFlags = property(_connect.SScan_IN_m_dwScanFlags_get, _connect.SScan_IN_m_dwScanFlags_set, doc=r""" EScanFlags. Upper 16 bits specify the PAUSE loop count if JTAG_flPAUSE_EXIT2 is set""")
    m_dwNumBits = property(_connect.SScan_IN_m_dwNumBits_get, _connect.SScan_IN_m_dwNumBits_set, doc=r""" number of TCK clocks to perform.""")
    m_wIRPrefix = property(_connect.SScan_IN_m_wIRPrefix_get, _connect.SScan_IN_m_wIRPrefix_set, doc=r""" override IR prefix len""")
    m_wIRPostfix = property(_connect.SScan_IN_m_wIRPostfix_get, _connect.SScan_IN_m_wIRPostfix_set, doc=r""" override IR postfix len""")
    m_wDRPrefix = property(_connect.SScan_IN_m_wDRPrefix_get, _connect.SScan_IN_m_wDRPrefix_set, doc=r""" override DR prefix len""")
    m_wDRPostfix = property(_connect.SScan_IN_m_wDRPostfix_get, _connect.SScan_IN_m_wDRPostfix_set, doc=r""" override DR postfix len""")

    def __init__(self):
        _connect.SScan_IN_swiginit(self, _connect.new_SScan_IN())
    __swig_destroy__ = _connect.delete_SScan_IN

# Register SScan_IN in _connect:
_connect.SScan_IN_swigregister(SScan_IN)
SERVICE_Scan = cvar.SERVICE_Scan


def Scan_IN_Size(rIN: "SScan_IN") -> "unsigned long":
    r""" utility function to get the size of TDI packet."""
    return _connect.Scan_IN_Size(rIN)
class SScan_OUT(object):
    r"""Structure for scan output parameters."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_dwResult = property(_connect.SScan_OUT_m_dwResult_get, _connect.SScan_OUT_m_dwResult_set, doc=r""" reserved, should be 0""")

    def __init__(self):
        _connect.SScan_OUT_swiginit(self, _connect.new_SScan_OUT())
    __swig_destroy__ = _connect.delete_SScan_OUT

# Register SScan_OUT in _connect:
_connect.SScan_OUT_swigregister(SScan_OUT)


def Scan_OUT_Size(rIN: "SScan_IN") -> "unsigned long":
    r""" utility function to get the size of OUT packet."""
    return _connect.Scan_OUT_Size(rIN)
mmu_None = _connect.mmu_None
mmu_z1 = _connect.mmu_z1
mmu_z3 = _connect.mmu_z3
mmu_z4 = _connect.mmu_z4
mmu_z6 = _connect.mmu_z6
mmu_z7 = _connect.mmu_z7
mmu_Mask = _connect.mmu_Mask
mmu_NumTLBsMask = _connect.mmu_NumTLBsMask
class STLBEntry(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_dwMAS1 = property(_connect.STLBEntry_m_dwMAS1_get, _connect.STLBEntry_m_dwMAS1_set)
    m_dwMAS2 = property(_connect.STLBEntry_m_dwMAS2_get, _connect.STLBEntry_m_dwMAS2_set)
    m_dwMAS3 = property(_connect.STLBEntry_m_dwMAS3_get, _connect.STLBEntry_m_dwMAS3_set)
    m_dwMAS4 = property(_connect.STLBEntry_m_dwMAS4_get, _connect.STLBEntry_m_dwMAS4_set)
    m_dwMAS6 = property(_connect.STLBEntry_m_dwMAS6_get, _connect.STLBEntry_m_dwMAS6_set)

    def __init__(self):
        _connect.STLBEntry_swiginit(self, _connect.new_STLBEntry())
    __swig_destroy__ = _connect.delete_STLBEntry

# Register STLBEntry in _connect:
_connect.STLBEntry_swigregister(STLBEntry)

CPUSFR_PROP_AREAS = _connect.CPUSFR_PROP_AREAS
CPUSFR_PROP_AREA = _connect.CPUSFR_PROP_AREA
CPUSFR_PROP_AREA_START = _connect.CPUSFR_PROP_AREA_START
CPUSFR_PROP_AREA_END = _connect.CPUSFR_PROP_AREA_END
CPUSFR_PROP_AREA_MAU = _connect.CPUSFR_PROP_AREA_MAU
CPUSFR_PROP_AREA_VISIBLE = _connect.CPUSFR_PROP_AREA_VISIBLE
CPUSFR_PROP_REGISTERS = _connect.CPUSFR_PROP_REGISTERS
CPUSFR_PROP_REGISTER = _connect.CPUSFR_PROP_REGISTER
CPUSFR_PROP_REGISTER_SIZE = _connect.CPUSFR_PROP_REGISTER_SIZE
CPUSFR_PROP_REGISTER_VISIBLE = _connect.CPUSFR_PROP_REGISTER_VISIBLE
class CEvent(object):
    r""" This is wrapper for Windows events."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, bManualReset: "bool", bInitialState: "bool", eventName: "std::string const &"):
        r"""
        Creates Windows event object.

        :type bManualReset: boolean
        :param bManualReset: Specifies whether a manual-reset or
            auto-reset event object is created. If ``true``, then you must
            use the ``reset()`` method to manually reset the
            state to nonsignaled. If ``false``, Windows automatically
            resets the state to nonsignaled after a single waiting
            thread has been released.

        :type bInitialState: boolean
        :param bInitialState: Specifies the initial state of the
            event object. If ``true``, the initial state is signaled;
            otherwise, it is nonsignaled.

        :type eventName: string
        :param eventName: specifies the name of the event object. The name is
            limited to ``MAX_PATH`` characters and can contain any
            character except the backslash path-separator character
            (\). Name comparison is case sensitive.



            If ``eventName`` matches the name of an existing
            named event object, this constructor requests
            ``EVENT_ALL_ACCESS`` access to the existing
            object. In this case, the ``bManualReset`` and
            ``bInitialState`` parameters are ignored because
            they have already been set by the creating process.
            If ``eventName`` is empty string,
            the event object is created without a name.



            If ``eventName`` matches the name of an existing
            semaphore, mutex, or file-mapping object, the constructor
            fails and the ``SystemException`` is thrown. This
            occurs because event, mutex, semaphore, and file-mapping
            objects share the same name space.

        :raises: SystemException if Windows event object can not be
            created.

        See also: #alreadyExists
        """
        _connect.CEvent_swiginit(self, _connect.new_CEvent(bManualReset, bInitialState, eventName))
    __swig_destroy__ = _connect.delete_CEvent

    def set(self) -> "void":
        r"""
        Sets the state of object to signaled.

        The state of a manual-reset event object remains signaled
        until it is reset by ``reset()`` method. Any
        number of waiting threads, or threads that subsequently
        begin wait operations for the specified event object by
        calling one of the wait functions, can be released while
        the object's state is signaled.

        The state of an auto-reset event object remains set
        until a single waiting thread is released, at which time
        the system automatically resets the object. If
        no threads are waiting, the object remains
        set.

        :raises: SystemException if operation failed.
        """
        return _connect.CEvent_set(self)

    def pulse(self) -> "void":
        r"""
        Sets the state of the specified event object to signaled
        and then to non-signaled after releasing the appropriate
        number of waiting threads.

        For a manual-reset event object, all waiting threads that
        can be released immediately are released. The function then
        resets the event object's state to non-signaled and returns.

        For an auto-reset event object, the function resets the
        state to non-signaled and returns after releasing a single
        waiting thread, even if multiple threads are waiting.

        If no threads are waiting, or if no thread can be released
        immediately, PulseEvent simply sets the event object's
        state to non-signaled and returns.

        :raises: SystemException if operation failed.
        """
        return _connect.CEvent_pulse(self)

    def reset(self) -> "void":
        r"""
        Sets the state of object to non-signaled.

        The object remains reset until it
        is explicitly set by the ``set`` or ``pulse``
        method. This state blocks the execution of
        any threads that have called ``waitFor()`` method.

        The ``reset()`` method is used primarily for
        manual-reset event objects, which must be reset explicitly.
        Auto-reset event objects automatically change to reset
        state after a single waiting thread is released.

        :raises: SystemException if operation failed.
        """
        return _connect.CEvent_reset(self)

    def waitFor(self, *args) -> "bool":
        r"""
        Waits until event is set or timeout expires.

        :type timeout: int, optional
        :param timeout: Specifies the time-out interval, in
            milliseconds. The function returns if the interval elapses,
            even if the object's state is non-signaled. If
            ``timeout`` is zero, the function tests the object's
            state and returns immediately. If ``timeout`` is
            INFINITE, the function's time-out interval never elapses.

        :rtype: boolean
        :return: ``true`` if event was set,
            ``false`` if timeout elapsed

        :raises: SystemException if function failed.
        """
        return _connect.CEvent_waitFor(self, *args)

    def getHandle(self) -> "HANDLE":
        r"""
        Returns Windows handle to event object. Use this method
        only if you really need functionality not covered by this
        class.
        """
        return _connect.CEvent_getHandle(self)

    def alreadyExists(self) -> "bool":
        r"""
        Returns true, if event object, with the name specified in
        constructor parameter ``eventName``, existed before
        creation of this object.
        """
        return _connect.CEvent_alreadyExists(self)

    def close(self) -> "void":
        r"""
        Closes event handle. It is recommended to use this method
        when closing event. This way we can get the exception if
        something goes wrong, while in destructor it is lost.

        If this method is not called directly by application, it is
        called by destructor. However, see recommendation above.


        :raises: SystemException if ``CloseHandle()`` system function fails
        :raises: IllegalStateException if event is already closed.
        """
        return _connect.CEvent_close(self)

# Register CEvent in _connect:
_connect.CEvent_swigregister(CEvent)

class VectorBYTE(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.VectorBYTE_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.VectorBYTE___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.VectorBYTE___bool__(self)

    def __len__(self) -> "std::vector< unsigned char >::size_type":
        return _connect.VectorBYTE___len__(self)

    def __getslice__(self, i: "std::vector< unsigned char >::difference_type", j: "std::vector< unsigned char >::difference_type") -> "std::vector< unsigned char,std::allocator< unsigned char > > *":
        return _connect.VectorBYTE___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.VectorBYTE___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned char >::difference_type", j: "std::vector< unsigned char >::difference_type") -> "void":
        return _connect.VectorBYTE___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.VectorBYTE___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned char >::value_type const &":
        return _connect.VectorBYTE___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.VectorBYTE___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned char >::value_type":
        return _connect.VectorBYTE_pop(self)

    def append(self, x: "std::vector< unsigned char >::value_type const &") -> "void":
        return _connect.VectorBYTE_append(self, x)

    def empty(self) -> "bool":
        return _connect.VectorBYTE_empty(self)

    def size(self) -> "std::vector< unsigned char >::size_type":
        return _connect.VectorBYTE_size(self)

    def swap(self, v: "VectorBYTE") -> "void":
        return _connect.VectorBYTE_swap(self, v)

    def begin(self) -> "std::vector< unsigned char >::iterator":
        return _connect.VectorBYTE_begin(self)

    def end(self) -> "std::vector< unsigned char >::iterator":
        return _connect.VectorBYTE_end(self)

    def rbegin(self) -> "std::vector< unsigned char >::reverse_iterator":
        return _connect.VectorBYTE_rbegin(self)

    def rend(self) -> "std::vector< unsigned char >::reverse_iterator":
        return _connect.VectorBYTE_rend(self)

    def clear(self) -> "void":
        return _connect.VectorBYTE_clear(self)

    def get_allocator(self) -> "std::vector< unsigned char >::allocator_type":
        return _connect.VectorBYTE_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.VectorBYTE_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned char >::iterator":
        return _connect.VectorBYTE_erase(self, *args)

    def __init__(self, *args):
        _connect.VectorBYTE_swiginit(self, _connect.new_VectorBYTE(*args))

    def push_back(self, x: "std::vector< unsigned char >::value_type const &") -> "void":
        return _connect.VectorBYTE_push_back(self, x)

    def front(self) -> "std::vector< unsigned char >::value_type const &":
        return _connect.VectorBYTE_front(self)

    def back(self) -> "std::vector< unsigned char >::value_type const &":
        return _connect.VectorBYTE_back(self)

    def assign(self, n: "std::vector< unsigned char >::size_type", x: "std::vector< unsigned char >::value_type const &") -> "void":
        return _connect.VectorBYTE_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.VectorBYTE_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.VectorBYTE_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned char >::size_type") -> "void":
        return _connect.VectorBYTE_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned char >::size_type":
        return _connect.VectorBYTE_capacity(self)
    __swig_destroy__ = _connect.delete_VectorBYTE

# Register VectorBYTE in _connect:
_connect.VectorBYTE_swigregister(VectorBYTE)

class VectorBatchAccessItem(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.VectorBatchAccessItem_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.VectorBatchAccessItem___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.VectorBatchAccessItem___bool__(self)

    def __len__(self) -> "std::vector< SBatchAccessItem >::size_type":
        return _connect.VectorBatchAccessItem___len__(self)

    def __getslice__(self, i: "std::vector< SBatchAccessItem >::difference_type", j: "std::vector< SBatchAccessItem >::difference_type") -> "std::vector< SBatchAccessItem,std::allocator< SBatchAccessItem > > *":
        return _connect.VectorBatchAccessItem___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.VectorBatchAccessItem___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< SBatchAccessItem >::difference_type", j: "std::vector< SBatchAccessItem >::difference_type") -> "void":
        return _connect.VectorBatchAccessItem___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.VectorBatchAccessItem___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< SBatchAccessItem >::value_type const &":
        return _connect.VectorBatchAccessItem___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.VectorBatchAccessItem___setitem__(self, *args)

    def pop(self) -> "std::vector< SBatchAccessItem >::value_type":
        return _connect.VectorBatchAccessItem_pop(self)

    def append(self, x: "SBatchAccessItem") -> "void":
        return _connect.VectorBatchAccessItem_append(self, x)

    def empty(self) -> "bool":
        return _connect.VectorBatchAccessItem_empty(self)

    def size(self) -> "std::vector< SBatchAccessItem >::size_type":
        return _connect.VectorBatchAccessItem_size(self)

    def swap(self, v: "VectorBatchAccessItem") -> "void":
        return _connect.VectorBatchAccessItem_swap(self, v)

    def begin(self) -> "std::vector< SBatchAccessItem >::iterator":
        return _connect.VectorBatchAccessItem_begin(self)

    def end(self) -> "std::vector< SBatchAccessItem >::iterator":
        return _connect.VectorBatchAccessItem_end(self)

    def rbegin(self) -> "std::vector< SBatchAccessItem >::reverse_iterator":
        return _connect.VectorBatchAccessItem_rbegin(self)

    def rend(self) -> "std::vector< SBatchAccessItem >::reverse_iterator":
        return _connect.VectorBatchAccessItem_rend(self)

    def clear(self) -> "void":
        return _connect.VectorBatchAccessItem_clear(self)

    def get_allocator(self) -> "std::vector< SBatchAccessItem >::allocator_type":
        return _connect.VectorBatchAccessItem_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.VectorBatchAccessItem_pop_back(self)

    def erase(self, *args) -> "std::vector< SBatchAccessItem >::iterator":
        return _connect.VectorBatchAccessItem_erase(self, *args)

    def __init__(self, *args):
        _connect.VectorBatchAccessItem_swiginit(self, _connect.new_VectorBatchAccessItem(*args))

    def push_back(self, x: "SBatchAccessItem") -> "void":
        return _connect.VectorBatchAccessItem_push_back(self, x)

    def front(self) -> "std::vector< SBatchAccessItem >::value_type const &":
        return _connect.VectorBatchAccessItem_front(self)

    def back(self) -> "std::vector< SBatchAccessItem >::value_type const &":
        return _connect.VectorBatchAccessItem_back(self)

    def assign(self, n: "std::vector< SBatchAccessItem >::size_type", x: "SBatchAccessItem") -> "void":
        return _connect.VectorBatchAccessItem_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.VectorBatchAccessItem_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.VectorBatchAccessItem_insert(self, *args)

    def reserve(self, n: "std::vector< SBatchAccessItem >::size_type") -> "void":
        return _connect.VectorBatchAccessItem_reserve(self, n)

    def capacity(self) -> "std::vector< SBatchAccessItem >::size_type":
        return _connect.VectorBatchAccessItem_capacity(self)
    __swig_destroy__ = _connect.delete_VectorBatchAccessItem

# Register VectorBatchAccessItem in _connect:
_connect.VectorBatchAccessItem_swigregister(VectorBatchAccessItem)

class VectorBatchAccessResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.VectorBatchAccessResult_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.VectorBatchAccessResult___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.VectorBatchAccessResult___bool__(self)

    def __len__(self) -> "std::vector< SBatchAccessItemResult >::size_type":
        return _connect.VectorBatchAccessResult___len__(self)

    def __getslice__(self, i: "std::vector< SBatchAccessItemResult >::difference_type", j: "std::vector< SBatchAccessItemResult >::difference_type") -> "std::vector< SBatchAccessItemResult,std::allocator< SBatchAccessItemResult > > *":
        return _connect.VectorBatchAccessResult___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.VectorBatchAccessResult___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< SBatchAccessItemResult >::difference_type", j: "std::vector< SBatchAccessItemResult >::difference_type") -> "void":
        return _connect.VectorBatchAccessResult___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.VectorBatchAccessResult___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< SBatchAccessItemResult >::value_type const &":
        return _connect.VectorBatchAccessResult___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.VectorBatchAccessResult___setitem__(self, *args)

    def pop(self) -> "std::vector< SBatchAccessItemResult >::value_type":
        return _connect.VectorBatchAccessResult_pop(self)

    def append(self, x: "SBatchAccessItemResult") -> "void":
        return _connect.VectorBatchAccessResult_append(self, x)

    def empty(self) -> "bool":
        return _connect.VectorBatchAccessResult_empty(self)

    def size(self) -> "std::vector< SBatchAccessItemResult >::size_type":
        return _connect.VectorBatchAccessResult_size(self)

    def swap(self, v: "VectorBatchAccessResult") -> "void":
        return _connect.VectorBatchAccessResult_swap(self, v)

    def begin(self) -> "std::vector< SBatchAccessItemResult >::iterator":
        return _connect.VectorBatchAccessResult_begin(self)

    def end(self) -> "std::vector< SBatchAccessItemResult >::iterator":
        return _connect.VectorBatchAccessResult_end(self)

    def rbegin(self) -> "std::vector< SBatchAccessItemResult >::reverse_iterator":
        return _connect.VectorBatchAccessResult_rbegin(self)

    def rend(self) -> "std::vector< SBatchAccessItemResult >::reverse_iterator":
        return _connect.VectorBatchAccessResult_rend(self)

    def clear(self) -> "void":
        return _connect.VectorBatchAccessResult_clear(self)

    def get_allocator(self) -> "std::vector< SBatchAccessItemResult >::allocator_type":
        return _connect.VectorBatchAccessResult_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.VectorBatchAccessResult_pop_back(self)

    def erase(self, *args) -> "std::vector< SBatchAccessItemResult >::iterator":
        return _connect.VectorBatchAccessResult_erase(self, *args)

    def __init__(self, *args):
        _connect.VectorBatchAccessResult_swiginit(self, _connect.new_VectorBatchAccessResult(*args))

    def push_back(self, x: "SBatchAccessItemResult") -> "void":
        return _connect.VectorBatchAccessResult_push_back(self, x)

    def front(self) -> "std::vector< SBatchAccessItemResult >::value_type const &":
        return _connect.VectorBatchAccessResult_front(self)

    def back(self) -> "std::vector< SBatchAccessItemResult >::value_type const &":
        return _connect.VectorBatchAccessResult_back(self)

    def assign(self, n: "std::vector< SBatchAccessItemResult >::size_type", x: "SBatchAccessItemResult") -> "void":
        return _connect.VectorBatchAccessResult_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.VectorBatchAccessResult_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.VectorBatchAccessResult_insert(self, *args)

    def reserve(self, n: "std::vector< SBatchAccessItemResult >::size_type") -> "void":
        return _connect.VectorBatchAccessResult_reserve(self, n)

    def capacity(self) -> "std::vector< SBatchAccessItemResult >::size_type":
        return _connect.VectorBatchAccessResult_capacity(self)
    __swig_destroy__ = _connect.delete_VectorBatchAccessResult

# Register VectorBatchAccessResult in _connect:
_connect.VectorBatchAccessResult_swigregister(VectorBatchAccessResult)

class VectorWinIDEAInstanceInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.VectorWinIDEAInstanceInfo_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.VectorWinIDEAInstanceInfo___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.VectorWinIDEAInstanceInfo___bool__(self)

    def __len__(self) -> "std::vector< isys::WinIDEAInstanceInfo >::size_type":
        return _connect.VectorWinIDEAInstanceInfo___len__(self)

    def __getslice__(self, i: "std::vector< isys::WinIDEAInstanceInfo >::difference_type", j: "std::vector< isys::WinIDEAInstanceInfo >::difference_type") -> "std::vector< isys::WinIDEAInstanceInfo,std::allocator< isys::WinIDEAInstanceInfo > > *":
        return _connect.VectorWinIDEAInstanceInfo___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.VectorWinIDEAInstanceInfo___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< isys::WinIDEAInstanceInfo >::difference_type", j: "std::vector< isys::WinIDEAInstanceInfo >::difference_type") -> "void":
        return _connect.VectorWinIDEAInstanceInfo___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.VectorWinIDEAInstanceInfo___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::WinIDEAInstanceInfo >::value_type const &":
        return _connect.VectorWinIDEAInstanceInfo___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.VectorWinIDEAInstanceInfo___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::WinIDEAInstanceInfo >::value_type":
        return _connect.VectorWinIDEAInstanceInfo_pop(self)

    def append(self, x: "WinIDEAInstanceInfo") -> "void":
        return _connect.VectorWinIDEAInstanceInfo_append(self, x)

    def empty(self) -> "bool":
        return _connect.VectorWinIDEAInstanceInfo_empty(self)

    def size(self) -> "std::vector< isys::WinIDEAInstanceInfo >::size_type":
        return _connect.VectorWinIDEAInstanceInfo_size(self)

    def swap(self, v: "VectorWinIDEAInstanceInfo") -> "void":
        return _connect.VectorWinIDEAInstanceInfo_swap(self, v)

    def begin(self) -> "std::vector< isys::WinIDEAInstanceInfo >::iterator":
        return _connect.VectorWinIDEAInstanceInfo_begin(self)

    def end(self) -> "std::vector< isys::WinIDEAInstanceInfo >::iterator":
        return _connect.VectorWinIDEAInstanceInfo_end(self)

    def rbegin(self) -> "std::vector< isys::WinIDEAInstanceInfo >::reverse_iterator":
        return _connect.VectorWinIDEAInstanceInfo_rbegin(self)

    def rend(self) -> "std::vector< isys::WinIDEAInstanceInfo >::reverse_iterator":
        return _connect.VectorWinIDEAInstanceInfo_rend(self)

    def clear(self) -> "void":
        return _connect.VectorWinIDEAInstanceInfo_clear(self)

    def get_allocator(self) -> "std::vector< isys::WinIDEAInstanceInfo >::allocator_type":
        return _connect.VectorWinIDEAInstanceInfo_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.VectorWinIDEAInstanceInfo_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::WinIDEAInstanceInfo >::iterator":
        return _connect.VectorWinIDEAInstanceInfo_erase(self, *args)

    def __init__(self, *args):
        _connect.VectorWinIDEAInstanceInfo_swiginit(self, _connect.new_VectorWinIDEAInstanceInfo(*args))

    def push_back(self, x: "WinIDEAInstanceInfo") -> "void":
        return _connect.VectorWinIDEAInstanceInfo_push_back(self, x)

    def front(self) -> "std::vector< isys::WinIDEAInstanceInfo >::value_type const &":
        return _connect.VectorWinIDEAInstanceInfo_front(self)

    def back(self) -> "std::vector< isys::WinIDEAInstanceInfo >::value_type const &":
        return _connect.VectorWinIDEAInstanceInfo_back(self)

    def assign(self, n: "std::vector< isys::WinIDEAInstanceInfo >::size_type", x: "WinIDEAInstanceInfo") -> "void":
        return _connect.VectorWinIDEAInstanceInfo_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.VectorWinIDEAInstanceInfo_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.VectorWinIDEAInstanceInfo_insert(self, *args)

    def reserve(self, n: "std::vector< isys::WinIDEAInstanceInfo >::size_type") -> "void":
        return _connect.VectorWinIDEAInstanceInfo_reserve(self, n)

    def capacity(self) -> "std::vector< isys::WinIDEAInstanceInfo >::size_type":
        return _connect.VectorWinIDEAInstanceInfo_capacity(self)
    __swig_destroy__ = _connect.delete_VectorWinIDEAInstanceInfo

# Register VectorWinIDEAInstanceInfo in _connect:
_connect.VectorWinIDEAInstanceInfo_swigregister(VectorWinIDEAInstanceInfo)

class VectorDataComposite(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.VectorDataComposite_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.VectorDataComposite___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.VectorDataComposite___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::size_type":
        return _connect.VectorDataComposite___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< isys::CDataComposite > >::difference_type", j: "std::vector< std::shared_ptr< isys::CDataComposite > >::difference_type") -> "std::vector< std::shared_ptr< isys::CDataComposite >,std::allocator< std::shared_ptr< isys::CDataComposite > > > *":
        return _connect.VectorDataComposite___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.VectorDataComposite___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< isys::CDataComposite > >::difference_type", j: "std::vector< std::shared_ptr< isys::CDataComposite > >::difference_type") -> "void":
        return _connect.VectorDataComposite___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.VectorDataComposite___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::value_type const &":
        return _connect.VectorDataComposite___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.VectorDataComposite___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::value_type":
        return _connect.VectorDataComposite_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< isys::CDataComposite > >::value_type const &") -> "void":
        return _connect.VectorDataComposite_append(self, x)

    def empty(self) -> "bool":
        return _connect.VectorDataComposite_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::size_type":
        return _connect.VectorDataComposite_size(self)

    def swap(self, v: "VectorDataComposite") -> "void":
        return _connect.VectorDataComposite_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::iterator":
        return _connect.VectorDataComposite_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::iterator":
        return _connect.VectorDataComposite_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::reverse_iterator":
        return _connect.VectorDataComposite_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::reverse_iterator":
        return _connect.VectorDataComposite_rend(self)

    def clear(self) -> "void":
        return _connect.VectorDataComposite_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::allocator_type":
        return _connect.VectorDataComposite_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.VectorDataComposite_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::iterator":
        return _connect.VectorDataComposite_erase(self, *args)

    def __init__(self, *args):
        _connect.VectorDataComposite_swiginit(self, _connect.new_VectorDataComposite(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< isys::CDataComposite > >::value_type const &") -> "void":
        return _connect.VectorDataComposite_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::value_type const &":
        return _connect.VectorDataComposite_front(self)

    def back(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::value_type const &":
        return _connect.VectorDataComposite_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< isys::CDataComposite > >::size_type", x: "std::vector< std::shared_ptr< isys::CDataComposite > >::value_type const &") -> "void":
        return _connect.VectorDataComposite_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.VectorDataComposite_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.VectorDataComposite_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< isys::CDataComposite > >::size_type") -> "void":
        return _connect.VectorDataComposite_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::size_type":
        return _connect.VectorDataComposite_capacity(self)
    __swig_destroy__ = _connect.delete_VectorDataComposite

# Register VectorDataComposite in _connect:
_connect.VectorDataComposite_swigregister(VectorDataComposite)

class VectorOnChipData(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.VectorOnChipData_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.VectorOnChipData___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.VectorOnChipData___bool__(self)

    def __len__(self) -> "std::vector< unsigned long >::size_type":
        return _connect.VectorOnChipData___len__(self)

    def __getslice__(self, i: "std::vector< unsigned long >::difference_type", j: "std::vector< unsigned long >::difference_type") -> "std::vector< unsigned long,std::allocator< unsigned long > > *":
        return _connect.VectorOnChipData___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.VectorOnChipData___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned long >::difference_type", j: "std::vector< unsigned long >::difference_type") -> "void":
        return _connect.VectorOnChipData___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.VectorOnChipData___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned long >::value_type const &":
        return _connect.VectorOnChipData___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.VectorOnChipData___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned long >::value_type":
        return _connect.VectorOnChipData_pop(self)

    def append(self, x: "std::vector< unsigned long >::value_type const &") -> "void":
        return _connect.VectorOnChipData_append(self, x)

    def empty(self) -> "bool":
        return _connect.VectorOnChipData_empty(self)

    def size(self) -> "std::vector< unsigned long >::size_type":
        return _connect.VectorOnChipData_size(self)

    def swap(self, v: "VectorOnChipData") -> "void":
        return _connect.VectorOnChipData_swap(self, v)

    def begin(self) -> "std::vector< unsigned long >::iterator":
        return _connect.VectorOnChipData_begin(self)

    def end(self) -> "std::vector< unsigned long >::iterator":
        return _connect.VectorOnChipData_end(self)

    def rbegin(self) -> "std::vector< unsigned long >::reverse_iterator":
        return _connect.VectorOnChipData_rbegin(self)

    def rend(self) -> "std::vector< unsigned long >::reverse_iterator":
        return _connect.VectorOnChipData_rend(self)

    def clear(self) -> "void":
        return _connect.VectorOnChipData_clear(self)

    def get_allocator(self) -> "std::vector< unsigned long >::allocator_type":
        return _connect.VectorOnChipData_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.VectorOnChipData_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned long >::iterator":
        return _connect.VectorOnChipData_erase(self, *args)

    def __init__(self, *args):
        _connect.VectorOnChipData_swiginit(self, _connect.new_VectorOnChipData(*args))

    def push_back(self, x: "std::vector< unsigned long >::value_type const &") -> "void":
        return _connect.VectorOnChipData_push_back(self, x)

    def front(self) -> "std::vector< unsigned long >::value_type const &":
        return _connect.VectorOnChipData_front(self)

    def back(self) -> "std::vector< unsigned long >::value_type const &":
        return _connect.VectorOnChipData_back(self)

    def assign(self, n: "std::vector< unsigned long >::size_type", x: "std::vector< unsigned long >::value_type const &") -> "void":
        return _connect.VectorOnChipData_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.VectorOnChipData_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.VectorOnChipData_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned long >::size_type") -> "void":
        return _connect.VectorOnChipData_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned long >::size_type":
        return _connect.VectorOnChipData_capacity(self)
    __swig_destroy__ = _connect.delete_VectorOnChipData

# Register VectorOnChipData in _connect:
_connect.VectorOnChipData_swigregister(VectorOnChipData)

class IVectorDisassemblyLines(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::IDisassemblyLine >::size_type":
        r""" Returns the number of elements in vector."""
        return _connect.IVectorDisassemblyLines_size(self)

    def at(self, _Pos: "IVector< iEclipse::IDisassemblyLine >::size_type") -> "IVector< iEclipse::IDisassemblyLine >::interface_type *":
        r""" Returns the element at position _Pos in vector."""
        return _connect.IVectorDisassemblyLines_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorDisassemblyLines

# Register IVectorDisassemblyLines in _connect:
_connect.IVectorDisassemblyLines_swigregister(IVectorDisassemblyLines)

class IVectorVariables(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::IVariable >::size_type":
        r""" Returns the number of elements in vector."""
        return _connect.IVectorVariables_size(self)

    def at(self, _Pos: "IVector< iEclipse::IVariable >::size_type") -> "IVector< iEclipse::IVariable >::interface_type *":
        r""" Returns the element at position _Pos in vector."""
        return _connect.IVectorVariables_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorVariables

# Register IVectorVariables in _connect:
_connect.IVectorVariables_swigregister(IVectorVariables)

class IVectorFunctions(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::IFunction >::size_type":
        r""" Returns the number of elements in vector."""
        return _connect.IVectorFunctions_size(self)

    def at(self, _Pos: "IVector< iEclipse::IFunction >::size_type") -> "IVector< iEclipse::IFunction >::interface_type *":
        r""" Returns the element at position _Pos in vector."""
        return _connect.IVectorFunctions_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorFunctions

# Register IVectorFunctions in _connect:
_connect.IVectorFunctions_swigregister(IVectorFunctions)

class IVectorStackFrames(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::IStackFrame >::size_type":
        r""" Returns the number of elements in vector."""
        return _connect.IVectorStackFrames_size(self)

    def at(self, _Pos: "IVector< iEclipse::IStackFrame >::size_type") -> "IVector< iEclipse::IStackFrame >::interface_type *":
        r""" Returns the element at position _Pos in vector."""
        return _connect.IVectorStackFrames_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorStackFrames

# Register IVectorStackFrames in _connect:
_connect.IVectorStackFrames_swigregister(IVectorStackFrames)

class IVectorPartitions(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::IPartition >::size_type":
        r""" Returns the number of elements in vector."""
        return _connect.IVectorPartitions_size(self)

    def at(self, _Pos: "IVector< iEclipse::IPartition >::size_type") -> "IVector< iEclipse::IPartition >::interface_type *":
        r""" Returns the element at position _Pos in vector."""
        return _connect.IVectorPartitions_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorPartitions

# Register IVectorPartitions in _connect:
_connect.IVectorPartitions_swigregister(IVectorPartitions)

class IVectorModules(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::IModule >::size_type":
        r""" Returns the number of elements in vector."""
        return _connect.IVectorModules_size(self)

    def at(self, _Pos: "IVector< iEclipse::IModule >::size_type") -> "IVector< iEclipse::IModule >::interface_type *":
        r""" Returns the element at position _Pos in vector."""
        return _connect.IVectorModules_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorModules

# Register IVectorModules in _connect:
_connect.IVectorModules_swigregister(IVectorModules)

class IVectorSFRs(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::ISFR >::size_type":
        r""" Returns the number of elements in vector."""
        return _connect.IVectorSFRs_size(self)

    def at(self, _Pos: "IVector< iEclipse::ISFR >::size_type") -> "IVector< iEclipse::ISFR >::interface_type *":
        r""" Returns the element at position _Pos in vector."""
        return _connect.IVectorSFRs_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorSFRs

# Register IVectorSFRs in _connect:
_connect.IVectorSFRs_swigregister(IVectorSFRs)

class IVectorValueMap(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::ISFRValueMap >::size_type":
        r""" Returns the number of elements in vector."""
        return _connect.IVectorValueMap_size(self)

    def at(self, _Pos: "IVector< iEclipse::ISFRValueMap >::size_type") -> "IVector< iEclipse::ISFRValueMap >::interface_type *":
        r""" Returns the element at position _Pos in vector."""
        return _connect.IVectorValueMap_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorValueMap

# Register IVectorValueMap in _connect:
_connect.IVectorValueMap_swigregister(IVectorValueMap)

class IVectorTypes(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::IType >::size_type":
        r""" Returns the number of elements in vector."""
        return _connect.IVectorTypes_size(self)

    def at(self, _Pos: "IVector< iEclipse::IType >::size_type") -> "IVector< iEclipse::IType >::interface_type *":
        r""" Returns the element at position _Pos in vector."""
        return _connect.IVectorTypes_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorTypes

# Register IVectorTypes in _connect:
_connect.IVectorTypes_swigregister(IVectorTypes)

class IVectorTypedefs(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::ITypedef >::size_type":
        r""" Returns the number of elements in vector."""
        return _connect.IVectorTypedefs_size(self)

    def at(self, _Pos: "IVector< iEclipse::ITypedef >::size_type") -> "IVector< iEclipse::ITypedef >::interface_type *":
        r""" Returns the element at position _Pos in vector."""
        return _connect.IVectorTypedefs_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorTypedefs

# Register IVectorTypedefs in _connect:
_connect.IVectorTypedefs_swigregister(IVectorTypedefs)

class IVectorItemDescriptors(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< DataDescriptor::IItemDescriptor >::size_type":
        r""" Returns the number of elements in vector."""
        return _connect.IVectorItemDescriptors_size(self)

    def at(self, _Pos: "IVector< DataDescriptor::IItemDescriptor >::size_type") -> "IVector< DataDescriptor::IItemDescriptor >::interface_type *":
        r""" Returns the element at position _Pos in vector."""
        return _connect.IVectorItemDescriptors_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorItemDescriptors

# Register IVectorItemDescriptors in _connect:
_connect.IVectorItemDescriptors_swigregister(IVectorItemDescriptors)

class IVectorEnumMaps(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< DataDescriptor::IEnumMap >::size_type":
        r""" Returns the number of elements in vector."""
        return _connect.IVectorEnumMaps_size(self)

    def at(self, _Pos: "IVector< DataDescriptor::IEnumMap >::size_type") -> "IVector< DataDescriptor::IEnumMap >::interface_type *":
        r""" Returns the element at position _Pos in vector."""
        return _connect.IVectorEnumMaps_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorEnumMaps

# Register IVectorEnumMaps in _connect:
_connect.IVectorEnumMaps_swigregister(IVectorEnumMaps)

class IVectorMenuItems(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< isys::IMenuItem >::size_type":
        r""" Returns the number of elements in vector."""
        return _connect.IVectorMenuItems_size(self)

    def at(self, _Pos: "IVector< isys::IMenuItem >::size_type") -> "IVector< isys::IMenuItem >::interface_type *":
        r""" Returns the element at position _Pos in vector."""
        return _connect.IVectorMenuItems_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorMenuItems

# Register IVectorMenuItems in _connect:
_connect.IVectorMenuItems_swigregister(IVectorMenuItems)

class IVectorCallees(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::ICallee >::size_type":
        r""" Returns the number of elements in vector."""
        return _connect.IVectorCallees_size(self)

    def at(self, _Pos: "IVector< iEclipse::ICallee >::size_type") -> "IVector< iEclipse::ICallee >::interface_type *":
        r""" Returns the element at position _Pos in vector."""
        return _connect.IVectorCallees_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorCallees

# Register IVectorCallees in _connect:
_connect.IVectorCallees_swigregister(IVectorCallees)

class ProfilerStatistics2Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.ProfilerStatistics2Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.ProfilerStatistics2Vector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.ProfilerStatistics2Vector___bool__(self)

    def __len__(self) -> "std::vector< isys::CProfilerStatistics2 >::size_type":
        return _connect.ProfilerStatistics2Vector___len__(self)

    def __getslice__(self, i: "std::vector< isys::CProfilerStatistics2 >::difference_type", j: "std::vector< isys::CProfilerStatistics2 >::difference_type") -> "std::vector< isys::CProfilerStatistics2,std::allocator< isys::CProfilerStatistics2 > > *":
        return _connect.ProfilerStatistics2Vector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.ProfilerStatistics2Vector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< isys::CProfilerStatistics2 >::difference_type", j: "std::vector< isys::CProfilerStatistics2 >::difference_type") -> "void":
        return _connect.ProfilerStatistics2Vector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.ProfilerStatistics2Vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CProfilerStatistics2 >::value_type const &":
        return _connect.ProfilerStatistics2Vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.ProfilerStatistics2Vector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CProfilerStatistics2 >::value_type":
        return _connect.ProfilerStatistics2Vector_pop(self)

    def append(self, x: "CProfilerStatistics2") -> "void":
        return _connect.ProfilerStatistics2Vector_append(self, x)

    def empty(self) -> "bool":
        return _connect.ProfilerStatistics2Vector_empty(self)

    def size(self) -> "std::vector< isys::CProfilerStatistics2 >::size_type":
        return _connect.ProfilerStatistics2Vector_size(self)

    def swap(self, v: "ProfilerStatistics2Vector") -> "void":
        return _connect.ProfilerStatistics2Vector_swap(self, v)

    def begin(self) -> "std::vector< isys::CProfilerStatistics2 >::iterator":
        return _connect.ProfilerStatistics2Vector_begin(self)

    def end(self) -> "std::vector< isys::CProfilerStatistics2 >::iterator":
        return _connect.ProfilerStatistics2Vector_end(self)

    def rbegin(self) -> "std::vector< isys::CProfilerStatistics2 >::reverse_iterator":
        return _connect.ProfilerStatistics2Vector_rbegin(self)

    def rend(self) -> "std::vector< isys::CProfilerStatistics2 >::reverse_iterator":
        return _connect.ProfilerStatistics2Vector_rend(self)

    def clear(self) -> "void":
        return _connect.ProfilerStatistics2Vector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CProfilerStatistics2 >::allocator_type":
        return _connect.ProfilerStatistics2Vector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.ProfilerStatistics2Vector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CProfilerStatistics2 >::iterator":
        return _connect.ProfilerStatistics2Vector_erase(self, *args)

    def __init__(self, *args):
        _connect.ProfilerStatistics2Vector_swiginit(self, _connect.new_ProfilerStatistics2Vector(*args))

    def push_back(self, x: "CProfilerStatistics2") -> "void":
        return _connect.ProfilerStatistics2Vector_push_back(self, x)

    def front(self) -> "std::vector< isys::CProfilerStatistics2 >::value_type const &":
        return _connect.ProfilerStatistics2Vector_front(self)

    def back(self) -> "std::vector< isys::CProfilerStatistics2 >::value_type const &":
        return _connect.ProfilerStatistics2Vector_back(self)

    def assign(self, n: "std::vector< isys::CProfilerStatistics2 >::size_type", x: "CProfilerStatistics2") -> "void":
        return _connect.ProfilerStatistics2Vector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.ProfilerStatistics2Vector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.ProfilerStatistics2Vector_insert(self, *args)

    def reserve(self, n: "std::vector< isys::CProfilerStatistics2 >::size_type") -> "void":
        return _connect.ProfilerStatistics2Vector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CProfilerStatistics2 >::size_type":
        return _connect.ProfilerStatistics2Vector_capacity(self)
    __swig_destroy__ = _connect.delete_ProfilerStatistics2Vector

# Register ProfilerStatistics2Vector in _connect:
_connect.ProfilerStatistics2Vector_swigregister(ProfilerStatistics2Vector)

class ProfilerStatisticVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.ProfilerStatisticVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.ProfilerStatisticVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.ProfilerStatisticVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CProfilerStatistic >::size_type":
        return _connect.ProfilerStatisticVector___len__(self)

    def __getslice__(self, i: "std::vector< isys::CProfilerStatistic >::difference_type", j: "std::vector< isys::CProfilerStatistic >::difference_type") -> "std::vector< isys::CProfilerStatistic,std::allocator< isys::CProfilerStatistic > > *":
        return _connect.ProfilerStatisticVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.ProfilerStatisticVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< isys::CProfilerStatistic >::difference_type", j: "std::vector< isys::CProfilerStatistic >::difference_type") -> "void":
        return _connect.ProfilerStatisticVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.ProfilerStatisticVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CProfilerStatistic >::value_type const &":
        return _connect.ProfilerStatisticVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.ProfilerStatisticVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CProfilerStatistic >::value_type":
        return _connect.ProfilerStatisticVector_pop(self)

    def append(self, x: "CProfilerStatistic") -> "void":
        return _connect.ProfilerStatisticVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.ProfilerStatisticVector_empty(self)

    def size(self) -> "std::vector< isys::CProfilerStatistic >::size_type":
        return _connect.ProfilerStatisticVector_size(self)

    def swap(self, v: "ProfilerStatisticVector") -> "void":
        return _connect.ProfilerStatisticVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CProfilerStatistic >::iterator":
        return _connect.ProfilerStatisticVector_begin(self)

    def end(self) -> "std::vector< isys::CProfilerStatistic >::iterator":
        return _connect.ProfilerStatisticVector_end(self)

    def rbegin(self) -> "std::vector< isys::CProfilerStatistic >::reverse_iterator":
        return _connect.ProfilerStatisticVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CProfilerStatistic >::reverse_iterator":
        return _connect.ProfilerStatisticVector_rend(self)

    def clear(self) -> "void":
        return _connect.ProfilerStatisticVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CProfilerStatistic >::allocator_type":
        return _connect.ProfilerStatisticVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.ProfilerStatisticVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CProfilerStatistic >::iterator":
        return _connect.ProfilerStatisticVector_erase(self, *args)

    def __init__(self, *args):
        _connect.ProfilerStatisticVector_swiginit(self, _connect.new_ProfilerStatisticVector(*args))

    def push_back(self, x: "CProfilerStatistic") -> "void":
        return _connect.ProfilerStatisticVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CProfilerStatistic >::value_type const &":
        return _connect.ProfilerStatisticVector_front(self)

    def back(self) -> "std::vector< isys::CProfilerStatistic >::value_type const &":
        return _connect.ProfilerStatisticVector_back(self)

    def assign(self, n: "std::vector< isys::CProfilerStatistic >::size_type", x: "CProfilerStatistic") -> "void":
        return _connect.ProfilerStatisticVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.ProfilerStatisticVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.ProfilerStatisticVector_insert(self, *args)

    def reserve(self, n: "std::vector< isys::CProfilerStatistic >::size_type") -> "void":
        return _connect.ProfilerStatisticVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CProfilerStatistic >::size_type":
        return _connect.ProfilerStatisticVector_capacity(self)
    __swig_destroy__ = _connect.delete_ProfilerStatisticVector

# Register ProfilerStatisticVector in _connect:
_connect.ProfilerStatisticVector_swigregister(ProfilerStatisticVector)

class ProfilerHistoryVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.ProfilerHistoryVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.ProfilerHistoryVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.ProfilerHistoryVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CProfilerHistory >::size_type":
        return _connect.ProfilerHistoryVector___len__(self)

    def __getslice__(self, i: "std::vector< isys::CProfilerHistory >::difference_type", j: "std::vector< isys::CProfilerHistory >::difference_type") -> "std::vector< isys::CProfilerHistory,std::allocator< isys::CProfilerHistory > > *":
        return _connect.ProfilerHistoryVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.ProfilerHistoryVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< isys::CProfilerHistory >::difference_type", j: "std::vector< isys::CProfilerHistory >::difference_type") -> "void":
        return _connect.ProfilerHistoryVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.ProfilerHistoryVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CProfilerHistory >::value_type const &":
        return _connect.ProfilerHistoryVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.ProfilerHistoryVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CProfilerHistory >::value_type":
        return _connect.ProfilerHistoryVector_pop(self)

    def append(self, x: "CProfilerHistory") -> "void":
        return _connect.ProfilerHistoryVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.ProfilerHistoryVector_empty(self)

    def size(self) -> "std::vector< isys::CProfilerHistory >::size_type":
        return _connect.ProfilerHistoryVector_size(self)

    def swap(self, v: "ProfilerHistoryVector") -> "void":
        return _connect.ProfilerHistoryVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CProfilerHistory >::iterator":
        return _connect.ProfilerHistoryVector_begin(self)

    def end(self) -> "std::vector< isys::CProfilerHistory >::iterator":
        return _connect.ProfilerHistoryVector_end(self)

    def rbegin(self) -> "std::vector< isys::CProfilerHistory >::reverse_iterator":
        return _connect.ProfilerHistoryVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CProfilerHistory >::reverse_iterator":
        return _connect.ProfilerHistoryVector_rend(self)

    def clear(self) -> "void":
        return _connect.ProfilerHistoryVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CProfilerHistory >::allocator_type":
        return _connect.ProfilerHistoryVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.ProfilerHistoryVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CProfilerHistory >::iterator":
        return _connect.ProfilerHistoryVector_erase(self, *args)

    def __init__(self, *args):
        _connect.ProfilerHistoryVector_swiginit(self, _connect.new_ProfilerHistoryVector(*args))

    def push_back(self, x: "CProfilerHistory") -> "void":
        return _connect.ProfilerHistoryVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CProfilerHistory >::value_type const &":
        return _connect.ProfilerHistoryVector_front(self)

    def back(self) -> "std::vector< isys::CProfilerHistory >::value_type const &":
        return _connect.ProfilerHistoryVector_back(self)

    def assign(self, n: "std::vector< isys::CProfilerHistory >::size_type", x: "CProfilerHistory") -> "void":
        return _connect.ProfilerHistoryVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.ProfilerHistoryVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.ProfilerHistoryVector_insert(self, *args)

    def reserve(self, n: "std::vector< isys::CProfilerHistory >::size_type") -> "void":
        return _connect.ProfilerHistoryVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CProfilerHistory >::size_type":
        return _connect.ProfilerHistoryVector_capacity(self)
    __swig_destroy__ = _connect.delete_ProfilerHistoryVector

# Register ProfilerHistoryVector in _connect:
_connect.ProfilerHistoryVector_swigregister(ProfilerHistoryVector)

class CoverageRangeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.CoverageRangeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.CoverageRangeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.CoverageRangeVector___bool__(self)

    def __len__(self) -> "std::vector< SCoverageRange >::size_type":
        return _connect.CoverageRangeVector___len__(self)

    def __getslice__(self, i: "std::vector< SCoverageRange >::difference_type", j: "std::vector< SCoverageRange >::difference_type") -> "std::vector< SCoverageRange,std::allocator< SCoverageRange > > *":
        return _connect.CoverageRangeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.CoverageRangeVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< SCoverageRange >::difference_type", j: "std::vector< SCoverageRange >::difference_type") -> "void":
        return _connect.CoverageRangeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.CoverageRangeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< SCoverageRange >::value_type const &":
        return _connect.CoverageRangeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.CoverageRangeVector___setitem__(self, *args)

    def pop(self) -> "std::vector< SCoverageRange >::value_type":
        return _connect.CoverageRangeVector_pop(self)

    def append(self, x: "SCoverageRange") -> "void":
        return _connect.CoverageRangeVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.CoverageRangeVector_empty(self)

    def size(self) -> "std::vector< SCoverageRange >::size_type":
        return _connect.CoverageRangeVector_size(self)

    def swap(self, v: "CoverageRangeVector") -> "void":
        return _connect.CoverageRangeVector_swap(self, v)

    def begin(self) -> "std::vector< SCoverageRange >::iterator":
        return _connect.CoverageRangeVector_begin(self)

    def end(self) -> "std::vector< SCoverageRange >::iterator":
        return _connect.CoverageRangeVector_end(self)

    def rbegin(self) -> "std::vector< SCoverageRange >::reverse_iterator":
        return _connect.CoverageRangeVector_rbegin(self)

    def rend(self) -> "std::vector< SCoverageRange >::reverse_iterator":
        return _connect.CoverageRangeVector_rend(self)

    def clear(self) -> "void":
        return _connect.CoverageRangeVector_clear(self)

    def get_allocator(self) -> "std::vector< SCoverageRange >::allocator_type":
        return _connect.CoverageRangeVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.CoverageRangeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< SCoverageRange >::iterator":
        return _connect.CoverageRangeVector_erase(self, *args)

    def __init__(self, *args):
        _connect.CoverageRangeVector_swiginit(self, _connect.new_CoverageRangeVector(*args))

    def push_back(self, x: "SCoverageRange") -> "void":
        return _connect.CoverageRangeVector_push_back(self, x)

    def front(self) -> "std::vector< SCoverageRange >::value_type const &":
        return _connect.CoverageRangeVector_front(self)

    def back(self) -> "std::vector< SCoverageRange >::value_type const &":
        return _connect.CoverageRangeVector_back(self)

    def assign(self, n: "std::vector< SCoverageRange >::size_type", x: "SCoverageRange") -> "void":
        return _connect.CoverageRangeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.CoverageRangeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.CoverageRangeVector_insert(self, *args)

    def reserve(self, n: "std::vector< SCoverageRange >::size_type") -> "void":
        return _connect.CoverageRangeVector_reserve(self, n)

    def capacity(self) -> "std::vector< SCoverageRange >::size_type":
        return _connect.CoverageRangeVector_capacity(self)
    __swig_destroy__ = _connect.delete_CoverageRangeVector

# Register CoverageRangeVector in _connect:
_connect.CoverageRangeVector_swigregister(CoverageRangeVector)

class DownloadListVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.DownloadListVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.DownloadListVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.DownloadListVector___bool__(self)

    def __len__(self) -> "std::vector< isys::DownloadListMember >::size_type":
        return _connect.DownloadListVector___len__(self)

    def __getslice__(self, i: "std::vector< isys::DownloadListMember >::difference_type", j: "std::vector< isys::DownloadListMember >::difference_type") -> "std::vector< isys::DownloadListMember,std::allocator< isys::DownloadListMember > > *":
        return _connect.DownloadListVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.DownloadListVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< isys::DownloadListMember >::difference_type", j: "std::vector< isys::DownloadListMember >::difference_type") -> "void":
        return _connect.DownloadListVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.DownloadListVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::DownloadListMember >::value_type const &":
        return _connect.DownloadListVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.DownloadListVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::DownloadListMember >::value_type":
        return _connect.DownloadListVector_pop(self)

    def append(self, x: "DownloadListMember") -> "void":
        return _connect.DownloadListVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.DownloadListVector_empty(self)

    def size(self) -> "std::vector< isys::DownloadListMember >::size_type":
        return _connect.DownloadListVector_size(self)

    def swap(self, v: "DownloadListVector") -> "void":
        return _connect.DownloadListVector_swap(self, v)

    def begin(self) -> "std::vector< isys::DownloadListMember >::iterator":
        return _connect.DownloadListVector_begin(self)

    def end(self) -> "std::vector< isys::DownloadListMember >::iterator":
        return _connect.DownloadListVector_end(self)

    def rbegin(self) -> "std::vector< isys::DownloadListMember >::reverse_iterator":
        return _connect.DownloadListVector_rbegin(self)

    def rend(self) -> "std::vector< isys::DownloadListMember >::reverse_iterator":
        return _connect.DownloadListVector_rend(self)

    def clear(self) -> "void":
        return _connect.DownloadListVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::DownloadListMember >::allocator_type":
        return _connect.DownloadListVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.DownloadListVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::DownloadListMember >::iterator":
        return _connect.DownloadListVector_erase(self, *args)

    def __init__(self, *args):
        _connect.DownloadListVector_swiginit(self, _connect.new_DownloadListVector(*args))

    def push_back(self, x: "DownloadListMember") -> "void":
        return _connect.DownloadListVector_push_back(self, x)

    def front(self) -> "std::vector< isys::DownloadListMember >::value_type const &":
        return _connect.DownloadListVector_front(self)

    def back(self) -> "std::vector< isys::DownloadListMember >::value_type const &":
        return _connect.DownloadListVector_back(self)

    def assign(self, n: "std::vector< isys::DownloadListMember >::size_type", x: "DownloadListMember") -> "void":
        return _connect.DownloadListVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.DownloadListVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.DownloadListVector_insert(self, *args)

    def reserve(self, n: "std::vector< isys::DownloadListMember >::size_type") -> "void":
        return _connect.DownloadListVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::DownloadListMember >::size_type":
        return _connect.DownloadListVector_capacity(self)
    __swig_destroy__ = _connect.delete_DownloadListVector

# Register DownloadListVector in _connect:
_connect.DownloadListVector_swigregister(DownloadListVector)

class StackFrameVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StackFrameVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.StackFrameVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.StackFrameVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CStackFrame >::size_type":
        return _connect.StackFrameVector___len__(self)

    def __getslice__(self, i: "std::vector< isys::CStackFrame >::difference_type", j: "std::vector< isys::CStackFrame >::difference_type") -> "std::vector< isys::CStackFrame,std::allocator< isys::CStackFrame > > *":
        return _connect.StackFrameVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.StackFrameVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< isys::CStackFrame >::difference_type", j: "std::vector< isys::CStackFrame >::difference_type") -> "void":
        return _connect.StackFrameVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.StackFrameVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CStackFrame >::value_type const &":
        return _connect.StackFrameVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.StackFrameVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CStackFrame >::value_type":
        return _connect.StackFrameVector_pop(self)

    def append(self, x: "CStackFrame") -> "void":
        return _connect.StackFrameVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.StackFrameVector_empty(self)

    def size(self) -> "std::vector< isys::CStackFrame >::size_type":
        return _connect.StackFrameVector_size(self)

    def swap(self, v: "StackFrameVector") -> "void":
        return _connect.StackFrameVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CStackFrame >::iterator":
        return _connect.StackFrameVector_begin(self)

    def end(self) -> "std::vector< isys::CStackFrame >::iterator":
        return _connect.StackFrameVector_end(self)

    def rbegin(self) -> "std::vector< isys::CStackFrame >::reverse_iterator":
        return _connect.StackFrameVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CStackFrame >::reverse_iterator":
        return _connect.StackFrameVector_rend(self)

    def clear(self) -> "void":
        return _connect.StackFrameVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CStackFrame >::allocator_type":
        return _connect.StackFrameVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.StackFrameVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CStackFrame >::iterator":
        return _connect.StackFrameVector_erase(self, *args)

    def __init__(self, *args):
        _connect.StackFrameVector_swiginit(self, _connect.new_StackFrameVector(*args))

    def push_back(self, x: "CStackFrame") -> "void":
        return _connect.StackFrameVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CStackFrame >::value_type const &":
        return _connect.StackFrameVector_front(self)

    def back(self) -> "std::vector< isys::CStackFrame >::value_type const &":
        return _connect.StackFrameVector_back(self)

    def assign(self, n: "std::vector< isys::CStackFrame >::size_type", x: "CStackFrame") -> "void":
        return _connect.StackFrameVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.StackFrameVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.StackFrameVector_insert(self, *args)

    def reserve(self, n: "std::vector< isys::CStackFrame >::size_type") -> "void":
        return _connect.StackFrameVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CStackFrame >::size_type":
        return _connect.StackFrameVector_capacity(self)
    __swig_destroy__ = _connect.delete_StackFrameVector

# Register StackFrameVector in _connect:
_connect.StackFrameVector_swigregister(StackFrameVector)

class VariableVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.VariableVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.VariableVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.VariableVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CVariable >::size_type":
        return _connect.VariableVector___len__(self)

    def __getslice__(self, i: "std::vector< isys::CVariable >::difference_type", j: "std::vector< isys::CVariable >::difference_type") -> "std::vector< isys::CVariable,std::allocator< isys::CVariable > > *":
        return _connect.VariableVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.VariableVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< isys::CVariable >::difference_type", j: "std::vector< isys::CVariable >::difference_type") -> "void":
        return _connect.VariableVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.VariableVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CVariable >::value_type const &":
        return _connect.VariableVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.VariableVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CVariable >::value_type":
        return _connect.VariableVector_pop(self)

    def append(self, x: "CVariable") -> "void":
        return _connect.VariableVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.VariableVector_empty(self)

    def size(self) -> "std::vector< isys::CVariable >::size_type":
        return _connect.VariableVector_size(self)

    def swap(self, v: "VariableVector") -> "void":
        return _connect.VariableVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CVariable >::iterator":
        return _connect.VariableVector_begin(self)

    def end(self) -> "std::vector< isys::CVariable >::iterator":
        return _connect.VariableVector_end(self)

    def rbegin(self) -> "std::vector< isys::CVariable >::reverse_iterator":
        return _connect.VariableVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CVariable >::reverse_iterator":
        return _connect.VariableVector_rend(self)

    def clear(self) -> "void":
        return _connect.VariableVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CVariable >::allocator_type":
        return _connect.VariableVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.VariableVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CVariable >::iterator":
        return _connect.VariableVector_erase(self, *args)

    def __init__(self, *args):
        _connect.VariableVector_swiginit(self, _connect.new_VariableVector(*args))

    def push_back(self, x: "CVariable") -> "void":
        return _connect.VariableVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CVariable >::value_type const &":
        return _connect.VariableVector_front(self)

    def back(self) -> "std::vector< isys::CVariable >::value_type const &":
        return _connect.VariableVector_back(self)

    def assign(self, n: "std::vector< isys::CVariable >::size_type", x: "CVariable") -> "void":
        return _connect.VariableVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.VariableVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.VariableVector_insert(self, *args)

    def reserve(self, n: "std::vector< isys::CVariable >::size_type") -> "void":
        return _connect.VariableVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CVariable >::size_type":
        return _connect.VariableVector_capacity(self)
    __swig_destroy__ = _connect.delete_VariableVector

# Register VariableVector in _connect:
_connect.VariableVector_swigregister(VariableVector)

class FunctionVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.FunctionVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.FunctionVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.FunctionVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CFunction >::size_type":
        return _connect.FunctionVector___len__(self)

    def __getslice__(self, i: "std::vector< isys::CFunction >::difference_type", j: "std::vector< isys::CFunction >::difference_type") -> "std::vector< isys::CFunction,std::allocator< isys::CFunction > > *":
        return _connect.FunctionVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.FunctionVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< isys::CFunction >::difference_type", j: "std::vector< isys::CFunction >::difference_type") -> "void":
        return _connect.FunctionVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.FunctionVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CFunction >::value_type const &":
        return _connect.FunctionVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.FunctionVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CFunction >::value_type":
        return _connect.FunctionVector_pop(self)

    def append(self, x: "CFunction") -> "void":
        return _connect.FunctionVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.FunctionVector_empty(self)

    def size(self) -> "std::vector< isys::CFunction >::size_type":
        return _connect.FunctionVector_size(self)

    def swap(self, v: "FunctionVector") -> "void":
        return _connect.FunctionVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CFunction >::iterator":
        return _connect.FunctionVector_begin(self)

    def end(self) -> "std::vector< isys::CFunction >::iterator":
        return _connect.FunctionVector_end(self)

    def rbegin(self) -> "std::vector< isys::CFunction >::reverse_iterator":
        return _connect.FunctionVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CFunction >::reverse_iterator":
        return _connect.FunctionVector_rend(self)

    def clear(self) -> "void":
        return _connect.FunctionVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CFunction >::allocator_type":
        return _connect.FunctionVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.FunctionVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CFunction >::iterator":
        return _connect.FunctionVector_erase(self, *args)

    def __init__(self, *args):
        _connect.FunctionVector_swiginit(self, _connect.new_FunctionVector(*args))

    def push_back(self, x: "CFunction") -> "void":
        return _connect.FunctionVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CFunction >::value_type const &":
        return _connect.FunctionVector_front(self)

    def back(self) -> "std::vector< isys::CFunction >::value_type const &":
        return _connect.FunctionVector_back(self)

    def assign(self, n: "std::vector< isys::CFunction >::size_type", x: "CFunction") -> "void":
        return _connect.FunctionVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.FunctionVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.FunctionVector_insert(self, *args)

    def reserve(self, n: "std::vector< isys::CFunction >::size_type") -> "void":
        return _connect.FunctionVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CFunction >::size_type":
        return _connect.FunctionVector_capacity(self)
    __swig_destroy__ = _connect.delete_FunctionVector

# Register FunctionVector in _connect:
_connect.FunctionVector_swigregister(FunctionVector)

class ModuleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.ModuleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.ModuleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.ModuleVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CModule >::size_type":
        return _connect.ModuleVector___len__(self)

    def __getslice__(self, i: "std::vector< isys::CModule >::difference_type", j: "std::vector< isys::CModule >::difference_type") -> "std::vector< isys::CModule,std::allocator< isys::CModule > > *":
        return _connect.ModuleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.ModuleVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< isys::CModule >::difference_type", j: "std::vector< isys::CModule >::difference_type") -> "void":
        return _connect.ModuleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.ModuleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CModule >::value_type const &":
        return _connect.ModuleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.ModuleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CModule >::value_type":
        return _connect.ModuleVector_pop(self)

    def append(self, x: "CModule") -> "void":
        return _connect.ModuleVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.ModuleVector_empty(self)

    def size(self) -> "std::vector< isys::CModule >::size_type":
        return _connect.ModuleVector_size(self)

    def swap(self, v: "ModuleVector") -> "void":
        return _connect.ModuleVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CModule >::iterator":
        return _connect.ModuleVector_begin(self)

    def end(self) -> "std::vector< isys::CModule >::iterator":
        return _connect.ModuleVector_end(self)

    def rbegin(self) -> "std::vector< isys::CModule >::reverse_iterator":
        return _connect.ModuleVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CModule >::reverse_iterator":
        return _connect.ModuleVector_rend(self)

    def clear(self) -> "void":
        return _connect.ModuleVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CModule >::allocator_type":
        return _connect.ModuleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.ModuleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CModule >::iterator":
        return _connect.ModuleVector_erase(self, *args)

    def __init__(self, *args):
        _connect.ModuleVector_swiginit(self, _connect.new_ModuleVector(*args))

    def push_back(self, x: "CModule") -> "void":
        return _connect.ModuleVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CModule >::value_type const &":
        return _connect.ModuleVector_front(self)

    def back(self) -> "std::vector< isys::CModule >::value_type const &":
        return _connect.ModuleVector_back(self)

    def assign(self, n: "std::vector< isys::CModule >::size_type", x: "CModule") -> "void":
        return _connect.ModuleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.ModuleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.ModuleVector_insert(self, *args)

    def reserve(self, n: "std::vector< isys::CModule >::size_type") -> "void":
        return _connect.ModuleVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CModule >::size_type":
        return _connect.ModuleVector_capacity(self)
    __swig_destroy__ = _connect.delete_ModuleVector

# Register ModuleVector in _connect:
_connect.ModuleVector_swigregister(ModuleVector)

class TypeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.TypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.TypeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.TypeVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CType >::size_type":
        return _connect.TypeVector___len__(self)

    def __getslice__(self, i: "std::vector< isys::CType >::difference_type", j: "std::vector< isys::CType >::difference_type") -> "std::vector< isys::CType,std::allocator< isys::CType > > *":
        return _connect.TypeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.TypeVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< isys::CType >::difference_type", j: "std::vector< isys::CType >::difference_type") -> "void":
        return _connect.TypeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.TypeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CType >::value_type const &":
        return _connect.TypeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.TypeVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CType >::value_type":
        return _connect.TypeVector_pop(self)

    def append(self, x: "CType") -> "void":
        return _connect.TypeVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.TypeVector_empty(self)

    def size(self) -> "std::vector< isys::CType >::size_type":
        return _connect.TypeVector_size(self)

    def swap(self, v: "TypeVector") -> "void":
        return _connect.TypeVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CType >::iterator":
        return _connect.TypeVector_begin(self)

    def end(self) -> "std::vector< isys::CType >::iterator":
        return _connect.TypeVector_end(self)

    def rbegin(self) -> "std::vector< isys::CType >::reverse_iterator":
        return _connect.TypeVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CType >::reverse_iterator":
        return _connect.TypeVector_rend(self)

    def clear(self) -> "void":
        return _connect.TypeVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CType >::allocator_type":
        return _connect.TypeVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.TypeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CType >::iterator":
        return _connect.TypeVector_erase(self, *args)

    def __init__(self, *args):
        _connect.TypeVector_swiginit(self, _connect.new_TypeVector(*args))

    def push_back(self, x: "CType") -> "void":
        return _connect.TypeVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CType >::value_type const &":
        return _connect.TypeVector_front(self)

    def back(self) -> "std::vector< isys::CType >::value_type const &":
        return _connect.TypeVector_back(self)

    def assign(self, n: "std::vector< isys::CType >::size_type", x: "CType") -> "void":
        return _connect.TypeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.TypeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.TypeVector_insert(self, *args)

    def reserve(self, n: "std::vector< isys::CType >::size_type") -> "void":
        return _connect.TypeVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CType >::size_type":
        return _connect.TypeVector_capacity(self)
    __swig_destroy__ = _connect.delete_TypeVector

# Register TypeVector in _connect:
_connect.TypeVector_swigregister(TypeVector)

class TypedefVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.TypedefVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.TypedefVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.TypedefVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CTypedef >::size_type":
        return _connect.TypedefVector___len__(self)

    def __getslice__(self, i: "std::vector< isys::CTypedef >::difference_type", j: "std::vector< isys::CTypedef >::difference_type") -> "std::vector< isys::CTypedef,std::allocator< isys::CTypedef > > *":
        return _connect.TypedefVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.TypedefVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< isys::CTypedef >::difference_type", j: "std::vector< isys::CTypedef >::difference_type") -> "void":
        return _connect.TypedefVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.TypedefVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CTypedef >::value_type const &":
        return _connect.TypedefVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.TypedefVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CTypedef >::value_type":
        return _connect.TypedefVector_pop(self)

    def append(self, x: "CTypedef") -> "void":
        return _connect.TypedefVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.TypedefVector_empty(self)

    def size(self) -> "std::vector< isys::CTypedef >::size_type":
        return _connect.TypedefVector_size(self)

    def swap(self, v: "TypedefVector") -> "void":
        return _connect.TypedefVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CTypedef >::iterator":
        return _connect.TypedefVector_begin(self)

    def end(self) -> "std::vector< isys::CTypedef >::iterator":
        return _connect.TypedefVector_end(self)

    def rbegin(self) -> "std::vector< isys::CTypedef >::reverse_iterator":
        return _connect.TypedefVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CTypedef >::reverse_iterator":
        return _connect.TypedefVector_rend(self)

    def clear(self) -> "void":
        return _connect.TypedefVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CTypedef >::allocator_type":
        return _connect.TypedefVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.TypedefVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CTypedef >::iterator":
        return _connect.TypedefVector_erase(self, *args)

    def __init__(self, *args):
        _connect.TypedefVector_swiginit(self, _connect.new_TypedefVector(*args))

    def push_back(self, x: "CTypedef") -> "void":
        return _connect.TypedefVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CTypedef >::value_type const &":
        return _connect.TypedefVector_front(self)

    def back(self) -> "std::vector< isys::CTypedef >::value_type const &":
        return _connect.TypedefVector_back(self)

    def assign(self, n: "std::vector< isys::CTypedef >::size_type", x: "CTypedef") -> "void":
        return _connect.TypedefVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.TypedefVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.TypedefVector_insert(self, *args)

    def reserve(self, n: "std::vector< isys::CTypedef >::size_type") -> "void":
        return _connect.TypedefVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CTypedef >::size_type":
        return _connect.TypedefVector_capacity(self)
    __swig_destroy__ = _connect.delete_TypedefVector

# Register TypedefVector in _connect:
_connect.TypedefVector_swigregister(TypedefVector)

class HILChannelVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.HILChannelVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.HILChannelVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.HILChannelVector___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::size_type":
        return _connect.HILChannelVector___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< isys::CHILChannel > >::difference_type", j: "std::vector< std::shared_ptr< isys::CHILChannel > >::difference_type") -> "std::vector< std::shared_ptr< isys::CHILChannel >,std::allocator< std::shared_ptr< isys::CHILChannel > > > *":
        return _connect.HILChannelVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.HILChannelVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< isys::CHILChannel > >::difference_type", j: "std::vector< std::shared_ptr< isys::CHILChannel > >::difference_type") -> "void":
        return _connect.HILChannelVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.HILChannelVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::value_type const &":
        return _connect.HILChannelVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.HILChannelVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::value_type":
        return _connect.HILChannelVector_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< isys::CHILChannel > >::value_type const &") -> "void":
        return _connect.HILChannelVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.HILChannelVector_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::size_type":
        return _connect.HILChannelVector_size(self)

    def swap(self, v: "HILChannelVector") -> "void":
        return _connect.HILChannelVector_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::iterator":
        return _connect.HILChannelVector_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::iterator":
        return _connect.HILChannelVector_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::reverse_iterator":
        return _connect.HILChannelVector_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::reverse_iterator":
        return _connect.HILChannelVector_rend(self)

    def clear(self) -> "void":
        return _connect.HILChannelVector_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::allocator_type":
        return _connect.HILChannelVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.HILChannelVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::iterator":
        return _connect.HILChannelVector_erase(self, *args)

    def __init__(self, *args):
        _connect.HILChannelVector_swiginit(self, _connect.new_HILChannelVector(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< isys::CHILChannel > >::value_type const &") -> "void":
        return _connect.HILChannelVector_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::value_type const &":
        return _connect.HILChannelVector_front(self)

    def back(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::value_type const &":
        return _connect.HILChannelVector_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< isys::CHILChannel > >::size_type", x: "std::vector< std::shared_ptr< isys::CHILChannel > >::value_type const &") -> "void":
        return _connect.HILChannelVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.HILChannelVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.HILChannelVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< isys::CHILChannel > >::size_type") -> "void":
        return _connect.HILChannelVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::size_type":
        return _connect.HILChannelVector_capacity(self)
    __swig_destroy__ = _connect.delete_HILChannelVector

# Register HILChannelVector in _connect:
_connect.HILChannelVector_swigregister(HILChannelVector)

class StrVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.StrVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.StrVector___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _connect.StrVector___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        return _connect.StrVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.StrVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        return _connect.StrVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.StrVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _connect.StrVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.StrVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _connect.StrVector_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _connect.StrVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.StrVector_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _connect.StrVector_size(self)

    def swap(self, v: "StrVector") -> "void":
        return _connect.StrVector_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _connect.StrVector_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _connect.StrVector_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _connect.StrVector_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _connect.StrVector_rend(self)

    def clear(self) -> "void":
        return _connect.StrVector_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _connect.StrVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.StrVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _connect.StrVector_erase(self, *args)

    def __init__(self, *args):
        _connect.StrVector_swiginit(self, _connect.new_StrVector(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _connect.StrVector_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _connect.StrVector_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _connect.StrVector_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        return _connect.StrVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.StrVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.StrVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        return _connect.StrVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _connect.StrVector_capacity(self)
    __swig_destroy__ = _connect.delete_StrVector

# Register StrVector in _connect:
_connect.StrVector_swigregister(StrVector)

class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.IntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.IntVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _connect.IntVector___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _connect.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.IntVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _connect.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _connect.IntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.IntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _connect.IntVector_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _connect.IntVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.IntVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _connect.IntVector_size(self)

    def swap(self, v: "IntVector") -> "void":
        return _connect.IntVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _connect.IntVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _connect.IntVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _connect.IntVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _connect.IntVector_rend(self)

    def clear(self) -> "void":
        return _connect.IntVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _connect.IntVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.IntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _connect.IntVector_erase(self, *args)

    def __init__(self, *args):
        _connect.IntVector_swiginit(self, _connect.new_IntVector(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _connect.IntVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _connect.IntVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _connect.IntVector_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _connect.IntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.IntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.IntVector_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _connect.IntVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _connect.IntVector_capacity(self)
    __swig_destroy__ = _connect.delete_IntVector

# Register IntVector in _connect:
_connect.IntVector_swigregister(IntVector)

class StrSet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.StrSet_swiginit(self, _connect.new_StrSet(*args))

    def size(self) -> "unsigned int":
        return _connect.StrSet_size(self)

    def empty(self) -> "bool":
        return _connect.StrSet_empty(self)

    def clear(self) -> "void":
        return _connect.StrSet_clear(self)

    def remove(self, key: "std::string const &") -> "void":
        return _connect.StrSet_remove(self, key)

    def contains(self, value: "std::string const &") -> "bool":
        return _connect.StrSet_contains(self, value)

    def toString(self) -> "std::string":
        return _connect.StrSet_toString(self)
    __swig_destroy__ = _connect.delete_StrSet

# Register StrSet in _connect:
_connect.StrSet_swigregister(StrSet)

class StrStrMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrStrMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.StrStrMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.StrStrMap___bool__(self)

    def __len__(self) -> "std::map< std::string,std::string >::size_type":
        return _connect.StrStrMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::mapped_type const &":
        return _connect.StrStrMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,std::string >::key_type const &") -> "void":
        return _connect.StrStrMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,std::string >::key_type const &") -> "bool":
        return _connect.StrStrMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _connect.StrStrMap_keys(self)

    def values(self) -> "PyObject *":
        return _connect.StrStrMap_values(self)

    def items(self) -> "PyObject *":
        return _connect.StrStrMap_items(self)

    def __contains__(self, key: "std::map< std::string,std::string >::key_type const &") -> "bool":
        return _connect.StrStrMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrStrMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrStrMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _connect.StrStrMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _connect.StrStrMap_asdict(self)

    def __init__(self, *args):
        _connect.StrStrMap_swiginit(self, _connect.new_StrStrMap(*args))

    def empty(self) -> "bool":
        return _connect.StrStrMap_empty(self)

    def size(self) -> "std::map< std::string,std::string >::size_type":
        return _connect.StrStrMap_size(self)

    def swap(self, v: "StrStrMap") -> "void":
        return _connect.StrStrMap_swap(self, v)

    def begin(self) -> "std::map< std::string,std::string >::iterator":
        return _connect.StrStrMap_begin(self)

    def end(self) -> "std::map< std::string,std::string >::iterator":
        return _connect.StrStrMap_end(self)

    def rbegin(self) -> "std::map< std::string,std::string >::reverse_iterator":
        return _connect.StrStrMap_rbegin(self)

    def rend(self) -> "std::map< std::string,std::string >::reverse_iterator":
        return _connect.StrStrMap_rend(self)

    def clear(self) -> "void":
        return _connect.StrStrMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::string >::allocator_type":
        return _connect.StrStrMap_get_allocator(self)

    def count(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::size_type":
        return _connect.StrStrMap_count(self, x)

    def erase(self, *args) -> "void":
        return _connect.StrStrMap_erase(self, *args)

    def find(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        return _connect.StrStrMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        return _connect.StrStrMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        return _connect.StrStrMap_upper_bound(self, x)
    __swig_destroy__ = _connect.delete_StrStrMap

# Register StrStrMap in _connect:
_connect.StrStrMap_swigregister(StrStrMap)

class StrStrMapIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, container: "StrStrMap"):
        _connect.StrStrMapIterator_swiginit(self, _connect.new_StrStrMapIterator(container))

    def isValid(self) -> "bool":
        return _connect.StrStrMapIterator_isValid(self)

    def key(self) -> "std::string const &":
        return _connect.StrStrMapIterator_key(self)

    def value(self) -> "std::string const &":
        return _connect.StrStrMapIterator_value(self)

    def inc(self) -> "void":
        return _connect.StrStrMapIterator_inc(self)
    __swig_destroy__ = _connect.delete_StrStrMapIterator

# Register StrStrMapIterator in _connect:
_connect.StrStrMapIterator_swigregister(StrStrMapIterator)

class StrStrVectorMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrStrVectorMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.StrStrVectorMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.StrStrVectorMap___bool__(self)

    def __len__(self) -> "std::map< std::string,std::vector< std::string > >::size_type":
        return _connect.StrStrVectorMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,std::vector< std::string > >::key_type const &") -> "std::map< std::string,std::vector< std::string > >::mapped_type const &":
        return _connect.StrStrVectorMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,std::vector< std::string > >::key_type const &") -> "void":
        return _connect.StrStrVectorMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,std::vector< std::string > >::key_type const &") -> "bool":
        return _connect.StrStrVectorMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _connect.StrStrVectorMap_keys(self)

    def values(self) -> "PyObject *":
        return _connect.StrStrVectorMap_values(self)

    def items(self) -> "PyObject *":
        return _connect.StrStrVectorMap_items(self)

    def __contains__(self, key: "std::map< std::string,std::vector< std::string > >::key_type const &") -> "bool":
        return _connect.StrStrVectorMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrStrVectorMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrStrVectorMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _connect.StrStrVectorMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _connect.StrStrVectorMap_asdict(self)

    def __init__(self, *args):
        _connect.StrStrVectorMap_swiginit(self, _connect.new_StrStrVectorMap(*args))

    def empty(self) -> "bool":
        return _connect.StrStrVectorMap_empty(self)

    def size(self) -> "std::map< std::string,std::vector< std::string > >::size_type":
        return _connect.StrStrVectorMap_size(self)

    def swap(self, v: "StrStrVectorMap") -> "void":
        return _connect.StrStrVectorMap_swap(self, v)

    def begin(self) -> "std::map< std::string,std::vector< std::string > >::iterator":
        return _connect.StrStrVectorMap_begin(self)

    def end(self) -> "std::map< std::string,std::vector< std::string > >::iterator":
        return _connect.StrStrVectorMap_end(self)

    def rbegin(self) -> "std::map< std::string,std::vector< std::string > >::reverse_iterator":
        return _connect.StrStrVectorMap_rbegin(self)

    def rend(self) -> "std::map< std::string,std::vector< std::string > >::reverse_iterator":
        return _connect.StrStrVectorMap_rend(self)

    def clear(self) -> "void":
        return _connect.StrStrVectorMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::vector< std::string > >::allocator_type":
        return _connect.StrStrVectorMap_get_allocator(self)

    def count(self, x: "std::map< std::string,std::vector< std::string > >::key_type const &") -> "std::map< std::string,std::vector< std::string > >::size_type":
        return _connect.StrStrVectorMap_count(self, x)

    def erase(self, *args) -> "void":
        return _connect.StrStrVectorMap_erase(self, *args)

    def find(self, x: "std::map< std::string,std::vector< std::string > >::key_type const &") -> "std::map< std::string,std::vector< std::string > >::iterator":
        return _connect.StrStrVectorMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,std::vector< std::string > >::key_type const &") -> "std::map< std::string,std::vector< std::string > >::iterator":
        return _connect.StrStrVectorMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,std::vector< std::string > >::key_type const &") -> "std::map< std::string,std::vector< std::string > >::iterator":
        return _connect.StrStrVectorMap_upper_bound(self, x)
    __swig_destroy__ = _connect.delete_StrStrVectorMap

# Register StrStrVectorMap in _connect:
_connect.StrStrVectorMap_swigregister(StrStrVectorMap)

class DIOBankChannelIndexVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.DIOBankChannelIndexVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.DIOBankChannelIndexVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.DIOBankChannelIndexVector___bool__(self)

    def __len__(self) -> "std::vector< isys::DIOBankChannelIndex >::size_type":
        return _connect.DIOBankChannelIndexVector___len__(self)

    def __getslice__(self, i: "std::vector< isys::DIOBankChannelIndex >::difference_type", j: "std::vector< isys::DIOBankChannelIndex >::difference_type") -> "std::vector< isys::DIOBankChannelIndex,std::allocator< isys::DIOBankChannelIndex > > *":
        return _connect.DIOBankChannelIndexVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.DIOBankChannelIndexVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< isys::DIOBankChannelIndex >::difference_type", j: "std::vector< isys::DIOBankChannelIndex >::difference_type") -> "void":
        return _connect.DIOBankChannelIndexVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.DIOBankChannelIndexVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::DIOBankChannelIndex >::value_type const &":
        return _connect.DIOBankChannelIndexVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.DIOBankChannelIndexVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::DIOBankChannelIndex >::value_type":
        return _connect.DIOBankChannelIndexVector_pop(self)

    def append(self, x: "DIOBankChannelIndex") -> "void":
        return _connect.DIOBankChannelIndexVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.DIOBankChannelIndexVector_empty(self)

    def size(self) -> "std::vector< isys::DIOBankChannelIndex >::size_type":
        return _connect.DIOBankChannelIndexVector_size(self)

    def swap(self, v: "DIOBankChannelIndexVector") -> "void":
        return _connect.DIOBankChannelIndexVector_swap(self, v)

    def begin(self) -> "std::vector< isys::DIOBankChannelIndex >::iterator":
        return _connect.DIOBankChannelIndexVector_begin(self)

    def end(self) -> "std::vector< isys::DIOBankChannelIndex >::iterator":
        return _connect.DIOBankChannelIndexVector_end(self)

    def rbegin(self) -> "std::vector< isys::DIOBankChannelIndex >::reverse_iterator":
        return _connect.DIOBankChannelIndexVector_rbegin(self)

    def rend(self) -> "std::vector< isys::DIOBankChannelIndex >::reverse_iterator":
        return _connect.DIOBankChannelIndexVector_rend(self)

    def clear(self) -> "void":
        return _connect.DIOBankChannelIndexVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::DIOBankChannelIndex >::allocator_type":
        return _connect.DIOBankChannelIndexVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.DIOBankChannelIndexVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::DIOBankChannelIndex >::iterator":
        return _connect.DIOBankChannelIndexVector_erase(self, *args)

    def __init__(self, *args):
        _connect.DIOBankChannelIndexVector_swiginit(self, _connect.new_DIOBankChannelIndexVector(*args))

    def push_back(self, x: "DIOBankChannelIndex") -> "void":
        return _connect.DIOBankChannelIndexVector_push_back(self, x)

    def front(self) -> "std::vector< isys::DIOBankChannelIndex >::value_type const &":
        return _connect.DIOBankChannelIndexVector_front(self)

    def back(self) -> "std::vector< isys::DIOBankChannelIndex >::value_type const &":
        return _connect.DIOBankChannelIndexVector_back(self)

    def assign(self, n: "std::vector< isys::DIOBankChannelIndex >::size_type", x: "DIOBankChannelIndex") -> "void":
        return _connect.DIOBankChannelIndexVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.DIOBankChannelIndexVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.DIOBankChannelIndexVector_insert(self, *args)

    def reserve(self, n: "std::vector< isys::DIOBankChannelIndex >::size_type") -> "void":
        return _connect.DIOBankChannelIndexVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::DIOBankChannelIndex >::size_type":
        return _connect.DIOBankChannelIndexVector_capacity(self)
    __swig_destroy__ = _connect.delete_DIOBankChannelIndexVector

# Register DIOBankChannelIndexVector in _connect:
_connect.DIOBankChannelIndexVector_swigregister(DIOBankChannelIndexVector)

class AddressVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.AddressVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.AddressVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.AddressVector___bool__(self)

    def __len__(self) -> "std::vector< unsigned long long >::size_type":
        return _connect.AddressVector___len__(self)

    def __getslice__(self, i: "std::vector< unsigned long long >::difference_type", j: "std::vector< unsigned long long >::difference_type") -> "std::vector< unsigned long long,std::allocator< unsigned long long > > *":
        return _connect.AddressVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.AddressVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned long long >::difference_type", j: "std::vector< unsigned long long >::difference_type") -> "void":
        return _connect.AddressVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.AddressVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned long long >::value_type const &":
        return _connect.AddressVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.AddressVector___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned long long >::value_type":
        return _connect.AddressVector_pop(self)

    def append(self, x: "std::vector< unsigned long long >::value_type const &") -> "void":
        return _connect.AddressVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.AddressVector_empty(self)

    def size(self) -> "std::vector< unsigned long long >::size_type":
        return _connect.AddressVector_size(self)

    def swap(self, v: "AddressVector") -> "void":
        return _connect.AddressVector_swap(self, v)

    def begin(self) -> "std::vector< unsigned long long >::iterator":
        return _connect.AddressVector_begin(self)

    def end(self) -> "std::vector< unsigned long long >::iterator":
        return _connect.AddressVector_end(self)

    def rbegin(self) -> "std::vector< unsigned long long >::reverse_iterator":
        return _connect.AddressVector_rbegin(self)

    def rend(self) -> "std::vector< unsigned long long >::reverse_iterator":
        return _connect.AddressVector_rend(self)

    def clear(self) -> "void":
        return _connect.AddressVector_clear(self)

    def get_allocator(self) -> "std::vector< unsigned long long >::allocator_type":
        return _connect.AddressVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.AddressVector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned long long >::iterator":
        return _connect.AddressVector_erase(self, *args)

    def __init__(self, *args):
        _connect.AddressVector_swiginit(self, _connect.new_AddressVector(*args))

    def push_back(self, x: "std::vector< unsigned long long >::value_type const &") -> "void":
        return _connect.AddressVector_push_back(self, x)

    def front(self) -> "std::vector< unsigned long long >::value_type const &":
        return _connect.AddressVector_front(self)

    def back(self) -> "std::vector< unsigned long long >::value_type const &":
        return _connect.AddressVector_back(self)

    def assign(self, n: "std::vector< unsigned long long >::size_type", x: "std::vector< unsigned long long >::value_type const &") -> "void":
        return _connect.AddressVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.AddressVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.AddressVector_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned long long >::size_type") -> "void":
        return _connect.AddressVector_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned long long >::size_type":
        return _connect.AddressVector_capacity(self)
    __swig_destroy__ = _connect.delete_AddressVector

# Register AddressVector in _connect:
_connect.AddressVector_swigregister(AddressVector)

class StrCoverageTestResultsMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrCoverageTestResultsMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.StrCoverageTestResultsMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.StrCoverageTestResultsMap___bool__(self)

    def __len__(self) -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::size_type":
        return _connect.StrCoverageTestResultsMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::key_type const &") -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::mapped_type const &":
        return _connect.StrCoverageTestResultsMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::key_type const &") -> "void":
        return _connect.StrCoverageTestResultsMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::key_type const &") -> "bool":
        return _connect.StrCoverageTestResultsMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _connect.StrCoverageTestResultsMap_keys(self)

    def values(self) -> "PyObject *":
        return _connect.StrCoverageTestResultsMap_values(self)

    def items(self) -> "PyObject *":
        return _connect.StrCoverageTestResultsMap_items(self)

    def __contains__(self, key: "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::key_type const &") -> "bool":
        return _connect.StrCoverageTestResultsMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrCoverageTestResultsMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrCoverageTestResultsMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _connect.StrCoverageTestResultsMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _connect.StrCoverageTestResultsMap_asdict(self)

    def __init__(self, *args):
        _connect.StrCoverageTestResultsMap_swiginit(self, _connect.new_StrCoverageTestResultsMap(*args))

    def empty(self) -> "bool":
        return _connect.StrCoverageTestResultsMap_empty(self)

    def size(self) -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::size_type":
        return _connect.StrCoverageTestResultsMap_size(self)

    def swap(self, v: "StrCoverageTestResultsMap") -> "void":
        return _connect.StrCoverageTestResultsMap_swap(self, v)

    def begin(self) -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::iterator":
        return _connect.StrCoverageTestResultsMap_begin(self)

    def end(self) -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::iterator":
        return _connect.StrCoverageTestResultsMap_end(self)

    def rbegin(self) -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::reverse_iterator":
        return _connect.StrCoverageTestResultsMap_rbegin(self)

    def rend(self) -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::reverse_iterator":
        return _connect.StrCoverageTestResultsMap_rend(self)

    def clear(self) -> "void":
        return _connect.StrCoverageTestResultsMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::allocator_type":
        return _connect.StrCoverageTestResultsMap_get_allocator(self)

    def count(self, x: "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::key_type const &") -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::size_type":
        return _connect.StrCoverageTestResultsMap_count(self, x)

    def erase(self, *args) -> "void":
        return _connect.StrCoverageTestResultsMap_erase(self, *args)

    def find(self, x: "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::key_type const &") -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::iterator":
        return _connect.StrCoverageTestResultsMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::key_type const &") -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::iterator":
        return _connect.StrCoverageTestResultsMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::key_type const &") -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::iterator":
        return _connect.StrCoverageTestResultsMap_upper_bound(self, x)
    __swig_destroy__ = _connect.delete_StrCoverageTestResultsMap

# Register StrCoverageTestResultsMap in _connect:
_connect.StrCoverageTestResultsMap_swigregister(StrCoverageTestResultsMap)

class StrProfilerTestResultsMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrProfilerTestResultsMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.StrProfilerTestResultsMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.StrProfilerTestResultsMap___bool__(self)

    def __len__(self) -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::size_type":
        return _connect.StrProfilerTestResultsMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::key_type const &") -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::mapped_type const &":
        return _connect.StrProfilerTestResultsMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::key_type const &") -> "void":
        return _connect.StrProfilerTestResultsMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::key_type const &") -> "bool":
        return _connect.StrProfilerTestResultsMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _connect.StrProfilerTestResultsMap_keys(self)

    def values(self) -> "PyObject *":
        return _connect.StrProfilerTestResultsMap_values(self)

    def items(self) -> "PyObject *":
        return _connect.StrProfilerTestResultsMap_items(self)

    def __contains__(self, key: "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::key_type const &") -> "bool":
        return _connect.StrProfilerTestResultsMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrProfilerTestResultsMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrProfilerTestResultsMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _connect.StrProfilerTestResultsMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _connect.StrProfilerTestResultsMap_asdict(self)

    def __init__(self, *args):
        _connect.StrProfilerTestResultsMap_swiginit(self, _connect.new_StrProfilerTestResultsMap(*args))

    def empty(self) -> "bool":
        return _connect.StrProfilerTestResultsMap_empty(self)

    def size(self) -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::size_type":
        return _connect.StrProfilerTestResultsMap_size(self)

    def swap(self, v: "StrProfilerTestResultsMap") -> "void":
        return _connect.StrProfilerTestResultsMap_swap(self, v)

    def begin(self) -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::iterator":
        return _connect.StrProfilerTestResultsMap_begin(self)

    def end(self) -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::iterator":
        return _connect.StrProfilerTestResultsMap_end(self)

    def rbegin(self) -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::reverse_iterator":
        return _connect.StrProfilerTestResultsMap_rbegin(self)

    def rend(self) -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::reverse_iterator":
        return _connect.StrProfilerTestResultsMap_rend(self)

    def clear(self) -> "void":
        return _connect.StrProfilerTestResultsMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::allocator_type":
        return _connect.StrProfilerTestResultsMap_get_allocator(self)

    def count(self, x: "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::key_type const &") -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::size_type":
        return _connect.StrProfilerTestResultsMap_count(self, x)

    def erase(self, *args) -> "void":
        return _connect.StrProfilerTestResultsMap_erase(self, *args)

    def find(self, x: "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::key_type const &") -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::iterator":
        return _connect.StrProfilerTestResultsMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::key_type const &") -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::iterator":
        return _connect.StrProfilerTestResultsMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::key_type const &") -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::iterator":
        return _connect.StrProfilerTestResultsMap_upper_bound(self, x)
    __swig_destroy__ = _connect.delete_StrProfilerTestResultsMap

# Register StrProfilerTestResultsMap in _connect:
_connect.StrProfilerTestResultsMap_swigregister(StrProfilerTestResultsMap)

class TestResultsVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.TestResultsVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.TestResultsVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.TestResultsVector___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::size_type":
        return _connect.TestResultsVector___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< isys::CTestResult > >::difference_type", j: "std::vector< std::shared_ptr< isys::CTestResult > >::difference_type") -> "std::vector< std::shared_ptr< isys::CTestResult >,std::allocator< std::shared_ptr< isys::CTestResult > > > *":
        return _connect.TestResultsVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.TestResultsVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< isys::CTestResult > >::difference_type", j: "std::vector< std::shared_ptr< isys::CTestResult > >::difference_type") -> "void":
        return _connect.TestResultsVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.TestResultsVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< isys::CTestResult > >::value_type const &":
        return _connect.TestResultsVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.TestResultsVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::value_type":
        return _connect.TestResultsVector_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< isys::CTestResult > >::value_type const &") -> "void":
        return _connect.TestResultsVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.TestResultsVector_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::size_type":
        return _connect.TestResultsVector_size(self)

    def swap(self, v: "TestResultsVector") -> "void":
        return _connect.TestResultsVector_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::iterator":
        return _connect.TestResultsVector_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::iterator":
        return _connect.TestResultsVector_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::reverse_iterator":
        return _connect.TestResultsVector_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::reverse_iterator":
        return _connect.TestResultsVector_rend(self)

    def clear(self) -> "void":
        return _connect.TestResultsVector_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::allocator_type":
        return _connect.TestResultsVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.TestResultsVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< isys::CTestResult > >::iterator":
        return _connect.TestResultsVector_erase(self, *args)

    def __init__(self, *args):
        _connect.TestResultsVector_swiginit(self, _connect.new_TestResultsVector(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< isys::CTestResult > >::value_type const &") -> "void":
        return _connect.TestResultsVector_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::value_type const &":
        return _connect.TestResultsVector_front(self)

    def back(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::value_type const &":
        return _connect.TestResultsVector_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< isys::CTestResult > >::size_type", x: "std::vector< std::shared_ptr< isys::CTestResult > >::value_type const &") -> "void":
        return _connect.TestResultsVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.TestResultsVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.TestResultsVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< isys::CTestResult > >::size_type") -> "void":
        return _connect.TestResultsVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::size_type":
        return _connect.TestResultsVector_capacity(self)
    __swig_destroy__ = _connect.delete_TestResultsVector

# Register TestResultsVector in _connect:
_connect.TestResultsVector_swigregister(TestResultsVector)

class TestFilterVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.TestFilterVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.TestFilterVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.TestFilterVector___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::size_type":
        return _connect.TestFilterVector___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< isys::CTestFilter > >::difference_type", j: "std::vector< std::shared_ptr< isys::CTestFilter > >::difference_type") -> "std::vector< std::shared_ptr< isys::CTestFilter >,std::allocator< std::shared_ptr< isys::CTestFilter > > > *":
        return _connect.TestFilterVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.TestFilterVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< isys::CTestFilter > >::difference_type", j: "std::vector< std::shared_ptr< isys::CTestFilter > >::difference_type") -> "void":
        return _connect.TestFilterVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.TestFilterVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::value_type const &":
        return _connect.TestFilterVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.TestFilterVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::value_type":
        return _connect.TestFilterVector_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< isys::CTestFilter > >::value_type const &") -> "void":
        return _connect.TestFilterVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.TestFilterVector_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::size_type":
        return _connect.TestFilterVector_size(self)

    def swap(self, v: "TestFilterVector") -> "void":
        return _connect.TestFilterVector_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::iterator":
        return _connect.TestFilterVector_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::iterator":
        return _connect.TestFilterVector_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::reverse_iterator":
        return _connect.TestFilterVector_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::reverse_iterator":
        return _connect.TestFilterVector_rend(self)

    def clear(self) -> "void":
        return _connect.TestFilterVector_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::allocator_type":
        return _connect.TestFilterVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.TestFilterVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::iterator":
        return _connect.TestFilterVector_erase(self, *args)

    def __init__(self, *args):
        _connect.TestFilterVector_swiginit(self, _connect.new_TestFilterVector(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< isys::CTestFilter > >::value_type const &") -> "void":
        return _connect.TestFilterVector_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::value_type const &":
        return _connect.TestFilterVector_front(self)

    def back(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::value_type const &":
        return _connect.TestFilterVector_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< isys::CTestFilter > >::size_type", x: "std::vector< std::shared_ptr< isys::CTestFilter > >::value_type const &") -> "void":
        return _connect.TestFilterVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.TestFilterVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.TestFilterVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< isys::CTestFilter > >::size_type") -> "void":
        return _connect.TestFilterVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::size_type":
        return _connect.TestFilterVector_capacity(self)
    __swig_destroy__ = _connect.delete_TestFilterVector

# Register TestFilterVector in _connect:
_connect.TestFilterVector_swigregister(TestFilterVector)

class DAQSampleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.DAQSampleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.DAQSampleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.DAQSampleVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CDAQSample >::size_type":
        return _connect.DAQSampleVector___len__(self)

    def __getslice__(self, i: "std::vector< isys::CDAQSample >::difference_type", j: "std::vector< isys::CDAQSample >::difference_type") -> "std::vector< isys::CDAQSample,std::allocator< isys::CDAQSample > > *":
        return _connect.DAQSampleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.DAQSampleVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< isys::CDAQSample >::difference_type", j: "std::vector< isys::CDAQSample >::difference_type") -> "void":
        return _connect.DAQSampleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.DAQSampleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CDAQSample >::value_type const &":
        return _connect.DAQSampleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.DAQSampleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CDAQSample >::value_type":
        return _connect.DAQSampleVector_pop(self)

    def append(self, x: "CDAQSample") -> "void":
        return _connect.DAQSampleVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.DAQSampleVector_empty(self)

    def size(self) -> "std::vector< isys::CDAQSample >::size_type":
        return _connect.DAQSampleVector_size(self)

    def swap(self, v: "DAQSampleVector") -> "void":
        return _connect.DAQSampleVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CDAQSample >::iterator":
        return _connect.DAQSampleVector_begin(self)

    def end(self) -> "std::vector< isys::CDAQSample >::iterator":
        return _connect.DAQSampleVector_end(self)

    def rbegin(self) -> "std::vector< isys::CDAQSample >::reverse_iterator":
        return _connect.DAQSampleVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CDAQSample >::reverse_iterator":
        return _connect.DAQSampleVector_rend(self)

    def clear(self) -> "void":
        return _connect.DAQSampleVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CDAQSample >::allocator_type":
        return _connect.DAQSampleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.DAQSampleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CDAQSample >::iterator":
        return _connect.DAQSampleVector_erase(self, *args)

    def __init__(self, *args):
        _connect.DAQSampleVector_swiginit(self, _connect.new_DAQSampleVector(*args))

    def push_back(self, x: "CDAQSample") -> "void":
        return _connect.DAQSampleVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CDAQSample >::value_type const &":
        return _connect.DAQSampleVector_front(self)

    def back(self) -> "std::vector< isys::CDAQSample >::value_type const &":
        return _connect.DAQSampleVector_back(self)

    def assign(self, n: "std::vector< isys::CDAQSample >::size_type", x: "CDAQSample") -> "void":
        return _connect.DAQSampleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.DAQSampleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.DAQSampleVector_insert(self, *args)

    def reserve(self, n: "std::vector< isys::CDAQSample >::size_type") -> "void":
        return _connect.DAQSampleVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CDAQSample >::size_type":
        return _connect.DAQSampleVector_capacity(self)
    __swig_destroy__ = _connect.delete_DAQSampleVector

# Register DAQSampleVector in _connect:
_connect.DAQSampleVector_swigregister(DAQSampleVector)

class DAQConfigVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.DAQConfigVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.DAQConfigVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.DAQConfigVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CDAQConfigItem >::size_type":
        return _connect.DAQConfigVector___len__(self)

    def __getslice__(self, i: "std::vector< isys::CDAQConfigItem >::difference_type", j: "std::vector< isys::CDAQConfigItem >::difference_type") -> "std::vector< isys::CDAQConfigItem,std::allocator< isys::CDAQConfigItem > > *":
        return _connect.DAQConfigVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.DAQConfigVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< isys::CDAQConfigItem >::difference_type", j: "std::vector< isys::CDAQConfigItem >::difference_type") -> "void":
        return _connect.DAQConfigVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.DAQConfigVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CDAQConfigItem >::value_type const &":
        return _connect.DAQConfigVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.DAQConfigVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CDAQConfigItem >::value_type":
        return _connect.DAQConfigVector_pop(self)

    def append(self, x: "CDAQConfigItem") -> "void":
        return _connect.DAQConfigVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.DAQConfigVector_empty(self)

    def size(self) -> "std::vector< isys::CDAQConfigItem >::size_type":
        return _connect.DAQConfigVector_size(self)

    def swap(self, v: "DAQConfigVector") -> "void":
        return _connect.DAQConfigVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CDAQConfigItem >::iterator":
        return _connect.DAQConfigVector_begin(self)

    def end(self) -> "std::vector< isys::CDAQConfigItem >::iterator":
        return _connect.DAQConfigVector_end(self)

    def rbegin(self) -> "std::vector< isys::CDAQConfigItem >::reverse_iterator":
        return _connect.DAQConfigVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CDAQConfigItem >::reverse_iterator":
        return _connect.DAQConfigVector_rend(self)

    def clear(self) -> "void":
        return _connect.DAQConfigVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CDAQConfigItem >::allocator_type":
        return _connect.DAQConfigVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.DAQConfigVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CDAQConfigItem >::iterator":
        return _connect.DAQConfigVector_erase(self, *args)

    def __init__(self, *args):
        _connect.DAQConfigVector_swiginit(self, _connect.new_DAQConfigVector(*args))

    def push_back(self, x: "CDAQConfigItem") -> "void":
        return _connect.DAQConfigVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CDAQConfigItem >::value_type const &":
        return _connect.DAQConfigVector_front(self)

    def back(self) -> "std::vector< isys::CDAQConfigItem >::value_type const &":
        return _connect.DAQConfigVector_back(self)

    def assign(self, n: "std::vector< isys::CDAQConfigItem >::size_type", x: "CDAQConfigItem") -> "void":
        return _connect.DAQConfigVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.DAQConfigVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.DAQConfigVector_insert(self, *args)

    def reserve(self, n: "std::vector< isys::CDAQConfigItem >::size_type") -> "void":
        return _connect.DAQConfigVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CDAQConfigItem >::size_type":
        return _connect.DAQConfigVector_capacity(self)
    __swig_destroy__ = _connect.delete_DAQConfigVector

# Register DAQConfigVector in _connect:
_connect.DAQConfigVector_swigregister(DAQConfigVector)

class ViewDataVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.ViewDataVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.ViewDataVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.ViewDataVector___bool__(self)

    def __len__(self) -> "std::vector< isys::ViewData >::size_type":
        return _connect.ViewDataVector___len__(self)

    def __getslice__(self, i: "std::vector< isys::ViewData >::difference_type", j: "std::vector< isys::ViewData >::difference_type") -> "std::vector< isys::ViewData,std::allocator< isys::ViewData > > *":
        return _connect.ViewDataVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.ViewDataVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< isys::ViewData >::difference_type", j: "std::vector< isys::ViewData >::difference_type") -> "void":
        return _connect.ViewDataVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.ViewDataVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::ViewData >::value_type const &":
        return _connect.ViewDataVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.ViewDataVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::ViewData >::value_type":
        return _connect.ViewDataVector_pop(self)

    def append(self, x: "ViewData") -> "void":
        return _connect.ViewDataVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.ViewDataVector_empty(self)

    def size(self) -> "std::vector< isys::ViewData >::size_type":
        return _connect.ViewDataVector_size(self)

    def swap(self, v: "ViewDataVector") -> "void":
        return _connect.ViewDataVector_swap(self, v)

    def begin(self) -> "std::vector< isys::ViewData >::iterator":
        return _connect.ViewDataVector_begin(self)

    def end(self) -> "std::vector< isys::ViewData >::iterator":
        return _connect.ViewDataVector_end(self)

    def rbegin(self) -> "std::vector< isys::ViewData >::reverse_iterator":
        return _connect.ViewDataVector_rbegin(self)

    def rend(self) -> "std::vector< isys::ViewData >::reverse_iterator":
        return _connect.ViewDataVector_rend(self)

    def clear(self) -> "void":
        return _connect.ViewDataVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::ViewData >::allocator_type":
        return _connect.ViewDataVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.ViewDataVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::ViewData >::iterator":
        return _connect.ViewDataVector_erase(self, *args)

    def __init__(self, *args):
        _connect.ViewDataVector_swiginit(self, _connect.new_ViewDataVector(*args))

    def push_back(self, x: "ViewData") -> "void":
        return _connect.ViewDataVector_push_back(self, x)

    def front(self) -> "std::vector< isys::ViewData >::value_type const &":
        return _connect.ViewDataVector_front(self)

    def back(self) -> "std::vector< isys::ViewData >::value_type const &":
        return _connect.ViewDataVector_back(self)

    def assign(self, n: "std::vector< isys::ViewData >::size_type", x: "ViewData") -> "void":
        return _connect.ViewDataVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.ViewDataVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.ViewDataVector_insert(self, *args)

    def reserve(self, n: "std::vector< isys::ViewData >::size_type") -> "void":
        return _connect.ViewDataVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::ViewData >::size_type":
        return _connect.ViewDataVector_capacity(self)
    __swig_destroy__ = _connect.delete_ViewDataVector

# Register ViewDataVector in _connect:
_connect.ViewDataVector_swigregister(ViewDataVector)



