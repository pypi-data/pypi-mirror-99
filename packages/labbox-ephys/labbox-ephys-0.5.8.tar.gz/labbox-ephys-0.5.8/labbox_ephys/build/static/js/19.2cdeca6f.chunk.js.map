{"version":3,"sources":["../node_modules/@material-ui/core/esm/utils/ownerDocument.js","../node_modules/@material-ui/core/esm/utils/requirePropFactory.js","../node_modules/@material-ui/core/esm/utils/ownerWindow.js","../node_modules/@material-ui/core/esm/utils/createChainedFunction.js","../node_modules/@material-ui/core/esm/utils/debounce.js","../node_modules/@material-ui/core/esm/utils/useControlled.js","../node_modules/@material-ui/core/esm/utils/isMuiElement.js","../node_modules/@material-ui/core/esm/utils/unsupportedProp.js","../node_modules/@babel/runtime/helpers/interopRequireDefault.js","../node_modules/@babel/runtime/helpers/interopRequireWildcard.js","../node_modules/@material-ui/icons/utils/createSvgIcon.js","../node_modules/@material-ui/core/esm/utils/deprecatedPropType.js","../node_modules/@material-ui/core/esm/utils/unstable_useId.js","../node_modules/@babel/runtime/helpers/typeof.js","python/labbox_ephys/extensions/averagewaveforms/AverageWaveformsView/setupElectrodes.ts","python/labbox_ephys/extensions/averagewaveforms/AverageWaveformsView/electrodesLayer.ts","../node_modules/@material-ui/icons/Grain.js","python/labbox_ephys/extensions/electrodegeometry/ElectrodeGeometryWidget/ElectrodeGeometryWidget.tsx","python/labbox_ephys/extensions/electrodegeometry/electrodegeometry.tsx"],"names":["ownerDocument","node","document","requirePropFactory","componentNameInError","ownerWindow","defaultView","window","createChainedFunction","_len","arguments","length","funcs","Array","_key","reduce","acc","func","_len2","args","_key2","apply","this","debounce","timeout","wait","undefined","debounced","that","later","clearTimeout","setTimeout","clear","useControlled","_ref","controlled","defaultProp","default","isControlled","name","state","React","current","_React$useState","valueState","setValue","newValue","isMuiElement","element","muiNames","indexOf","type","muiName","unsupportedProp","props","propName","componentName","location","propFullName","module","exports","obj","__esModule","_typeof","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","value","enumerable","_utils","createSvgIcon","require","deprecatedPropType","validator","reason","useId","idOverride","defaultId","setDefaultId","id","concat","Math","round","random","Symbol","iterator","constructor","computeRadiusCache","Map","computeRadius","electrodeLocations","JSON","stringify","val","leastNorm","Number","MAX_VALUE","forEach","point","otherPoint","dist","norm","min","radius","getElectrodesBoundingBox","xmin","getArrayMin","map","e","xmax","getArrayMax","ymin","ymax","getElectrodesAspectRatio","boundingBox","getWidth","getHeight","setupElectrodes","width","height","electrodeIds","layoutMode","n","transform","funcToTransform","p","electrodeBoxes","eid","ii","y","rect","transform0","label","x","pixelRadius","setupVerticalElectrodes","scaleFactor","correctedElectrodeLocations","box","fixDegenerateCase","W","H","canvasAspect","boxAspect","realizedElectrodeLocations","loc","maxElectrodePixelRadius","xMargin","yMargin","i","getBoundingBoxForEllipse","transformDistance","initialLayerState","dragRegion","draggedElectrodeIds","hoveredElectrodeId","defaultColors","border","base","selected","hover","selectedHover","dragged","draggedSelected","dragRect","textLight","textDark","handleClick","event","layer","ClickEventType","Release","getProps","selectionDispatch","electrodeOpts","disableSelection","getState","hitIds","filter","r","pointIsInEllipse","hitId","currentSelection","selection","selectedElectrodeIds","modifiers","ctrl","includes","shift","scheduleRepaint","handleHover","Move","hoveredIds","setState","handleDragSelect","drag","hits","rectangularRegionsIntersect","released","currentSelected","createElectrodesLayer","CanvasWidgetLayer","painter","opts","colors","showLabels","wipe","useLabels","hovered","color","fillEllipse","drawEllipse","drawLine","fontColor","drawText","alignment","Horizontal","Vertical","font","pixelSize","family","pen","brush","text","fillRect","setTransformMatrix","discreteMouseEventHandlers","dragHandlers","_interopRequireDefault","_interopRequireWildcard","_default","createElement","d","ElectrodeGeometryWidget","electrodeLayerProps","useMemo","electrodes","noiseLevel","samplingFrequency","useLayer","layers","useLayers","ElectrodeGeometryRecordingView","recording","ri","useRecordingInfo","recordingObject","visibleElectrodeIds","locations","ids","Error","index","zipElectrodes","geom","channel_ids","a","ElectrodeGeometrySortingView","recordingInfo","calculationPool","activate","context","registerPlugin","priority","defaultExpanded","component","singleton","icon"],"mappings":"qHAAe,SAASA,EAAcC,GACpC,OAAOA,GAAQA,EAAKD,eAAiBE,SADvC,mC,iCCAe,SAASC,EAAmBC,GAEvC,OAAO,WACL,OAAO,MAHb,mC,iCCAA,+CACe,SAASC,EAAYJ,GAElC,OADUD,YAAcC,GACbK,aAAeC,S,iCCMb,SAASC,IACtB,IAAK,IAAIC,EAAOC,UAAUC,OAAQC,EAAQ,IAAIC,MAAMJ,GAAOK,EAAO,EAAGA,EAAOL,EAAMK,IAChFF,EAAME,GAAQJ,UAAUI,GAG1B,OAAOF,EAAMG,QAAO,SAAUC,EAAKC,GACjC,OAAY,MAARA,EACKD,EASF,WACL,IAAK,IAAIE,EAAQR,UAAUC,OAAQQ,EAAO,IAAIN,MAAMK,GAAQE,EAAQ,EAAGA,EAAQF,EAAOE,IACpFD,EAAKC,GAASV,UAAUU,GAG1BJ,EAAIK,MAAMC,KAAMH,GAChBF,EAAKI,MAAMC,KAAMH,OAElB,eAjCL,mC,iCCEe,SAASI,EAASN,GAC/B,IACIO,EADAC,EAAOf,UAAUC,OAAS,QAAsBe,IAAjBhB,UAAU,GAAmBA,UAAU,GAAK,IAG/E,SAASiB,IACP,IAAK,IAAIlB,EAAOC,UAAUC,OAAQQ,EAAO,IAAIN,MAAMJ,GAAOK,EAAO,EAAGA,EAAOL,EAAMK,IAC/EK,EAAKL,GAAQJ,UAAUI,GAIzB,IAAIc,EAAON,KAEPO,EAAQ,WACVZ,EAAKI,MAAMO,EAAMT,IAGnBW,aAAaN,GACbA,EAAUO,WAAWF,EAAOJ,GAO9B,OAJAE,EAAUK,MAAQ,WAChBF,aAAaN,IAGRG,EA1BT,mC,iCCAA,6CAEe,SAASM,EAAcC,GACpC,IAAIC,EAAaD,EAAKC,WAClBC,EAAcF,EAAKG,QAMnBC,GALOJ,EAAKK,KACCL,EAAKM,MAGFC,cAA4Bf,IAAfS,GACAO,SAE7BC,EAAkBF,WAAeL,GACjCQ,EAAaD,EAAgB,GAC7BE,EAAWF,EAAgB,GA0B/B,MAAO,CAxBKL,EAAeH,EAAaS,EAmBXH,eAAkB,SAAUK,GAClDR,GACHO,EAASC,KAEV,O,iCCvCL,6CACe,SAASC,EAAaC,EAASC,GAC5C,OAAoBR,iBAAqBO,KAAwD,IAA5CC,EAASC,QAAQF,EAAQG,KAAKC,W,iCCFtE,SAASC,EAAgBC,EAAOC,EAAUC,EAAeC,EAAUC,GAE9E,OAAO,KAFX,mC,kBCMAC,EAAOC,QANP,SAAgCC,GAC9B,OAAOA,GAAOA,EAAIC,WAAaD,EAAM,CACnC,QAAWA,K,oBCFf,IAAIE,EAAU,EAAQ,KAEtB,SAASC,IACP,GAAuB,oBAAZC,QAAwB,OAAO,KAC1C,IAAIC,EAAQ,IAAID,QAMhB,OAJAD,EAA2B,WACzB,OAAOE,GAGFA,EA4CTP,EAAOC,QAzCP,SAAiCC,GAC/B,GAAIA,GAAOA,EAAIC,WACb,OAAOD,EAGT,GAAY,OAARA,GAAiC,WAAjBE,EAAQF,IAAoC,oBAARA,EACtD,MAAO,CACL,QAAWA,GAIf,IAAIK,EAAQF,IAEZ,GAAIE,GAASA,EAAMC,IAAIN,GACrB,OAAOK,EAAME,IAAIP,GAGnB,IAAIQ,EAAS,GACTC,EAAwBC,OAAOC,gBAAkBD,OAAOE,yBAE5D,IAAK,IAAIC,KAAOb,EACd,GAAIU,OAAOI,UAAUC,eAAeC,KAAKhB,EAAKa,GAAM,CAClD,IAAII,EAAOR,EAAwBC,OAAOE,yBAAyBZ,EAAKa,GAAO,KAE3EI,IAASA,EAAKV,KAAOU,EAAKC,KAC5BR,OAAOC,eAAeH,EAAQK,EAAKI,GAEnCT,EAAOK,GAAOb,EAAIa,GAWxB,OANAL,EAAgB,QAAIR,EAEhBK,GACFA,EAAMa,IAAIlB,EAAKQ,GAGVA,I,iCCjDTE,OAAOC,eAAeZ,EAAS,aAAc,CAC3CoB,OAAO,IAETT,OAAOC,eAAeZ,EAAS,UAAW,CACxCqB,YAAY,EACZb,IAAK,WACH,OAAOc,EAAOC,iBAIlB,IAAID,EAASE,EAAQ,M,m1BCZN,SAASC,EAAmBC,EAAWC,GAElD,OAAO,WACL,OAAO,M,4FCEE,SAASC,EAAMC,GAC5B,IAAI9C,EAAkBF,WAAegD,GACjCC,EAAY/C,EAAgB,GAC5BgD,EAAehD,EAAgB,GAE/BiD,EAAKH,GAAcC,EASvB,OARAjD,aAAgB,WACG,MAAbiD,GAIFC,EAAa,OAAOE,OAAOC,KAAKC,MAAsB,IAAhBD,KAAKE,cAE5C,CAACN,IACGE,E,gCCnBT,SAAS7B,EAAQF,GAaf,MAVsB,oBAAXoC,QAAoD,kBAApBA,OAAOC,SAChDvC,EAAOC,QAAUG,EAAU,SAAiBF,GAC1C,cAAcA,GAGhBF,EAAOC,QAAUG,EAAU,SAAiBF,GAC1C,OAAOA,GAAyB,oBAAXoC,QAAyBpC,EAAIsC,cAAgBF,QAAUpC,IAAQoC,OAAOtB,UAAY,gBAAkBd,GAItHE,EAAQF,GAGjBF,EAAOC,QAAUG,G,iCChBjB,0EAcMqC,EAAqB,IAAIC,IACzBC,EAAgB,SAACC,GACnB,IAAM7B,EAAM8B,KAAKC,UAAUF,GACrBG,EAAMN,EAAmBhC,IAAIM,GACnC,QAAYhD,IAARgF,EACA,OAAOA,EAKX,IAAIC,EAAYC,OAAOC,UACvBN,EAAmBO,SAAQ,SAACC,GACxBR,EAAmBO,SAAQ,SAACE,GACxB,IAAMC,EAAOC,YAAK,CAACH,EAAM,GAAKC,EAAW,GAAID,EAAM,GAAKC,EAAW,KACtD,IAATC,IACJN,EAAYb,KAAKqB,IAAIR,EAAWM,UAIxC,IAAMG,EAAS,IAAOT,EAEtB,OADAP,EAAmBrB,IAAIL,EAAK0C,GACrBA,GAGLC,EAA2B,SAACd,EAAgCa,GAC9D,MAAO,CACHE,KAAMC,YAAYhB,EAAmBiB,KAAI,SAAAC,GAAC,OAAKA,EAAE,OAAQL,EACzDM,KAAMC,YAAYpB,EAAmBiB,KAAI,SAAAC,GAAC,OAAKA,EAAE,OAAQL,EACzDQ,KAAML,YAAYhB,EAAmBiB,KAAI,SAAAC,GAAC,OAAKA,EAAE,OAAQL,EACzDS,KAAMF,YAAYpB,EAAmBiB,KAAI,SAAAC,GAAC,OAAKA,EAAE,OAAQL,IAIpDU,EAA2B,SAACvB,GACrC,IAAMa,EAASd,EAAcC,GACvBwB,EAAcV,EAAyBd,EAAoBa,GAEjE,OADkBY,YAASD,GAAeE,YAAUF,IA8IzCG,IAzES,SAAC/G,GAKnB,IACMgH,EAAgEhH,EAAhEgH,MAAOC,EAAyDjH,EAAzDiH,OAAQ7B,EAAiDpF,EAAjDoF,mBAAoB8B,EAA6BlH,EAA7BkH,aAC3C,GAAmB,aADqDlH,EAAfmH,WAErD,OAzEwB,SAAC,GAA4F,IAA3FH,EAA0F,EAA1FA,MAAOC,EAAmF,EAAnFA,OAAQC,EAA2E,EAA3EA,aAOvCE,EAAIF,EAAa1H,OAIjB6H,EAAYC,aAAgB,SAACC,GAG/B,MAAO,CATK,GAOQA,EAAE,IAAOP,EAAQ,IANzB,GAOQO,EAAE,IAAON,EAAS,QA6B1C,MAAO,CACHO,eA1BmCN,EAAab,KAAI,SAACoB,EAAKC,GAG1D,IAAMC,GAAK,GAAMD,IAAON,EAAI,GAGtBQ,EAAO,CAACzB,KAAM,EAAGI,KAAM,EAAGE,KAAMkB,EAAI,IAAOP,EAAI,GAAIV,KAAMiB,EAAI,IAAOP,EAAI,IAIxES,EAAaP,aAAgB,SAACC,GAGhC,MAAO,CAFGK,EAAKzB,KAAOoB,EAAE,IAAMK,EAAKrB,KAAOqB,EAAKzB,MACrCyB,EAAKnB,KAAOc,EAAE,IAAMK,EAAKlB,KAAOkB,EAAKnB,UAGnD,MAAO,CACHqB,MAAOL,EAAM,GACbhD,GAAIgD,EACJM,EAAG,GACHJ,IACAC,OACAP,UAAWQ,MAMfR,YACApB,OAAQ,GAAKmB,EAAI,GACjBY,aAAcf,EAAS,KAAgBG,EAAI,IA2BpCa,CAAwB,CAACjB,QAAOC,SAAQC,iBAEnD,IAsBIgB,EAtBEC,EAzBgB,SAAC/C,GACvB,IAAMgD,EACIhC,YAAYhB,EAAmBiB,KAAI,SAAAC,GAAC,OAAKA,EAAE,OAD/C8B,EAEI5B,YAAYpB,EAAmBiB,KAAI,SAAAC,GAAC,OAAKA,EAAE,OAF/C8B,EAGIhC,YAAYhB,EAAmBiB,KAAI,SAAAC,GAAC,OAAKA,EAAE,OAH/C8B,EAII5B,YAAYpB,EAAmBiB,KAAI,SAAAC,GAAC,OAAKA,EAAE,OAErD,OAAK8B,IAAaA,GAAcA,IAAaA,EAClChD,EAAmBiB,KAAI,SAAC0B,EAAGL,GAAJ,MAAW,CAACA,EAAI,MAGvCtC,EAcyBiD,CAAkBjD,GAChDkD,EAAItB,EAAQ,GACZuB,EAAItB,EAAS,GACbuB,EAAeF,EAAIC,EAEnBtC,EAASd,EAAcgD,GACzBvB,EAAcV,EAAyBiC,EAA6BlC,GACpEwC,EAAY5B,YAASD,GAAeE,YAAUF,GAE9C8B,EAA6BP,EAC5BM,EAAY,IAAQD,EAAe,IAIpCE,EAA6BP,EAA4B9B,KAAI,SAACsC,GAC1D,MAAO,CAACA,EAAI,IAAKA,EAAI,OAGzB/B,EAAc,CAAET,KAAMS,EAAYH,KAAMF,KAAMK,EAAYF,KAAMD,MAAOG,EAAYL,KAAMG,MAAOE,EAAYT,MAC5GsC,EAAY5B,YAASD,GAAeE,YAAUF,IAM9CsB,EAFAO,EAAYD,EAEEF,EAAIzB,YAASD,GAIb2B,EAAIzB,YAAUF,GAI5B5G,EAAK4I,yBACD3C,EAASiC,EAAclI,EAAK4I,0BAC5BV,GAAgBjC,EAASiC,EAAclI,EAAK4I,yBAIpD,IAAMC,GAAW7B,EAAQH,YAASD,GAAesB,GAAe,EAC1DY,GAAW7B,EAASH,YAAUF,GAAesB,GAAe,EAE5Db,EAAYC,aAAgB,SAACC,GAG/B,MAAO,CAFGsB,GAAWtB,EAAE,GAAKX,EAAYT,MAAQ+B,EACtCY,GAAWvB,EAAE,GAAKX,EAAYH,MAAQyB,MAI9CV,EAAiCkB,EAA2BrC,KAAI,SAACsC,EAAKI,GACxE,IAAMhB,EAAIY,EAAI,GACRhB,EAAIgB,EAAI,GACRf,EAAOoB,YAAyB,CAACjB,EAAGJ,GAAI1B,EAAQA,GAChD4B,EAAaP,aAAgB,SAACC,GAGhC,MAAO,CAFGK,EAAKzB,KAAOoB,EAAE,IAAMK,EAAKrB,KAAOqB,EAAKzB,MACrCyB,EAAKnB,KAAOc,EAAE,IAAMK,EAAKlB,KAAOkB,EAAKnB,UAGnD,MAAO,CAAEqB,MAAOZ,EAAa6B,GAAK,GAAItE,GAAIyC,EAAa6B,GAAIhB,EAAGA,EAAGJ,EAAGA,EAAGC,OAAMP,UAAWQ,MAEtFG,EAAciB,YAAkB5B,EAAW,CAACpB,EAAQ,IAAI,GAC9D,MAAO,CAACuB,iBAAgBH,YAAWpB,SAAQ+B,iB,0HCnKzCkB,EAAoB,CACtB1B,eAAgB,GAChBvB,OAAQ,EACR+B,YAAa,EACbmB,WAAY,KACZC,oBAAqB,GACrBC,mBAAoB,MAGlBC,EAAiC,CACnCC,OAAQ,kBACRC,KAAM,iBACNC,SAAU,qBACVC,MAAO,qBACPC,cAAe,qBACfC,QAAS,iBACTC,gBAAiB,qBACjBC,SAAU,2BACVC,UAAW,qBACXC,SAAU,mBAGRC,EAAyC,SAACC,EAAmBC,GAC/D,GAAID,EAAMlI,OAASoI,IAAeC,QAAlC,CAD6H,MAE1EF,EAAMG,WAAjDC,EAFqH,EAErHA,kBACR,IAH6H,EAElGC,cAClBC,iBAAT,CACA,IAAMpJ,EAAQ8I,EAAMO,WACpB,GAAc,OAAVrJ,EAAJ,CACA,IAAMsJ,EAAStJ,EAAMmG,eAAeoD,QAAO,SAACC,GAAD,OAAOC,YAAiBZ,EAAMtE,MAAO,CAACiF,EAAE9C,EAAG8C,EAAElD,GAAItG,EAAM4E,WAASI,KAAI,SAAAwE,GAAC,OAAIA,EAAEpG,MAEtH,GAAsB,IAAlBkG,EAAOnL,OAAX,CASA,IAAMuL,EAAQJ,EAAO,GAEfK,EAAmBb,EAAMG,WAAWW,UAAUC,sBAAwB,GAQ5EX,EAAkB,CAACvI,KAAM,0BAA2BkJ,qBAP/BhB,EAAMiB,UAAUC,KACXJ,EAAiBK,SAASN,GACtBC,EAAiBJ,QAAO,SAAAnG,GAAE,OAAIA,IAAOsG,KADzC,sBAEQC,GAFR,CAE0BD,IAC1Bb,EAAMiB,UAAUG,MAAhB,sBACQN,GADR,CAC0BD,IACtB,CAACA,KAE/BZ,EAAMoB,uBAnBIrB,EAAMiB,UAAUC,MAAQlB,EAAMiB,UAAUG,OAASjK,EAAM8H,YAEzDoB,EAAkB,CAACvI,KAAM,0BAA2BkJ,qBAAsB,SAoBhFM,EAAyC,SAACtB,EAAmBC,GAC/D,GAAID,EAAMlI,OAASoI,IAAeqB,KAAlC,CACA,IAAMpK,EAAQ8I,EAAMO,WACpB,GAAc,OAAVrJ,EAAJ,CACA,IAAMqK,EAAarK,EAAMmG,eAAeoD,QAAO,SAACC,GAAD,OAAOC,YAAiBZ,EAAMtE,MAAO,CAACiF,EAAE9C,EAAG8C,EAAElD,GAAItG,EAAM4E,WAASI,KAAI,SAAAwE,GAAC,OAAIA,EAAEpG,MAC1H0F,EAAMwB,SAAN,2BAAmBtK,GAAnB,IAA0BgI,mBAA0C,IAAtBqC,EAAWlM,OAAe,KAAOkM,EAAW,MAC1FvB,EAAMoB,qBAGJK,EAAgC,SAACzB,EAA2D0B,GAA2B,IAAD,EAClHxK,EAAQ8I,EAAMO,WADoG,EAErEP,EAAMG,WAAjDC,EAFgH,EAEhHA,kBACR,IAHwH,EAE7FC,cAClBC,kBACK,OAAVpJ,EAAJ,CACA,IAAMyK,EAAI,UAAGzK,EAAMmG,eAAeoD,QAAO,SAACC,GAAD,OAAOkB,YAA4BlB,EAAEjD,KAAMiE,EAAK/B,oBAA/E,QAA6F,GACvG,GAAI+B,EAAKG,SAAU,CAAC,IAAD,IACTC,EAAkBJ,EAAKP,OAAL,oBAAanB,EAAMG,kBAAnB,aAAa,EAAkBW,UAAUC,4BAAzC,QAAsE,GAC9FX,EAAkB,CAACvI,KAAM,0BAA2BkJ,qBAAqB,GAAD,mBAAMe,GAAN,YAA0BH,EAAKzF,KAAI,SAAAwE,GAAC,OAAIA,EAAEpG,UAClH0F,EAAMwB,SAAN,2BAAmBtK,GAAnB,IAA0B8H,WAAY,KAAMC,oBAAqB,WAEjEe,EAAMwB,SAAN,2BAAmBtK,GAAnB,IAA0B8H,WAAY0C,EAAK/B,SAAUV,oBAAqB0C,EAAKzF,KAAI,SAAAwE,GAAC,OAAIA,EAAEpG,SAE9F0F,EAAMoB,oBAGGW,EAAwB,WAuDjC,OAAO,IAAIC,KAtDK,SAACC,EAAwBjK,EAA4Bd,GACjE,IAAMgL,EAAOlK,EAAMqI,cACb8B,EAASD,EAAKC,QAAUhD,EACxBiD,EAAaF,EAAKE,WACxBH,EAAQI,OACR,IALuF,EAKjFC,EAAYpL,EAAM2G,YAAc,EALiD,cAMzE3G,EAAMmG,gBANmE,IAMvF,2BAAoC,CAAC,IAAD,IAA3BlB,EAA2B,QAC1BmD,GAAa4C,EAAK5B,oBAAsB,UAAAtI,EAAM8I,UAAUC,4BAAhB,eAAsCG,SAAS/E,EAAE7B,OAAO,GAChGiI,GAAYL,EAAK5B,kBAAsBpJ,EAAMgI,qBAAuB/C,EAAE7B,GACtEmF,GAAYyC,EAAK5B,oBAAsB,UAAApJ,EAAM+H,2BAAN,eAA2BiC,SAAS/E,EAAE7B,OAAO,GACpFkI,EAAQlD,EACIG,EACI0C,EAAOzC,gBAEHyC,EAAO3C,cAEfC,EACI0C,EAAO1C,QACP8C,EACIJ,EAAO5C,MACP4C,EAAO9C,KAC3BrC,EAAahF,EAAMgF,WAQzB,GAPmB,SAAfA,GACAiF,EAAQQ,YAAYtG,EAAEsB,KAAM,CAAC+E,MAAOA,IACpCP,EAAQS,YAAYvG,EAAEsB,KAAM,CAAC+E,MAAOL,EAAO/C,UAEvB,aAAfpC,GACLiF,EAAQU,SAASxG,EAAEsB,KAAKzB,MAAOG,EAAEsB,KAAKnB,KAAOH,EAAEsB,KAAKlB,MAAQ,EAAGJ,EAAEsB,KAAKrB,MAAOD,EAAEsB,KAAKnB,KAAOH,EAAEsB,KAAKlB,MAAQ,EAAG,CAACiG,MAAOL,EAAO/C,SAE5HkD,EAAW,CACX,IAAMM,EAAa,CAACT,EAAO7C,SAAU6C,EAAOzC,gBAAiByC,EAAO5C,MAAO4C,EAAO3C,eAAe0B,SAASsB,GAAUL,EAAOtC,SAAWsC,EAAOvC,UACzIwC,GACAH,EAAQY,SAAS,CACbpF,KAAMtB,EAAEsB,KACRqF,UAAW,CAACC,WAAY,cAAeC,SAAU,eACjDC,KAAM,CAACC,UAAWhM,EAAM2G,YAAasF,OAAQ,SAC7CC,IAAK,CAACZ,MAAOI,GACbS,MAAO,CAACb,MAAOI,GACfU,KAAMnH,EAAEwB,UAtC+D,8BA4CvFzG,EAAM8H,YAAciD,EAAQsB,SAASrM,EAAM8H,WAAY,CAACwD,MAAOL,EAAOxC,cAEpD,SAACK,EAA2DhI,GAC9E,IAAMd,EAAQ8I,EAAMO,WACZ1D,EAAgE7E,EAAhE6E,MAAOC,EAAyD9E,EAAzD8E,OAAQ7B,EAAiDjD,EAAjDiD,mBAAoB8B,EAA6B/E,EAA7B+E,aAAcC,EAAehF,EAAfgF,WAFoD,EAGlDJ,YAAgB,CAACC,QAAOC,SAAQ7B,qBAAoB8B,eAAcC,aAAYyB,wBAAyBzG,EAAMqI,cAAc5B,0BAA9KpB,EAHqG,EAGrGA,eAAgBH,EAHqF,EAGrFA,UAAWpB,EAH0E,EAG1EA,OAAQ+B,EAHkE,EAGlEA,YAC3CmC,EAAMwD,mBAAmBtG,GACzB8C,EAAMwB,SAAN,2BAAmBtK,GAAnB,IAA0BmG,iBAAgBvB,SAAQ+B,iBAClDmC,EAAMoB,oBAKNrC,EACA,CACI0E,2BAA4B,CAAC3D,EAAauB,GAC1CqC,aAAc,CAACjC,O,iCCnK3B,IAAIkC,EAAyB7J,EAAQ,KAEjC8J,EAA0B9J,EAAQ,KAEtCb,OAAOC,eAAeZ,EAAS,aAAc,CAC3CoB,OAAO,IAETpB,EAAQvB,aAAU,EAElB,IAAII,EAAQyM,EAAwB9J,EAAQ,IAIxC+J,GAAW,EAFMF,EAAuB7J,EAAQ,MAElB/C,SAAuBI,EAAM2M,cAAc,OAAQ,CACnFC,EAAG,2YACD,SAEJzL,EAAQvB,QAAU8M,G,uFC6BHG,IA3BiB,SAAChM,GAC7B,IAAMiM,EAA2CC,mBAAQ,iBAAO,CAC5DlH,WAAY,OACZD,aAAc/E,EAAMmM,WAAWjI,KAAI,SAAAC,GAAC,OAAIA,EAAE7B,MAC1CW,mBAAoBjD,EAAMmM,WAAWjI,KAAI,SAAAC,GAAC,MAAI,CAACA,EAAEyB,EAAGzB,EAAEqB,MACtDX,MAAO7E,EAAM6E,MACbC,OAAQ9E,EAAM8E,OACdgE,UAAW9I,EAAM8I,UACjBV,kBAAmBpI,EAAMoI,kBACzBC,cAAe,CACX+B,YAAY,EACZ3D,wBAAyB,IAE7B2F,WAAY,EACZC,kBAAmB,KACnB,CAACrM,IACCgI,EAAQsE,YAASvC,IAAuBkC,GACxCM,EAASC,YAAU,CAACxE,IAC1B,OACI,cAAC,IAAD,aAEIuE,OAAQA,GACJ,CAAC1H,MAAO7E,EAAM6E,MAAOC,OAAQ9E,EAAM8E,SAFnC,6B,gJCxBV2H,EAAwE,SAAC,GAA8D,IAA7DC,EAA4D,EAA5DA,UAAW7H,EAAiD,EAAjDA,MAAOC,EAA0C,EAA1CA,OAAQgE,EAAkC,EAAlCA,UAAWV,EAAuB,EAAvBA,kBAC3GuE,EAAKC,YAAiBF,EAAUG,iBAChCC,EAAsBhE,EAAUgE,oBAChCX,EAAaD,mBAAQ,kBAAOS,EAXhB,SAACI,EAAuBC,GAC1C,GAAID,GAAaC,GAAOA,EAAI3P,SAAW0P,EAAU1P,OAAQ,MAAM4P,MAAM,qDACrE,OAAOD,EAAI9I,KAAI,SAAC0B,EAAGsH,GACf,IAAM1G,EAAMuG,EAAUG,GACtB,MAAO,CAAEvH,MAAOC,EAAI,GAAItD,GAAIsD,EAAGA,EAAGY,EAAI,GAAIhB,EAAGgB,EAAI,OAOd2G,CAAcR,EAAGS,KAAMT,EAAGU,aAAe,IAAI5E,QAAO,SAAA6E,GAAC,OAAOR,GAAyBA,EAAoB5D,SAASoE,EAAEhL,SAAQ,CAACqK,EAAIG,IASxK,OAAKH,EAMD,cAAC,IAAD,CACIR,WAAYA,EACZrD,UAAWA,EACXV,kBAAmBA,EACnBvD,MAAOA,GAAS,IAChBC,OAAQA,GAAU,MATlB,0EAcNyI,EAAoE,SAAC,GAA8F,IAA7Fb,EAA4F,EAA5FA,UAAWc,EAAiF,EAAjFA,cAAeC,EAAkE,EAAlEA,gBAAiB5I,EAAiD,EAAjDA,MAAOC,EAA0C,EAA1CA,OAAQgE,EAAkC,EAAlCA,UAAWV,EAAuB,EAAvBA,kBAC7I,OACI,cAACqE,EAAD,eACQ,CAACC,YAAWc,gBAAeC,kBAAiB5I,QAAOC,SAAQgE,YAAWV,wBAK/E,SAASsF,EAASC,GACrBA,EAAQC,eAAe,CACnB/N,KAAM,gBACNZ,KAAM,iCACN0G,MAAO,qBACPkI,SAAU,GACVC,iBAAiB,EACjBC,UAAWtB,EACXuB,WAAW,EACXC,KAAM,cAAC,IAAD,MAEVN,EAAQC,eAAe,CACnB/N,KAAM,cACNZ,KAAM,+BACN0G,MAAO,qBACPkI,SAAU,GACVE,UAAWR,EACXS,WAAW,EACXC,KAAM,cAAC,IAAD","file":"static/js/19.2cdeca6f.chunk.js","sourcesContent":["export default function ownerDocument(node) {\n  return node && node.ownerDocument || document;\n}","export default function requirePropFactory(componentNameInError) {\n  if (process.env.NODE_ENV === 'production') {\n    return function () {\n      return null;\n    };\n  }\n\n  var requireProp = function requireProp(requiredProp) {\n    return function (props, propName, componentName, location, propFullName) {\n      var propFullNameSafe = propFullName || propName;\n\n      if (typeof props[propName] !== 'undefined' && !props[requiredProp]) {\n        return new Error(\"The prop `\".concat(propFullNameSafe, \"` of \") + \"`\".concat(componentNameInError, \"` must be used on `\").concat(requiredProp, \"`.\"));\n      }\n\n      return null;\n    };\n  };\n\n  return requireProp;\n}","import ownerDocument from './ownerDocument';\nexport default function ownerWindow(node) {\n  var doc = ownerDocument(node);\n  return doc.defaultView || window;\n}","/**\n * Safe chained function\n *\n * Will only create a new function if needed,\n * otherwise will pass back existing functions or null.\n *\n * @param {function} functions to chain\n * @returns {function|null}\n */\nexport default function createChainedFunction() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  return funcs.reduce(function (acc, func) {\n    if (func == null) {\n      return acc;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof func !== 'function') {\n        console.error('Material-UI: Invalid Argument Type, must only provide functions, undefined, or null.');\n      }\n    }\n\n    return function chainedFunction() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      acc.apply(this, args);\n      func.apply(this, args);\n    };\n  }, function () {});\n}","// Corresponds to 10 frames at 60 Hz.\n// A few bytes payload overhead when lodash/debounce is ~3 kB and debounce ~300 B.\nexport default function debounce(func) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 166;\n  var timeout;\n\n  function debounced() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // eslint-disable-next-line consistent-this\n    var that = this;\n\n    var later = function later() {\n      func.apply(that, args);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  }\n\n  debounced.clear = function () {\n    clearTimeout(timeout);\n  };\n\n  return debounced;\n}","/* eslint-disable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */\nimport * as React from 'react';\nexport default function useControlled(_ref) {\n  var controlled = _ref.controlled,\n      defaultProp = _ref.default,\n      name = _ref.name,\n      _ref$state = _ref.state,\n      state = _ref$state === void 0 ? 'value' : _ref$state;\n\n  var _React$useRef = React.useRef(controlled !== undefined),\n      isControlled = _React$useRef.current;\n\n  var _React$useState = React.useState(defaultProp),\n      valueState = _React$useState[0],\n      setValue = _React$useState[1];\n\n  var value = isControlled ? controlled : valueState;\n\n  if (process.env.NODE_ENV !== 'production') {\n    React.useEffect(function () {\n      if (isControlled !== (controlled !== undefined)) {\n        console.error([\"Material-UI: A component is changing the \".concat(isControlled ? '' : 'un', \"controlled \").concat(state, \" state of \").concat(name, \" to be \").concat(isControlled ? 'un' : '', \"controlled.\"), 'Elements should not switch from uncontrolled to controlled (or vice versa).', \"Decide between using a controlled or uncontrolled \".concat(name, \" \") + 'element for the lifetime of the component.', \"The nature of the state is determined during the first render, it's considered controlled if the value is not `undefined`.\", 'More info: https://fb.me/react-controlled-components'].join('\\n'));\n      }\n    }, [controlled]);\n\n    var _React$useRef2 = React.useRef(defaultProp),\n        defaultValue = _React$useRef2.current;\n\n    React.useEffect(function () {\n      if (!isControlled && defaultValue !== defaultProp) {\n        console.error([\"Material-UI: A component is changing the default \".concat(state, \" state of an uncontrolled \").concat(name, \" after being initialized. \") + \"To suppress this warning opt to use a controlled \".concat(name, \".\")].join('\\n'));\n      }\n    }, [JSON.stringify(defaultProp)]);\n  }\n\n  var setValueIfUncontrolled = React.useCallback(function (newValue) {\n    if (!isControlled) {\n      setValue(newValue);\n    }\n  }, []);\n  return [value, setValueIfUncontrolled];\n}","import * as React from 'react';\nexport default function isMuiElement(element, muiNames) {\n  return /*#__PURE__*/React.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;\n}","export default function unsupportedProp(props, propName, componentName, location, propFullName) {\n  if (process.env.NODE_ENV === 'production') {\n    return null;\n  }\n\n  var propFullNameSafe = propFullName || propName;\n\n  if (typeof props[propName] !== 'undefined') {\n    return new Error(\"The prop `\".concat(propFullNameSafe, \"` is not supported. Please remove it.\"));\n  }\n\n  return null;\n}","function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;","var _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nmodule.exports = _interopRequireWildcard;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function get() {\n    return _utils.createSvgIcon;\n  }\n});\n\nvar _utils = require(\"@material-ui/core/utils\");","export default function deprecatedPropType(validator, reason) {\n  if (process.env.NODE_ENV === 'production') {\n    return function () {\n      return null;\n    };\n  }\n\n  return function (props, propName, componentName, location, propFullName) {\n    var componentNameSafe = componentName || '<<anonymous>>';\n    var propFullNameSafe = propFullName || propName;\n\n    if (typeof props[propName] !== 'undefined') {\n      return new Error(\"The \".concat(location, \" `\").concat(propFullNameSafe, \"` of \") + \"`\".concat(componentNameSafe, \"` is deprecated. \").concat(reason));\n    }\n\n    return null;\n  };\n}","import * as React from 'react';\n/**\n * Private module reserved for @material-ui/x packages.\n */\n\nexport default function useId(idOverride) {\n  var _React$useState = React.useState(idOverride),\n      defaultId = _React$useState[0],\n      setDefaultId = _React$useState[1];\n\n  var id = idOverride || defaultId;\n  React.useEffect(function () {\n    if (defaultId == null) {\n      // Fallback to this default id when possible.\n      // Use the random value for client-side rendering only.\n      // We can't use it server-side.\n      setDefaultId(\"mui-\".concat(Math.round(Math.random() * 1e5)));\n    }\n  }, [defaultId]);\n  return id;\n}","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","import { norm } from 'mathjs';\nimport { funcToTransform } from '../../common/CanvasWidget';\nimport { getBoundingBoxForEllipse, getHeight, getWidth, RectangularRegion, TransformationMatrix, transformDistance, Vec2 } from '../../common/CanvasWidget/Geometry';\nimport { getArrayMax, getArrayMin } from '../../common/Utility';\n\nexport type ElectrodeBox = {\n    label: string\n    id: number\n    x: number\n    y: number\n    rect: RectangularRegion\n    transform: TransformationMatrix\n}\n\nconst computeRadiusCache = new Map<string, number>()\nconst computeRadius = (electrodeLocations: number[][]): number => {\n    const key = JSON.stringify(electrodeLocations)\n    const val = computeRadiusCache.get(key)\n    if (val !== undefined) {\n        return val\n    }\n    // how big should each electrode dot be? Really depends on how close\n    // the dots are to each other. Let's find the closest pair of dots and\n    // set the radius to 40% of the distance between them.\n    let leastNorm = Number.MAX_VALUE\n    electrodeLocations.forEach((point) => {\n        electrodeLocations.forEach((otherPoint) => {\n            const dist = norm([point[0] - otherPoint[0], point[1] - otherPoint[1]])\n            if (dist === 0) return\n            leastNorm = Math.min(leastNorm, dist as number)\n        })\n    })\n    // (might set a hard cap, but remember these numbers are in electrode-space coordinates)\n    const radius = 0.45 * leastNorm\n    computeRadiusCache.set(key, radius)\n    return radius\n}\n\nconst getElectrodesBoundingBox = (electrodeLocations: number[][], radius: number): RectangularRegion => {\n    return {\n        xmin: getArrayMin(electrodeLocations.map(e => (e[0]))) - radius,\n        xmax: getArrayMax(electrodeLocations.map(e => (e[0]))) + radius,\n        ymin: getArrayMin(electrodeLocations.map(e => (e[1]))) - radius,\n        ymax: getArrayMax(electrodeLocations.map(e => (e[1]))) + radius\n    }\n}\n\nexport const getElectrodesAspectRatio = (electrodeLocations: Vec2[]) => {\n    const radius = computeRadius(electrodeLocations)\n    const boundingBox = getElectrodesBoundingBox(electrodeLocations, radius)\n    const boxAspect = getWidth(boundingBox) / getHeight(boundingBox)\n    return boxAspect\n}\n\nconst setupVerticalElectrodes = ({width, height, electrodeIds}: {width: number, height: number, electrodeIds: number[]}) => {\n    // This is the case where we are displaying electrodes vertically\n    // i.e., not according to the elec geometry, but rather in a\n    // vertical fashion (as in the original MountainView)\n    // There is a user option to toggle this display\n    const xMargin = 10\n    const yMargin = 10\n    const n = electrodeIds.length\n    \n    // This is the layer transform which maps [0,1]x[0,1] into the content area of the layer\n    // It is composed with the below transform for each electrode\n    const transform = funcToTransform((p: Vec2): Vec2 => {\n        const x = xMargin + p[0] * ( width - 2 * xMargin )\n        const y = yMargin + p[1] * ( height - 2 * yMargin )\n        return [x, y]\n    })\n\n    const electrodeBoxes: ElectrodeBox[] = electrodeIds.map((eid, ii) => {\n        // The vertical position of the ii^th electrode\n        // scaled to be between 0 and 1\n        const y = (0.5 + ii) / (n + 1)\n        \n        // The rectangle which goes from x=0-1\n        const rect = {xmin: 0, xmax: 1, ymin: y - 0.5 / (n + 1), ymax: y + 0.5 / (n + 1)}\n\n        // This is the transform associated with the ii^th electrode\n        // This transponse gets composed with the above layer transform\n        const transform0 = funcToTransform((p: Vec2): Vec2 => {\n            const a = rect.xmin + p[0] * (rect.xmax - rect.xmin)\n            const b = rect.ymin + p[1] * (rect.ymax - rect.ymin)\n            return [a, b]\n        })\n        return {\n            label: eid + '',\n            id: eid,\n            x: 0.5, // (x, y) here is the center point\n            y,\n            rect,\n            transform: transform0\n        }\n    })\n    \n    return {\n        electrodeBoxes,\n        transform,\n        radius: 1 / (n + 1), // this is the radius of one electrode, which determines the amplitude scaling for waveforms\n        pixelRadius: (height - 2 * yMargin) / (n + 1) // this is the same, except scaled to pixels\n    }\n}\n\nconst fixDegenerateCase = (electrodeLocations: Vec2[]) => {\n    const box = {\n        xmin: getArrayMin(electrodeLocations.map(e => (e[0]))),\n        xmax: getArrayMax(electrodeLocations.map(e => (e[0]))),\n        ymin: getArrayMin(electrodeLocations.map(e => (e[1]))),\n        ymax: getArrayMax(electrodeLocations.map(e => (e[1])))\n    }\n    if ((box.xmin === box.xmax) && (box.ymin === box.ymax)) {\n        return electrodeLocations.map((x, ii) => [ii, 0])\n    }\n    else {\n        return electrodeLocations\n    }\n}\n\nconst setupElectrodes = (args: {width: number, height: number, electrodeLocations: Vec2[], electrodeIds: number[], layoutMode: 'geom' | 'vertical', maxElectrodePixelRadius?: number}): {\n    electrodeBoxes: ElectrodeBox[],\n    transform: TransformationMatrix,\n    radius: number,\n    pixelRadius: number\n} => {\n    const { width, height, electrodeLocations, electrodeIds, layoutMode } = args\n    if (layoutMode === 'vertical') {\n        return setupVerticalElectrodes({width, height, electrodeIds})\n    }\n    const correctedElectrodeLocations = fixDegenerateCase(electrodeLocations)\n    const W = width - 10 * 2\n    const H = height - 10 * 2\n    const canvasAspect = W / H\n\n    const radius = computeRadius(correctedElectrodeLocations)\n    let boundingBox = getElectrodesBoundingBox(correctedElectrodeLocations, radius)\n    let boxAspect = getWidth(boundingBox) / getHeight(boundingBox)\n\n    let realizedElectrodeLocations = correctedElectrodeLocations\n    if ((boxAspect > 1) !== (canvasAspect > 1)) {\n        // if the two aspect ratios' relationship to 1 is different, then one is portrait\n        // and the other landscape. We should then correct by rotating the electrode set 90 degrees.\n        // note: a 90-degree rotation around the origin makes x' = y and y' = -x\n        realizedElectrodeLocations = correctedElectrodeLocations.map((loc) => {\n            return [loc[1], -loc[0]]\n        })\n        // and of course that also means resetting the x- and y-ranges of the bounding box.\n        boundingBox = { xmin: boundingBox.ymin, xmax: boundingBox.ymax, ymin: -boundingBox.xmax, ymax: -boundingBox.xmin }\n        boxAspect = getWidth(boundingBox) / getHeight(boundingBox)\n    }\n\n    let scaleFactor: number\n    if (boxAspect > canvasAspect) {\n        // we are constrained in width\n        scaleFactor = W / getWidth(boundingBox)\n    }\n    else {\n        // we are constrained in height\n        scaleFactor = H / getHeight(boundingBox)\n    }\n\n    // don't allow the electrodes to appear too big\n    if (args.maxElectrodePixelRadius) {\n        if (radius * scaleFactor > args.maxElectrodePixelRadius) {\n            scaleFactor /= (radius * scaleFactor / args.maxElectrodePixelRadius)\n        }\n    }\n\n    const xMargin = (width - getWidth(boundingBox) * scaleFactor) / 2\n    const yMargin = (height - getHeight(boundingBox) * scaleFactor) / 2\n\n    const transform = funcToTransform((p: Vec2): Vec2 => {\n        const x = xMargin + (p[0] - boundingBox.xmin) * scaleFactor\n        const y = yMargin + (p[1] - boundingBox.ymin) * scaleFactor\n        return [x, y]\n    })\n\n    const electrodeBoxes: ElectrodeBox[] = realizedElectrodeLocations.map((loc, i) => { \n        const x = loc[0]\n        const y = loc[1]\n        const rect = getBoundingBoxForEllipse([x, y], radius, radius)\n        const transform0 = funcToTransform((p: Vec2): Vec2 => {\n            const a = rect.xmin + p[0] * (rect.xmax - rect.xmin)\n            const b = rect.ymin + p[1] * (rect.ymax - rect.ymin)\n            return [a, b]\n        })\n        return { label: electrodeIds[i] + '', id: electrodeIds[i], x: x, y: y, rect, transform: transform0}}\n    )\n    const pixelRadius = transformDistance(transform, [radius, 0])[0]\n    return {electrodeBoxes, transform, radius, pixelRadius}\n}\n\nexport default setupElectrodes","import { CanvasPainter } from '../../common/CanvasWidget/CanvasPainter';\nimport { CanvasDragEvent, CanvasWidgetLayer, ClickEvent, ClickEventType, DiscreteMouseEventHandler, DragHandler } from \"../../common/CanvasWidget/CanvasWidgetLayer\";\nimport { pointIsInEllipse, RectangularRegion, rectangularRegionsIntersect } from '../../common/CanvasWidget/Geometry';\nimport setupElectrodes, { ElectrodeBox } from './setupElectrodes';\nimport { ElectrodeLayerProps } from './WaveformWidget';\n\nexport type ElectrodeColors = {\n    border: string,\n    base: string,\n    selected: string,\n    hover: string,\n    selectedHover: string,\n    dragged: string,\n    draggedSelected: string,\n    dragRect: string,\n    textLight: string,\n    textDark: string\n}\ntype LayerState = {\n    electrodeBoxes: ElectrodeBox[]\n    radius: number\n    pixelRadius: number\n    dragRegion: RectangularRegion | null\n    draggedElectrodeIds: number[]\n    hoveredElectrodeId: number | null\n}\nconst initialLayerState = {\n    electrodeBoxes: [],\n    radius: 0,\n    pixelRadius: 0,\n    dragRegion: null,\n    draggedElectrodeIds: [],\n    hoveredElectrodeId: null\n}\n\nconst defaultColors: ElectrodeColors = {\n    border: 'rgb(30, 30, 30)',\n    base: 'rgb(0, 0, 255)',\n    selected: 'rgb(196, 196, 128)',\n    hover: 'rgb(128, 128, 255)',\n    selectedHover: 'rgb(200, 200, 196)',\n    dragged: 'rgb(0, 0, 196)',\n    draggedSelected: 'rgb(180, 180, 150)',\n    dragRect: 'rgba(196, 196, 196, 0.5)',\n    textLight: 'rgb(228, 228, 228)',\n    textDark: 'rgb(32, 32, 32)'\n}\n\nconst handleClick: DiscreteMouseEventHandler = (event: ClickEvent, layer: CanvasWidgetLayer<ElectrodeLayerProps, LayerState>) => {\n    if (event.type !== ClickEventType.Release) return\n    const { selectionDispatch, electrodeOpts: opts } = layer.getProps()\n    if (opts.disableSelection) return\n    const state = layer.getState()\n    if (state === null) return\n    const hitIds = state.electrodeBoxes.filter((r) => pointIsInEllipse(event.point, [r.x, r.y], state.radius)).map(r => r.id)\n    // handle clicks that weren't on an electrode\n    if (hitIds.length === 0) {\n        if (!(event.modifiers.ctrl || event.modifiers.shift || state.dragRegion)) {\n            // simple-click that doesn't select anything should deselect everything. Shift- or Ctrl-clicks on empty space do nothing.\n            selectionDispatch({type: 'SetSelectedElectrodeIds', selectedElectrodeIds: []})\n        }\n        return\n    }\n    // Our definition of radius precludes any two electrodes from overlapping, so hitIds should have 0 or 1 elements.\n    // Since we've already handled the case where it's 0, now it must be 1.\n    const hitId = hitIds[0]\n    \n    const currentSelection = layer.getProps().selection.selectedElectrodeIds || []\n    const newSelection = event.modifiers.ctrl  // ctrl-click: toggle state of clicked item\n                            ? currentSelection.includes(hitId)\n                                ? currentSelection.filter(id => id !== hitId)\n                                : [...currentSelection, hitId]\n                            : event.modifiers.shift\n                                ? [...currentSelection, hitId] // shift-click: add selected item unconditionally\n                                : [hitId] // simple click: clear all selections except clicked item\n    selectionDispatch({type: 'SetSelectedElectrodeIds', selectedElectrodeIds: newSelection})\n    layer.scheduleRepaint()\n}\n\nconst handleHover: DiscreteMouseEventHandler = (event: ClickEvent, layer: CanvasWidgetLayer<ElectrodeLayerProps, LayerState>) => {\n    if (event.type !== ClickEventType.Move) return\n    const state = layer.getState()\n    if (state === null) return\n    const hoveredIds = state.electrodeBoxes.filter((r) => pointIsInEllipse(event.point, [r.x, r.y], state.radius)).map(r => r.id)\n    layer.setState({...state, hoveredElectrodeId: hoveredIds.length === 0 ? null : hoveredIds[0]})\n    layer.scheduleRepaint()\n}\n\nconst handleDragSelect: DragHandler = (layer: CanvasWidgetLayer<ElectrodeLayerProps, LayerState>, drag: CanvasDragEvent) => {\n    const state = layer.getState()\n    const { selectionDispatch, electrodeOpts: opts } = layer.getProps()\n    if (opts.disableSelection) return\n    if (state === null) return // state not set; can't happen but keeps linter happy\n    const hits = state.electrodeBoxes.filter((r) => rectangularRegionsIntersect(r.rect, drag.dragRect)) ?? []\n    if (drag.released) {\n        const currentSelected = drag.shift ? layer.getProps()?.selection.selectedElectrodeIds ?? [] : []\n        selectionDispatch({type: 'SetSelectedElectrodeIds', selectedElectrodeIds: [...currentSelected, ...hits.map(r => r.id)]})\n        layer.setState({...state, dragRegion: null, draggedElectrodeIds: []})\n    } else {\n        layer.setState({...state, dragRegion: drag.dragRect, draggedElectrodeIds: hits.map(r => r.id)})\n    }\n    layer.scheduleRepaint()\n}\n\nexport const createElectrodesLayer = () => {\n    const onPaint = (painter: CanvasPainter, props: ElectrodeLayerProps, state: LayerState) => {\n        const opts = props.electrodeOpts\n        const colors = opts.colors || defaultColors\n        const showLabels = opts.showLabels\n        painter.wipe()\n        const useLabels = state.pixelRadius > 5\n        for (let e of state.electrodeBoxes) {\n            const selected = (!opts.disableSelection) && (props.selection.selectedElectrodeIds?.includes(e.id) || false)\n            const hovered = (!opts.disableSelection) && (state.hoveredElectrodeId === e.id)\n            const dragged = (!opts.disableSelection) && (state.draggedElectrodeIds?.includes(e.id) || false)\n            const color = selected \n                            ? dragged\n                                ? colors.draggedSelected\n                                : hovered\n                                    ? colors.selectedHover\n                                    : colors.selectedHover\n                            : dragged\n                                ? colors.dragged\n                                : hovered\n                                    ? colors.hover\n                                    : colors.base\n            const layoutMode = props.layoutMode\n            if (layoutMode === 'geom') {\n                painter.fillEllipse(e.rect, {color: color})\n                painter.drawEllipse(e.rect, {color: colors.border})\n            }\n            else if (layoutMode === 'vertical') {\n                painter.drawLine(e.rect.xmin, (e.rect.ymin + e.rect.ymax) / 2, e.rect.xmax, (e.rect.ymin + e.rect.ymax) / 2, {color: colors.border})\n            }\n            if (useLabels) {\n                const fontColor = ([colors.selected, colors.draggedSelected, colors.hover, colors.selectedHover].includes(color)) ? colors.textDark : colors.textLight\n                if (showLabels) {\n                    painter.drawText({\n                        rect: e.rect, \n                        alignment: {Horizontal: 'AlignCenter', Vertical: 'AlignCenter'}, \n                        font: {pixelSize: state.pixelRadius, family: 'Arial'},\n                        pen: {color: fontColor},\n                        brush: {color: fontColor},\n                        text: e.label\n                    })\n                }\n            }\n        }\n        \n        state.dragRegion && painter.fillRect(state.dragRegion, {color: colors.dragRect})\n    }\n    const onPropsChange = (layer: CanvasWidgetLayer<ElectrodeLayerProps, LayerState>, props: ElectrodeLayerProps) => {\n        const state = layer.getState()\n        const { width, height, electrodeLocations, electrodeIds, layoutMode } = props\n        const { electrodeBoxes, transform, radius, pixelRadius } = setupElectrodes({width, height, electrodeLocations, electrodeIds, layoutMode, maxElectrodePixelRadius: props.electrodeOpts.maxElectrodePixelRadius})\n        layer.setTransformMatrix(transform)\n        layer.setState({...state, electrodeBoxes, radius, pixelRadius})\n        layer.scheduleRepaint()\n    }\n    return new CanvasWidgetLayer<ElectrodeLayerProps, LayerState>(\n        onPaint,\n        onPropsChange,\n        initialLayerState,\n        {\n            discreteMouseEventHandlers: [handleClick, handleHover],\n            dragHandlers: [handleDragSelect],\n        }\n    )\n}","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M10 12c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM6 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12-8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm-4 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z\"\n}), 'Grain');\n\nexports.default = _default;","import React, { useMemo } from \"react\"\nimport { createElectrodesLayer } from \"../../averagewaveforms/AverageWaveformsView/electrodesLayer\"\nimport { ElectrodeLayerProps } from \"../../averagewaveforms/AverageWaveformsView/WaveformWidget\"\nimport CanvasWidget from \"../../common/CanvasWidget\"\nimport { useLayer, useLayers } from \"../../common/CanvasWidget/CanvasWidgetLayer\"\nimport { RecordingSelection, RecordingSelectionDispatch } from \"../../pluginInterface\"\nimport { Electrode } from \"./electrodeGeometryLayer\"\n\n// Okay, so after some hoop-jumping, we've learned the RecordingInfo has:\n// - sampling frequency (number), - channel_ids (list of number),\n// - channel_groups (list of number), - geom (list of Vec2),\n// - num_frames (number), - is_local (boolean).\n\ninterface WidgetProps {\n    electrodes: Electrode[] // Note: these shouldn't be interacted with directly. Use the bounding boxes in the state, instead.\n    selection: RecordingSelection\n    selectionDispatch: RecordingSelectionDispatch\n    width: number\n    height: number\n}\n\nconst ElectrodeGeometryWidget = (props: WidgetProps) => {\n    const electrodeLayerProps: ElectrodeLayerProps = useMemo(() => ({\n        layoutMode: 'geom',\n        electrodeIds: props.electrodes.map(e => e.id),\n        electrodeLocations: props.electrodes.map(e => [e.x, e.y]),\n        width: props.width,\n        height: props.height,\n        selection: props.selection,\n        selectionDispatch: props.selectionDispatch,\n        electrodeOpts: {\n            showLabels: true,\n            maxElectrodePixelRadius: 25\n        },\n        noiseLevel: 0, // not needed\n        samplingFrequency: 0 // not needed\n    }), [props])\n    const layer = useLayer(createElectrodesLayer, electrodeLayerProps)\n    const layers = useLayers([layer])\n    return (\n        <CanvasWidget\n            key='electrodeGeometryCanvas'\n            layers={layers}\n            {...{width: props.width, height: props.height}}\n        />\n    )\n}\n\nexport default ElectrodeGeometryWidget","// LABBOX-EXTENSION: electrodegeometry\n// LABBOX-EXTENSION-TAGS: jupyter\n\nimport GrainIcon from '@material-ui/icons/Grain';\nimport React, { FunctionComponent, useMemo } from 'react';\nimport { useRecordingInfo } from '../common/useRecordingInfo';\nimport { LabboxExtensionContext, RecordingViewProps, SortingViewProps } from \"../pluginInterface\";\nimport ElectrodeGeometryWidget from './ElectrodeGeometryWidget/ElectrodeGeometryWidget';\n\nconst zipElectrodes = (locations: number[][], ids: number[]) => {\n    if (locations && ids && ids.length !== locations.length) throw Error('Electrode ID count does not match location count.')\n    return ids.map((x, index) => {\n        const loc = locations[index]\n        return { label: x + '', id: x, x: loc[0], y: loc[1] }\n    })\n}\n\nconst ElectrodeGeometryRecordingView: FunctionComponent<RecordingViewProps> = ({recording, width, height, selection, selectionDispatch}) => {\n    const ri = useRecordingInfo(recording.recordingObject)\n    const visibleElectrodeIds = selection.visibleElectrodeIds\n    const electrodes = useMemo(() => (ri ? zipElectrodes(ri.geom, ri.channel_ids) : []).filter(a => ((!visibleElectrodeIds) || (visibleElectrodeIds.includes(a.id)))), [ri, visibleElectrodeIds])\n\n    // const handleSelectedElectrodeIdsChanged = useCallback((x: number[]) => {\n    //     selectionDispatch({type: 'SetSelectedElectrodeIds', selectedElectrodeIds: x})\n    // }, [selectionDispatch])\n\n    // const selectedElectrodeIds = useMemo(() => (selection.selectedElectrodeIds || []), [selection.selectedElectrodeIds])\n\n    // const [selectedElectrodeIds, setSelectedElectrodeIds] = useState<number[]>([]);\n    if (!ri) {\n        return (\n            <div>No recording info found for recording.</div>\n        )\n    }\n    return (\n        <ElectrodeGeometryWidget\n            electrodes={electrodes}\n            selection={selection}\n            selectionDispatch={selectionDispatch}\n            width={width || 350}\n            height={height || 150}\n        />\n    );\n}\n\nconst ElectrodeGeometrySortingView: FunctionComponent<SortingViewProps> = ({recording, recordingInfo, calculationPool, width, height, selection, selectionDispatch}) => {\n    return (\n        <ElectrodeGeometryRecordingView\n            {...{recording, recordingInfo, calculationPool, width, height, selection, selectionDispatch}}\n        />\n    )\n}\n\nexport function activate(context: LabboxExtensionContext) {\n    context.registerPlugin({\n        type: 'RecordingView',\n        name: 'ElectrodeGeometryRecordingView',\n        label: 'Electrode geometry',\n        priority: 50,\n        defaultExpanded: false,\n        component: ElectrodeGeometryRecordingView,\n        singleton: true,\n        icon: <GrainIcon />\n    })\n    context.registerPlugin({\n        type: 'SortingView',\n        name: 'ElectrodeGeometrySortingView',\n        label: 'Electrode geometry',\n        priority: 50,\n        component: ElectrodeGeometrySortingView,\n        singleton: true,\n        icon: <GrainIcon />\n    })\n}"],"sourceRoot":""}