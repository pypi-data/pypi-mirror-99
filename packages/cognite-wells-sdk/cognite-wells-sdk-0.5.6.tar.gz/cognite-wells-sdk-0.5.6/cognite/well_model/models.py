# generated by datamodel-codegen:
#   filename:  openapi.yaml

from __future__ import annotations

from datetime import date
from enum import Enum
from typing import Dict, List, Optional

from pydantic import Extra, Field

from cognite.well_model.base_model import WellsBaseModel


class WellIds(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: Optional[List[int]] = None


class DoubleWithUnit(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    value: float = Field(..., example=123.123)
    unit: str = Field(..., example="m")


class ParentType(Enum):
    well = "well"
    wellbore = "wellbore"


class Trajectory(WellsBaseModel):
    pass

    class Config:
        allow_population_by_field_name = True


class Geometry(Enum):
    geo_json = "GeoJSON"
    wkt = "WKT"


class Wellhead(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    x: float = Field(..., example=1)
    y: float = Field(..., example=1)
    crs: str = Field(..., example="Example")


class PolygonFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    geometry: str = Field(..., example="POINT (1.42 1.35)")
    crs: str = Field(..., example="EPSG:4326")
    geometry_type: Optional[str] = Field(None, alias="geometryType", example="WKT")


class WellType(Enum):
    exploration = "Exploration"
    development = "Development"
    any = "Any"


class Asset(WellsBaseModel):
    pass

    class Config:
        allow_population_by_field_name = True


class WellDatum(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    elevation: DoubleWithUnit
    reference: Optional[str] = Field(None, example="Example")
    name: Optional[str] = Field(None, example="Example")


class Metadata(WellsBaseModel):
    class Config:
        extra = Extra.allow

    __root__: str


class Survey(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    id: int = Field(..., description="unique id for sequence in cdf")
    name: Optional[str] = Field(None, description="name of sequence Survey in cdf")
    description: Optional[str] = Field(None, description="additional description for the data")
    metadata: Optional[Dict[str, Metadata]] = Field(None, description="metadata connected to the sequence")


class SurveyRow(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    row_number: int = Field(..., alias="rowNumber", description="The row number for this row")
    values: List = Field(
        ...,
        description="List of values in order defined in the columns field (Number of items must match. Null is accepted for missing values. String values must be no longer than 256 characters)",
    )


class ValueType(Enum):
    string = "STRING"
    double = "DOUBLE"
    long = "LONG"


class SurveyColumnInfo(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    external_id: Optional[str] = Field(
        None,
        alias="externalId",
        description="User provided column identifier (Unique for a given sequence)",
        example="DPS1",
    )
    name: Optional[str] = Field(None, description="Human readable name of the column", example="Depth sensor 1")
    value_type: Optional[ValueType] = Field(
        None,
        alias="valueType",
        description="What type the datapoints in a column will have. DOUBLE is restricted to the range [-1E100, 1E100]",
        example="DOUBLE",
    )


class SurveyDataRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    id: int = Field(..., description="A server-generated ID for the object.")
    start: Optional[int] = Field(None, description="Lowest row number included.")
    end: Optional[int] = Field(None, description="Get rows up to, but excluding, this row number. Default - No limit")
    limit: Optional[int] = Field(
        None,
        description="Maximum number of rows returned in one request. Api might return less even if there is more data, but it will then provide a cursor for continuation. If there is more data beyond this limit, a cursor will be returned to simplify further fetching of data.",
    )
    cursor: Optional[str] = Field(
        None,
        description="Cursor for pagination returned from a previous request. Apart from this cursor, the rest of the request object have be the same as for the original request.",
    )
    columns: Optional[List[str]] = Field(
        None,
        description="Columns to be included. Specified as list of column externalIds. In case this filter is not set, all available columns will be returned.",
    )


class SurveyData(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    id: int = Field(..., description="A server-generated ID for the object.")
    external_id: Optional[str] = Field(
        None, alias="externalId", description="A user provided identifier (Unique for a given survey)"
    )
    columns: List[SurveyColumnInfo] = Field(..., description="Column information in order given by data")
    rows: List[SurveyRow] = Field(..., description="List of row information")
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="Cursor to get the next page of results (if available)."
    )


class TrajectoryFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min_depth: Optional[float] = Field(
        None,
        alias="minDepth",
        description="Not implemented in the first version. Allows to filter on trajectories that go below this depth",
        example=1000,
    )
    max_depth: Optional[float] = Field(
        None,
        alias="maxDepth",
        description="Not implemented in the first version. Allows to filter on trajectories that go below this depth",
        example=3000,
    )
    crosses_formations: Optional[List[str]] = Field(
        None,
        alias="crossesFormations",
        description="Filters only trajectories that cross the specified formations. Not implemented in the first version.",
        example=["HEIMDALL FM", "SELE FM"],
    )


class Measurement(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    id: int
    external_id: Optional[str] = Field(None, alias="externalId")
    name: Optional[str] = None


class Wellbore(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str = Field(..., example="25/5-A")
    id: Optional[int] = Field(None, description="Asset id in CDF")
    external_id: Optional[str] = Field(None, alias="externalId")
    well_id: Optional[int] = Field(None, alias="wellId", description="Parent asset id in CDF")


class MeasurementType(Enum):
    gamma_ray = "GammaRay"
    caliper = "Caliper"
    resistivity = "Resistivity"
    density = "Density"
    neutron = "Neutron"
    ppfg = "PPFG"
    geomechanics = "Geomechanics"
    core = "Core"


class MeasurementFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement_type: MeasurementType = Field(..., alias="measurementType", example="GammaRay")
    min_depth: Optional[float] = Field(
        None,
        alias="minDepth",
        description="Not implemented in the first version. Allows to filter on measurements that have values below this depth",
        example=1000,
    )
    max_depth: Optional[float] = Field(
        None,
        alias="maxDepth",
        description="Not implemented in the first version. Allows to filter on measurements that have values above this depth",
        example=3000,
    )


class MeasurementFilters(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    contains_all: Optional[List[MeasurementFilter]] = Field(
        None, alias="containsAll", description="match on all of the measurements"
    )
    contains_any: Optional[List[MeasurementFilter]] = Field(
        None, alias="containsAny", description="match on any of the measurements"
    )


class Error(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    code: int
    message: str


class ErrorResponse(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    error: Error


class DoubleArrayWithUnit(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    values: List[float]
    unit: str


class TrajectoryIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    source_sequence_ext_id: str = Field(..., alias="sourceSequenceExtId")
    measured_depths: DoubleArrayWithUnit = Field(..., alias="measuredDepths")
    inclinations: DoubleArrayWithUnit
    azimuths: DoubleArrayWithUnit
    dogleg_severities: Optional[DoubleArrayWithUnit] = Field(None, alias="doglegSeverities")


class SequenceValueTypeEnum(Enum):
    string = "STRING"
    double = "DOUBLE"
    long = "LONG"


class SequenceRowDTO(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    row_number: int = Field(..., alias="rowNumber", description="The row number for this row", example=1, ge=0.0)
    values: List = Field(
        ...,
        description="List of values in order defined in the columns field (Number of items must match. Null is accepted for missing values. String values must be no longer than 256 characters)",
        max_items=200,
        min_items=1,
    )


class BasicGetSequenceColumnInfo(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    external_id: Optional[str] = Field(
        None,
        alias="externalId",
        description="User provided column identifier (Unique for a given sequence)",
        example="DPS1",
    )
    name: Optional[str] = Field(None, description="Human readable name of the column", example="Depth sensor 1")
    value_type: Optional[SequenceValueTypeEnum] = Field(None, alias="valueType")


class SequenceDataRequestDTO(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    id: Optional[int] = None
    start: Optional[int] = Field(0, description="Lowest row number included.")
    end: Optional[int] = Field(
        None, description="Get rows up to, but excluding, this row number. Default - No limit", example=1
    )
    limit: Optional[int] = Field(
        100,
        description="Maximum number of rows returned in one request. Api might return less even if there is more data, but it will then provide a cursor for continuation. If there is more data beyond this limit, a cursor will be returned to simplify further fetching of data.",
        example=1,
        ge=1.0,
        le=10000.0,
    )
    cursor: Optional[str] = Field(
        None,
        description="Cursor for pagination returned from a previous request. Apart from this cursor, the rest of the request object have be the same as for the original request.",
    )
    columns: Optional[List[str]] = Field(
        None,
        description="Columns to be included. Specified as list of column externalIds. In case this filter is not set, all available columns will be returned.",
        max_items=200,
        min_items=1,
    )


class SourcesCreate(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[str]


class Well(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    id: int = Field(..., description="id of the corresponding CDF asset", example=1)
    name: str = Field(..., example="25/5-5")
    external_id: str = Field(..., alias="externalId", example="WDL:Well:25/5-5")
    description: Optional[str] = Field(
        None, description="additional description for the data", example="extracted from EDM"
    )
    country: Optional[str] = Field(None, example="Norway")
    quadrant: Optional[str] = Field(None, example="25")
    block: Optional[str] = Field(None, example="25/5")
    field: Optional[str] = Field(None, example="Example")
    operator: Optional[str] = Field(None, example="Op1")
    spud_date: Optional[date] = Field(None, alias="spudDate", example="2017-05-17")
    water_depth: Optional[DoubleWithUnit] = Field(None, alias="waterDepth")
    wellhead: Optional[Wellhead] = None
    datum: Optional[WellDatum] = None
    sources: Optional[List[str]] = Field(
        None,
        description="List of source systems that are associated to this well (user may drill down further to explore metadata for each source by calling well/{id}/source/{sourcename}",
    )


class WellIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    asset_id: int = Field(..., alias="assetId", description="id of the corresponding CDF asset", example=1)
    well_name: str = Field(..., alias="wellName", example="25/5-5")
    description: Optional[str] = Field(
        None, description="additional description for the data", example="extracted from EDM"
    )
    country: Optional[str] = Field(None, example="Norway")
    quadrant: Optional[str] = Field(None, example="25")
    spud_date: Optional[date] = Field(None, alias="spudDate", example="2017-05-17")
    block: Optional[str] = Field(None, example="25/5")
    field: Optional[str] = Field(None, example="Example")
    operator: Optional[str] = Field(None, example="Op1")
    water_depth: int = Field(..., alias="waterDepth", description="Water depth", example=1)
    water_depth_unit: str = Field(..., alias="waterDepthUnit", example="m")
    wellhead: Wellhead
    datum: WellDatum
    source: str = Field(..., example="EDM")


class WellboreIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    asset_id: int = Field(..., alias="assetId", description="id of the corresponding CDF asset", example=1)
    wellbore_name: str = Field(..., alias="wellboreName", example="25/5-5")
    parent_name: str = Field(
        ..., alias="parentName", description="Name of either the well or wellbore parent of this wellbore"
    )
    parent_type: ParentType = Field(
        ..., alias="parentType", description="The type of the parent, either well or wellbore"
    )
    source: str = Field(..., example="EDM")
    trajectory_ingestion: Optional[TrajectoryIngestion] = Field(None, alias="trajectoryIngestion")
    well_ingestion: Optional[WellIngestion] = Field(None, alias="wellIngestion")


class WellFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    well_type: Optional[WellType] = Field(None, alias="wellType", example="Exploration")
    string_matching: Optional[str] = Field(
        None, alias="stringMatching", description="fuzzy match on description and name", example="Field"
    )
    quadrants: Optional[List[str]] = Field(None, example=["24", "25", "34"])
    blocks: Optional[List[str]] = Field(None, example=["24/6", "25/7", "34/1"])
    fields: Optional[List[str]] = Field(None, example=["Gullfaks", "Alvheim"])
    operators: Optional[List[str]] = Field(None, example=["op1", "op2"])
    sources: Optional[List[str]] = Field(None, example=["EDM", "Sitecom"])
    has_trajectory: Optional[TrajectoryFilter] = Field(None, alias="hasTrajectory")
    has_measurements: Optional[MeasurementFilters] = Field(None, alias="hasMeasurements")
    polygon: Optional[PolygonFilter] = None
    output_crs: Optional[str] = Field(None, alias="outputCrs", example="EPSG:4326")


class MeasurementItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Measurement]


class WellboreItems(WellsBaseModel):
    __root__: List[Wellbore]


class CasingIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    source_casing_id: int = Field(..., alias="sourceCasingId", description="ID of the casing sequence to ingest.")
    wellbore_name: str = Field(..., alias="wellboreName", description="Name of the wellbore. This must exist.")
    casing_name: Optional[List[str]] = Field(
        None,
        alias="casingName",
        description="Name of the casings/assemblies/components.",
        example=["Surface Casing", "Intermediate Casing", "Production Casing"],
    )
    body_inside_diameter: DoubleArrayWithUnit = Field(..., alias="bodyInsideDiameter")
    body_outside_diameter: DoubleArrayWithUnit = Field(..., alias="bodyOutsideDiameter")
    md_top: DoubleArrayWithUnit = Field(..., alias="mdTop")
    md_base: DoubleArrayWithUnit = Field(..., alias="mdBase")
    tvd_top: Optional[DoubleArrayWithUnit] = Field(None, alias="tvdTop")
    tvd_base: Optional[DoubleArrayWithUnit] = Field(None, alias="tvdBase")


class GetSequenceColumnDTO(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: Optional[str] = Field(None, description="Human readable name of the column", example="depth")
    external_id: Optional[str] = Field(
        None,
        alias="externalId",
        description="User provided column identifier (Unique for a given sequence)",
        example="DPS1",
    )
    description: Optional[str] = Field(None, description="Description of the column", example="Optional description")
    value_type: SequenceValueTypeEnum = Field(..., alias="valueType")
    metadata: Optional[Dict[str, Metadata]] = Field(
        None,
        description="Custom, application specific metadata. String key -> String value",
        example={"extracted-by": "cognite"},
    )
    created_time: int = Field(
        ...,
        alias="createdTime",
        description="Time when this asset was created in CDF in milliseconds since Jan 1, 1970.",
        example=100000000000,
    )
    last_updated_time: int = Field(
        ...,
        alias="lastUpdatedTime",
        description="The last time this asset was updated in CDF, in milliseconds since Jan 1, 1970.",
        example=100000000000,
    )


class SequenceGetData(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    id: int
    external_id: Optional[str] = Field(None, alias="externalId")
    columns: List[BasicGetSequenceColumnInfo] = Field(..., description="Column information in order given by data")
    rows: List[SequenceRowDTO] = Field(..., description="List of row information")
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="Cursor to get the next page of results (if available)."
    )


class WellItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Well]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class WellIngestionItems(WellsBaseModel):
    __root__: List[WellIngestion]


class WellboreIngestionItems(WellsBaseModel):
    __root__: List[WellboreIngestion]


class CasingIngestionItems(WellsBaseModel):
    __root__: List[CasingIngestion]


class GetSequenceDTO(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    id: int
    name: Optional[str] = Field(None, description="Name of the sequence", example="Any relevant name")
    description: Optional[str] = Field(None, description="Description of the sequence", example="Optional description")
    asset_id: Optional[int] = Field(
        None, alias="assetId", description="Optional asset this sequence is associated with", example=1221123111
    )
    external_id: Optional[str] = Field(None, alias="externalId")
    metadata: Optional[Dict[str, Metadata]] = Field(
        None,
        description="Custom, application specific metadata. String key -> String value. Maximum length of key is 32 bytes, value 512 bytes, up to 16 key-value pairs.",
        example={"extracted-by": "cognite"},
    )
    columns: List[GetSequenceColumnDTO] = Field(..., description="List of column definitions")
    created_time: int = Field(
        ...,
        alias="createdTime",
        description="Time when this sequence was created in CDF in milliseconds since Jan 1, 1970.",
        example=100000000000,
    )
    last_updated_time: int = Field(
        ...,
        alias="lastUpdatedTime",
        description="The last time this sequence was updated in CDF, in milliseconds since Jan 1, 1970.",
        example=100000000000,
    )
    data_set_id: Optional[int] = Field(
        None, alias="dataSetId", description="Data set that this sequence belongs to", example=2718281828459
    )
