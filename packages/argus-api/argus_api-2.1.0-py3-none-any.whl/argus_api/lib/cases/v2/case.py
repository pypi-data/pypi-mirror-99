"""Autogenerated API"""
from argus_api import session
from requests import Response



def abort_fragmented_upload(
    caseID: int,
    attachmentID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Abort fragmented upload of an attachment (DEV)
    
    :param int caseID: Case ID
    :param str attachmentID: Attachment ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments/{attachmentID}/abort".format(caseID=caseID,
        attachmentID=attachmentID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def acknowledge_workflow(
    caseID: int,
    workflow: str,
    comment: str = None,
    publicComment: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Acknowledge workflow on case (PUBLIC)
    
    :param int caseID: Case ID
    :param str workflow: Workflow to acknowledge
    :param str comment: Optional acknowledgement comment to add. Html is allowed, will be sanitized. 
    :param bool publicComment: If true, the comment is marked as public, and is made visible to customer. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/workflows/{workflow}/acknowledge".format(caseID=caseID,
        workflow=workflow)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send comment if the argument was provided, dont send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send publicComment if the argument was provided, dont send null values
    if publicComment is not None:
        body.update({"publicComment": publicComment})

    query_parameters = {}

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def add_attachment(
    caseID: int,
    name: str = None,
    mimeType: str = None,
    data: str = None,
    originEmailAddress: str = None,
    notification: dict = None,
    encryptedZip: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Add new attachment (PUBLIC)
    
    :param int caseID: Case ID
    :param str name: Name of attachment to add.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str mimeType: MimeType for attachment to add.  => Sanitize by regex [^ /]+/[^ /]+
    :param str data: Attachment bytes 
    :param str originEmailAddress: If update is made from an email, specify origin email address here  => format:email
    :param dict notification: 
    :param bool encryptedZip: If set, mark this attachment as an encrypted zip (should have password 'argus'). NOTE: the service does not encrypt or zip the attachment, this should be done by the client. (default false)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments".format(caseID=caseID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send mimeType if the argument was provided, dont send null values
    if mimeType is not None:
        body.update({"mimeType": mimeType})
    # Only send data if the argument was provided, dont send null values
    if data is not None:
        body.update({"data": data})
    # Only send encryptedZip if the argument was provided, dont send null values
    if encryptedZip is not None:
        body.update({"encryptedZip": encryptedZip})
    # Only send originEmailAddress if the argument was provided, dont send null values
    if originEmailAddress is not None:
        body.update({"originEmailAddress": originEmailAddress})
    # Only send notification if the argument was provided, dont send null values
    if notification is not None:
        body.update({"notification": notification})

    query_parameters = {}

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def add_case_link(
    caseID: int,
    linkToCaseID: int,
    type: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Add link to case (PUBLIC)
    
    :param int caseID: ID of case to link from
    :param int linkToCaseID: ID of case to link to
    :param str type: Type of link to add 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/links/{linkToCaseID}".format(caseID=caseID,
        linkToCaseID=linkToCaseID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send type if the argument was provided, dont send null values
    if type is not None:
        body.update({"type": type})

    query_parameters = {}

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def add_case_tag(
    caseID: int,
    tags: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Add tag to case (PUBLIC)
    
    :param int caseID: Case ID
    :param list tags: Add multiple tags as key/value strings or JSON objects 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/tags".format(caseID=caseID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send tags if the argument was provided, dont send null values
    if tags is not None:
        body.update({"tags": tags})

    query_parameters = {}

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def add_case_watcher(
    caseID: int,
    subjectID: int = None,
    type: str = None,
    userOrGroup: str = None,
    destination: str = None,
    verbose: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Add watcher to case (PUBLIC)
    
    :param int caseID: Case ID
    :param int subjectID: 
    :param str type: Type of watcher to add (default email)
    :param str userOrGroup: User or group to add watcher for, by ID or shortname. Shortname will be resolved in current users domain. 
    :param str destination: Contact information to add as watcher (email address or phone number). If subject is specified, this is ignored. 
    :param bool verbose: If set, explicitly set verbosity for watcher (will override default settings on subject) 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/watchers".format(caseID=caseID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send subjectID if the argument was provided, dont send null values
    if subjectID is not None:
        body.update({"subjectID": subjectID})
    # Only send type if the argument was provided, dont send null values
    if type is not None:
        body.update({"type": type})
    # Only send userOrGroup if the argument was provided, dont send null values
    if userOrGroup is not None:
        body.update({"userOrGroup": userOrGroup})
    # Only send destination if the argument was provided, dont send null values
    if destination is not None:
        body.update({"destination": destination})
    # Only send verbose if the argument was provided, dont send null values
    if verbose is not None:
        body.update({"verbose": verbose})

    query_parameters = {}

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def add_comment(
    caseID: int,
    asReplyTo: str = None,
    comment: str = None,
    internal: bool = None,
    originEmailAddress: str = None,
    notification: dict = None,
    associatedAttachmentID: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Submit new comment to case (PUBLIC)
    
    :param int caseID: Case ID
    :param str asReplyTo: Optional ID of comment to reply to. 
    :param str comment: Comment to add. Html is allowed, will be sanitized. 
    :param bool internal: If true, mark comment as internal, only visible to service techs. Default is false. 
    :param str originEmailAddress: If comment is added from an email, specify origin email address here.  => format:email
    :param dict notification: 
    :param list associatedAttachmentID: If set, associate this comment with the listed attachments. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/comments".format(caseID=caseID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send asReplyTo if the argument was provided, dont send null values
    if asReplyTo is not None:
        body.update({"asReplyTo": asReplyTo})
    # Only send comment if the argument was provided, dont send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send internal if the argument was provided, dont send null values
    if internal is not None:
        body.update({"internal": internal})
    # Only send originEmailAddress if the argument was provided, dont send null values
    if originEmailAddress is not None:
        body.update({"originEmailAddress": originEmailAddress})
    # Only send notification if the argument was provided, dont send null values
    if notification is not None:
        body.update({"notification": notification})
    # Only send associatedAttachmentID if the argument was provided, dont send null values
    if associatedAttachmentID is not None:
        body.update({"associatedAttachmentID": associatedAttachmentID})

    query_parameters = {}

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def advanced_case_search(
    startTimestamp: int = None,
    endTimestamp: int = None,
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    subCriteria: dict = None,
    exclude: bool = None,
    required: bool = None,
    customerID: int = None,
    caseID: int = None,
    customer: str = None,
    type: str = None,
    service: str = None,
    category: str = None,
    status: str = None,
    initialStatus: str = None,
    priority: str = None,
    initialPriority: str = None,
    assetID: str = None,
    tag: dict = None,
    workflow: dict = None,
    field: dict = None,
    keywords: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    user: str = None,
    userID: int = None,
    userFieldStrategy: str = None,
    userAssigned: bool = None,
    techAssigned: bool = None,
    includeWorkflows: bool = None,
    includeDescription: bool = None,
    accessMode: str = None,
    explicitAccess: dict = None,
    includeTestData: bool = None,
    sortBy: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Returns cases matching the defined CaseSearchCriteria (PUBLIC)
    
    :param int startTimestamp: 
    :param int endTimestamp: 
    :param int limit: Set this value to set max number of results. By default, no restriction on result set size. 
    :param int offset: Set this value to skip the first (offset) objects. By default, return result from first object. 
    :param bool includeDeleted: Set to true to include deleted objects. By default, exclude deleted objects. 
    :param list subCriteria: Set additional criterias which are applied using a logical OR. 
    :param bool exclude: Only relevant for subcriteria. If set to true, objects matching this subcriteria object will be excluded. 
    :param bool required: Only relevant for subcriteria. If set to true, objects matching this subcriteria are required (AND-ed together with parent criteria). 
    :param list customerID: Restrict search to data belonging to specified customers. 
    :param list caseID: Restrict search to specific cases (by ID). 
    :param list customer: Restrict search to specific customers (by ID or shortname). 
    :param list type: Restrict search to entries of one of these types. 
    :param list service: Restrict search to entries of one of these services (by service shortname or ID). 
    :param list category: Restrict search to entries of one of these categories (by category shortname or ID). 
    :param list status: Restrict search to entries of one of these statuses. 
    :param list initialStatus: Restrict search to entries where the initial status is one of these statuses. 
    :param list priority: Restrict search to entries with given priorties 
    :param list initialPriority: Restrict search to entries where the initial priority is one of these priorties 
    :param list assetID: Restrict search to cases associated with specified assets (hosts, services or processes) 
    :param list tag: Restrict search to entries matching the given tag criteria. 
    :param list workflow: Restrict search to entries matching the given workflow criteria. 
    :param list field: Restrict search to entries matching the given field criteria. 
    :param list keywords: Search for keywords. 
    :param list timeFieldStrategy: Defines which timestamps will be included in the search (default all). 
    :param str timeMatchStrategy: Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any) 
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords (default all supported fields). 
    :param str keywordMatchStrategy: Defines the MatchStrategy for keywords (default match all keywords). 
    :param list user: Restrict search to cases associated with these users or user groups (by ID or shortname). 
    :param list userID: This field is deprecated. Use field 'user' instead. 
    :param list userFieldStrategy: Defines which user fields will be searched (default match all user fields). 
    :param bool userAssigned: If set, limit search to cases where assignedUser field is set/unset 
    :param bool techAssigned: If set, limit search to cases where assignedTech field is set/unset 
    :param bool includeWorkflows: If true, include list of workflows in result. Default is false (not present). 
    :param bool includeDescription: If false, omit description from response. Default is true (description is present). 
    :param list accessMode: If set, only match cases which is set to one of these access modes 
    :param list explicitAccess: If set, only match cases which have explicit access grants matching the specified criteria 
    :param bool includeTestData: If true, also include cases marked as TEST_DATA in search result. This option is restricted to users with permission viewCaseTestData. Default is false (excluded). 
    :param list sortBy: List of properties to sort by (prefix with "-" to sort descending). 
    :param list includeFlags: Only include objects which have includeFlags set. 
    :param list excludeFlags: Exclude objects which have excludeFlags set. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: requests.Response object or dictionary translated from JSON
    """

    route = "/cases/v2/case/search".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': None
    }
    if json:
        headers['content'] = 'application/json'

    body = body or {}
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send exclude if the argument was provided, dont send null values
    if exclude is not None:
        body.update({"exclude": exclude})
    # Only send required if the argument was provided, dont send null values
    if required is not None:
        body.update({"required": required})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send caseID if the argument was provided, dont send null values
    if caseID is not None:
        body.update({"caseID": caseID})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send type if the argument was provided, dont send null values
    if type is not None:
        body.update({"type": type})
    # Only send service if the argument was provided, dont send null values
    if service is not None:
        body.update({"service": service})
    # Only send category if the argument was provided, dont send null values
    if category is not None:
        body.update({"category": category})
    # Only send status if the argument was provided, dont send null values
    if status is not None:
        body.update({"status": status})
    # Only send initialStatus if the argument was provided, dont send null values
    if initialStatus is not None:
        body.update({"initialStatus": initialStatus})
    # Only send priority if the argument was provided, dont send null values
    if priority is not None:
        body.update({"priority": priority})
    # Only send initialPriority if the argument was provided, dont send null values
    if initialPriority is not None:
        body.update({"initialPriority": initialPriority})
    # Only send assetID if the argument was provided, dont send null values
    if assetID is not None:
        body.update({"assetID": assetID})
    # Only send tag if the argument was provided, dont send null values
    if tag is not None:
        body.update({"tag": tag})
    # Only send workflow if the argument was provided, dont send null values
    if workflow is not None:
        body.update({"workflow": workflow})
    # Only send field if the argument was provided, dont send null values
    if field is not None:
        body.update({"field": field})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, dont send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send keywordFieldStrategy if the argument was provided, dont send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, dont send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send user if the argument was provided, dont send null values
    if user is not None:
        body.update({"user": user})
    # Only send userID if the argument was provided, dont send null values
    if userID is not None:
        body.update({"userID": userID})
    # Only send userFieldStrategy if the argument was provided, dont send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send userAssigned if the argument was provided, dont send null values
    if userAssigned is not None:
        body.update({"userAssigned": userAssigned})
    # Only send techAssigned if the argument was provided, dont send null values
    if techAssigned is not None:
        body.update({"techAssigned": techAssigned})
    # Only send includeWorkflows if the argument was provided, dont send null values
    if includeWorkflows is not None:
        body.update({"includeWorkflows": includeWorkflows})
    # Only send includeDescription if the argument was provided, dont send null values
    if includeDescription is not None:
        body.update({"includeDescription": includeDescription})
    # Only send accessMode if the argument was provided, dont send null values
    if accessMode is not None:
        body.update({"accessMode": accessMode})
    # Only send explicitAccess if the argument was provided, dont send null values
    if explicitAccess is not None:
        body.update({"explicitAccess": explicitAccess})
    # Only send includeTestData if the argument was provided, dont send null values
    if includeTestData is not None:
        body.update({"includeTestData": includeTestData})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})

    query_parameters = {}

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response



def change_access_settings(
    caseID: int,
    accessMode: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Change general access settings (PUBLIC)
    
    :param int caseID: Case ID
    :param str accessMode: If set, this will alter the access mode of the case. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/access".format(caseID=caseID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send accessMode if the argument was provided, dont send null values
    if accessMode is not None:
        body.update({"accessMode": accessMode})

    query_parameters = {}

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def clear_field(
    caseID: int,
    field: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Clear specific field for a case, by either field ID or field name. For multivalue fields, the field may contain multiple values. (DEV)
    
    :param int caseID: ID of the case to clear fields for
    :param str field: ID or fieldName of the field to clear
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/fields/{field}".format(caseID=caseID,
        field=field)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def close_case(
    caseID: int,
    comment: str = None,
    notification: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Close an open case (PUBLIC)
    
    :param int caseID: Case ID
    :param str comment: Closing comment to add to case. May use HTML, will be sanitized. 
    :param dict notification: 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/close".format(caseID=caseID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send comment if the argument was provided, dont send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send notification if the argument was provided, dont send null values
    if notification is not None:
        body.update({"notification": notification})

    query_parameters = {}

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def complete_fragmented_upload(
    caseID: int,
    attachmentID: str,
    sha256: str = None,
    notification: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Complete fragmented upload of an attachment (DEV)
    
    :param int caseID: Case ID
    :param str attachmentID: Attachment ID
    :param str sha256: The sha256 of the entire document. 
    :param dict notification: 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments/{attachmentID}/complete".format(caseID=caseID,
        attachmentID=attachmentID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send attachmentID if the argument was provided, dont send null values
    if attachmentID is not None:
        body.update({"attachmentID": attachmentID})
    # Only send sha256 if the argument was provided, dont send null values
    if sha256 is not None:
        body.update({"sha256": sha256})
    # Only send notification if the argument was provided, dont send null values
    if notification is not None:
        body.update({"notification": notification})

    query_parameters = {}

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def create_case(
    customerID: int = None,
    customer: str = None,
    service: str = None,
    category: str = None,
    type: str = None,
    status: str = None,
    watchers: dict = None,
    fields: dict = None,
    tags: dict = None,
    subject: str = None,
    description: str = None,
    customerReference: str = None,
    priority: str = None,
    accessMode: str = None,
    aclMembers: dict = None,
    notification: dict = None,
    originEmailAddress: str = None,
    triggers: dict = None,
    assignedUser: str = None,
    assignedTech: str = None,
    testData: bool = None,
    publish: bool = True,
    defaultWatchers: bool = True,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Create a new case defined by CaseCreateRequest (PUBLIC)
    
    :param int customerID: DEPRECATED. Use customer instead 
    :param str customer: ID or shortname of customer to create case for. Defaults to current users customer 
    :param str service: ID of service to create case for 
    :param str category: If set, assign given category to new case (by category shortname). 
    :param str type: Type of case to create 
    :param str status: Status of case to create. If not set, system will select automatically. Creating a new case with status closed is not permitted. 
    :param list watchers: Explicit watchers to add to this case. 
    :param list fields: Fields to set on case creation. Fields in the policy for requested service and customer specifies fields available. If any of the fields in the policy are required on create, and do not have a default value,those fields must be set in the case create request, or the request will fail. 
    :param list tags: Tags to add on case creation. 
    :param str subject: Subject of case to create.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str description: Case description. May use HTML, which will be sanitized. 
    :param str customerReference: Customer reference for case.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str priority: Priority of case to create. (default medium)
    :param str accessMode: Access mode for new case. (default roleBased)
    :param list aclMembers: Explicit ACL members to add to case. 
    :param dict notification: 
    :param str originEmailAddress: If case is created from an email, specify origin email address here  => format:email
    :param dict triggers: 
    :param str assignedUser: If set, assign given user to case (by ID or shortname). Shortname will be resolved in the current users domain. 
    :param str assignedTech: If set, assign given technical user (solution engineer) to case (by ID or shortname). Shortname will be resolved in the current users domain. 
    :param bool testData: If true, this case will be marked as TEST_DATA. TEST_DATA cases are excluded from search results by default. 
    :param bool publish: Whether to publish new case. Creating an unpublished case requires special permission. (default true)
    :param bool defaultWatchers: Whether to enable default watchers for this case. If set to false, default watchers will not be enabled, and will not be notified upon creation of this case. (default true)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send service if the argument was provided, dont send null values
    if service is not None:
        body.update({"service": service})
    # Only send category if the argument was provided, dont send null values
    if category is not None:
        body.update({"category": category})
    # Only send type if the argument was provided, dont send null values
    if type is not None:
        body.update({"type": type})
    # Only send status if the argument was provided, dont send null values
    if status is not None:
        body.update({"status": status})
    # Only send publish if the argument was provided, dont send null values
    if publish is not None:
        body.update({"publish": publish})
    # Only send defaultWatchers if the argument was provided, dont send null values
    if defaultWatchers is not None:
        body.update({"defaultWatchers": defaultWatchers})
    # Only send watchers if the argument was provided, dont send null values
    if watchers is not None:
        body.update({"watchers": watchers})
    # Only send fields if the argument was provided, dont send null values
    if fields is not None:
        body.update({"fields": fields})
    # Only send tags if the argument was provided, dont send null values
    if tags is not None:
        body.update({"tags": tags})
    # Only send subject if the argument was provided, dont send null values
    if subject is not None:
        body.update({"subject": subject})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send customerReference if the argument was provided, dont send null values
    if customerReference is not None:
        body.update({"customerReference": customerReference})
    # Only send priority if the argument was provided, dont send null values
    if priority is not None:
        body.update({"priority": priority})
    # Only send accessMode if the argument was provided, dont send null values
    if accessMode is not None:
        body.update({"accessMode": accessMode})
    # Only send aclMembers if the argument was provided, dont send null values
    if aclMembers is not None:
        body.update({"aclMembers": aclMembers})
    # Only send notification if the argument was provided, dont send null values
    if notification is not None:
        body.update({"notification": notification})
    # Only send originEmailAddress if the argument was provided, dont send null values
    if originEmailAddress is not None:
        body.update({"originEmailAddress": originEmailAddress})
    # Only send triggers if the argument was provided, dont send null values
    if triggers is not None:
        body.update({"triggers": triggers})
    # Only send assignedUser if the argument was provided, dont send null values
    if assignedUser is not None:
        body.update({"assignedUser": assignedUser})
    # Only send assignedTech if the argument was provided, dont send null values
    if assignedTech is not None:
        body.update({"assignedTech": assignedTech})
    # Only send testData if the argument was provided, dont send null values
    if testData is not None:
        body.update({"testData": testData})

    query_parameters = {}

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def current_user_watcher_status(
    caseID: int,
    email: bool = None,
    sms: bool = None,
    verbose: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Query and set watcher status for the current user on this case (PUBLIC)
    
    :param int caseID: Case ID
    :param bool email: If true, enable email notification for current user. If false, disable email. Default is no change. 
    :param bool sms: If true, enable SMS notification for current user. If false, disable SMS. Default is no change. 
    :param bool verbose: If set, explicitly set verbosity for watcher for enabled contact methods (will override default settings on current user) 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/watch".format(caseID=caseID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send email if the argument was provided, dont send null values
    if email is not None:
        body.update({"email": email})
    # Only send sms if the argument was provided, dont send null values
    if sms is not None:
        body.update({"sms": sms})
    # Only send verbose if the argument was provided, dont send null values
    if verbose is not None:
        body.update({"verbose": verbose})

    query_parameters = {}

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def delete_attachment(
    caseID: int,
    attachmentID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Delete specified attachment from case (PUBLIC)
    
    :param int caseID: Case ID
    :param str attachmentID: Attachment ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments/{attachmentID}".format(caseID=caseID,
        attachmentID=attachmentID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def delete_case(
    caseID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Mark existing case as deleted (PUBLIC)
    
    :param int caseID: Case ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}".format(caseID=caseID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def delete_case_link(
    caseID: int,
    linkID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Remove existing case link (PUBLIC)
    
    :param int caseID: Case ID
    :param str linkID: Link ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/links/{linkID}".format(caseID=caseID,
        linkID=linkID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def delete_comment(
    caseID: int,
    commentID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Mark existing comment as deleted (PUBLIC)
    
    :param int caseID: Case ID
    :param str commentID: Comment ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/comments/{commentID}".format(caseID=caseID,
        commentID=commentID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def download_attachment(
    caseID: int,
    attachmentID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> Response:
    """Download specific attachment contents. (PUBLIC)
    
    :param int caseID: Case ID
    :param str attachmentID: Attachment ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: requests.Response object
    
    """

    route = "/cases/v2/case/{caseID}/attachments/{attachmentID}/download".format(caseID=caseID,
        attachmentID=attachmentID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': None
    }

    body = body or {}

    query_parameters = {}

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response
    



def edit_comment(
    caseID: int,
    commentID: str,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Edit existing comment (PUBLIC)
    
    :param int caseID: Case ID
    :param str commentID: Comment ID
    :param str comment: Updated comment 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/comments/{commentID}".format(caseID=caseID,
        commentID=commentID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send comment if the argument was provided, dont send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def get_attachment(
    caseID: int,
    attachmentID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch specific attachment metadata (PUBLIC)
    
    :param int caseID: Case ID
    :param str attachmentID: Attachment ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments/{attachmentID}".format(caseID=caseID,
        attachmentID=attachmentID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def get_case_comment(
    caseID: int,
    commentID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch specific comment (PUBLIC)
    
    :param int caseID: Case ID
    :param str commentID: Comment ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/comments/{commentID}".format(caseID=caseID,
        commentID=commentID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def get_case_comment_notifications(
    caseID: int,
    commentID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch notifications recorded for specified comment (DEV)
    
    :param int caseID: Case ID
    :param str commentID: Comment ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/comments/{commentID}/notifications".format(caseID=caseID,
        commentID=commentID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def get_case_metadata_by_id(
    id: int,
    skipRedirect: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Returns the basic case descriptor for the case identified by ID (PUBLIC)
    
    :param int id: Case ID
    :param bool skipRedirect: If true, skip automatic redirect (for merged cases)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{id}".format(id=id,
        skipRedirect=skipRedirect)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send skipRedirect if the argument was provided, dont send null values
    if skipRedirect is not None:
        query_parameters.update({"skipRedirect": skipRedirect})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def get_case_service(
    id: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Returns the service descriptor for the case identified by ID (PUBLIC)
    
    :param int id: Case ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{id}/service".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def get_case_transaction(
    caseID: int,
    transactionID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Returns a single case transaction transactions (DEV)
    
    :param int caseID: Case ID
    :param str transactionID: Transaction ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/history/{transactionID}".format(caseID=caseID,
        transactionID=transactionID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def get_field(
    caseID: int,
    field: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch specific field for a case, by either field ID or field name. For multivalue fields, the field may contain multiple values. (DEV)
    
    :param int caseID: ID of the case to fetch fields for
    :param str field: ID or fieldName of the field to fetch
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/fields/{field}".format(caseID=caseID,
        field=field)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def get_field_policy_by_case(
    caseID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch field policy for a specific case (DEV)
    
    :param int caseID: ID of case to fetch policy for
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/fieldpolicy".format(caseID=caseID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def grant_access(
    caseID: int,
    userOrGroup: str = None,
    subjectID: int = None,
    level: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Grant access to a case (PUBLIC)
    
    :param int caseID: Case ID
    :param str userOrGroup: ID or shortname of user or group to grant access to. Shortname will be resolved in current users domain. 
    :param int subjectID: This field is deprecated. Use field 'userOrGroup' instead. 
    :param str level: Level to grant for subject. (default read)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/access".format(caseID=caseID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send userOrGroup if the argument was provided, dont send null values
    if userOrGroup is not None:
        body.update({"userOrGroup": userOrGroup})
    # Only send subjectID if the argument was provided, dont send null values
    if subjectID is not None:
        body.update({"subjectID": subjectID})
    # Only send level if the argument was provided, dont send null values
    if level is not None:
        body.update({"level": level})

    query_parameters = {}

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def list_case_a_c_l(
    caseID: int,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List ACL entries for an existing case (PUBLIC)
    
    :param int caseID: Case ID
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/access".format(limit=limit,
        caseID=caseID,
        offset=offset)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def list_case_attachments(
    caseID: int,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List attachments for an existing case (PUBLIC)
    
    :param int caseID: Case ID
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments".format(limit=limit,
        caseID=caseID,
        offset=offset)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def list_case_comments(
    caseID: int,
    beforeComment: str = None,
    afterComment: str = None,
    sortBy: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List comments for an existing case (PUBLIC)
    
    :param int caseID: Case ID
    :param str beforeComment: Limit to comments before this comment ID (in sort order)
    :param str afterComment: Limit to comments after this comment ID (in sort order)
    :param list sortBy: Sort ordering. Default is addedTimestamp (ascending)
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/comments".format(limit=limit,
        caseID=caseID,
        beforeComment=beforeComment,
        afterComment=afterComment,
        offset=offset,
        sortBy=sortBy)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send beforeComment if the argument was provided, dont send null values
    if beforeComment is not None:
        query_parameters.update({"beforeComment": beforeComment})
    # Only send afterComment if the argument was provided, dont send null values
    if afterComment is not None:
        query_parameters.update({"afterComment": afterComment})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def list_case_history(
    caseID: int,
    type: str = None,
    operation: str = None,
    field: str = None,
    userID: int = None,
    transactionID: str = None,
    beforeTransaction: str = None,
    afterTransaction: str = None,
    startTimestamp: str = None,
    endTimestamp: str = None,
    sortBy: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Returns the history of case transactions (DEV)
    
    :param int caseID: Case ID
    :param list type: Transaction types to fetch
    :param list operation: Include operations
    :param list field: Include fields
    :param list userID: Filter out transactions by specified users
    :param list transactionID: Filter out specific transactions
    :param str beforeTransaction: Limit to transactions before this transaction (in sort order)
    :param str afterTransaction: Limit to transactions after this transaction (in sort order)
    :param str startTimestamp: Limit to transactions after this timestamp
    :param str endTimestamp: Limit to transactions before this timestamp
    :param list sortBy: Sort ordering. Default is timestamp (ascending)
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/history".format(limit=limit,
        caseID=caseID,
        type=type,
        operation=operation,
        field=field,
        userID=userID,
        transactionID=transactionID,
        beforeTransaction=beforeTransaction,
        afterTransaction=afterTransaction,
        startTimestamp=startTimestamp,
        endTimestamp=endTimestamp,
        offset=offset,
        sortBy=sortBy)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send type if the argument was provided, dont send null values
    if type is not None:
        query_parameters.update({"type": type})
    # Only send operation if the argument was provided, dont send null values
    if operation is not None:
        query_parameters.update({"operation": operation})
    # Only send field if the argument was provided, dont send null values
    if field is not None:
        query_parameters.update({"field": field})
    # Only send userID if the argument was provided, dont send null values
    if userID is not None:
        query_parameters.update({"userID": userID})
    # Only send transactionID if the argument was provided, dont send null values
    if transactionID is not None:
        query_parameters.update({"transactionID": transactionID})
    # Only send beforeTransaction if the argument was provided, dont send null values
    if beforeTransaction is not None:
        query_parameters.update({"beforeTransaction": beforeTransaction})
    # Only send afterTransaction if the argument was provided, dont send null values
    if afterTransaction is not None:
        query_parameters.update({"afterTransaction": afterTransaction})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def list_case_links(
    caseID: int,
    direction: str = None,
    type: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List links for an existing case (PUBLIC)
    
    :param int caseID: Case ID
    :param str direction: Specify direction of links to fetch (default all)
    :param list type: Specify link types to fetch (default all)
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/links".format(limit=limit,
        caseID=caseID,
        offset=offset,
        direction=direction,
        type=type)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send direction if the argument was provided, dont send null values
    if direction is not None:
        query_parameters.update({"direction": direction})
    # Only send type if the argument was provided, dont send null values
    if type is not None:
        query_parameters.update({"type": type})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def list_case_tags(
    caseID: int,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List tags for an existing case (PUBLIC)
    
    :param int caseID: Case ID
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/tags".format(limit=limit,
        caseID=caseID,
        offset=offset)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def list_case_watchers(
    caseID: int,
    limit: int = 25,
    includeExplicit: bool = True,
    includeDefault: bool = True,
    offset: int = None,
    includeDisabled: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List watchers for an existing case (PUBLIC)
    
    :param int caseID: Case ID
    :param int limit: Maximum number of returned results
    :param bool includeExplicit: Include explicit watchers (default true)
    :param bool includeDefault: Include default watchers (default true)
    :param int offset: Skip a number of results
    :param bool includeDisabled: Include disabled watchers (default false)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/watchers".format(limit=limit,
        includeExplicit=includeExplicit,
        includeDefault=includeDefault,
        caseID=caseID,
        offset=offset,
        includeDisabled=includeDisabled)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send includeExplicit if the argument was provided, dont send null values
    if includeExplicit is not None:
        query_parameters.update({"includeExplicit": includeExplicit})
    # Only send includeDefault if the argument was provided, dont send null values
    if includeDefault is not None:
        query_parameters.update({"includeDefault": includeDefault})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send includeDisabled if the argument was provided, dont send null values
    if includeDisabled is not None:
        query_parameters.update({"includeDisabled": includeDisabled})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def list_fields(
    caseID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List fields on case. Each field represents a defined field which has a value set for this case. For multivalue fields, the field may contain multiple values. (DEV)
    
    :param int caseID: ID of the case to fetch fields for
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/fields".format(caseID=caseID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def list_transaction_notifications(
    caseID: int,
    transactionID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Returns the notifications of a specified transaction (DEV)
    
    :param int caseID: Case ID
    :param str transactionID: Transaction ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/history/{transactionID}/notifications".format(caseID=caseID,
        transactionID=transactionID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def list_workflows(
    caseID: int,
    includeDeleted: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List workflows for an existing case (PUBLIC)
    
    :param int caseID: Case ID
    :param bool includeDeleted: If true, include deleted workflows
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/workflows".format(caseID=caseID,
        includeDeleted=includeDeleted)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def merge_cases(
    mergeInto: int,
    mergeFrom: int,
    description: str = None,
    priority: str = None,
    status: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Merge two cases (PUBLIC)
    
    :param int mergeInto: ID of case to merge into
    :param int mergeFrom: ID of case to merge
    :param str description: Case description of merged case. May use HTML, which will be sanitized. If not set, the description of both cases will be combined. 
    :param str priority: Priority of merged case. If not set, keep priority of mergeInto case. 
    :param str status: Status of merged case. If not set, keep status of mergeInto case. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{mergeInto}/merge/{mergeFrom}".format(mergeInto=mergeInto,
        mergeFrom=mergeFrom)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send priority if the argument was provided, dont send null values
    if priority is not None:
        body.update({"priority": priority})
    # Only send status if the argument was provided, dont send null values
    if status is not None:
        body.update({"status": status})

    query_parameters = {}

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def move_case(
    id: int,
    customerID: int = None,
    customer: str = None,
    service: str = None,
    category: str = None,
    type: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Move a case to a differnet category, service or customer (PUBLIC)
    
    :param int id: Case ID
    :param int customerID: DEPRECATED. Use customer instead 
    :param str customer: If set, move case to specified customer (id or shortname). 
    :param str service: If set, move case to specified service (id or shortname). 
    :param str category: If set, assign given category to specified category (by category id or shortname). Set value to empty string to unset category. 
    :param str type: If set, move case to specified type. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{id}/move".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send service if the argument was provided, dont send null values
    if service is not None:
        body.update({"service": service})
    # Only send category if the argument was provided, dont send null values
    if category is not None:
        body.update({"category": category})
    # Only send type if the argument was provided, dont send null values
    if type is not None:
        body.update({"type": type})

    query_parameters = {}

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def prepare_attachment_upload(
    caseID: int,
    name: str = None,
    mimeType: str = None,
    originEmailAddress: str = None,
    encryptedZip: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Prepare new fragmentedattachment upload (DEV)
    
    :param int caseID: Case ID
    :param str name: Name of attachment to add.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str mimeType: MimeType for attachment to add.  => Sanitize by regex [^ /]+/[^ /]+
    :param str originEmailAddress: If update is made from an email, specify origin email address here  => format:email
    :param bool encryptedZip: If set, mark this attachment as an encrypted zip (should have password 'argus'). NOTE: the service does not encrypt or zip the attachment, this should be done by the client. (default false)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments/prepare".format(caseID=caseID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send mimeType if the argument was provided, dont send null values
    if mimeType is not None:
        body.update({"mimeType": mimeType})
    # Only send encryptedZip if the argument was provided, dont send null values
    if encryptedZip is not None:
        body.update({"encryptedZip": encryptedZip})
    # Only send originEmailAddress if the argument was provided, dont send null values
    if originEmailAddress is not None:
        body.update({"originEmailAddress": originEmailAddress})

    query_parameters = {}

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def publish_case(
    caseID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Publish existing case not marked as published (PUBLIC)
    
    :param int caseID: Case ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/publish".format(caseID=caseID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def remove_access(
    caseID: int,
    aclEntryID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Revoke access from a case (PUBLIC)
    
    :param int caseID: Case ID
    :param str aclEntryID: ACL entry to revoke
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/access/{aclEntryID}".format(caseID=caseID,
        aclEntryID=aclEntryID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def remove_case_contact_watcher(
    caseID: int,
    contactID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Remove a specific contact listed in the default watchers from watching this case (PUBLIC)
    
    :param int caseID: Case ID
    :param int contactID: Contact ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/watchers/contact/{contactID}".format(caseID=caseID,
        contactID=contactID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def remove_case_tag_by_id(
    caseID: int,
    tagID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Remove existing tag (PUBLIC)
    
    :param int caseID: Case ID
    :param str tagID: Tag ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/tags/{tagID}".format(caseID=caseID,
        tagID=tagID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def remove_case_tag_by_key_value(
    caseID: int,
    tagKey: str,
    tagValue: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Remove existing tag (PUBLIC)
    
    :param int caseID: Case ID
    :param str tagKey: Tag Key
    :param str tagValue: Tag Value
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/tags/{tagKey}/{tagValue}".format(caseID=caseID,
        tagKey=tagKey,
        tagValue=tagValue)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def remove_case_watcher(
    caseID: int,
    watcherID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Remove specific watcher from a case (PUBLIC)
    
    :param int caseID: Case ID
    :param str watcherID: Watcher ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/watchers/{watcherID}".format(caseID=caseID,
        watcherID=watcherID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def remove_current_user_watcher(
    caseID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Remove the current user from the watchlist of this case.If the currentuser is a contact, this will override the contact settings for the current user for this case. (PUBLIC)
    
    :param int caseID: Case ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/watch".format(caseID=caseID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def request_workflow(
    caseID: int,
    workflow: str,
    comment: str = None,
    externalReference: str = None,
    publicComment: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Request new workflow on case (PUBLIC)
    
    :param int caseID: Case ID
    :param str workflow: Workflow to request
    :param str comment: Optional comment to add. Html is allowed, will be sanitized. 
    :param str externalReference: Optional external reference to add. Should be a link or an issue number. 
    :param bool publicComment: If true, the comment is marked as public, and is made visible to customer. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/workflows/{workflow}/request".format(caseID=caseID,
        workflow=workflow)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send comment if the argument was provided, dont send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send externalReference if the argument was provided, dont send null values
    if externalReference is not None:
        body.update({"externalReference": externalReference})
    # Only send publicComment if the argument was provided, dont send null values
    if publicComment is not None:
        body.update({"publicComment": publicComment})

    query_parameters = {}

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def search_case_statistics(
    startTimestamp: int = None,
    endTimestamp: int = None,
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    subCriteria: dict = None,
    exclude: bool = None,
    required: bool = None,
    customerID: int = None,
    caseID: int = None,
    customer: str = None,
    type: str = None,
    service: str = None,
    category: str = None,
    status: str = None,
    initialStatus: str = None,
    priority: str = None,
    initialPriority: str = None,
    assetID: str = None,
    tag: dict = None,
    workflow: dict = None,
    field: dict = None,
    keywords: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    user: str = None,
    userID: int = None,
    userFieldStrategy: str = None,
    userAssigned: bool = None,
    techAssigned: bool = None,
    includeWorkflows: bool = None,
    includeDescription: bool = None,
    accessMode: str = None,
    explicitAccess: dict = None,
    includeTestData: bool = None,
    groupBy: str = None,
    values: str = None,
    resolution: int = None,
    resolutionUnit: str = None,
    cutoff: int = None,
    cutoffFields: dict = None,
    cutoffValue: str = None,
    includeOthers: bool = None,
    sortByField: str = None,
    sortByValue: str = None,
    sortBy: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Returns statistics data matching the defined CaseStatsSearchCriteria (PUBLIC)
    
    :param int startTimestamp: 
    :param int endTimestamp: 
    :param int limit: Set this value to set max number of results. By default, no restriction on result set size. 
    :param int offset: Set this value to skip the first (offset) objects. By default, return result from first object. 
    :param bool includeDeleted: Set to true to include deleted objects. By default, exclude deleted objects. 
    :param list subCriteria: Set additional criterias which are applied using a logical OR. 
    :param bool exclude: Only relevant for subcriteria. If set to true, objects matching this subcriteria object will be excluded. 
    :param bool required: Only relevant for subcriteria. If set to true, objects matching this subcriteria are required (AND-ed together with parent criteria). 
    :param list customerID: Restrict search to data belonging to specified customers. 
    :param list caseID: Restrict search to specific cases (by ID). 
    :param list customer: Restrict search to specific customers (by ID or shortname). 
    :param list type: Restrict search to entries of one of these types. 
    :param list service: Restrict search to entries of one of these services (by service shortname or ID). 
    :param list category: Restrict search to entries of one of these categories (by category shortname or ID). 
    :param list status: Restrict search to entries of one of these statuses. 
    :param list initialStatus: Restrict search to entries where the initial status is one of these statuses. 
    :param list priority: Restrict search to entries with given priorties 
    :param list initialPriority: Restrict search to entries where the initial priority is one of these priorties 
    :param list assetID: Restrict search to cases associated with specified assets (hosts, services or processes) 
    :param list tag: Restrict search to entries matching the given tag criteria. 
    :param list workflow: Restrict search to entries matching the given workflow criteria. 
    :param list field: Restrict search to entries matching the given field criteria. 
    :param list keywords: Search for keywords. 
    :param list timeFieldStrategy: Defines which timestamps will be included in the search (default all). 
    :param str timeMatchStrategy: Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any) 
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords (default all supported fields). 
    :param str keywordMatchStrategy: Defines the MatchStrategy for keywords (default match all keywords). 
    :param list user: Restrict search to cases associated with these users or user groups (by ID or shortname). 
    :param list userID: This field is deprecated. Use field 'user' instead. 
    :param list userFieldStrategy: Defines which user fields will be searched (default match all user fields). 
    :param bool userAssigned: If set, limit search to cases where assignedUser field is set/unset 
    :param bool techAssigned: If set, limit search to cases where assignedTech field is set/unset 
    :param bool includeWorkflows: If true, include list of workflows in result. Default is false (not present). 
    :param bool includeDescription: If false, omit description from response. Default is true (description is present). 
    :param list accessMode: If set, only match cases which is set to one of these access modes 
    :param list explicitAccess: If set, only match cases which have explicit access grants matching the specified criteria 
    :param bool includeTestData: If true, also include cases marked as TEST_DATA in search result. This option is restricted to users with permission viewCaseTestData. Default is false (excluded). 
    :param list groupBy: Specify which fields will be grouped by in stats 
    :param list values: Specify which values will be included in stats (default created) 
    :param int resolution: Stats resolution period (unit specified by resolutionUnit), if is 0 means to generate non-timeline statistics 
    :param str resolutionUnit: Stats resolution period time unit. (default milliseconds)
    :param int cutoff: This option is deprecated. Use cutoffFields instead. 
    :param dict cutoffFields: Reduce stats keys to max amount of distinct values per field. Fields which are not listed will not be reduced. 
    :param str cutoffValue: Specify which value to be cutoff on (default created) 
    :param bool includeOthers: If reduce (cutoff>0), true means remaining keys (other than cutoff keys) are collected into an "other" key, default false 
    :param str sortByField: If set, sort by this field. The returned field must be in the groupBy list. If not set, the container will be sorted by value. 
    :param str sortByValue: If set, sort by this value (descending by value). The specified value must be in the values list. If not set, it defaults to the first returned value. This field cannot be set if sortByField id set.. 
    :param list sortBy: List of properties to sort by (prefix with "-" to sort descending). 
    :param list includeFlags: Only include objects which have includeFlags set. 
    :param list excludeFlags: Exclude objects which have excludeFlags set. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/stats".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send exclude if the argument was provided, dont send null values
    if exclude is not None:
        body.update({"exclude": exclude})
    # Only send required if the argument was provided, dont send null values
    if required is not None:
        body.update({"required": required})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send caseID if the argument was provided, dont send null values
    if caseID is not None:
        body.update({"caseID": caseID})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send type if the argument was provided, dont send null values
    if type is not None:
        body.update({"type": type})
    # Only send service if the argument was provided, dont send null values
    if service is not None:
        body.update({"service": service})
    # Only send category if the argument was provided, dont send null values
    if category is not None:
        body.update({"category": category})
    # Only send status if the argument was provided, dont send null values
    if status is not None:
        body.update({"status": status})
    # Only send initialStatus if the argument was provided, dont send null values
    if initialStatus is not None:
        body.update({"initialStatus": initialStatus})
    # Only send priority if the argument was provided, dont send null values
    if priority is not None:
        body.update({"priority": priority})
    # Only send initialPriority if the argument was provided, dont send null values
    if initialPriority is not None:
        body.update({"initialPriority": initialPriority})
    # Only send assetID if the argument was provided, dont send null values
    if assetID is not None:
        body.update({"assetID": assetID})
    # Only send tag if the argument was provided, dont send null values
    if tag is not None:
        body.update({"tag": tag})
    # Only send workflow if the argument was provided, dont send null values
    if workflow is not None:
        body.update({"workflow": workflow})
    # Only send field if the argument was provided, dont send null values
    if field is not None:
        body.update({"field": field})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, dont send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send keywordFieldStrategy if the argument was provided, dont send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, dont send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send user if the argument was provided, dont send null values
    if user is not None:
        body.update({"user": user})
    # Only send userID if the argument was provided, dont send null values
    if userID is not None:
        body.update({"userID": userID})
    # Only send userFieldStrategy if the argument was provided, dont send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send userAssigned if the argument was provided, dont send null values
    if userAssigned is not None:
        body.update({"userAssigned": userAssigned})
    # Only send techAssigned if the argument was provided, dont send null values
    if techAssigned is not None:
        body.update({"techAssigned": techAssigned})
    # Only send includeWorkflows if the argument was provided, dont send null values
    if includeWorkflows is not None:
        body.update({"includeWorkflows": includeWorkflows})
    # Only send includeDescription if the argument was provided, dont send null values
    if includeDescription is not None:
        body.update({"includeDescription": includeDescription})
    # Only send accessMode if the argument was provided, dont send null values
    if accessMode is not None:
        body.update({"accessMode": accessMode})
    # Only send explicitAccess if the argument was provided, dont send null values
    if explicitAccess is not None:
        body.update({"explicitAccess": explicitAccess})
    # Only send includeTestData if the argument was provided, dont send null values
    if includeTestData is not None:
        body.update({"includeTestData": includeTestData})
    # Only send groupBy if the argument was provided, dont send null values
    if groupBy is not None:
        body.update({"groupBy": groupBy})
    # Only send values if the argument was provided, dont send null values
    if values is not None:
        body.update({"values": values})
    # Only send resolution if the argument was provided, dont send null values
    if resolution is not None:
        body.update({"resolution": resolution})
    # Only send resolutionUnit if the argument was provided, dont send null values
    if resolutionUnit is not None:
        body.update({"resolutionUnit": resolutionUnit})
    # Only send cutoff if the argument was provided, dont send null values
    if cutoff is not None:
        body.update({"cutoff": cutoff})
    # Only send cutoffFields if the argument was provided, dont send null values
    if cutoffFields is not None:
        body.update({"cutoffFields": cutoffFields})
    # Only send cutoffValue if the argument was provided, dont send null values
    if cutoffValue is not None:
        body.update({"cutoffValue": cutoffValue})
    # Only send includeOthers if the argument was provided, dont send null values
    if includeOthers is not None:
        body.update({"includeOthers": includeOthers})
    # Only send sortByField if the argument was provided, dont send null values
    if sortByField is not None:
        body.update({"sortByField": sortByField})
    # Only send sortByValue if the argument was provided, dont send null values
    if sortByValue is not None:
        body.update({"sortByValue": sortByValue})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})

    query_parameters = {}

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def set_field(
    caseID: int,
    field: str,
    value: str = None,
    valuesToAdd: str = None,
    valuesToSet: str = None,
    valuesToRemove: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Set specific field for a case, by either field ID or field name. For multivalue fields, the field may contain multiple values. (DEV)
    
    :param int caseID: ID of the case to set fields for
    :param str field: ID or fieldName of the field to set
    :param str value: Value to set on field. Multivalue fields will reject requests using this parameter. 
    :param list valuesToAdd: Value to add to a multivalue field. Existing values will be retained. Singlevalue fields will reject requests using this parameter. 
    :param list valuesToSet: Value to set on a multivalue field. Existing values will be discarded. Singlevalue fields will reject requests using this parameter. 
    :param list valuesToRemove: Value to remove from a multivalue field. Singlevalue fields will reject requests using this parameter. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/fields/{field}".format(caseID=caseID,
        field=field)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send value if the argument was provided, dont send null values
    if value is not None:
        body.update({"value": value})
    # Only send valuesToAdd if the argument was provided, dont send null values
    if valuesToAdd is not None:
        body.update({"valuesToAdd": valuesToAdd})
    # Only send valuesToSet if the argument was provided, dont send null values
    if valuesToSet is not None:
        body.update({"valuesToSet": valuesToSet})
    # Only send valuesToRemove if the argument was provided, dont send null values
    if valuesToRemove is not None:
        body.update({"valuesToRemove": valuesToRemove})

    query_parameters = {}

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def simple_case_search(
    customerID: int = None,
    customer: str = None,
    service: str = None,
    status: str = None,
    type: str = None,
    keywords: str = None,
    sortBy: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Returns cases matching the query parameters (PUBLIC)
    
    :param list customerID: 
    :param list customer: Limit result to specified customers (by id or shortname)
    :param list service: Limit result to specified services (service shortname)
    :param list status: Limit result to specified statuses
    :param list type: Limit result to specified types
    :param list keywords: Search by keywords
    :param list sortBy: Sort order (see /cases/v2/case/search documentation for details)
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: requests.Response object or dictionary translated from JSON
    """

    route = "/cases/v2/case".format(limit=limit,
        customerID=customerID,
        customer=customer,
        service=service,
        status=status,
        type=type,
        keywords=keywords,
        sortBy=sortBy,
        offset=offset)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': None
    }
    if json:
        headers['content'] = 'application/json'

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        query_parameters.update({"customerID": customerID})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send service if the argument was provided, dont send null values
    if service is not None:
        query_parameters.update({"service": service})
    # Only send status if the argument was provided, dont send null values
    if status is not None:
        query_parameters.update({"status": status})
    # Only send type if the argument was provided, dont send null values
    if type is not None:
        query_parameters.update({"type": type})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response



def update_case(
    id: int,
    subject: str = None,
    description: str = None,
    priority: str = None,
    category: str = None,
    reporter: str = None,
    assignedUser: str = None,
    assignedTech: str = None,
    customerReference: str = None,
    comment: str = None,
    notification: dict = None,
    originEmailAddress: str = None,
    hasEvents: bool = None,
    status: str = None,
    internalComment: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Request changes to basic fields of an existing case (PUBLIC)
    
    :param int id: Case ID
    :param str subject: If set, change subject of case.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str description: If set, change description of case. May use HTML, will be sanitized. 
    :param str priority: If set, change priority of case. 
    :param str category: If set, assign given category to specified category (by category shortname). Set value to empty string to unset category. 
    :param str reporter: If set, set given user as reporter for case (by ID or shortname). Shortname will be resolved in the current users domain. 
    :param str assignedUser: If set, assign given user to case (by ID or shortname). Shortname will be resolved in the current users domain. If blank, this will unset assignedUser. 
    :param str assignedTech: If set, assign given technical user (solution engineer) to case (by ID or shortname). Shortname will be resolved in the current users domain. If blank, this will unset assignedTech. 
    :param str customerReference: If set, change customer reference for case.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str comment: If set, add comment to case. May use HTML, will be sanitized. 
    :param dict notification: 
    :param str originEmailAddress: If update is made from an email, specify origin email address here  => format:email
    :param bool hasEvents: If set, update the hasEvents flag for this case, signalling that this case may have events associated to it. 
    :param str status: If set, change status of case 
    :param bool internalComment: If true, add comment as internal. (default false)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{id}".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send subject if the argument was provided, dont send null values
    if subject is not None:
        body.update({"subject": subject})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send priority if the argument was provided, dont send null values
    if priority is not None:
        body.update({"priority": priority})
    # Only send category if the argument was provided, dont send null values
    if category is not None:
        body.update({"category": category})
    # Only send reporter if the argument was provided, dont send null values
    if reporter is not None:
        body.update({"reporter": reporter})
    # Only send assignedUser if the argument was provided, dont send null values
    if assignedUser is not None:
        body.update({"assignedUser": assignedUser})
    # Only send assignedTech if the argument was provided, dont send null values
    if assignedTech is not None:
        body.update({"assignedTech": assignedTech})
    # Only send customerReference if the argument was provided, dont send null values
    if customerReference is not None:
        body.update({"customerReference": customerReference})
    # Only send comment if the argument was provided, dont send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send internalComment if the argument was provided, dont send null values
    if internalComment is not None:
        body.update({"internalComment": internalComment})
    # Only send notification if the argument was provided, dont send null values
    if notification is not None:
        body.update({"notification": notification})
    # Only send originEmailAddress if the argument was provided, dont send null values
    if originEmailAddress is not None:
        body.update({"originEmailAddress": originEmailAddress})
    # Only send hasEvents if the argument was provided, dont send null values
    if hasEvents is not None:
        body.update({"hasEvents": hasEvents})
    # Only send status if the argument was provided, dont send null values
    if status is not None:
        body.update({"status": status})

    query_parameters = {}

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def update_case_watcher(
    caseID: int,
    watcherID: str,
    verbose: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Update settings for a specific watcher on a case (PUBLIC)
    
    :param int caseID: Case ID
    :param str watcherID: Watcher ID
    :param bool verbose: If set, will enable/disable verbose status for this watcher. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/watchers/{watcherID}".format(caseID=caseID,
        watcherID=watcherID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send verbose if the argument was provided, dont send null values
    if verbose is not None:
        body.update({"verbose": verbose})

    query_parameters = {}

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def update_watcher_settings(
    caseID: int,
    defaultWatchers: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Update general watcher settings on a case (PUBLIC)
    
    :param int caseID: Case ID
    :param bool defaultWatchers: If set, will enable/disable use of default watchers on this case. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/watchers".format(caseID=caseID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send defaultWatchers if the argument was provided, dont send null values
    if defaultWatchers is not None:
        body.update({"defaultWatchers": defaultWatchers})

    query_parameters = {}

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def update_workflow(
    caseID: int,
    workflow: str,
    requestComment: str = None,
    acknowledgedComment: str = None,
    externalReference: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Update workflow on case (PUBLIC)
    
    :param int caseID: Case ID
    :param str workflow: Workflow to update
    :param str requestComment: If set, modify request comment. Html is allowed, will be sanitized.  => format:html
    :param str acknowledgedComment: If set, modify acknowledged comment. Html is allowed, will be sanitized.  => format:html
    :param str externalReference: If set, modify external reference. Should be a link or an issue number. Empty string will delete existing reference. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/workflows/{workflow}".format(caseID=caseID,
        workflow=workflow)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send requestComment if the argument was provided, dont send null values
    if requestComment is not None:
        body.update({"requestComment": requestComment})
    # Only send acknowledgedComment if the argument was provided, dont send null values
    if acknowledgedComment is not None:
        body.update({"acknowledgedComment": acknowledgedComment})
    # Only send externalReference if the argument was provided, dont send null values
    if externalReference is not None:
        body.update({"externalReference": externalReference})

    query_parameters = {}

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def upload_attachment_fragment(
    caseID: int,
    attachmentID: str,
    idx: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Upload fragment of an attachment (DEV)
    
    :param int caseID: Case ID
    :param str attachmentID: Attachment ID
    :param int idx: Attachment Fragment Index
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments/{attachmentID}/fragment/{idx}".format(caseID=caseID,
        attachmentID=attachmentID,
        idx=idx)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def upload_streaming_attachment(
    caseID: int,
    filename: str,
    encryptedZip: bool = None,
    skipNotification: bool = None,
    originEmailAddress: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Add new attachment (PUBLIC)
    
    :param int caseID: Case ID
    :param str filename: Attachment filename
    :param bool encryptedZip: If true, mark attachment as an encrypted zipfile
    :param bool skipNotification: If true, skip notification
    :param str originEmailAddress: If set, mark attachment with this origin email address
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments/upload/{filename}".format(caseID=caseID,
        filename=filename,
        encryptedZip=encryptedZip,
        skipNotification=skipNotification,
        originEmailAddress=originEmailAddress)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send encryptedZip if the argument was provided, dont send null values
    if encryptedZip is not None:
        query_parameters.update({"encryptedZip": encryptedZip})
    # Only send skipNotification if the argument was provided, dont send null values
    if skipNotification is not None:
        query_parameters.update({"skipNotification": skipNotification})
    # Only send originEmailAddress if the argument was provided, dont send null values
    if originEmailAddress is not None:
        query_parameters.update({"originEmailAddress": originEmailAddress})

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()

