"""Autogenerated API"""
from argus_api import session



def add_asset_group(
    customer: str = None,
    shortName: str = None,
    name: str = None,
    description: str = None,
    owner: str = None,
    criticality: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Creates a new AssetGroup (DEV)
    
    :param str customer: ID or short name of customer, if not specified then current user's customer will be assigned 
    :param str shortName: Short name of asset group  => [a-zA-Z0-9_\-\.]*
    :param str name: Name of asset group  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str description: Description of asset group. May use HTML, which will be sanitized 
    :param str owner: ID or username of user who owns the asset group. When username is specified, it should exist within current user's domain 
    :param dict criticality: 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/group".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send owner if the argument was provided, dont send null values
    if owner is not None:
        body.update({"owner": owner})
    # Only send criticality if the argument was provided, dont send null values
    if criticality is not None:
        body.update({"criticality": criticality})

    query_parameters = {}

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def attach_assets(
    idOrShortName: str,
    customer: str = None,
    assets: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Attach asset to the asset group. Asset group will recalculate de-normalized fields and flags base on children groups and assets, such as totalCVSS, vulnerabilitiesCount and flags to indicate whether there is high or critical severity vulnerability. (DEV)
    
    :param str idOrShortName: AssetGroup ID or short name
    :param str customer: Customer ID or short name (default is user's customer), only used when group/asset short name was provided
    :param list assets: Specify set of assets to be attached to the asset group, it accepts asset's ID or short name. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/assets".format(idOrShortName=idOrShortName,
        customer=customer)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send assets if the argument was provided, dont send null values
    if assets is not None:
        body.update({"assets": assets})

    query_parameters = {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def attach_children_groups(
    idOrShortName: str,
    customer: str = None,
    childrenGroups: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Attach asset groups to parent asset group as children. Associating groups should not cause circular relationships. Parent group will recalculate de-normalized fields and flags base on children groups and assets, such as totalCVSS, vulnerabilitiesCount and flags to indicate whether there is high or critical severity vulnerability. (DEV)
    
    :param str idOrShortName: AssetGroup ID or short name
    :param str customer: Customer ID or short name (default is user's customer), only used when group short name was provided
    :param list childrenGroups: Specify set of asset groups to be attached as children groups, it accepts asset group ID or short name. Child group should not cause circular relationship among asset groups. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/groups".format(idOrShortName=idOrShortName,
        customer=customer)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send childrenGroups if the argument was provided, dont send null values
    if childrenGroups is not None:
        body.update({"childrenGroups": childrenGroups})

    query_parameters = {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def delete_asset_group(
    idOrShortName: str,
    customer: str = None,
    forceIndex: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Delete asset group (DEV)
    
    :param str idOrShortName: AssetGroup ID or short name
    :param str customer: Customer ID or short name (default is user's customer), only used when group short name was provided
    :param bool forceIndex: Whether to force an Elasticsearch index refresh such that the AssetGroup is immediately no longer searchable.
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}".format(idOrShortName=idOrShortName,
        customer=customer,
        forceIndex=forceIndex)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send forceIndex if the argument was provided, dont send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def detach_assets(
    idOrShortName: str,
    asset: str,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Detach multiple assets from parent asset group. Parent group will recalculate de-normalized fields and flags base on remaining children groups and assets, such as totalCVSS, vulnerabilitiesCount and flags to indicate whether there is high or critical severity vulnerability. Response with parent group after change. (DEV)
    
    :param str idOrShortName: Parent group's ID or short name
    :param list asset: Assets' IDs or short names to be detached
    :param str customer: Customer ID or short name (default is user's customer), only used when group short name was provided
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/assets".format(idOrShortName=idOrShortName,
        asset=asset,
        customer=customer)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send asset if the argument was provided, dont send null values
    if asset is not None:
        query_parameters.update({"asset": asset})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def detach_children_groups(
    idOrShortName: str,
    group: str,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Detach multiple asset groups from parent asset group. Parent group will recalculate de-normalized fields and flags base on remaining children groups and assets, such as totalCVSS, vulnerabilitiesCount and flags to indicate whether there is high or critical severity vulnerability. Response with parent group after change. (DEV)
    
    :param str idOrShortName: Parent group's ID or short name
    :param list group: Children groups' IDs or short names to be detached
    :param str customer: Customer ID or short name (default is user's customer), only used when group short name was provided
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/groups".format(idOrShortName=idOrShortName,
        group=group,
        customer=customer)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send group if the argument was provided, dont send null values
    if group is not None:
        query_parameters.update({"group": group})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def detach_single_child_asset(
    idOrShortName: str,
    assetIDOrShortName: str,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Detach single asset from parent asset group. Parent group will recalculate de-normalized fields and flags base on remaining children groups and assets, such as totalCVSS, vulnerabilitiesCount and flags to indicate whether there is high or critical severity vulnerability. Response with parent group after change. (DEV)
    
    :param str idOrShortName: Parent group's ID or short name
    :param str assetIDOrShortName: Asset's ID or short name to be detached
    :param str customer: Customer ID or short name (default is user's customer), only used when group short name was provided
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/assets/{assetIDOrShortName}".format(idOrShortName=idOrShortName,
        assetIDOrShortName=assetIDOrShortName,
        customer=customer)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def detach_single_child_group(
    idOrShortName: str,
    childGroupIDOrShortName: str,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Detach single child asset group from parent asset group. Parent group will recalculate de-normalized fields and flags base on remaining children groups and assets, such as totalCVSS, vulnerabilitiesCount and flags to indicate whether there is high or critical severity vulnerability. Response with parent group after change. (DEV)
    
    :param str idOrShortName: Parent group's ID or short name
    :param str childGroupIDOrShortName: Child group's ID or short name to be detached
    :param str customer: Customer ID or short name (default is user's customer), only used when group short name was provided
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/groups/{childGroupIDOrShortName}".format(idOrShortName=idOrShortName,
        childGroupIDOrShortName=childGroupIDOrShortName,
        customer=customer)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def get_asset_group(
    idOrShortName: str,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Get Asset Group (DEV)
    
    :param str idOrShortName: AssetGroup ID or short name
    :param str customer: Customer ID or short name (default is user's customer), only used when group short name was provided
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}".format(idOrShortName=idOrShortName,
        customer=customer)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def get_children_asset_groups(
    idOrShortName: str,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Get children asset groups associated with specified asset group (DEV)
    
    :param str idOrShortName: AssetGroup ID or short name
    :param str customer: Customer ID or short name (default is user's customer), only used when group short name was provided
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/groups".format(idOrShortName=idOrShortName,
        customer=customer)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def get_children_assets(
    idOrShortName: str,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Get assets that associated with specified asset group (DEV)
    
    :param str idOrShortName: AssetGroup ID or short name
    :param str customer: Customer ID or short name (default is user's customer), only used when group short name was provided
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/assets".format(idOrShortName=idOrShortName,
        customer=customer)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def list_asset_groups(
    customer: str = None,
    group: str = None,
    keywords: str = None,
    sortBy: str = None,
    limit: int = 25,
    startTimestamp: str = "0",
    endTimestamp: str = "0",
    offset: int = None,
    includeDeleted: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Basic Asset Group search.If keywords are present, they must all must be present in at least one of the keyword fields.Check the documentation for the KeywordFieldStrategy field for more details.If start/end timestamps are present, the range must be valid for at least one of the time stamp fields.Check the documentation for the TimestampFieldStrategy field for more details. (DEV)
    
    :param list customer: Customer ids or short names
    :param list group: Asset group ids or short names
    :param list keywords: Limit search by asset group keywords
    :param list sortBy: Field(s) to sort by - refer to the search POST endpoint to see which fields are permitted
    :param int limit: Limit results
    :param str startTimestamp: Lower bound timestamp filter value
    :param str endTimestamp: Upper bound timestamp filter value
    :param int offset: Offset results
    :param bool includeDeleted: Include deleted
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/group".format(limit=limit,
        startTimestamp=startTimestamp,
        endTimestamp=endTimestamp,
        customer=customer,
        group=group,
        keywords=keywords,
        offset=offset,
        includeDeleted=includeDeleted,
        sortBy=sortBy)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send group if the argument was provided, dont send null values
    if group is not None:
        query_parameters.update({"group": group})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def search_asset_groups(
    sortBy: str = None,
    keywords: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    userFieldStrategy: str = None,
    user: str = None,
    customer: str = None,
    group: str = None,
    asset: str = None,
    parent: str = None,
    ancestor: str = None,
    child: str = None,
    minimumTotalCvss: float = None,
    maximumTotalCvss: float = None,
    criticalitySearchRequest: dict = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    subCriteria: dict = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    limit: int = 25,
    offset: int = None,
    includeDeleted: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Search Asset Groups (DEV)
    
    :param list sortBy: 
    :param list keywords: Search for keywords against fields defined by a KeywordFieldStrategy 
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords (default all supported fields) (default any)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched (default match all keywords) (default any)
    :param list timeFieldStrategy: Defines which timestamps fields will be filtered with start/endTimestamp (default lastUpdatedTimestamp)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any) (default any)
    :param list userFieldStrategy: Defines which user fields to filter with the submitted user value(s) (default all)
    :param list user: Search for AssetGroups by associated user IDs or short names defined by the UserFieldStrategy 
    :param list customer: Search for AssetGroups with these Customer IDs or short names 
    :param list group: Search for AssetGroups with these IDs or short names 
    :param list asset: Search for AssetGroups containing Assets with these IDs or short names 
    :param list parent: Search for AssetGroups with these parent IDs or short names 
    :param str ancestor: Search for AssetGroups in the hierarchy below this ancestor AssetGroup identified by its ID or short name.<br />This will resolve all descendant Asset Groups and expand the search to return AssetsGroups below this 'ancestor' group 
    :param list child: Search for AssetGroups with these children IDs or short namesi.e. return the groups who contain at least one of these AssetGroups 
    :param float minimumTotalCvss: Search for AssetGroups with at least this CVSS score 
    :param float maximumTotalCvss: Search for AssetGroups with at most this CVSS score 
    :param list criticalitySearchRequest: Search by Asset Groups by Confidentiality, Availability, and Integrity.<br />All criteria values must match for an Asset Group to match. Use subcriteria for OR query behaviour. 
    :param list includeFlags: Explicitly search for AssetGroups that contain these flags 
    :param list excludeFlags: Explicitly filter out AssetGroups that contain these flags 
    :param list subCriteria: Set additional criteria that are applied with logical OR by default 
    :param int startTimestamp: Restrict to a time frame based on the set timeFieldStrategy (start timestamp) (default 0)
    :param int endTimestamp: Restrict to a time frame based on the set timeFieldStrategy (end timestamp) (default 0)
    :param int limit: Limit the results to the specified amount (default 25)
    :param int offset: Skip specified amount of results (default 0)
    :param bool includeDeleted: Whether to include deleted Asset groups (default false)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/group/search".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordFieldStrategy if the argument was provided, dont send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, dont send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, dont send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send userFieldStrategy if the argument was provided, dont send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send user if the argument was provided, dont send null values
    if user is not None:
        body.update({"user": user})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send group if the argument was provided, dont send null values
    if group is not None:
        body.update({"group": group})
    # Only send asset if the argument was provided, dont send null values
    if asset is not None:
        body.update({"asset": asset})
    # Only send parent if the argument was provided, dont send null values
    if parent is not None:
        body.update({"parent": parent})
    # Only send ancestor if the argument was provided, dont send null values
    if ancestor is not None:
        body.update({"ancestor": ancestor})
    # Only send child if the argument was provided, dont send null values
    if child is not None:
        body.update({"child": child})
    # Only send minimumTotalCvss if the argument was provided, dont send null values
    if minimumTotalCvss is not None:
        body.update({"minimumTotalCvss": minimumTotalCvss})
    # Only send maximumTotalCvss if the argument was provided, dont send null values
    if maximumTotalCvss is not None:
        body.update({"maximumTotalCvss": maximumTotalCvss})
    # Only send criticalitySearchRequest if the argument was provided, dont send null values
    if criticalitySearchRequest is not None:
        body.update({"criticalitySearchRequest": criticalitySearchRequest})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})

    query_parameters = {}

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def update_asset_group(
    idOrShortName: str,
    customer: str = None,
    shortName: str = None,
    name: str = None,
    description: str = None,
    owner: str = None,
    criticality: dict = None,
    forceIndex: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Updates an existing AssetGroup (DEV)
    
    :param str idOrShortName: AssetGroup ID or short name
    :param str customer: Customer ID or short name (default is user's customer), only used when group short name was provided
    :param str shortName: Update short name of asset group  => [a-zA-Z0-9_\-\.]*
    :param str name: Update name of asset group  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str description: Update description of asset group. Support HTML, which will be sanitized 
    :param str owner: Update owner of asset group, specified by user ID or username. When username is specified, it should exist within current user's domain 
    :param dict criticality: 
    :param bool forceIndex: Whether to force an Elasticsearch index refresh such that changes to the AssetGroup are immediately searchable.
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}".format(idOrShortName=idOrShortName,
        customer=customer,
        forceIndex=forceIndex)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send owner if the argument was provided, dont send null values
    if owner is not None:
        body.update({"owner": owner})
    # Only send criticality if the argument was provided, dont send null values
    if criticality is not None:
        body.update({"criticality": criticality})

    query_parameters = {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send forceIndex if the argument was provided, dont send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()

