"""Autogenerated API"""
from argus_api import session
from requests import Response



def add_user(
    customer: str = None,
    shortName: str = None,
    name: str = None,
    email: str = None,
    phoneNumber: str = None,
    role: str = None,
    language: str = None,
    daemonAccount: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Add new user (PUBLIC)
    
    :param str customer: The shortname or ID for customer to register the subject to 
    :param str shortName: The shortname of the subject  => Sanitize by regex [a-zA-Z0-9_\-\.@]+
    :param str name: The name of the subject  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str email: The user's email  => format:email
    :param str phoneNumber: The user's phone number  => format:phone
    :param str role: The user's role 
    :param str language: The user's language (default english)
    :param bool daemonAccount: If set, mark this account as a daemon account (default false)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send email if the argument was provided, dont send null values
    if email is not None:
        body.update({"email": email})
    # Only send phoneNumber if the argument was provided, dont send null values
    if phoneNumber is not None:
        body.update({"phoneNumber": phoneNumber})
    # Only send role if the argument was provided, dont send null values
    if role is not None:
        body.update({"role": role})
    # Only send language if the argument was provided, dont send null values
    if language is not None:
        body.update({"language": language})
    # Only send daemonAccount if the argument was provided, dont send null values
    if daemonAccount is not None:
        body.update({"daemonAccount": daemonAccount})

    query_parameters = {}

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def delete_user_1(
    shortNameOrID: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Deletes a user (PUBLIC)
    
    :param str shortNameOrID: Short name or ID of user
    :param str domain: Name or ID of the domain of the user
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}".format(shortNameOrID=shortNameOrID,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def delete_user_preferences(
    shortNameOrID: str,
    domain: str = None,
    key: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Deletes selected user preferences (PUBLIC)
    
    :param str shortNameOrID: Short name or ID of subject
    :param str domain: Domain ID or short name (optional, defaults to current user domain)
    :param list key: Name of preference to delete
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/preferences".format(shortNameOrID=shortNameOrID,
        domain=domain,
        key=key)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send key if the argument was provided, dont send null values
    if key is not None:
        query_parameters.update({"key": key})

    

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def get_user(
    shortNameOrID: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Get a user (PUBLIC)
    
    :param str shortNameOrID: Short name or ID of user
    :param str domain: Name or ID of the domain of the user
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}".format(shortNameOrID=shortNameOrID,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def get_user_image_1(
    shortNameOrID: str,
    domain: str = None,
    size: str = None,
    width: int = None,
    height: int = None,
    default: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> Response:
    """Returns user profile picture. (PUBLIC)
    
    :param str shortNameOrID: User ID or username
    :param str domain: Domain ID or shortname (optional, defaults to current user domain)
    :param str size: The preferred size of the image (small, medium, large, xlarge), should not be used together with parameters 'width' and 'height', will crop the original image if it is not a square (optional)
    :param int width: The preferred width of the image. Preserves aspect ratio if height is not set (optional)
    :param int height: The preferred height of the image. Preserves aspect ratio if width is not set (optional)
    :param bool default: If true, return default avatar image if user picture not set. Default is false.
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: requests.Response object
    
    """

    route = "/useradmin/v2/user/{shortNameOrID}/picture".format(shortNameOrID=shortNameOrID,
        domain=domain,
        size=size,
        width=width,
        height=height,
        default=default)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': None
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send size if the argument was provided, dont send null values
    if size is not None:
        query_parameters.update({"size": size})
    # Only send width if the argument was provided, dont send null values
    if width is not None:
        query_parameters.update({"width": width})
    # Only send height if the argument was provided, dont send null values
    if height is not None:
        query_parameters.update({"height": height})
    # Only send default if the argument was provided, dont send null values
    if default is not None:
        query_parameters.update({"default": default})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response
    



def get_user_preference(
    shortNameOrID: str,
    key: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Return the preference with the given key (PUBLIC)
    
    :param str shortNameOrID: Short name or ID of subject
    :param str key: Name of preference to return
    :param str domain: Domain ID or short name (optional, defaults to current user domain)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/preferences/{key}".format(shortNameOrID=shortNameOrID,
        key=key,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def list_permissions_for_user(
    shortNameOrID: str,
    domain: str = None,
    limit: int = 25,
    includeInherited: bool = True,
    offset: int = None,
    includeDeleted: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List permissions for a user (PUBLIC)
    
    :param str shortNameOrID: Short name or ID of user
    :param str domain: Name or ID of the domain of the user
    :param int limit: Maximum number of returned results
    :param bool includeInherited: Include inherited permission
    :param int offset: Skip a number of results
    :param bool includeDeleted: Include deleted permission
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/permissions".format(limit=limit,
        includeInherited=includeInherited,
        shortNameOrID=shortNameOrID,
        domain=domain,
        offset=offset,
        includeDeleted=includeDeleted)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send includeInherited if the argument was provided, dont send null values
    if includeInherited is not None:
        query_parameters.update({"includeInherited": includeInherited})
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def list_user_preference_as_map(
    shortNameOrID: str,
    domain: str = None,
    key: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Lists out the user's preferences. Returns all user preferences if no keys are specified (PUBLIC)
    
    :param str shortNameOrID: Short name or ID of subject
    :param str domain: Domain ID or short name (optional, defaults to current user domain)
    :param list key: List of preferences to return, default is all
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/preferencemap".format(limit=limit,
        offset=offset,
        shortNameOrID=shortNameOrID,
        domain=domain,
        key=key)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send key if the argument was provided, dont send null values
    if key is not None:
        query_parameters.update({"key": key})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def list_user_preferences(
    shortNameOrID: str,
    domain: str = None,
    key: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Lists out the user's preferences. Returns all user preferences if no keys are specified (PUBLIC)
    
    :param str shortNameOrID: Short name or ID of subject
    :param str domain: Domain ID or short name (optional, defaults to current user domain)
    :param list key: List of preferences to return, default is all
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/preferences".format(limit=limit,
        offset=offset,
        shortNameOrID=shortNameOrID,
        domain=domain,
        key=key)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send key if the argument was provided, dont send null values
    if key is not None:
        query_parameters.update({"key": key})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def list_users_1(
    domain: str = None,
    subject: str = None,
    customer: str = None,
    excludeFlag: str = None,
    includeFlag: str = None,
    keyword: str = None,
    keywordField: str = None,
    sortBy: str = None,
    limit: int = 25,
    keywordMatch: str = "all",
    offset: int = None,
    includeDeleted: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Returns the users matching the query (PUBLIC)
    
    :param list domain: Domain to search in by short name or id
    :param list subject: Subject to search for by short name or id
    :param list customer: Customer to search for by short name or id
    :param list excludeFlag: Exclude users with flag
    :param list includeFlag: Include users with flag
    :param list keyword: Search by keywords
    :param list keywordField: Set field strategy for keyword search
    :param list sortBy: Field to sort by
    :param int limit: Maximum number of returned results
    :param str keywordMatch: Set match strategy for keyword search
    :param int offset: Skip a number of results
    :param bool includeDeleted: Include deleted users
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user".format(limit=limit,
        keywordMatch=keywordMatch,
        offset=offset,
        domain=domain,
        subject=subject,
        customer=customer,
        includeDeleted=includeDeleted,
        excludeFlag=excludeFlag,
        includeFlag=includeFlag,
        keyword=keyword,
        keywordField=keywordField,
        sortBy=sortBy)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send keywordMatch if the argument was provided, dont send null values
    if keywordMatch is not None:
        query_parameters.update({"keywordMatch": keywordMatch})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send subject if the argument was provided, dont send null values
    if subject is not None:
        query_parameters.update({"subject": subject})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    # Only send excludeFlag if the argument was provided, dont send null values
    if excludeFlag is not None:
        query_parameters.update({"excludeFlag": excludeFlag})
    # Only send includeFlag if the argument was provided, dont send null values
    if includeFlag is not None:
        query_parameters.update({"includeFlag": includeFlag})
    # Only send keyword if the argument was provided, dont send null values
    if keyword is not None:
        query_parameters.update({"keyword": keyword})
    # Only send keywordField if the argument was provided, dont send null values
    if keywordField is not None:
        query_parameters.update({"keywordField": keywordField})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def move_user(
    shortNameOrID: str,
    domain: str = None,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Move a user to another customer (DEV)
    
    :param str shortNameOrID: Short name or ID of user
    :param str domain: Domain ID or short name (optional, defaults to current user domain)
    :param str customer: ID or shortname of customer to move the subject to. The customer must be in same domain as the subject. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/move".format(shortNameOrID=shortNameOrID,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def reenable_user(
    shortNameOrID: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Reenables a deleted user (PUBLIC)
    
    :param str shortNameOrID: Short name or ID of user
    :param str domain: Name or ID of the domain of the user
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/reenable".format(shortNameOrID=shortNameOrID,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def reset_password(
    shortNameOrID: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Resets a users password (PUBLIC)
    
    :param str shortNameOrID: Short name or ID of user
    :param str domain: Name or ID of the domain of the user
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/resetpassword".format(shortNameOrID=shortNameOrID,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def search_users(
    domain: str = None,
    subject: str = None,
    ancestor: str = None,
    parent: str = None,
    customer: str = None,
    sortBy: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    permissions: dict = None,
    keywords: str = None,
    keywordMatchStrategy: str = None,
    keywordFieldStrategy: str = None,
    endTimestamp: int = None,
    timeMatchStrategy: str = None,
    timeFieldStrategy: str = None,
    subCriteria: dict = None,
    userPreferences: dict = None,
    includeDeleted: bool = None,
    startTimestamp: int = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Returns the users matching the query (PUBLIC)
    
    :param list domain: Restrict the search to subjects in these domains, by domain ID or name. 
    :param list subject: Restrict search to specific subjects, by ID or shortname 
    :param list ancestor: Restrict search to subjects descending from specific groups, by ID or shortname 
    :param list parent: Restrict search to subjects which are direct member of specific groups, by ID or shortname 
    :param list customer: Restrict search to subjects bound to these customers (by ID or shortname). Customer groups will resolve to all subcustomers as well. 
    :param list sortBy: Field to sort by (default name)
    :param list includeFlags: Restrict search to subjects having all of the specified flags. 
    :param list excludeFlags: Exclude subjects with these flags from the search. 
    :param list permissions: Limit search to subjects with one of the given permissions 
    :param list keywords: Keywords to search for 
    :param str keywordMatchStrategy: Search based on all keywords (AND), or based on any keyword (OR) (default Match all keywords (AND))
    :param list keywordFieldStrategy: Which fields will be searched for the given keyword (default All supported fields)
    :param int endTimestamp: The end time of the search (default now)
    :param str timeMatchStrategy: Search based on all time-field (AND), or based on any time-field (OR) (default Match any field)
    :param list timeFieldStrategy: The fields to limit the time search to (default All fields)
    :param list subCriteria: Set additional criteria with AND, OR or AND NOT 
    :param dict userPreferences: Restricts the search to users with matching user preferences. The key should be the name of the user preference. The UserPreferenceSearchSubCriteria can provide value, or if the preference should be included or excluded 
    :param bool includeDeleted: Whether or not to include deleted subjects. (default false)
    :param int startTimestamp: The start time of the search (default 0)
    :param int limit: The max amount of items to display (default 25)
    :param int offset: The amount of items to skip (default 0)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user/search".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send subject if the argument was provided, dont send null values
    if subject is not None:
        body.update({"subject": subject})
    # Only send ancestor if the argument was provided, dont send null values
    if ancestor is not None:
        body.update({"ancestor": ancestor})
    # Only send parent if the argument was provided, dont send null values
    if parent is not None:
        body.update({"parent": parent})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send permissions if the argument was provided, dont send null values
    if permissions is not None:
        body.update({"permissions": permissions})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordMatchStrategy if the argument was provided, dont send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send keywordFieldStrategy if the argument was provided, dont send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeMatchStrategy if the argument was provided, dont send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send userPreferences if the argument was provided, dont send null values
    if userPreferences is not None:
        body.update({"userPreferences": userPreferences})
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})

    query_parameters = {}

    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def set_user_image(
    shortNameOrID: str,
    domain: str = None,
    image: str = None,
    mimeType: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Sets a users profile image (PUBLIC)
    
    :param str shortNameOrID: Short name or ID of user
    :param str domain: Name or ID of the domain of the user
    :param str image: The image to upload (in base64) 
    :param str mimeType: The MIME type of the image 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/picture".format(shortNameOrID=shortNameOrID,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send image if the argument was provided, dont send null values
    if image is not None:
        body.update({"image": image})
    # Only send mimeType if the argument was provided, dont send null values
    if mimeType is not None:
        body.update({"mimeType": mimeType})

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def set_user_preference(
    shortNameOrID: str,
    key: str,
    value: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Update the user's preferences (PUBLIC)
    
    :param str shortNameOrID: Short name or ID of subject
    :param str key: Name of preference to set
    :param str value: Value of the preference to set
    :param str domain: Domain ID or short name (optional, defaults to current user domain)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/preferences/{key}/{value}".format(shortNameOrID=shortNameOrID,
        domain=domain,
        key=key,
        value=value)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def set_user_preferences(
    shortNameOrID: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Update the user's preferences (PUBLIC)
    
    :param str shortNameOrID: Short name or ID of subject
    :param str domain: Domain ID or short name (optional, defaults to current user domain)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/preferences".format(shortNameOrID=shortNameOrID,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def unblock_user(
    shortNameOrID: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Unblocks a user (PUBLIC)
    
    :param str shortNameOrID: Short name or ID of user
    :param str domain: Name or ID of the domain of the user
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/unblock".format(shortNameOrID=shortNameOrID,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()



def update_user(
    shortNameOrID: str,
    domain: str = None,
    shortName: str = None,
    name: str = None,
    email: str = None,
    phoneNumber: str = None,
    role: str = None,
    language: str = None,
    daemonAccount: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Update a user (PUBLIC)
    
    :param str shortNameOrID: Short name or ID of user
    :param str domain: Name or ID of the domain of the user
    :param str shortName: The shortname of the subject  => Sanitize by regex [a-zA-Z0-9_\-\.@]+
    :param str name: The name of the subject  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str email: If set, update the user's email. Blank string will delete the current value.  => format:email
    :param str phoneNumber: If set, update the user's phone number. Blank string will delete the current value.  => format:phone
    :param str role: If set, update the user's role. Blank string will delete the current value. 
    :param str language: If set, change the user's language 
    :param bool daemonAccount: If set, change the daemon flag for this user 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}".format(shortNameOrID=shortNameOrID,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send email if the argument was provided, dont send null values
    if email is not None:
        body.update({"email": email})
    # Only send phoneNumber if the argument was provided, dont send null values
    if phoneNumber is not None:
        body.update({"phoneNumber": phoneNumber})
    # Only send role if the argument was provided, dont send null values
    if role is not None:
        body.update({"role": role})
    # Only send language if the argument was provided, dont send null values
    if language is not None:
        body.update({"language": language})
    # Only send daemonAccount if the argument was provided, dont send null values
    if daemonAccount is not None:
        body.update({"daemonAccount": daemonAccount})

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()

