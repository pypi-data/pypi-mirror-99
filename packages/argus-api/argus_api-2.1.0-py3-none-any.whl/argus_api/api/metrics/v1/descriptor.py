"""Autogenerated API"""
from argus_api import session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(
    extending=("metrics", "v1", "descriptor"),
    module=argus_cli_module
)
def add_metric_descriptor(
    domain: str = None,
    customer: str = None,
    shortName: str = None,
    description: str = None,
    readFunction: str = None,
    writeFunction: str = None,
    adminFunction: str = None,
    keys: dict = None,
    values: dict = None,
    timeFrameSize: int = None,
    timeFrameSizeUnit: str = None,
    deduplicationFunction: str = None,
    useSeparateIndex: bool = None,
    keepBackup: bool = True,
    keepAuditData: bool = True,
    globalDescriptor: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Add new metric descriptor. (DEV)
    
    :param str domain: ID or shortname of domain bound to this metric descriptor. (default Current user domain)
    :param str customer: ID or shortname of customer bound to this metric descriptor. If not specified, descriptor is domain global 
    :param str shortName: Short name of the metric descriptor. Must be unique per domain.  => [a-zA-Z0-9_\-\.]*
    :param str description: Description of the metric descriptor.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str readFunction: Function required to fetch metric descriptor and associated records. 
    :param str writeFunction: Function required to submit metric record. 
    :param str adminFunction: Function required to update this metric descriptor. 
    :param list keys: Descriptors for metric keys. 
    :param list values: Descriptors for metric values. 
    :param int timeFrameSize: Time period used for setting up time frames. For each time frame, deduplicationFunction property is used to determine value(s) of metric record. 
    :param str timeFrameSizeUnit: Unit of the timeFrameSize value, this is used as the default resolution unit during aggregation. (default milliseconds)
    :param str deduplicationFunction: Function used while submitting a metric record, to calculate value if duplicates within same time frame appear. (default none)
    :param bool useSeparateIndex: Whether the separate index for metric records is used or not. (default false)
    :param bool keepBackup: Whether to keep a separate record of the metric as a backup outside ElasticSearch. (default true)
    :param bool keepAuditData: Whether to maintain a record of data useful for auditing. (default true)
    :param bool globalDescriptor: Whether this descriptor is intended for records that are not customer specific. (default false)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/metrics/v1/descriptor".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send readFunction if the argument was provided, dont send null values
    if readFunction is not None:
        body.update({"readFunction": readFunction})
    # Only send writeFunction if the argument was provided, dont send null values
    if writeFunction is not None:
        body.update({"writeFunction": writeFunction})
    # Only send adminFunction if the argument was provided, dont send null values
    if adminFunction is not None:
        body.update({"adminFunction": adminFunction})
    # Only send keys if the argument was provided, dont send null values
    if keys is not None:
        body.update({"keys": keys})
    # Only send values if the argument was provided, dont send null values
    if values is not None:
        body.update({"values": values})
    # Only send timeFrameSize if the argument was provided, dont send null values
    if timeFrameSize is not None:
        body.update({"timeFrameSize": timeFrameSize})
    # Only send timeFrameSizeUnit if the argument was provided, dont send null values
    if timeFrameSizeUnit is not None:
        body.update({"timeFrameSizeUnit": timeFrameSizeUnit})
    # Only send deduplicationFunction if the argument was provided, dont send null values
    if deduplicationFunction is not None:
        body.update({"deduplicationFunction": deduplicationFunction})
    # Only send useSeparateIndex if the argument was provided, dont send null values
    if useSeparateIndex is not None:
        body.update({"useSeparateIndex": useSeparateIndex})
    # Only send keepBackup if the argument was provided, dont send null values
    if keepBackup is not None:
        body.update({"keepBackup": keepBackup})
    # Only send keepAuditData if the argument was provided, dont send null values
    if keepAuditData is not None:
        body.update({"keepAuditData": keepAuditData})
    # Only send globalDescriptor if the argument was provided, dont send null values
    if globalDescriptor is not None:
        body.update({"globalDescriptor": globalDescriptor})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("metrics", "v1", "descriptor"),
    module=argus_cli_module
)
def delete_metric_descriptor(
    descriptor: str,
    descriptorDomain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Delete metric descriptor (DEV)
    
    :param str descriptor: Shortname or ID of descriptor
    :param str descriptorDomain: Domain which is used if short name is specified for 'descriptor' parameter. Defaults to current user domain.
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/metrics/v1/descriptor/{descriptor}".format(descriptor=descriptor,
        descriptorDomain=descriptorDomain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send descriptorDomain if the argument was provided, dont send null values
    if descriptorDomain is not None:
        query_parameters.update({"descriptorDomain": descriptorDomain})

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("metrics", "v1", "descriptor"),
    module=argus_cli_module
)
def get_metric_descriptor(
    descriptor: str,
    descriptorDomain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch metric descriptor. (DEV)
    
    :param str descriptor: ID or short name of metric descriptor
    :param str descriptorDomain: Domain which is used if short name is specified for 'descriptor' parameter. Defaults to current user domain.
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/metrics/v1/descriptor/{descriptor}".format(descriptor=descriptor,
        descriptorDomain=descriptorDomain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send descriptorDomain if the argument was provided, dont send null values
    if descriptorDomain is not None:
        query_parameters.update({"descriptorDomain": descriptorDomain})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("metrics", "v1", "descriptor"),
    module=argus_cli_module
)
def get_metric_descriptors(
    descriptorDomain: str = None,
    customer: str = None,
    keywords: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch metric descriptor based on criteria (DEV)
    
    :param list descriptorDomain: Restrict search to entries bound to specified domains (domain ID or shortname)
    :param list customer: Restrict search to entries bound to specified customers (customer ID or shortname)
    :param list keywords: Search by keywords
    :param int limit: Maximum number of returned results
    :param int offset: 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/metrics/v1/descriptor".format(limit=limit,
        descriptorDomain=descriptorDomain,
        customer=customer,
        keywords=keywords,
        offset=offset)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send descriptorDomain if the argument was provided, dont send null values
    if descriptorDomain is not None:
        query_parameters.update({"descriptorDomain": descriptorDomain})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("metrics", "v1", "descriptor"),
    module=argus_cli_module
)
def search_metric_descriptors(
    domain: str = None,
    customer: str = None,
    keywords: str = None,
    keywordMatchStrategy: str = None,
    keywordFieldStrategy: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    subCriteria: dict = None,
    offset: int = None,
    includeDeleted: bool = None,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch metric descriptor based on criteria (DEV)
    
    :param list domain: Restrict search to entries bound to specified domains (domain ID or shortname). 
    :param list customer: Restrict search to entries bound to specified customers (customer ID or shortname). 
    :param list keywords: Restrict search to entries containing keywords in description. 
    :param str keywordMatchStrategy: Defines the MatchStrategy for keywords. (default Match all keywords)
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords (default All supported fields)
    :param list includeFlags: Include descriptors which have includeFlags set. 
    :param list excludeFlags: Exclude descriptors which have excludeFlags set. 
    :param list subCriteria: Set additional criterias to be applied as specified in the subcriteria object(s) (AND, AND NOT, OR). (default OR)
    :param int offset: Set this value to skip the first (offset) objects. By default, return result from first object. 
    :param bool includeDeleted: Include descriptors which have been deleted. (default false)
    :param int limit: Set this value to set max number of results. (default 25)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/metrics/v1/descriptor/search".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordMatchStrategy if the argument was provided, dont send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send keywordFieldStrategy if the argument was provided, dont send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("metrics", "v1", "descriptor"),
    module=argus_cli_module
)
def update_metric_descriptor(
    descriptor: str,
    descriptorDomain: str = None,
    shortName: str = None,
    description: str = None,
    readFunction: str = None,
    writeFunction: str = None,
    adminFunction: str = None,
    addKeys: dict = None,
    updateKeys: dict = None,
    removeKeys: str = None,
    addValues: dict = None,
    removeValues: str = None,
    timeFrameSize: int = None,
    timeFrameSizeUnit: str = None,
    deduplicationFunction: str = None,
    useSeparateIndex: bool = None,
    keepBackup: bool = None,
    keepAuditData: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Update existing metric descriptor. (DEV)
    
    :param str descriptor: Shortname or ID of descriptor
    :param str descriptorDomain: Domain which is used if short name is specified for 'descriptor' parameter. Defaults to current user domain.
    :param str shortName: Short name of the metric descriptor. Must be unique per domain.  => [a-zA-Z0-9_\-\.]*
    :param str description: Description of the metric descriptor.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str readFunction: Function required to fetch metric descriptor and associated records. 
    :param str writeFunction: Function required to submit metric record. 
    :param str adminFunction: Function required to update this metric descriptor. 
    :param list addKeys: Descriptors for metric keys to add. Previously accepted metrics will still exist and considered valid, but new submissions must match the changed descriptor. 
    :param list updateKeys: Descriptors for metric keys to update. Only the translator and language can be updated while name and type are used to identify the key to modify. 
    :param list removeKeys: Descriptors for metric keys to remove. Previously accepted metrics will still exist and considered valid, but new submissions must match the changed descriptor. 
    :param list addValues: Descriptors for metric values to add. Previously accepted metrics will still exist and considered valid, but new submissions must match the changed descriptor. 
    :param list removeValues: Descriptors for metric values to remove. Previously accepted metrics will still exist and considered valid, but new submissions must match the changed descriptor. 
    :param int timeFrameSize: Time period used for setting up time frames. For each time frame, deduplicationFunction property is used to determine value(s) of metric record. 
    :param str timeFrameSizeUnit: Unit of the timeFrameSize value, this is used as the default resolution unit during aggregation. (default milliseconds)
    :param str deduplicationFunction: Function used while submitting a metric record, to calculate value if duplicates within same time frame appear. 
    :param bool useSeparateIndex: Whether the separate index for metric records is used or not. If value of this property is 'true', changing is not permitted. 
    :param bool keepBackup: Whether to keep a separate record of the metric as a backup outside ElasticSearch. 
    :param bool keepAuditData: Whether to maintain a record of data useful for auditing. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/metrics/v1/descriptor/{descriptor}".format(descriptor=descriptor,
        descriptorDomain=descriptorDomain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send readFunction if the argument was provided, dont send null values
    if readFunction is not None:
        body.update({"readFunction": readFunction})
    # Only send writeFunction if the argument was provided, dont send null values
    if writeFunction is not None:
        body.update({"writeFunction": writeFunction})
    # Only send adminFunction if the argument was provided, dont send null values
    if adminFunction is not None:
        body.update({"adminFunction": adminFunction})
    # Only send addKeys if the argument was provided, dont send null values
    if addKeys is not None:
        body.update({"addKeys": addKeys})
    # Only send updateKeys if the argument was provided, dont send null values
    if updateKeys is not None:
        body.update({"updateKeys": updateKeys})
    # Only send removeKeys if the argument was provided, dont send null values
    if removeKeys is not None:
        body.update({"removeKeys": removeKeys})
    # Only send addValues if the argument was provided, dont send null values
    if addValues is not None:
        body.update({"addValues": addValues})
    # Only send removeValues if the argument was provided, dont send null values
    if removeValues is not None:
        body.update({"removeValues": removeValues})
    # Only send timeFrameSize if the argument was provided, dont send null values
    if timeFrameSize is not None:
        body.update({"timeFrameSize": timeFrameSize})
    # Only send timeFrameSizeUnit if the argument was provided, dont send null values
    if timeFrameSizeUnit is not None:
        body.update({"timeFrameSizeUnit": timeFrameSizeUnit})
    # Only send deduplicationFunction if the argument was provided, dont send null values
    if deduplicationFunction is not None:
        body.update({"deduplicationFunction": deduplicationFunction})
    # Only send useSeparateIndex if the argument was provided, dont send null values
    if useSeparateIndex is not None:
        body.update({"useSeparateIndex": useSeparateIndex})
    # Only send keepBackup if the argument was provided, dont send null values
    if keepBackup is not None:
        body.update({"keepBackup": keepBackup})
    # Only send keepAuditData if the argument was provided, dont send null values
    if keepAuditData is not None:
        body.update({"keepAuditData": keepAuditData})

    query_parameters = {}
    # Only send descriptorDomain if the argument was provided, dont send null values
    if descriptorDomain is not None:
        query_parameters.update({"descriptorDomain": descriptorDomain})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()

