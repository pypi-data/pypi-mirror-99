"""Autogenerated API"""
from argus_api import session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(
    extending=("cases", "v2", "service"),
    module=argus_cli_module
)
def bind_category(
    serviceID: str,
    category: str = None,
    caseTypes: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Bind category to service (DEV)
    
    :param str serviceID: ID or shortname of service to bind category to
    :param str category: Shortname or ID of category to bind 
    :param list caseTypes: Case types to bind category for 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/service/{serviceID}/categories".format(serviceID=serviceID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send category if the argument was provided, dont send null values
    if category is not None:
        body.update({"category": category})
    # Only send caseTypes if the argument was provided, dont send null values
    if caseTypes is not None:
        body.update({"caseTypes": caseTypes})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "service"),
    module=argus_cli_module
)
def create_service(
    domain: str = None,
    shortName: str = None,
    name: str = None,
    localizedNames: dict = None,
    description: str = None,
    iconURL: str = None,
    notificationEmail: str = None,
    notifyOnCreate: bool = None,
    notifyOnUpdate: bool = None,
    notifyOnClose: bool = None,
    notifyFullFormat: bool = None,
    handledBySoc: bool = None,
    monitoredBySocOutsideOfficeHours: bool = None,
    eventEnabled: bool = None,
    assignDefaultTech: bool = None,
    assignDefaultUser: bool = None,
    workflows: dict = None,
    caseTypes: str = None,
    readFunction: str = None,
    writeFunction: str = None,
    techFunction: str = None,
    adminFunction: str = None,
    defineFunction: str = None,
    fieldPolicy: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Define a new service (INTERNAL)
    
    :param str domain: Name or ID of domain to bind service to. 
    :param str shortName: Shortname of service. This must be unique within a domain.  => [a-zA-Z0-9_\-\.]*
    :param str name: Descriptive name of service.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param dict localizedNames: Localized names. If not set, locales will fallback to main name.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str description: Longer description of service.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str iconURL: An image data-URL on the form data:image/png;base64,BASE64IMAGEDATA  => Sanitize by regex data:image/.+
    :param str notificationEmail: The service notification email address.  => format:email
    :param bool notifyOnCreate: If true, notify the service notification email address on created cases. Default is false. 
    :param bool notifyOnUpdate: If true, notify the service notification email address on updated cases. Default is false. 
    :param bool notifyOnClose: If true, notify the service notification email address on closed cases. Default is false. 
    :param bool notifyFullFormat: If true, use the full format when notifying to the service notification email. Default is false. 
    :param bool handledBySoc: If true, this service is handled by SOC 24/7. Default is false. 
    :param bool monitoredBySocOutsideOfficeHours: If true, this service is monitored by SOC outside office hours. Default is false. 
    :param bool eventEnabled: If true, this service is integrated with events. 
    :param bool assignDefaultTech: If true, cases created for this service will be automatically assign tech to the executing user (if tech). 
    :param bool assignDefaultUser: If true, cases created for this service will be automatically assign user to the executing user (if not tech). 
    :param dict workflows: If set, define workflows to enable for this service. 
    :param list caseTypes: The case types to enable for this service. 
    :param str readFunction: The name or ID of the function to set as READ function for this service. 
    :param str writeFunction: The name or ID of the function to set as WRITE function for this service. 
    :param str techFunction: The name or ID of the function to set as TECH function for this service. 
    :param str adminFunction: The name or ID of the function to set as ADMIN function for this service. 
    :param str defineFunction: The name or ID of the function to set as DEFINE function for this service. 
    :param str fieldPolicy: The ID of a field policy to set for this service. Default is no policy. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/service".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send localizedNames if the argument was provided, dont send null values
    if localizedNames is not None:
        body.update({"localizedNames": localizedNames})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send iconURL if the argument was provided, dont send null values
    if iconURL is not None:
        body.update({"iconURL": iconURL})
    # Only send notificationEmail if the argument was provided, dont send null values
    if notificationEmail is not None:
        body.update({"notificationEmail": notificationEmail})
    # Only send notifyOnCreate if the argument was provided, dont send null values
    if notifyOnCreate is not None:
        body.update({"notifyOnCreate": notifyOnCreate})
    # Only send notifyOnUpdate if the argument was provided, dont send null values
    if notifyOnUpdate is not None:
        body.update({"notifyOnUpdate": notifyOnUpdate})
    # Only send notifyOnClose if the argument was provided, dont send null values
    if notifyOnClose is not None:
        body.update({"notifyOnClose": notifyOnClose})
    # Only send notifyFullFormat if the argument was provided, dont send null values
    if notifyFullFormat is not None:
        body.update({"notifyFullFormat": notifyFullFormat})
    # Only send handledBySoc if the argument was provided, dont send null values
    if handledBySoc is not None:
        body.update({"handledBySoc": handledBySoc})
    # Only send monitoredBySocOutsideOfficeHours if the argument was provided, dont send null values
    if monitoredBySocOutsideOfficeHours is not None:
        body.update({"monitoredBySocOutsideOfficeHours": monitoredBySocOutsideOfficeHours})
    # Only send eventEnabled if the argument was provided, dont send null values
    if eventEnabled is not None:
        body.update({"eventEnabled": eventEnabled})
    # Only send assignDefaultTech if the argument was provided, dont send null values
    if assignDefaultTech is not None:
        body.update({"assignDefaultTech": assignDefaultTech})
    # Only send assignDefaultUser if the argument was provided, dont send null values
    if assignDefaultUser is not None:
        body.update({"assignDefaultUser": assignDefaultUser})
    # Only send workflows if the argument was provided, dont send null values
    if workflows is not None:
        body.update({"workflows": workflows})
    # Only send caseTypes if the argument was provided, dont send null values
    if caseTypes is not None:
        body.update({"caseTypes": caseTypes})
    # Only send readFunction if the argument was provided, dont send null values
    if readFunction is not None:
        body.update({"readFunction": readFunction})
    # Only send writeFunction if the argument was provided, dont send null values
    if writeFunction is not None:
        body.update({"writeFunction": writeFunction})
    # Only send techFunction if the argument was provided, dont send null values
    if techFunction is not None:
        body.update({"techFunction": techFunction})
    # Only send adminFunction if the argument was provided, dont send null values
    if adminFunction is not None:
        body.update({"adminFunction": adminFunction})
    # Only send defineFunction if the argument was provided, dont send null values
    if defineFunction is not None:
        body.update({"defineFunction": defineFunction})
    # Only send fieldPolicy if the argument was provided, dont send null values
    if fieldPolicy is not None:
        body.update({"fieldPolicy": fieldPolicy})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "service"),
    module=argus_cli_module
)
def delete_service(
    id: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Delete service (INTERNAL)
    
    :param str id: ID or shortname of service to delete
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/service/{id}".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "service"),
    module=argus_cli_module
)
def get_field_policy_by_service(
    service: str,
    customer: str = None,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch policy descriptor by service and customer (DEV)
    
    :param str service: ID or shortname of service to fetch policy for
    :param str customer: ID or shortname of customer to fetch policy for
    :param str domain: Domain to lookup service and customer in (when using shortnames). Defaults to the current users domain.
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/service/{service}/fieldpolicy".format(service=service,
        customer=customer,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "service"),
    module=argus_cli_module
)
def get_service(
    id: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch service (INTERNAL)
    
    :param str id: ID or shortname of service
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/service/{id}".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "service"),
    module=argus_cli_module
)
def list_categories_1(
    id: str,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List categories bound to service (DEV)
    
    :param str id: ID or shortname of service
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/service/{id}/categories".format(limit=limit,
        id=id,
        offset=offset)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "service"),
    module=argus_cli_module
)
def list_services(
    id: int = None,
    shortName: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List services (INTERNAL)
    
    :param list id: List of IDs to match
    :param list shortName: List of shortnames to match
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/service".format(limit=limit,
        id=id,
        shortName=shortName,
        offset=offset)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send id if the argument was provided, dont send null values
    if id is not None:
        query_parameters.update({"id": id})
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        query_parameters.update({"shortName": shortName})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "service"),
    module=argus_cli_module
)
def search_services(
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    subCriteria: dict = None,
    exclude: bool = None,
    required: bool = None,
    id: int = None,
    shortName: str = None,
    fieldPolicy: str = None,
    sortBy: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Search services (INTERNAL)
    
    :param int limit: Set this value to set max number of results. By default, no restriction on result set size. 
    :param int offset: Set this value to skip the first (offset) objects. By default, return result from first object. 
    :param bool includeDeleted: Set to true to include deleted objects. By default, exclude deleted objects. 
    :param list subCriteria: Set additional criterias which are applied using a logical OR. 
    :param bool exclude: Only relevant for subcriteria. If set to true, objects matching this subcriteria object will be excluded. 
    :param bool required: Only relevant for subcriteria. If set to true, objects matching this subcriteria are required (AND-ed together with parent criteria). 
    :param list id: Limit search to services with the specified numeric ID`s. 
    :param list shortName: Limit search to services with the specified shortnames 
    :param list fieldPolicy: Limit search to services bound to specified field policies (by UUID or name) 
    :param list sortBy: List of properties to sort by (prefix with "-" to sort descending). 
    :param list includeFlags: Only include objects which have includeFlags set. 
    :param list excludeFlags: Exclude objects which have excludeFlags set. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/service/search".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send exclude if the argument was provided, dont send null values
    if exclude is not None:
        body.update({"exclude": exclude})
    # Only send required if the argument was provided, dont send null values
    if required is not None:
        body.update({"required": required})
    # Only send id if the argument was provided, dont send null values
    if id is not None:
        body.update({"id": id})
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send fieldPolicy if the argument was provided, dont send null values
    if fieldPolicy is not None:
        body.update({"fieldPolicy": fieldPolicy})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "service"),
    module=argus_cli_module
)
def unbind_category(
    serviceID: str,
    categoryID: str,
    caseType: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Unbind category from service. If caseType is specified, only unbind specific casetype. Default is to unbind all casetypes, disallowing the category for use on this service. (DEV)
    
    :param str serviceID: ID or shortname of service to unbind category from
    :param str categoryID: ID or shortname of category to unbind
    :param list caseType: Casetypes to unbind (default is all)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/service/{serviceID}/categories/{categoryID}".format(serviceID=serviceID,
        categoryID=categoryID,
        caseType=caseType)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send caseType if the argument was provided, dont send null values
    if caseType is not None:
        query_parameters.update({"caseType": caseType})

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "service"),
    module=argus_cli_module
)
def update_service(
    id: str,
    shortName: str = None,
    name: str = None,
    localizedNames: dict = None,
    description: str = None,
    iconURL: str = None,
    notificationEmail: str = None,
    caseTypesToAdd: str = None,
    caseTypesToRemove: str = None,
    caseTypesToSet: str = None,
    readFunction: str = None,
    writeFunction: str = None,
    techFunction: str = None,
    adminFunction: str = None,
    defineFunction: str = None,
    fieldPolicy: str = None,
    notifyOnCreate: bool = None,
    notifyOnUpdate: bool = None,
    notifyOnClose: bool = None,
    notifyFullFormat: bool = None,
    handledBySoc: bool = None,
    monitoredBySocOutsideOfficeHours: bool = None,
    eventEnabled: bool = None,
    assignDefaultTech: bool = None,
    assignDefaultUser: bool = None,
    workflows: dict = None,
    deprecated: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Update an existing service (INTERNAL)
    
    :param str id: Service id or shortname
    :param str shortName: If set, change the shortname of this service. This must be unique within a domain. WARNING: This may affect scripts using shortname as service identifier.  => [a-zA-Z0-9_\-\.]*
    :param str name: If set, change the descriptive name of the service.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param dict localizedNames: Set localized names to override name for specified language. Only specified languages are changed.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str description: If set, change the longer description of the service.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str iconURL: If set, replace the icon for the service. An image data-URL on the form data:image/png;base64,BASE64IMAGEDATA  => Sanitize by regex data:image/.+
    :param str notificationEmail: If set, change the service notification email address.  => format:email
    :param list caseTypesToAdd: If set, enable the requested case type for this service. 
    :param list caseTypesToRemove: If set, disable the requested case type for this service. This will be rejected if any non-deleted cases exist which are bound to this service and casetype. 
    :param list caseTypesToSet: If set, override existing case types for this service. If this causes the service to remove a case type which has non-deleted cases bound to it, this will be rejected. 
    :param str readFunction: If set, change the READ function for this service, identified by function ID or shortname. 
    :param str writeFunction: If set, change the WRITE function for this service, identified by function ID or shortname. 
    :param str techFunction: If set, change the TECH function for this service, identified by function ID or shortname. 
    :param str adminFunction: If set, change the ADMIN function for this service, identified by function ID or shortname. 
    :param str defineFunction: If set, change the DEFINE function for this service, identified by function ID or shortname. 
    :param str fieldPolicy: If set, change the field policy for this service. Changing the field policy will affect new cases and future updates to existing cases, but will not change fields set on existing cases. 
    :param bool notifyOnCreate: If set, change settings for notifying the service notification email address on created cases. 
    :param bool notifyOnUpdate: If set, change settings for notifying the service notification email address on updated cases. 
    :param bool notifyOnClose: If set, change settings for notifying the service notification email address on closed cases. 
    :param bool notifyFullFormat: If set, change the format settings for notifying to the service notification email. 
    :param bool handledBySoc: If set, set whether this service is handled by SOC 24/7. 
    :param bool monitoredBySocOutsideOfficeHours: If set, set whether this service is monitored by SOC outside office hours. 
    :param bool eventEnabled: If set, set whether service is integrated with events. 
    :param bool assignDefaultTech: If set, change whether cases created for this service will be automatically assign tech to the executing user (if tech). 
    :param bool assignDefaultUser: If set, change whether cases created for this service will be automatically assign user to the executing user (if not tech). 
    :param dict workflows: If set, modify workflows enabled for this service. 
    :param bool deprecated: If set, enable/disable the deprecated flag for this service. Default is no change. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/service/{id}".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send localizedNames if the argument was provided, dont send null values
    if localizedNames is not None:
        body.update({"localizedNames": localizedNames})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send iconURL if the argument was provided, dont send null values
    if iconURL is not None:
        body.update({"iconURL": iconURL})
    # Only send notificationEmail if the argument was provided, dont send null values
    if notificationEmail is not None:
        body.update({"notificationEmail": notificationEmail})
    # Only send caseTypesToAdd if the argument was provided, dont send null values
    if caseTypesToAdd is not None:
        body.update({"caseTypesToAdd": caseTypesToAdd})
    # Only send caseTypesToRemove if the argument was provided, dont send null values
    if caseTypesToRemove is not None:
        body.update({"caseTypesToRemove": caseTypesToRemove})
    # Only send caseTypesToSet if the argument was provided, dont send null values
    if caseTypesToSet is not None:
        body.update({"caseTypesToSet": caseTypesToSet})
    # Only send readFunction if the argument was provided, dont send null values
    if readFunction is not None:
        body.update({"readFunction": readFunction})
    # Only send writeFunction if the argument was provided, dont send null values
    if writeFunction is not None:
        body.update({"writeFunction": writeFunction})
    # Only send techFunction if the argument was provided, dont send null values
    if techFunction is not None:
        body.update({"techFunction": techFunction})
    # Only send adminFunction if the argument was provided, dont send null values
    if adminFunction is not None:
        body.update({"adminFunction": adminFunction})
    # Only send defineFunction if the argument was provided, dont send null values
    if defineFunction is not None:
        body.update({"defineFunction": defineFunction})
    # Only send fieldPolicy if the argument was provided, dont send null values
    if fieldPolicy is not None:
        body.update({"fieldPolicy": fieldPolicy})
    # Only send notifyOnCreate if the argument was provided, dont send null values
    if notifyOnCreate is not None:
        body.update({"notifyOnCreate": notifyOnCreate})
    # Only send notifyOnUpdate if the argument was provided, dont send null values
    if notifyOnUpdate is not None:
        body.update({"notifyOnUpdate": notifyOnUpdate})
    # Only send notifyOnClose if the argument was provided, dont send null values
    if notifyOnClose is not None:
        body.update({"notifyOnClose": notifyOnClose})
    # Only send notifyFullFormat if the argument was provided, dont send null values
    if notifyFullFormat is not None:
        body.update({"notifyFullFormat": notifyFullFormat})
    # Only send handledBySoc if the argument was provided, dont send null values
    if handledBySoc is not None:
        body.update({"handledBySoc": handledBySoc})
    # Only send monitoredBySocOutsideOfficeHours if the argument was provided, dont send null values
    if monitoredBySocOutsideOfficeHours is not None:
        body.update({"monitoredBySocOutsideOfficeHours": monitoredBySocOutsideOfficeHours})
    # Only send eventEnabled if the argument was provided, dont send null values
    if eventEnabled is not None:
        body.update({"eventEnabled": eventEnabled})
    # Only send assignDefaultTech if the argument was provided, dont send null values
    if assignDefaultTech is not None:
        body.update({"assignDefaultTech": assignDefaultTech})
    # Only send assignDefaultUser if the argument was provided, dont send null values
    if assignDefaultUser is not None:
        body.update({"assignDefaultUser": assignDefaultUser})
    # Only send workflows if the argument was provided, dont send null values
    if workflows is not None:
        body.update({"workflows": workflows})
    # Only send deprecated if the argument was provided, dont send null values
    if deprecated is not None:
        body.update({"deprecated": deprecated})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()

