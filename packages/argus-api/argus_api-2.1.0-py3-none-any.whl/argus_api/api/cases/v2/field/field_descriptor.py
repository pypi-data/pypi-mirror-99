"""Autogenerated API"""
from argus_api import session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(
    extending=("cases", "v2", "field", "descriptor"),
    module=argus_cli_module
)
def add_field_policy(
    name: str = None,
    domain: str = None,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Define new field policy. (DEV)
    
    :param str name: Name of policy to add.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str domain: Name or ID of domain to create this policy in. 
    :param str customer: Name or ID of customer to create this policy for (optional). 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/field/policy".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "field", "descriptor"),
    module=argus_cli_module
)
def add_field_to_policy(
    policy: str,
    domain: str = None,
    field: str = None,
    displayName: str = None,
    fieldPolicy: str = None,
    readRole: str = None,
    writeRole: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Bind a field to a policy (DEV)
    
    :param str policy: ID or name of policy to bind field to
    :param str domain: Domain to look for policy in (when using policy name for ID). Defaults to the current users domain.
    :param str field: ID or field name of field to add to policy. 
    :param str displayName: Display name for field. Default is field name.  => [a-zA-Z0-9_\-\.]*
    :param str fieldPolicy: FieldPolicy for this field. If the field is requiredOnCreate, a case cannot be created without this field, unless a defaultValue is set in the field fieldPolicy.If the field is requiredOnClose, the case cannot be closed before this field has been set. Default fieldPolicy is optional. 
    :param str readRole: Required service role to read this field. Default is 'user', meaning that any user with read access to the case, can also read this field. 
    :param str writeRole: Required service role to set/update this field. Default is 'user', meaning that any user with write access to the case, can also write to this field. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/field/policy/{policy}/fields".format(policy=policy,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send field if the argument was provided, dont send null values
    if field is not None:
        body.update({"field": field})
    # Only send displayName if the argument was provided, dont send null values
    if displayName is not None:
        body.update({"displayName": displayName})
    # Only send fieldPolicy if the argument was provided, dont send null values
    if fieldPolicy is not None:
        body.update({"fieldPolicy": fieldPolicy})
    # Only send readRole if the argument was provided, dont send null values
    if readRole is not None:
        body.update({"readRole": readRole})
    # Only send writeRole if the argument was provided, dont send null values
    if writeRole is not None:
        body.update({"writeRole": writeRole})

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "field", "descriptor"),
    module=argus_cli_module
)
def create_field_descriptor(
    name: str = None,
    domain: str = None,
    customer: str = None,
    valueType: str = None,
    multiValue: bool = None,
    defaultValue: str = None,
    validator: dict = None,
    valueSource: dict = None,
    rendererOptions: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Define new field descriptor. (DEV)
    
    :param str name: Name of field to add.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str domain: Name or ID of domain to create this field in. 
    :param str customer: Name or ID of customer to create this field for (optional). 
    :param str valueType: Value type for the field.The field will only accept values that can be safely converted to this value type. If the field uses an autocompleter, the autocompleter should convert user input to valid values of this type. Default type is stringType. 
    :param bool multiValue: If multiValue is enabled, this field will accept multiple values of the specified type (optional). 
    :param str defaultValue: The default value to populate this field with. (optional, default is not set). 
    :param dict validator: 
    :param dict valueSource: 
    :param dict rendererOptions: Renderer options. Only for use by the Argus frontend application (optional). 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/field/descriptor".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send valueType if the argument was provided, dont send null values
    if valueType is not None:
        body.update({"valueType": valueType})
    # Only send multiValue if the argument was provided, dont send null values
    if multiValue is not None:
        body.update({"multiValue": multiValue})
    # Only send defaultValue if the argument was provided, dont send null values
    if defaultValue is not None:
        body.update({"defaultValue": defaultValue})
    # Only send validator if the argument was provided, dont send null values
    if validator is not None:
        body.update({"validator": validator})
    # Only send valueSource if the argument was provided, dont send null values
    if valueSource is not None:
        body.update({"valueSource": valueSource})
    # Only send rendererOptions if the argument was provided, dont send null values
    if rendererOptions is not None:
        body.update({"rendererOptions": rendererOptions})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "field", "descriptor"),
    module=argus_cli_module
)
def delete_field_descriptor(
    field: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Delete a field descriptor. (DEV)
    
    :param str field: ID or name of descriptor to delete
    :param str domain: Domain to look for field in (when using field name for ID). Defaults to the current users domain.
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/field/descriptor/{field}".format(field=field,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "field", "descriptor"),
    module=argus_cli_module
)
def delete_field_policy(
    policy: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Delete a field policy (DEV)
    
    :param str policy: ID or name of policy to delete
    :param str domain: Domain to look for policy in (when using policy name for ID). Defaults to the current users domain.
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/field/policy/{policy}".format(policy=policy,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "field", "descriptor"),
    module=argus_cli_module
)
def get_field_descriptor(
    field: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch field descriptor (DEV)
    
    :param str field: ID or name of descriptor to fetch
    :param str domain: Domain to look for field in (when using field name for ID). Defaults to the current users domain.
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/field/descriptor/{field}".format(field=field,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "field", "descriptor"),
    module=argus_cli_module
)
def get_field_policy_by_id(
    policy: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch policy descriptor by ID. (DEV)
    
    :param str policy: ID or name of policy to fetch
    :param str domain: Domain to look for policy in (when using policy name for ID). Defaults to the current users domain.
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/field/policy/{policy}".format(policy=policy,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "field", "descriptor"),
    module=argus_cli_module
)
def list_field_descriptors(
    customerID: int = None,
    domain: str = None,
    valueType: str = None,
    field: str = None,
    policy: str = None,
    keywords: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List field descriptors. (DEV)
    
    :param list customerID: Limit result to fields bound to one of these customer IDs
    :param list domain: Limit result to fields bound to one of these domains (by ID or name)
    :param list valueType: Limit result to fields with one of these valueTypes
    :param list field: Limit result to one of these fields (by ID or name)
    :param list policy: Limit result to fields bound to one of these field policies (by ID or name)
    :param list keywords: Limit result to fields matching one of these keywords
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/field/descriptor".format(limit=limit,
        customerID=customerID,
        domain=domain,
        valueType=valueType,
        field=field,
        policy=policy,
        keywords=keywords,
        offset=offset)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        query_parameters.update({"customerID": customerID})
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send valueType if the argument was provided, dont send null values
    if valueType is not None:
        query_parameters.update({"valueType": valueType})
    # Only send field if the argument was provided, dont send null values
    if field is not None:
        query_parameters.update({"field": field})
    # Only send policy if the argument was provided, dont send null values
    if policy is not None:
        query_parameters.update({"policy": policy})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "field", "descriptor"),
    module=argus_cli_module
)
def list_field_policies(
    customerID: int = None,
    domain: str = None,
    keywords: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List field policies (DEV)
    
    :param list customerID: Limit result to fields bound to one of these customer IDs
    :param list domain: Limit result to fields bound to one of these domains (ID or name)
    :param list keywords: Limit result to fields matching one of these keywords
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/field/policy".format(limit=limit,
        customerID=customerID,
        domain=domain,
        keywords=keywords,
        offset=offset)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        query_parameters.update({"customerID": customerID})
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "field", "descriptor"),
    module=argus_cli_module
)
def list_field_source_values(
    field: str,
    caseID: int = None,
    service: str = None,
    customer: str = None,
    domain: str = None,
    keywords: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List define source values for a field. Fields may have a defined value source for available values, which can be used to select valid values to set on the field. This endpoint returns and filters the values from the defined data source. (DEV)
    
    :param str field: ID or name of field to fetch values for
    :param int caseID: ID for case to list field values for
    :param str service: ID or shortname of service to list field values for
    :param str customer: ID or shortname of customer to list field values for
    :param str domain: ID or name of domain for looking up service and customer. Defaults to the current users domain
    :param list keywords: Keyword to filter returned values by
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/field/values/{field}".format(limit=limit,
        field=field,
        caseID=caseID,
        service=service,
        customer=customer,
        domain=domain,
        keywords=keywords,
        offset=offset)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send caseID if the argument was provided, dont send null values
    if caseID is not None:
        query_parameters.update({"caseID": caseID})
    # Only send service if the argument was provided, dont send null values
    if service is not None:
        query_parameters.update({"service": service})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "field", "descriptor"),
    module=argus_cli_module
)
def remove_field_from_policy(
    policy: str,
    field: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Unbind a field from a policy. (DEV)
    
    :param str policy: ID or name of policy to bind field to
    :param str field: ID or name of field to unbind
    :param str domain: Domain to look for policy in (when using policy name for ID). Defaults to the current users domain.
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/field/policy/{policy}/fields/{field}".format(policy=policy,
        field=field,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "field", "descriptor"),
    module=argus_cli_module
)
def search_field_descriptors(
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    subCriteria: dict = None,
    exclude: bool = None,
    required: bool = None,
    customerID: int = None,
    field: str = None,
    domain: str = None,
    service: str = None,
    policy: str = None,
    valueType: str = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    keywords: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    user: str = None,
    userID: int = None,
    userFieldStrategy: str = None,
    sortBy: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Search field descriptors. (DEV)
    
    :param int limit: Set this value to set max number of results. By default, no restriction on result set size. 
    :param int offset: Set this value to skip the first (offset) objects. By default, return result from first object. 
    :param bool includeDeleted: Set to true to include deleted objects. By default, exclude deleted objects. 
    :param list subCriteria: Set additional criterias which are applied using a logical OR. 
    :param bool exclude: Only relevant for subcriteria. If set to true, objects matching this subcriteria object will be excluded. 
    :param bool required: Only relevant for subcriteria. If set to true, objects matching this subcriteria are required (AND-ed together with parent criteria). 
    :param list customerID: Restrict search to data belonging to specified customers. 
    :param list field: Restrict search to specific fields (by name or ID). 
    :param list domain: Restrict search to fields bound to one of these domains. 
    :param list service: Restrict search to fields wich are in use in one of the specified services (service ID or shortname). 
    :param list policy: Restrict search to fields which are in use in one of the specified policies (by policy ID or name) 
    :param list valueType: Restrict search to entries of one of these value types. 
    :param int startTimestamp: Restrict search to a time frame based on the set TimeFieldStrategy (start timestamp). 
    :param int endTimestamp: Restrict search to a time frame based on the set TimeFieldStrategy (end timestamp). 
    :param list keywords: Search for keywords. 
    :param list timeFieldStrategy: Defines which timestamps will be included in the search (default lastUpdatedTimestamp). 
    :param str timeMatchStrategy: Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any) 
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords (default all supported fields). 
    :param str keywordMatchStrategy: Defines the MatchStrategy for keywords (default match all keywords). 
    :param list user: Restrict search to fields created or updated by specified users (by id or shortname, selected by userFieldStrategy). 
    :param list userID: This field is deprecated. Use field 'user' instead. 
    :param list userFieldStrategy: Defines which user fields will be searched (default match all user fields). 
    :param list sortBy: List of properties to sort by (prefix with "-" to sort descending). 
    :param list includeFlags: Only include objects which have includeFlags set. 
    :param list excludeFlags: Exclude objects which have excludeFlags set. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/field/descriptor/search".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send exclude if the argument was provided, dont send null values
    if exclude is not None:
        body.update({"exclude": exclude})
    # Only send required if the argument was provided, dont send null values
    if required is not None:
        body.update({"required": required})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send field if the argument was provided, dont send null values
    if field is not None:
        body.update({"field": field})
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send service if the argument was provided, dont send null values
    if service is not None:
        body.update({"service": service})
    # Only send policy if the argument was provided, dont send null values
    if policy is not None:
        body.update({"policy": policy})
    # Only send valueType if the argument was provided, dont send null values
    if valueType is not None:
        body.update({"valueType": valueType})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, dont send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send keywordFieldStrategy if the argument was provided, dont send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, dont send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send user if the argument was provided, dont send null values
    if user is not None:
        body.update({"user": user})
    # Only send userID if the argument was provided, dont send null values
    if userID is not None:
        body.update({"userID": userID})
    # Only send userFieldStrategy if the argument was provided, dont send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "field", "descriptor"),
    module=argus_cli_module
)
def search_field_policies(
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    includeFlags: int = None,
    excludeFlags: int = None,
    subCriteria: dict = None,
    exclude: bool = None,
    required: bool = None,
    customerID: int = None,
    domain: str = None,
    keywords: str = None,
    keywordMatchStrategy: str = None,
    keywordFieldStrategy: str = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    user: str = None,
    userID: int = None,
    userFieldStrategy: str = None,
    field: str = None,
    policy: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Search field policies (DEV)
    
    :param int limit: Set this value to set max number of results. By default, no restriction on result set size. 
    :param int offset: Set this value to skip the first (offset) objects. By default, return result from first object. 
    :param bool includeDeleted: Set to true to include deleted objects. By default, exclude deleted objects. 
    :param int includeFlags: Only include objects which have includeFlags set. 
    :param int excludeFlags: Exclude objects which have excludeFlags set. 
    :param list subCriteria: Set additional criterias which are applied using a logical OR. 
    :param bool exclude: Only relevant for subcriteria. If set to true, objects matching this subcriteria object will be excluded. 
    :param bool required: Only relevant for subcriteria. If set to true, objects matching this subcriteria are required (AND-ed together with parent criteria). 
    :param list customerID: Restrict search to data belonging to specified customers. 
    :param list domain: Search by domain (ID or name). 
    :param list keywords: Search for keywords. 
    :param str keywordMatchStrategy: Defines the MatchStrategy for keywords (default match all keywords). 
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords (default all supported fields). 
    :param int startTimestamp: Restrict search to a time frame based on the set TimeFieldStrategy (start timestamp). 
    :param int endTimestamp: Restrict search to a time frame based on the set TimeFieldStrategy (end timestamp). 
    :param list timeFieldStrategy: Defines which timestamps will be included in the search (default lastUpdatedTimestamp). 
    :param str timeMatchStrategy: Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any) 
    :param list user: Restrict search to policies created or updated by specified users (by id or shortname, selected by userFieldStrategy). 
    :param list userID: This field is deprecated. Use field 'user' instead. 
    :param list userFieldStrategy: Defines which user fields will be searched (default match all user fields). 
    :param list field: Search for policies bound to specific fields (by field UUID or name). 
    :param list policy: Search for policies with specified id (UUID or name). 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/field/policy/search".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send exclude if the argument was provided, dont send null values
    if exclude is not None:
        body.update({"exclude": exclude})
    # Only send required if the argument was provided, dont send null values
    if required is not None:
        body.update({"required": required})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordMatchStrategy if the argument was provided, dont send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send keywordFieldStrategy if the argument was provided, dont send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, dont send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send user if the argument was provided, dont send null values
    if user is not None:
        body.update({"user": user})
    # Only send userID if the argument was provided, dont send null values
    if userID is not None:
        body.update({"userID": userID})
    # Only send userFieldStrategy if the argument was provided, dont send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send field if the argument was provided, dont send null values
    if field is not None:
        body.update({"field": field})
    # Only send policy if the argument was provided, dont send null values
    if policy is not None:
        body.update({"policy": policy})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "field", "descriptor"),
    module=argus_cli_module
)
def update_field_descriptor(
    field: str,
    domain: str = None,
    name: str = None,
    valueType: str = None,
    multiValue: bool = None,
    defaultValue: str = None,
    validator: dict = None,
    valueSource: dict = None,
    rendererOptions: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Update a field descriptor. (DEV)
    
    :param str field: ID or name of descriptor to update
    :param str domain: Domain to look for field in (when using field name for ID). Defaults to the current users domain.
    :param str name: If set, change the name of the field.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str valueType: If set, change the value type for the field.The field will only accept values that can be safely converted to this value type. If the field uses an autocompleter, the autocompleter should convert user input to valid values of this type. 
    :param bool multiValue: If set, change the multivalue parameter of this field. This will not affect existing cases with this field set. 
    :param str defaultValue: If set, change the default value to populate this field with. 
    :param dict validator: 
    :param dict valueSource: 
    :param dict rendererOptions: Renderer options. Only for use by the Argus frontend application. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/field/descriptor/{field}".format(field=field,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send valueType if the argument was provided, dont send null values
    if valueType is not None:
        body.update({"valueType": valueType})
    # Only send multiValue if the argument was provided, dont send null values
    if multiValue is not None:
        body.update({"multiValue": multiValue})
    # Only send defaultValue if the argument was provided, dont send null values
    if defaultValue is not None:
        body.update({"defaultValue": defaultValue})
    # Only send validator if the argument was provided, dont send null values
    if validator is not None:
        body.update({"validator": validator})
    # Only send valueSource if the argument was provided, dont send null values
    if valueSource is not None:
        body.update({"valueSource": valueSource})
    # Only send rendererOptions if the argument was provided, dont send null values
    if rendererOptions is not None:
        body.update({"rendererOptions": rendererOptions})

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("cases", "v2", "field", "descriptor"),
    module=argus_cli_module
)
def update_field_policy(
    policy: str,
    domain: str = None,
    name: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Update a field policy. (DEV)
    
    :param str policy: ID or name of policy to update
    :param str domain: Domain to look for policy in (when using policy name for ID). Defaults to the current users domain.
    :param str name: If set, change the name of this policy.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/cases/v2/field/policy/{policy}".format(policy=policy,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()

