"""Autogenerated API"""
from argus_api import session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module
from requests import Response

log = logging.getLogger(__name__)


@register_command(
    extending=("assets", "v1", "service"),
    module=argus_cli_module
)
def add_service_asset(
    ownerID: int = None,
    customerID: int = None,
    name: str = None,
    description: str = None,
    criticality: dict = None,
    properties: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Creates a new ServiceAsset. (PUBLIC)
    
    :param int ownerID: User who owns the asset. 
    :param int customerID: Customer the asset belongs to. 
    :param str name: Name of the asset.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str description: Description of the asset.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param dict criticality: 
    :param dict properties: Custom user-defined properties.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v1/service".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send ownerID if the argument was provided, dont send null values
    if ownerID is not None:
        body.update({"ownerID": ownerID})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send criticality if the argument was provided, dont send null values
    if criticality is not None:
        body.update({"criticality": criticality})
    # Only send properties if the argument was provided, dont send null values
    if properties is not None:
        body.update({"properties": properties})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v1", "service"),
    module=argus_cli_module
)
def attach_hosts_to_service(
    id: str,
    hostAssetIDs: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Adds multiple HostAssets to a ServiceAsset. (PUBLIC)
    
    :param str id: ServiceAsset ID
    :param list hostAssetIDs: Specify hosts to add to service. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v1/service/{id}/attachhosts".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send hostAssetIDs if the argument was provided, dont send null values
    if hostAssetIDs is not None:
        body.update({"hostAssetIDs": hostAssetIDs})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v1", "service"),
    module=argus_cli_module
)
def delete_service_asset(
    id: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Marks a ServiceAsset as deleted. (PUBLIC)
    
    :param str id: ServiceAsset ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v1/service/{id}".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v1", "service"),
    module=argus_cli_module
)
def detach_hosts_from_service(
    id: str,
    hostAssetIDs: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Removes multiple HostAssets from a ServiceAsset. (PUBLIC)
    
    :param str id: ServiceAsset ID
    :param list hostAssetIDs: Specify hosts to detach from service. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v1/service/{id}/detachhosts".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send hostAssetIDs if the argument was provided, dont send null values
    if hostAssetIDs is not None:
        body.update({"hostAssetIDs": hostAssetIDs})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v1", "service"),
    module=argus_cli_module
)
def get_service_asset(
    id: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Returns a ServiceAsset identified by its ID. (PUBLIC)
    
    :param str id: ServiceAsset ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v1/service/{id}".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v1", "service"),
    module=argus_cli_module
)
def search_service_asset_statistics(
    name: str = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    keywords: str = None,
    keywordMatchStrategy: str = None,
    timeMatchStrategy: str = None,
    hostID: str = None,
    serviceID: str = None,
    businessProcessID: str = None,
    ipRange: str = None,
    applicationPort: int = None,
    applicationProtocol: str = None,
    cpe: str = None,
    hostCPE: str = None,
    applicationCPE: str = None,
    countTimeout: int = None,
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    subCriteria: dict = None,
    exclude: bool = None,
    required: bool = None,
    customerID: int = None,
    ownerID: int = None,
    criticality: dict = None,
    minimumTotalCvss: float = None,
    maximumTotalCvss: float = None,
    vulnerabilityReference: str = None,
    vulnerabilityID: str = None,
    applicationRole: int = None,
    timeFieldStrategy: str = None,
    keywordFieldStrategy: str = None,
    groupBy: str = None,
    values: str = None,
    resolution: int = None,
    cutoff: int = None,
    cutoffValue: str = None,
    includeOthers: bool = None,
    sortBy: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch service asset statistics base on criteria (DEV)
    
    :param list name: Restrict search to specific asset name
    :param int startTimestamp: Restrict search to a time frame based on the set TimeFieldStrategy (start timestamp).
    :param int endTimestamp: Restrict search to a time frame based on the set TimeFieldStrategy (end timestamp).
    :param list keywords: Search for keywords.
    :param str keywordMatchStrategy: Defines the MatchStrategy for keywords (default match all keywords).
    :param str timeMatchStrategy: Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any)
    :param list hostID: Restrict search to specific host UUIDs.
    :param list serviceID: Restrict search to specific service UUIDs.
    :param list businessProcessID: Restrict search to specific business process UUIDs.
    :param str ipRange: Restrict search to entities related to these IP-addresses (may specify single IPs, IP networks or IP ranges.
    :param list applicationPort: Restrict to applications listening on specific ports.
    :param list applicationProtocol: Restrict to applications by transport protocol name.
    :param str cpe: Restrict to applications or hosts by CPE.
    :param str hostCPE: Restrict to hosts by CPE.
    :param str applicationCPE: Restrict to applications by CPE.
    :param int countTimeout: Max wait in seconds for count query, if max wait passed and count query still executing the query; or -1 is set to indicate do not count, then the query will be cancelled and return count -1. Default value 0 means execute as long as service allows, -1 means do not count, max value is 30 (seconds).
    :param int limit: Set this value to set max number of results. By default, no restriction on result set size. 
    :param int offset: Set this value to skip the first (offset) objects. By default, return result from first object. 
    :param bool includeDeleted: Set to true to include deleted objects. By default, exclude deleted objects. 
    :param list subCriteria: Set additional criterias which are applied using a logical OR. 
    :param bool exclude: Only relevant for subcriteria. If set to true, objects matching this subcriteria object will be excluded. 
    :param bool required: Only relevant for subcriteria. If set to true, objects matching this subcriteria are required (AND-ed together with parent criteria). 
    :param list customerID: Restrict search to data belonging to specified customers. 
    :param list ownerID: Restrict search to specific ownerIDs 
    :param list criticality: Restrict search to a range of criticality levels (add multiple CriticalitySearch objects to specify OR criteria). 
    :param float minimumTotalCvss: Restrict search to a minimum total CVSS score. 
    :param float maximumTotalCvss: Restrict search to a maximum total CVSS score. 
    :param list vulnerabilityReference: Restrict to vulnerabilities identified by vulnerability reference. 
    :param list vulnerabilityID: Restrict to vulnerabilities identified by vulnerability ID. 
    :param list applicationRole: Restrict to applications with specific roles (list of role IDs). 
    :param list timeFieldStrategy: Defines which timestamps will be included in the search (default lastUpdatedTimestamp on service). 
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords (default all supported fields). 
    :param list groupBy: Specify which fields will be grouped by in stats 
    :param list values: Specify which values will be included in stats (default services) 
    :param int resolution: Stats resolution period in milliseconds, if is 0 means to generate non-timeline statistics 
    :param int cutoff: Reduce stats keys to the cutoff amount of keys that has largest hit count, default 0 means no reduce 
    :param str cutoffValue: Specify which value to be cutoff on (default services) 
    :param bool includeOthers: If reduce (cutoff >0), true means remaining keys (other than cutoff keys) are collected into an "other" key, default false 
    :param list sortBy: List of properties to sort by (prefix with "-" to sort descending). 
    :param list includeFlags: Only include objects which have includeFlags set. 
    :param list excludeFlags: Exclude objects which have excludeFlags set. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v1/service/statistics".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordMatchStrategy if the argument was provided, dont send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send timeMatchStrategy if the argument was provided, dont send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send hostID if the argument was provided, dont send null values
    if hostID is not None:
        body.update({"hostID": hostID})
    # Only send serviceID if the argument was provided, dont send null values
    if serviceID is not None:
        body.update({"serviceID": serviceID})
    # Only send businessProcessID if the argument was provided, dont send null values
    if businessProcessID is not None:
        body.update({"businessProcessID": businessProcessID})
    # Only send ipRange if the argument was provided, dont send null values
    if ipRange is not None:
        body.update({"ipRange": ipRange})
    # Only send applicationPort if the argument was provided, dont send null values
    if applicationPort is not None:
        body.update({"applicationPort": applicationPort})
    # Only send applicationProtocol if the argument was provided, dont send null values
    if applicationProtocol is not None:
        body.update({"applicationProtocol": applicationProtocol})
    # Only send cpe if the argument was provided, dont send null values
    if cpe is not None:
        body.update({"cpe": cpe})
    # Only send hostCPE if the argument was provided, dont send null values
    if hostCPE is not None:
        body.update({"hostCPE": hostCPE})
    # Only send applicationCPE if the argument was provided, dont send null values
    if applicationCPE is not None:
        body.update({"applicationCPE": applicationCPE})
    # Only send countTimeout if the argument was provided, dont send null values
    if countTimeout is not None:
        body.update({"countTimeout": countTimeout})
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send exclude if the argument was provided, dont send null values
    if exclude is not None:
        body.update({"exclude": exclude})
    # Only send required if the argument was provided, dont send null values
    if required is not None:
        body.update({"required": required})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send ownerID if the argument was provided, dont send null values
    if ownerID is not None:
        body.update({"ownerID": ownerID})
    # Only send criticality if the argument was provided, dont send null values
    if criticality is not None:
        body.update({"criticality": criticality})
    # Only send minimumTotalCvss if the argument was provided, dont send null values
    if minimumTotalCvss is not None:
        body.update({"minimumTotalCvss": minimumTotalCvss})
    # Only send maximumTotalCvss if the argument was provided, dont send null values
    if maximumTotalCvss is not None:
        body.update({"maximumTotalCvss": maximumTotalCvss})
    # Only send vulnerabilityReference if the argument was provided, dont send null values
    if vulnerabilityReference is not None:
        body.update({"vulnerabilityReference": vulnerabilityReference})
    # Only send vulnerabilityID if the argument was provided, dont send null values
    if vulnerabilityID is not None:
        body.update({"vulnerabilityID": vulnerabilityID})
    # Only send applicationRole if the argument was provided, dont send null values
    if applicationRole is not None:
        body.update({"applicationRole": applicationRole})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send keywordFieldStrategy if the argument was provided, dont send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send groupBy if the argument was provided, dont send null values
    if groupBy is not None:
        body.update({"groupBy": groupBy})
    # Only send values if the argument was provided, dont send null values
    if values is not None:
        body.update({"values": values})
    # Only send resolution if the argument was provided, dont send null values
    if resolution is not None:
        body.update({"resolution": resolution})
    # Only send cutoff if the argument was provided, dont send null values
    if cutoff is not None:
        body.update({"cutoff": cutoff})
    # Only send cutoffValue if the argument was provided, dont send null values
    if cutoffValue is not None:
        body.update({"cutoffValue": cutoffValue})
    # Only send includeOthers if the argument was provided, dont send null values
    if includeOthers is not None:
        body.update({"includeOthers": includeOthers})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v1", "service"),
    module=argus_cli_module
)
def search_service_assets(
    name: str = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    keywords: str = None,
    keywordMatchStrategy: str = None,
    timeMatchStrategy: str = None,
    hostID: str = None,
    serviceID: str = None,
    businessProcessID: str = None,
    ipRange: str = None,
    applicationPort: int = None,
    applicationProtocol: str = None,
    cpe: str = None,
    hostCPE: str = None,
    applicationCPE: str = None,
    countTimeout: int = None,
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    subCriteria: dict = None,
    exclude: bool = None,
    required: bool = None,
    customerID: int = None,
    ownerID: int = None,
    criticality: dict = None,
    minimumTotalCvss: float = None,
    maximumTotalCvss: float = None,
    vulnerabilityReference: str = None,
    vulnerabilityID: str = None,
    applicationRole: int = None,
    timeFieldStrategy: str = None,
    keywordFieldStrategy: str = None,
    sortBy: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Returns a set of ServiceAssets defined by a ServiceAssetSearchCriteria. (PUBLIC)
    
    :param list name: Restrict search to specific asset name
    :param int startTimestamp: Restrict search to a time frame based on the set TimeFieldStrategy (start timestamp).
    :param int endTimestamp: Restrict search to a time frame based on the set TimeFieldStrategy (end timestamp).
    :param list keywords: Search for keywords.
    :param str keywordMatchStrategy: Defines the MatchStrategy for keywords (default match all keywords).
    :param str timeMatchStrategy: Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any)
    :param list hostID: Restrict search to specific host UUIDs.
    :param list serviceID: Restrict search to specific service UUIDs.
    :param list businessProcessID: Restrict search to specific business process UUIDs.
    :param str ipRange: Restrict search to entities related to these IP-addresses (may specify single IPs, IP networks or IP ranges.
    :param list applicationPort: Restrict to applications listening on specific ports.
    :param list applicationProtocol: Restrict to applications by transport protocol name.
    :param str cpe: Restrict to applications or hosts by CPE.
    :param str hostCPE: Restrict to hosts by CPE.
    :param str applicationCPE: Restrict to applications by CPE.
    :param int countTimeout: Max wait in seconds for count query, if max wait passed and count query still executing the query; or -1 is set to indicate do not count, then the query will be cancelled and return count -1. Default value 0 means execute as long as service allows, -1 means do not count, max value is 30 (seconds).
    :param int limit: Set this value to set max number of results. By default, no restriction on result set size. 
    :param int offset: Set this value to skip the first (offset) objects. By default, return result from first object. 
    :param bool includeDeleted: Set to true to include deleted objects. By default, exclude deleted objects. 
    :param list subCriteria: Set additional criterias which are applied using a logical OR. 
    :param bool exclude: Only relevant for subcriteria. If set to true, objects matching this subcriteria object will be excluded. 
    :param bool required: Only relevant for subcriteria. If set to true, objects matching this subcriteria are required (AND-ed together with parent criteria). 
    :param list customerID: Restrict search to data belonging to specified customers. 
    :param list ownerID: Restrict search to specific ownerIDs 
    :param list criticality: Restrict search to a range of criticality levels (add multiple CriticalitySearch objects to specify OR criteria). 
    :param float minimumTotalCvss: Restrict search to a minimum total CVSS score. 
    :param float maximumTotalCvss: Restrict search to a maximum total CVSS score. 
    :param list vulnerabilityReference: Restrict to vulnerabilities identified by vulnerability reference. 
    :param list vulnerabilityID: Restrict to vulnerabilities identified by vulnerability ID. 
    :param list applicationRole: Restrict to applications with specific roles (list of role IDs). 
    :param list timeFieldStrategy: Defines which timestamps will be included in the search (default lastUpdatedTimestamp on service). 
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords (default all supported fields). 
    :param list sortBy: List of properties to sort by (prefix with "-" to sort descending). 
    :param list includeFlags: Only include objects which have includeFlags set. 
    :param list excludeFlags: Exclude objects which have excludeFlags set. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: requests.Response object or dictionary translated from JSON
    """

    route = "/assets/v1/service/search".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': None
    }
    if json:
        headers['content'] = 'application/json'

    body = body or {}
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordMatchStrategy if the argument was provided, dont send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send timeMatchStrategy if the argument was provided, dont send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send hostID if the argument was provided, dont send null values
    if hostID is not None:
        body.update({"hostID": hostID})
    # Only send serviceID if the argument was provided, dont send null values
    if serviceID is not None:
        body.update({"serviceID": serviceID})
    # Only send businessProcessID if the argument was provided, dont send null values
    if businessProcessID is not None:
        body.update({"businessProcessID": businessProcessID})
    # Only send ipRange if the argument was provided, dont send null values
    if ipRange is not None:
        body.update({"ipRange": ipRange})
    # Only send applicationPort if the argument was provided, dont send null values
    if applicationPort is not None:
        body.update({"applicationPort": applicationPort})
    # Only send applicationProtocol if the argument was provided, dont send null values
    if applicationProtocol is not None:
        body.update({"applicationProtocol": applicationProtocol})
    # Only send cpe if the argument was provided, dont send null values
    if cpe is not None:
        body.update({"cpe": cpe})
    # Only send hostCPE if the argument was provided, dont send null values
    if hostCPE is not None:
        body.update({"hostCPE": hostCPE})
    # Only send applicationCPE if the argument was provided, dont send null values
    if applicationCPE is not None:
        body.update({"applicationCPE": applicationCPE})
    # Only send countTimeout if the argument was provided, dont send null values
    if countTimeout is not None:
        body.update({"countTimeout": countTimeout})
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send exclude if the argument was provided, dont send null values
    if exclude is not None:
        body.update({"exclude": exclude})
    # Only send required if the argument was provided, dont send null values
    if required is not None:
        body.update({"required": required})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send ownerID if the argument was provided, dont send null values
    if ownerID is not None:
        body.update({"ownerID": ownerID})
    # Only send criticality if the argument was provided, dont send null values
    if criticality is not None:
        body.update({"criticality": criticality})
    # Only send minimumTotalCvss if the argument was provided, dont send null values
    if minimumTotalCvss is not None:
        body.update({"minimumTotalCvss": minimumTotalCvss})
    # Only send maximumTotalCvss if the argument was provided, dont send null values
    if maximumTotalCvss is not None:
        body.update({"maximumTotalCvss": maximumTotalCvss})
    # Only send vulnerabilityReference if the argument was provided, dont send null values
    if vulnerabilityReference is not None:
        body.update({"vulnerabilityReference": vulnerabilityReference})
    # Only send vulnerabilityID if the argument was provided, dont send null values
    if vulnerabilityID is not None:
        body.update({"vulnerabilityID": vulnerabilityID})
    # Only send applicationRole if the argument was provided, dont send null values
    if applicationRole is not None:
        body.update({"applicationRole": applicationRole})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send keywordFieldStrategy if the argument was provided, dont send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("assets", "v1", "service"),
    module=argus_cli_module
)
def search_service_assets_simplified(
    keywords: str = None,
    keywordField: str = None,
    name: str = None,
    hostID: str = None,
    serviceID: str = None,
    businessProcessID: str = None,
    customerID: int = None,
    ip: str = None,
    port: int = None,
    protocol: str = None,
    cpe: str = None,
    vulnID: str = None,
    vulnRef: str = None,
    includeFlag: str = None,
    excludeFlag: str = None,
    sortBy: str = None,
    countTimeout: int = None,
    limit: int = 25,
    keywordMatch: str = "all",
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Returns as set of ServiceAssets defined by query parameters. (PUBLIC)
    
    :param list keywords: Search by keywords
    :param list keywordField: Set field strategy for keyword search
    :param list name: Search by name
    :param list hostID: Search by HostAsset ID
    :param list serviceID: Search by ServiceAsset ID
    :param list businessProcessID: Search by BusinessProcess ID
    :param list customerID: Search by customer ID
    :param list ip: Search by IP range
    :param list port: Search by application port
    :param list protocol: Search by application protocol
    :param list cpe: Search by CPE
    :param list vulnID: Search by vulnerability ID
    :param list vulnRef: Search by vulnerability reference
    :param list includeFlag: Include certain ServiceAssets in the search result based on set flags
    :param list excludeFlag: Exclude certain ServiceAssets from the search result based on set flags
    :param list sortBy: Sort search result
    :param int countTimeout: Max wait in seconds for count query. Value 0 means execute as long as service allows, -1 means do not count, max value is 30 (seconds).
    :param int limit: Maximum number of returned results
    :param str keywordMatch: Set match strategy for keyword search
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: requests.Response object or dictionary translated from JSON
    """

    route = "/assets/v1/service".format(limit=limit,
        keywordMatch=keywordMatch,
        offset=offset,
        keywords=keywords,
        keywordField=keywordField,
        name=name,
        hostID=hostID,
        serviceID=serviceID,
        businessProcessID=businessProcessID,
        customerID=customerID,
        ip=ip,
        port=port,
        protocol=protocol,
        cpe=cpe,
        vulnID=vulnID,
        vulnRef=vulnRef,
        includeFlag=includeFlag,
        excludeFlag=excludeFlag,
        sortBy=sortBy,
        countTimeout=countTimeout)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': None
    }
    if json:
        headers['content'] = 'application/json'

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send keywordMatch if the argument was provided, dont send null values
    if keywordMatch is not None:
        query_parameters.update({"keywordMatch": keywordMatch})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send keywordField if the argument was provided, dont send null values
    if keywordField is not None:
        query_parameters.update({"keywordField": keywordField})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        query_parameters.update({"name": name})
    # Only send hostID if the argument was provided, dont send null values
    if hostID is not None:
        query_parameters.update({"hostID": hostID})
    # Only send serviceID if the argument was provided, dont send null values
    if serviceID is not None:
        query_parameters.update({"serviceID": serviceID})
    # Only send businessProcessID if the argument was provided, dont send null values
    if businessProcessID is not None:
        query_parameters.update({"businessProcessID": businessProcessID})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        query_parameters.update({"customerID": customerID})
    # Only send ip if the argument was provided, dont send null values
    if ip is not None:
        query_parameters.update({"ip": ip})
    # Only send port if the argument was provided, dont send null values
    if port is not None:
        query_parameters.update({"port": port})
    # Only send protocol if the argument was provided, dont send null values
    if protocol is not None:
        query_parameters.update({"protocol": protocol})
    # Only send cpe if the argument was provided, dont send null values
    if cpe is not None:
        query_parameters.update({"cpe": cpe})
    # Only send vulnID if the argument was provided, dont send null values
    if vulnID is not None:
        query_parameters.update({"vulnID": vulnID})
    # Only send vulnRef if the argument was provided, dont send null values
    if vulnRef is not None:
        query_parameters.update({"vulnRef": vulnRef})
    # Only send includeFlag if the argument was provided, dont send null values
    if includeFlag is not None:
        query_parameters.update({"includeFlag": includeFlag})
    # Only send excludeFlag if the argument was provided, dont send null values
    if excludeFlag is not None:
        query_parameters.update({"excludeFlag": excludeFlag})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    # Only send countTimeout if the argument was provided, dont send null values
    if countTimeout is not None:
        query_parameters.update({"countTimeout": countTimeout})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("assets", "v1", "service"),
    module=argus_cli_module
)
def update_service_asset(
    id: str,
    ownerID: int = None,
    name: str = None,
    description: str = None,
    criticality: dict = None,
    addProperties: dict = None,
    deleteProperties: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Updates an existing ServiceAsset. (PUBLIC)
    
    :param str id: ServiceAsset ID
    :param int ownerID: Change user who owns the asset. 
    :param str name: Change name of asset.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str description: Change description of asset.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param dict criticality: 
    :param dict addProperties: Add custom properties (updates a property if key already exists).  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param list deleteProperties: Delete custom properties by key. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v1/service/{id}".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send ownerID if the argument was provided, dont send null values
    if ownerID is not None:
        body.update({"ownerID": ownerID})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send criticality if the argument was provided, dont send null values
    if criticality is not None:
        body.update({"criticality": criticality})
    # Only send addProperties if the argument was provided, dont send null values
    if addProperties is not None:
        body.update({"addProperties": addProperties})
    # Only send deleteProperties if the argument was provided, dont send null values
    if deleteProperties is not None:
        body.update({"deleteProperties": deleteProperties})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()

