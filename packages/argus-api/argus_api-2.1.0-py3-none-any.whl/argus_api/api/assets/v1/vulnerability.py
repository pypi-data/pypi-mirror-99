"""Autogenerated API"""
from argus_api import session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module
from requests import Response

log = logging.getLogger(__name__)


@register_command(
    extending=("assets", "v1", "vulnerability"),
    module=argus_cli_module
)
def add_asset_vulnerability(
    hostID: str = None,
    vulnerabilityID: str = None,
    references: str = None,
    name: str = None,
    description: str = None,
    conclusion: str = None,
    solution: str = None,
    rawOutput: str = None,
    cvss: float = None,
    severity: str = None,
    properties: dict = None,
    exploitAvailable: bool = None,
    source: str = None,
    socket: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Creates a new AssetVulnerability. (PUBLIC)
    
    :param str hostID: Specify parent host. 
    :param str vulnerabilityID: Identifier of vulnerability (e.g. plug-in ID from vulnerability scanner).  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param list references: References to vulnerability (e.g. CVE number). 
    :param str name: Name of vulnerability. Will be sanitized and no line break allowed. 
    :param str description: Description of vulnerability. Will be sanitized. 
    :param str conclusion: Short summary of vulnerability. Will be sanitized. 
    :param str solution: How to fix vulnerability. Will be sanitized. 
    :param str rawOutput: Raw output from vulnerability scan. Will be sanitized. 
    :param float cvss: CVSS score of vulnerability (range from 0 to 10). 
    :param str severity: Severity level of vulnerability. 
    :param dict properties: Custom user-defined properties.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param bool exploitAvailable: Set if an exploit is available for the vulnerability. 
    :param str source: Source of the request. (default USER)
    :param str socket: Specify socket string of the vulnerability (e.g. tcp/80), or omit if not bound to a socket. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v1/vulnerability".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send hostID if the argument was provided, dont send null values
    if hostID is not None:
        body.update({"hostID": hostID})
    # Only send vulnerabilityID if the argument was provided, dont send null values
    if vulnerabilityID is not None:
        body.update({"vulnerabilityID": vulnerabilityID})
    # Only send references if the argument was provided, dont send null values
    if references is not None:
        body.update({"references": references})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send conclusion if the argument was provided, dont send null values
    if conclusion is not None:
        body.update({"conclusion": conclusion})
    # Only send solution if the argument was provided, dont send null values
    if solution is not None:
        body.update({"solution": solution})
    # Only send rawOutput if the argument was provided, dont send null values
    if rawOutput is not None:
        body.update({"rawOutput": rawOutput})
    # Only send cvss if the argument was provided, dont send null values
    if cvss is not None:
        body.update({"cvss": cvss})
    # Only send severity if the argument was provided, dont send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send properties if the argument was provided, dont send null values
    if properties is not None:
        body.update({"properties": properties})
    # Only send exploitAvailable if the argument was provided, dont send null values
    if exploitAvailable is not None:
        body.update({"exploitAvailable": exploitAvailable})
    # Only send source if the argument was provided, dont send null values
    if source is not None:
        body.update({"source": source})
    # Only send socket if the argument was provided, dont send null values
    if socket is not None:
        body.update({"socket": socket})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v1", "vulnerability"),
    module=argus_cli_module
)
def delete_asset_vulnerability(
    id: str,
    source: str = "USER",
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Marks an AssetVulnerability as deleted. (PUBLIC)
    
    :param str id: AssetVulnerability ID
    :param str source: Request source (default USER)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v1/vulnerability/{id}".format(source=source,
        id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send source if the argument was provided, dont send null values
    if source is not None:
        query_parameters.update({"source": source})

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v1", "vulnerability"),
    module=argus_cli_module
)
def get_asset_vulnerability(
    id: str,
    includeRawOutput: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Returns an AssetVulnerability identified by its ID. (PUBLIC)
    
    :param str id: AssetVulnerability ID
    :param bool includeRawOutput: Include raw output
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v1/vulnerability/{id}".format(id=id,
        includeRawOutput=includeRawOutput)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send includeRawOutput if the argument was provided, dont send null values
    if includeRawOutput is not None:
        query_parameters.update({"includeRawOutput": includeRawOutput})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v1", "vulnerability"),
    module=argus_cli_module
)
def reopen_asset_vulnerability(
    id: str,
    source: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Reopen a resolved AssetVulnerability. (DEV)
    
    :param str id: AssetVulnerability ID
    :param str source: Source of the request. (default USER)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v1/vulnerability/{id}/reopen".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send source if the argument was provided, dont send null values
    if source is not None:
        body.update({"source": source})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v1", "vulnerability"),
    module=argus_cli_module
)
def resolve_asset_vulnerability(
    id: str,
    resolution: str = None,
    comment: str = None,
    source: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Resolves an AssetVulnerability. (PUBLIC)
    
    :param str id: AssetVulnerability ID
    :param str resolution: Specify resolution reason. 
    :param str comment: Comment on why the vulnerability is resolved.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str source: Source of the request. (default USER)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v1/vulnerability/{id}/resolve".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send resolution if the argument was provided, dont send null values
    if resolution is not None:
        body.update({"resolution": resolution})
    # Only send comment if the argument was provided, dont send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send source if the argument was provided, dont send null values
    if source is not None:
        body.update({"source": source})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v1", "vulnerability"),
    module=argus_cli_module
)
def search_asset_vulnerabilities(
    name: str = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    keywords: str = None,
    keywordMatchStrategy: str = None,
    timeMatchStrategy: str = None,
    hostID: str = None,
    serviceID: str = None,
    businessProcessID: str = None,
    ipRange: str = None,
    applicationPort: int = None,
    applicationProtocol: str = None,
    cpe: str = None,
    hostCPE: str = None,
    applicationCPE: str = None,
    countTimeout: int = None,
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    subCriteria: dict = None,
    exclude: bool = None,
    required: bool = None,
    customerID: int = None,
    minimumCvss: float = None,
    maximumCvss: float = None,
    severity: str = None,
    resolutionCode: str = None,
    vulnerabilityReference: str = None,
    vulnerabilityID: str = None,
    timeFieldStrategy: str = None,
    keywordFieldStrategy: str = None,
    includeRawOutput: bool = None,
    includeConclusion: bool = None,
    includeSolution: bool = None,
    sortBy: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Returns a set of AssetVulnerabilities defined by an AssetVulnerabilitySearchCriteria. (PUBLIC)
    
    :param list name: Restrict search to specific asset name
    :param int startTimestamp: Restrict search to a time frame based on the set TimeFieldStrategy (start timestamp).
    :param int endTimestamp: Restrict search to a time frame based on the set TimeFieldStrategy (end timestamp).
    :param list keywords: Search for keywords.
    :param str keywordMatchStrategy: Defines the MatchStrategy for keywords (default match all keywords).
    :param str timeMatchStrategy: Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any)
    :param list hostID: Restrict search to specific host UUIDs.
    :param list serviceID: Restrict search to specific service UUIDs.
    :param list businessProcessID: Restrict search to specific business process UUIDs.
    :param str ipRange: Restrict search to entities related to these IP-addresses (may specify single IPs, IP networks or IP ranges.
    :param list applicationPort: Restrict to applications listening on specific ports.
    :param list applicationProtocol: Restrict to applications by transport protocol name.
    :param str cpe: Restrict to applications or hosts by CPE.
    :param str hostCPE: Restrict to hosts by CPE.
    :param str applicationCPE: Restrict to applications by CPE.
    :param int countTimeout: Max wait in seconds for count query, if max wait passed and count query still executing the query; or -1 is set to indicate do not count, then the query will be cancelled and return count -1. Default value 0 means execute as long as service allows, -1 means do not count, max value is 30 (seconds).
    :param int limit: Set this value to set max number of results. By default, no restriction on result set size. 
    :param int offset: Set this value to skip the first (offset) objects. By default, return result from first object. 
    :param bool includeDeleted: Set to true to include deleted objects. By default, exclude deleted objects. 
    :param list subCriteria: Set additional criterias which are applied using a logical OR. 
    :param bool exclude: Only relevant for subcriteria. If set to true, objects matching this subcriteria object will be excluded. 
    :param bool required: Only relevant for subcriteria. If set to true, objects matching this subcriteria are required (AND-ed together with parent criteria). 
    :param list customerID: Restrict search to data belonging to specified customers. 
    :param float minimumCvss: Restrict search to vulnerabilities with CVSS score at least this high. 
    :param float maximumCvss: Restrict search to vulnerabilities with CVSS score no more than this. 
    :param list severity: Restrict search to specified severity levels. 
    :param list resolutionCode: Restrict search to specific resolution codes. 
    :param list vulnerabilityReference: Restrict to vulnerabilities identified by vulnerability reference. 
    :param list vulnerabilityID: Restrict to vulnerabilities identified by vulnerability ID. 
    :param list timeFieldStrategy: Defines which timestamps will be included in the search (default lastUpdatedTimestamp). 
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords (default all supported fields). 
    :param bool includeRawOutput: Include vulnerability rawOutput in result (default false) 
    :param bool includeConclusion: Include vulnerability conclusion in result (default false) 
    :param bool includeSolution: Include vulnerability solution in result (default false) 
    :param list sortBy: List of properties to sort by (prefix with "-" to sort descending). 
    :param list includeFlags: Only include objects which have includeFlags set. 
    :param list excludeFlags: Exclude objects which have excludeFlags set. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: requests.Response object or dictionary translated from JSON
    """

    route = "/assets/v1/vulnerability/search".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': None
    }
    if json:
        headers['content'] = 'application/json'

    body = body or {}
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordMatchStrategy if the argument was provided, dont send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send timeMatchStrategy if the argument was provided, dont send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send hostID if the argument was provided, dont send null values
    if hostID is not None:
        body.update({"hostID": hostID})
    # Only send serviceID if the argument was provided, dont send null values
    if serviceID is not None:
        body.update({"serviceID": serviceID})
    # Only send businessProcessID if the argument was provided, dont send null values
    if businessProcessID is not None:
        body.update({"businessProcessID": businessProcessID})
    # Only send ipRange if the argument was provided, dont send null values
    if ipRange is not None:
        body.update({"ipRange": ipRange})
    # Only send applicationPort if the argument was provided, dont send null values
    if applicationPort is not None:
        body.update({"applicationPort": applicationPort})
    # Only send applicationProtocol if the argument was provided, dont send null values
    if applicationProtocol is not None:
        body.update({"applicationProtocol": applicationProtocol})
    # Only send cpe if the argument was provided, dont send null values
    if cpe is not None:
        body.update({"cpe": cpe})
    # Only send hostCPE if the argument was provided, dont send null values
    if hostCPE is not None:
        body.update({"hostCPE": hostCPE})
    # Only send applicationCPE if the argument was provided, dont send null values
    if applicationCPE is not None:
        body.update({"applicationCPE": applicationCPE})
    # Only send countTimeout if the argument was provided, dont send null values
    if countTimeout is not None:
        body.update({"countTimeout": countTimeout})
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send exclude if the argument was provided, dont send null values
    if exclude is not None:
        body.update({"exclude": exclude})
    # Only send required if the argument was provided, dont send null values
    if required is not None:
        body.update({"required": required})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send minimumCvss if the argument was provided, dont send null values
    if minimumCvss is not None:
        body.update({"minimumCvss": minimumCvss})
    # Only send maximumCvss if the argument was provided, dont send null values
    if maximumCvss is not None:
        body.update({"maximumCvss": maximumCvss})
    # Only send severity if the argument was provided, dont send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send resolutionCode if the argument was provided, dont send null values
    if resolutionCode is not None:
        body.update({"resolutionCode": resolutionCode})
    # Only send vulnerabilityReference if the argument was provided, dont send null values
    if vulnerabilityReference is not None:
        body.update({"vulnerabilityReference": vulnerabilityReference})
    # Only send vulnerabilityID if the argument was provided, dont send null values
    if vulnerabilityID is not None:
        body.update({"vulnerabilityID": vulnerabilityID})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send keywordFieldStrategy if the argument was provided, dont send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send includeRawOutput if the argument was provided, dont send null values
    if includeRawOutput is not None:
        body.update({"includeRawOutput": includeRawOutput})
    # Only send includeConclusion if the argument was provided, dont send null values
    if includeConclusion is not None:
        body.update({"includeConclusion": includeConclusion})
    # Only send includeSolution if the argument was provided, dont send null values
    if includeSolution is not None:
        body.update({"includeSolution": includeSolution})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("assets", "v1", "vulnerability"),
    module=argus_cli_module
)
def search_asset_vulnerabilities_simplified(
    keywords: str = None,
    keywordField: str = None,
    name: str = None,
    hostID: str = None,
    serviceID: str = None,
    businessProcessID: str = None,
    customerID: int = None,
    ip: str = None,
    port: int = None,
    protocol: str = None,
    cpe: str = None,
    vulnID: str = None,
    vulnRef: str = None,
    resolutionCode: str = None,
    severity: str = None,
    includeFlag: str = None,
    excludeFlag: str = None,
    sortBy: str = None,
    countTimeout: int = None,
    limit: int = 25,
    keywordMatch: str = "all",
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Returns as set of AssetVulnerabilities defined by query parameters. (PUBLIC)
    
    :param list keywords: Search by keywords
    :param list keywordField: Set field strategy for keyword search
    :param list name: Search by name
    :param list hostID: Search by HostAsset ID
    :param list serviceID: Search by ServiceAsset ID
    :param list businessProcessID: Search by BusinessProcess ID
    :param list customerID: Search by customer ID
    :param list ip: Search by IP range
    :param list port: Search by application port
    :param list protocol: Search by application protocol
    :param list cpe: Search by CPE
    :param list vulnID: Search by vulnerability ID
    :param list vulnRef: Search by vulnerability reference
    :param list resolutionCode: Search by resolution code
    :param list severity: Search by Vulnerability Severity
    :param list includeFlag: Include certain BusinessProcesses in the search result based on set flags
    :param list excludeFlag: Exclude certain BusinessProcesses from the search result based on set flags
    :param list sortBy: Sort search result
    :param int countTimeout: Max wait in seconds for count query. Value 0 means execute as long as service allows, -1 means do not count, max value is 30 (seconds).
    :param int limit: Maximum number of returned results
    :param str keywordMatch: Set match strategy for keyword search
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: requests.Response object or dictionary translated from JSON
    """

    route = "/assets/v1/vulnerability".format(limit=limit,
        keywordMatch=keywordMatch,
        offset=offset,
        keywords=keywords,
        keywordField=keywordField,
        name=name,
        hostID=hostID,
        serviceID=serviceID,
        businessProcessID=businessProcessID,
        customerID=customerID,
        ip=ip,
        port=port,
        protocol=protocol,
        cpe=cpe,
        vulnID=vulnID,
        vulnRef=vulnRef,
        resolutionCode=resolutionCode,
        severity=severity,
        includeFlag=includeFlag,
        excludeFlag=excludeFlag,
        sortBy=sortBy,
        countTimeout=countTimeout)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': None
    }
    if json:
        headers['content'] = 'application/json'

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send keywordMatch if the argument was provided, dont send null values
    if keywordMatch is not None:
        query_parameters.update({"keywordMatch": keywordMatch})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send keywordField if the argument was provided, dont send null values
    if keywordField is not None:
        query_parameters.update({"keywordField": keywordField})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        query_parameters.update({"name": name})
    # Only send hostID if the argument was provided, dont send null values
    if hostID is not None:
        query_parameters.update({"hostID": hostID})
    # Only send serviceID if the argument was provided, dont send null values
    if serviceID is not None:
        query_parameters.update({"serviceID": serviceID})
    # Only send businessProcessID if the argument was provided, dont send null values
    if businessProcessID is not None:
        query_parameters.update({"businessProcessID": businessProcessID})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        query_parameters.update({"customerID": customerID})
    # Only send ip if the argument was provided, dont send null values
    if ip is not None:
        query_parameters.update({"ip": ip})
    # Only send port if the argument was provided, dont send null values
    if port is not None:
        query_parameters.update({"port": port})
    # Only send protocol if the argument was provided, dont send null values
    if protocol is not None:
        query_parameters.update({"protocol": protocol})
    # Only send cpe if the argument was provided, dont send null values
    if cpe is not None:
        query_parameters.update({"cpe": cpe})
    # Only send vulnID if the argument was provided, dont send null values
    if vulnID is not None:
        query_parameters.update({"vulnID": vulnID})
    # Only send vulnRef if the argument was provided, dont send null values
    if vulnRef is not None:
        query_parameters.update({"vulnRef": vulnRef})
    # Only send resolutionCode if the argument was provided, dont send null values
    if resolutionCode is not None:
        query_parameters.update({"resolutionCode": resolutionCode})
    # Only send severity if the argument was provided, dont send null values
    if severity is not None:
        query_parameters.update({"severity": severity})
    # Only send includeFlag if the argument was provided, dont send null values
    if includeFlag is not None:
        query_parameters.update({"includeFlag": includeFlag})
    # Only send excludeFlag if the argument was provided, dont send null values
    if excludeFlag is not None:
        query_parameters.update({"excludeFlag": excludeFlag})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    # Only send countTimeout if the argument was provided, dont send null values
    if countTimeout is not None:
        query_parameters.update({"countTimeout": countTimeout})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("assets", "v1", "vulnerability"),
    module=argus_cli_module
)
def search_asset_vulnerability_statistics(
    name: str = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    keywords: str = None,
    keywordMatchStrategy: str = None,
    timeMatchStrategy: str = None,
    hostID: str = None,
    serviceID: str = None,
    businessProcessID: str = None,
    ipRange: str = None,
    applicationPort: int = None,
    applicationProtocol: str = None,
    cpe: str = None,
    hostCPE: str = None,
    applicationCPE: str = None,
    countTimeout: int = None,
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    subCriteria: dict = None,
    exclude: bool = None,
    required: bool = None,
    customerID: int = None,
    minimumCvss: float = None,
    maximumCvss: float = None,
    severity: str = None,
    resolutionCode: str = None,
    vulnerabilityReference: str = None,
    vulnerabilityID: str = None,
    timeFieldStrategy: str = None,
    keywordFieldStrategy: str = None,
    includeRawOutput: bool = None,
    includeConclusion: bool = None,
    includeSolution: bool = None,
    groupBy: str = None,
    values: str = None,
    resolution: int = None,
    cutoff: int = None,
    cutoffValue: str = None,
    includeOthers: bool = None,
    sortBy: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch asset vulnerability statistics base on criteria (DEV)
    
    :param list name: Restrict search to specific asset name
    :param int startTimestamp: Restrict search to a time frame based on the set TimeFieldStrategy (start timestamp).
    :param int endTimestamp: Restrict search to a time frame based on the set TimeFieldStrategy (end timestamp).
    :param list keywords: Search for keywords.
    :param str keywordMatchStrategy: Defines the MatchStrategy for keywords (default match all keywords).
    :param str timeMatchStrategy: Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any)
    :param list hostID: Restrict search to specific host UUIDs.
    :param list serviceID: Restrict search to specific service UUIDs.
    :param list businessProcessID: Restrict search to specific business process UUIDs.
    :param str ipRange: Restrict search to entities related to these IP-addresses (may specify single IPs, IP networks or IP ranges.
    :param list applicationPort: Restrict to applications listening on specific ports.
    :param list applicationProtocol: Restrict to applications by transport protocol name.
    :param str cpe: Restrict to applications or hosts by CPE.
    :param str hostCPE: Restrict to hosts by CPE.
    :param str applicationCPE: Restrict to applications by CPE.
    :param int countTimeout: Max wait in seconds for count query, if max wait passed and count query still executing the query; or -1 is set to indicate do not count, then the query will be cancelled and return count -1. Default value 0 means execute as long as service allows, -1 means do not count, max value is 30 (seconds).
    :param int limit: Set this value to set max number of results. By default, no restriction on result set size. 
    :param int offset: Set this value to skip the first (offset) objects. By default, return result from first object. 
    :param bool includeDeleted: Set to true to include deleted objects. By default, exclude deleted objects. 
    :param list subCriteria: Set additional criterias which are applied using a logical OR. 
    :param bool exclude: Only relevant for subcriteria. If set to true, objects matching this subcriteria object will be excluded. 
    :param bool required: Only relevant for subcriteria. If set to true, objects matching this subcriteria are required (AND-ed together with parent criteria). 
    :param list customerID: Restrict search to data belonging to specified customers. 
    :param float minimumCvss: Restrict search to vulnerabilities with CVSS score at least this high. 
    :param float maximumCvss: Restrict search to vulnerabilities with CVSS score no more than this. 
    :param list severity: Restrict search to specified severity levels. 
    :param list resolutionCode: Restrict search to specific resolution codes. 
    :param list vulnerabilityReference: Restrict to vulnerabilities identified by vulnerability reference. 
    :param list vulnerabilityID: Restrict to vulnerabilities identified by vulnerability ID. 
    :param list timeFieldStrategy: Defines which timestamps will be included in the search (default lastUpdatedTimestamp). 
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords (default all supported fields). 
    :param bool includeRawOutput: Include vulnerability rawOutput in result (default false) 
    :param bool includeConclusion: Include vulnerability conclusion in result (default false) 
    :param bool includeSolution: Include vulnerability solution in result (default false) 
    :param list groupBy: Specify which fields will be grouped by in stats 
    :param list values: Specify which values will be included in stats (default vulnerabilities) 
    :param int resolution: Stats resolution period in milliseconds, if is 0 means to generate non-timeline statistics 
    :param int cutoff: Reduce stats keys to the cutoff amount of keys that has largest hit count, default 0 means no reduce 
    :param str cutoffValue: Specify which value to be cutoff on (default vulnerabilities) 
    :param bool includeOthers: If reduce (cutoff >0), true means remaining keys (other than cutoff keys) are collected into an "other" key, default false 
    :param list sortBy: List of properties to sort by (prefix with "-" to sort descending). 
    :param list includeFlags: Only include objects which have includeFlags set. 
    :param list excludeFlags: Exclude objects which have excludeFlags set. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v1/vulnerability/statistics".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordMatchStrategy if the argument was provided, dont send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send timeMatchStrategy if the argument was provided, dont send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send hostID if the argument was provided, dont send null values
    if hostID is not None:
        body.update({"hostID": hostID})
    # Only send serviceID if the argument was provided, dont send null values
    if serviceID is not None:
        body.update({"serviceID": serviceID})
    # Only send businessProcessID if the argument was provided, dont send null values
    if businessProcessID is not None:
        body.update({"businessProcessID": businessProcessID})
    # Only send ipRange if the argument was provided, dont send null values
    if ipRange is not None:
        body.update({"ipRange": ipRange})
    # Only send applicationPort if the argument was provided, dont send null values
    if applicationPort is not None:
        body.update({"applicationPort": applicationPort})
    # Only send applicationProtocol if the argument was provided, dont send null values
    if applicationProtocol is not None:
        body.update({"applicationProtocol": applicationProtocol})
    # Only send cpe if the argument was provided, dont send null values
    if cpe is not None:
        body.update({"cpe": cpe})
    # Only send hostCPE if the argument was provided, dont send null values
    if hostCPE is not None:
        body.update({"hostCPE": hostCPE})
    # Only send applicationCPE if the argument was provided, dont send null values
    if applicationCPE is not None:
        body.update({"applicationCPE": applicationCPE})
    # Only send countTimeout if the argument was provided, dont send null values
    if countTimeout is not None:
        body.update({"countTimeout": countTimeout})
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send exclude if the argument was provided, dont send null values
    if exclude is not None:
        body.update({"exclude": exclude})
    # Only send required if the argument was provided, dont send null values
    if required is not None:
        body.update({"required": required})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send minimumCvss if the argument was provided, dont send null values
    if minimumCvss is not None:
        body.update({"minimumCvss": minimumCvss})
    # Only send maximumCvss if the argument was provided, dont send null values
    if maximumCvss is not None:
        body.update({"maximumCvss": maximumCvss})
    # Only send severity if the argument was provided, dont send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send resolutionCode if the argument was provided, dont send null values
    if resolutionCode is not None:
        body.update({"resolutionCode": resolutionCode})
    # Only send vulnerabilityReference if the argument was provided, dont send null values
    if vulnerabilityReference is not None:
        body.update({"vulnerabilityReference": vulnerabilityReference})
    # Only send vulnerabilityID if the argument was provided, dont send null values
    if vulnerabilityID is not None:
        body.update({"vulnerabilityID": vulnerabilityID})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send keywordFieldStrategy if the argument was provided, dont send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send includeRawOutput if the argument was provided, dont send null values
    if includeRawOutput is not None:
        body.update({"includeRawOutput": includeRawOutput})
    # Only send includeConclusion if the argument was provided, dont send null values
    if includeConclusion is not None:
        body.update({"includeConclusion": includeConclusion})
    # Only send includeSolution if the argument was provided, dont send null values
    if includeSolution is not None:
        body.update({"includeSolution": includeSolution})
    # Only send groupBy if the argument was provided, dont send null values
    if groupBy is not None:
        body.update({"groupBy": groupBy})
    # Only send values if the argument was provided, dont send null values
    if values is not None:
        body.update({"values": values})
    # Only send resolution if the argument was provided, dont send null values
    if resolution is not None:
        body.update({"resolution": resolution})
    # Only send cutoff if the argument was provided, dont send null values
    if cutoff is not None:
        body.update({"cutoff": cutoff})
    # Only send cutoffValue if the argument was provided, dont send null values
    if cutoffValue is not None:
        body.update({"cutoffValue": cutoffValue})
    # Only send includeOthers if the argument was provided, dont send null values
    if includeOthers is not None:
        body.update({"includeOthers": includeOthers})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v1", "vulnerability"),
    module=argus_cli_module
)
def update_asset_vulnerability(
    id: str,
    addReferences: str = None,
    deleteReferences: str = None,
    name: str = None,
    description: str = None,
    conclusion: str = None,
    solution: str = None,
    rawOutput: str = None,
    cvss: float = None,
    severity: str = None,
    addProperties: dict = None,
    deleteProperties: str = None,
    exploitAvailable: bool = None,
    source: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Updates an existing AssetVulnerability. (PUBLIC)
    
    :param str id: AssetVulnerability ID
    :param list addReferences: Add references to vulnerability (e.g. CVE number). 
    :param list deleteReferences: Delete references from vulnerability. 
    :param str name: Change vulnerability name. Will be sanitized and no line break allowed. 
    :param str description: Change vulnerability description. Will be sanitized. 
    :param str conclusion: Change vulnerability summary. Will be sanitized. 
    :param str solution: Change vulnerability solution. Will be sanitized. 
    :param str rawOutput: Change raw output from vulnerability scan. Will be sanitized. 
    :param float cvss: Change CVSS score of vulnerability (range from 0 to 10). 
    :param str severity: Change severity level of vulnerability. 
    :param dict addProperties: Add custom properties (updates a property if key already exists).  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param list deleteProperties: Delete custom properties by key. 
    :param bool exploitAvailable: Set if an exploit is available for the vulnerability. 
    :param str source: Source of the request. (default USER)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v1/vulnerability/{id}".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send addReferences if the argument was provided, dont send null values
    if addReferences is not None:
        body.update({"addReferences": addReferences})
    # Only send deleteReferences if the argument was provided, dont send null values
    if deleteReferences is not None:
        body.update({"deleteReferences": deleteReferences})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send conclusion if the argument was provided, dont send null values
    if conclusion is not None:
        body.update({"conclusion": conclusion})
    # Only send solution if the argument was provided, dont send null values
    if solution is not None:
        body.update({"solution": solution})
    # Only send rawOutput if the argument was provided, dont send null values
    if rawOutput is not None:
        body.update({"rawOutput": rawOutput})
    # Only send cvss if the argument was provided, dont send null values
    if cvss is not None:
        body.update({"cvss": cvss})
    # Only send severity if the argument was provided, dont send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send addProperties if the argument was provided, dont send null values
    if addProperties is not None:
        body.update({"addProperties": addProperties})
    # Only send deleteProperties if the argument was provided, dont send null values
    if deleteProperties is not None:
        body.update({"deleteProperties": deleteProperties})
    # Only send exploitAvailable if the argument was provided, dont send null values
    if exploitAvailable is not None:
        body.update({"exploitAvailable": exploitAvailable})
    # Only send source if the argument was provided, dont send null values
    if source is not None:
        body.update({"source": source})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()

