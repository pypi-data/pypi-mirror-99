"""Autogenerated API"""
from argus_api import session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def add_vulnerability(
    customer: str = None,
    asset: str = None,
    vulnerability: str = None,
    components: dict = None,
    severity: str = None,
    rawOutput: str = None,
    ttl: int = None,
    cvss: float = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Creates a new vulnerability instance (DEV)
    
    :param str customer: ID or short name of customer, if not specified then current user's customer will be assigned. 
    :param str asset: ID or short name of asset. If short name is specified, then the asset is looked up from the customer. 
    :param str vulnerability: Either vulnerability definition ID (UUID) or vulnerability identifier (e.g. CVE-2015-3429). First the value will be used to lookup vulnerability definition (UUID will only be supported for vulnerability definition lookup). If vulnerability definition exists, then associate this vulnerability instance to it, and require read permission on vulnerability source of the definition. Otherwise create vulnerability instance with vulnerability identifier.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param list components: Specify components to be added with the vulnerability. 
    :param str severity: Severity level of vulnerability. If not provided, then severity will be calculated based on CVSS value. 
    :param str rawOutput: Raw output from vulnerability scan. Will be sanitized as html. 
    :param int ttl: Time to live duration of this vulnerability since last seen, 0 means won't expire. 
    :param float cvss: CVSS score of vulnerability (range from 0 to 10). (default 0.0)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send asset if the argument was provided, dont send null values
    if asset is not None:
        body.update({"asset": asset})
    # Only send vulnerability if the argument was provided, dont send null values
    if vulnerability is not None:
        body.update({"vulnerability": vulnerability})
    # Only send components if the argument was provided, dont send null values
    if components is not None:
        body.update({"components": components})
    # Only send cvss if the argument was provided, dont send null values
    if cvss is not None:
        body.update({"cvss": cvss})
    # Only send severity if the argument was provided, dont send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send rawOutput if the argument was provided, dont send null values
    if rawOutput is not None:
        body.update({"rawOutput": rawOutput})
    # Only send ttl if the argument was provided, dont send null values
    if ttl is not None:
        body.update({"ttl": ttl})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def add_vulnerability_definition(
    vulnerabilitySource: str = None,
    vulnerabilityID: str = None,
    name: str = None,
    description: str = None,
    solution: str = None,
    conclusion: str = None,
    references: str = None,
    exploitAvailable: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Creates a new vulnerability definition also require to have read & write permission of vulnerability source that the definition is belonging to. (DEV)
    
    :param str vulnerabilitySource: Define vulnerability source by source ID or short name. 
    :param str vulnerabilityID: Identifier of vulnerability (e.g. plug-in ID from vulnerability scanner). Needs to be unique.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str name: Name of vulnerability. Will be sanitized as text. 
    :param str description: Description of vulnerability. Will be sanitized as html. 
    :param str solution: How to fix vulnerability. Will be sanitized as html. 
    :param str conclusion: Short summary of vulnerability. Will be sanitized as html. 
    :param list references: References to vulnerability (e.g. CVE number). Will be sanitized as html. 
    :param bool exploitAvailable: Set if an exploit is available for the vulnerability. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/definition".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send vulnerabilitySource if the argument was provided, dont send null values
    if vulnerabilitySource is not None:
        body.update({"vulnerabilitySource": vulnerabilitySource})
    # Only send vulnerabilityID if the argument was provided, dont send null values
    if vulnerabilityID is not None:
        body.update({"vulnerabilityID": vulnerabilityID})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send solution if the argument was provided, dont send null values
    if solution is not None:
        body.update({"solution": solution})
    # Only send conclusion if the argument was provided, dont send null values
    if conclusion is not None:
        body.update({"conclusion": conclusion})
    # Only send references if the argument was provided, dont send null values
    if references is not None:
        body.update({"references": references})
    # Only send exploitAvailable if the argument was provided, dont send null values
    if exploitAvailable is not None:
        body.update({"exploitAvailable": exploitAvailable})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def add_vulnerability_source(
    shortName: str = None,
    name: str = None,
    readPermission: str = None,
    writePermission: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Creates a new VulnerabilitySource (DEV)
    
    :param str shortName: Vulnerability source short name, required and unique  => [a-zA-Z0-9_\-\.]*
    :param str name: Name of source  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str readPermission: Permission required to allow read access of source & vulnerability definition belong to this source  => [a-zA-Z0-9_\-\.]*
    :param str writePermission: Permission required to allow write access (create/update/delete) source & of vulnerability definition belong to this source  => [a-zA-Z0-9_\-\.]*
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/source".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send readPermission if the argument was provided, dont send null values
    if readPermission is not None:
        body.update({"readPermission": readPermission})
    # Only send writePermission if the argument was provided, dont send null values
    if writePermission is not None:
        body.update({"writePermission": writePermission})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def delete_vulnerability(
    id: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Delete vulnerability (DEV)
    
    :param str id: vulnerability ID
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/{id}".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def delete_vulnerability_definition(
    idOrVulnerabilityID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Delete Vulnerability definition, also require to have read & write permission of vulnerability source that the definition is belonging to. (DEV)
    
    :param str idOrVulnerabilityID: Vulnerability definition ID or identifier of vulnerability
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/definition/{idOrVulnerabilityID}".format(idOrVulnerabilityID=idOrVulnerabilityID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def delete_vulnerability_source(
    source: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Marks a VulnerabilitySource as deleted (DEV)
    
    :param str source: VulnerabilitySource ID or short name
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/source/{source}".format(source=source)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def get_vulnerability_by_id(
    id: str,
    includeRawOutput: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Get Vulnerability by ID. (DEV)
    
    :param str id: Vulnerability ID (UUID)
    :param bool includeRawOutput: Whether include raw output, default not include
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/{id}".format(id=id,
        includeRawOutput=includeRawOutput)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send includeRawOutput if the argument was provided, dont send null values
    if includeRawOutput is not None:
        query_parameters.update({"includeRawOutput": includeRawOutput})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def get_vulnerability_definition(
    idOrVulnerabilityID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Get Vulnerability definition, also require to have read permission of vulnerability source that the definition is belonging to. (DEV)
    
    :param str idOrVulnerabilityID: Vulnerability definition ID or identifier of vulnerability
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/definition/{idOrVulnerabilityID}".format(idOrVulnerabilityID=idOrVulnerabilityID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def get_vulnerability_source(
    source: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Get VulnerabilitySource (DEV)
    
    :param str source: VulnerabilitySource ID or short name
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/source/{source}".format(source=source)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def list_vulnerabilities(
    customer: str = None,
    asset: str = None,
    vulnerabilityID: str = None,
    severity: str = None,
    timeFieldStrategy: str = None,
    sortBy: str = None,
    limit: int = 25,
    startTimestamp: str = "0",
    endTimestamp: str = "0",
    offset: int = None,
    includeDeleted: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Basic Vulnerability search. Will not return vulnerabilities seen more than 3 months ago. Please use advanced search to return older vulnerabilities. If start/end timestamps are present, the range must be valid for at least one of the time stamp fields. Check the documentation for the TimestampFieldStrategy field for more details.  (DEV)
    
    :param list customer: Customer ids or short names
    :param list asset: Asset ids or short names. Will resolve with the provided customers, or those the current user has access to if none are provided
    :param list vulnerabilityID: Vulnerability external ID
    :param str severity: Vulnerability Severity
    :param list timeFieldStrategy: Which time field(s) to filter by timestamp start/end
    :param list sortBy: Field(s) to sort by - refer to the search POST endpoint to see which fields are permitted
    :param int limit: Limit results. The sum of limit and offset must be <= 10'000
    :param str startTimestamp: Lower bound timestamp filter value
    :param str endTimestamp: Upper bound timestamp filter value
    :param int offset: Offset results. The sum of limit and offset must be <= 10'000
    :param bool includeDeleted: Include deleted
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability".format(limit=limit,
        startTimestamp=startTimestamp,
        endTimestamp=endTimestamp,
        customer=customer,
        asset=asset,
        vulnerabilityID=vulnerabilityID,
        severity=severity,
        offset=offset,
        includeDeleted=includeDeleted,
        timeFieldStrategy=timeFieldStrategy,
        sortBy=sortBy)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send asset if the argument was provided, dont send null values
    if asset is not None:
        query_parameters.update({"asset": asset})
    # Only send vulnerabilityID if the argument was provided, dont send null values
    if vulnerabilityID is not None:
        query_parameters.update({"vulnerabilityID": vulnerabilityID})
    # Only send severity if the argument was provided, dont send null values
    if severity is not None:
        query_parameters.update({"severity": severity})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        query_parameters.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def reopen_vulnerability(
    id: str,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Reopens a vulnerability, marking it as unresolved. (DEV)
    
    :param str id: Vulnerability ID
    :param str comment: Comment describing why the vulnerability should be reopened 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/{id}/reopen".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send comment if the argument was provided, dont send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def resolve_vulnerability(
    id: str,
    resolution: str = None,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Resolves a vulnerability. (DEV)
    
    :param str id: Vulnerability ID
    :param str resolution: Specify resolution reason. 
    :param str comment: Comment on why the vulnerability is resolved.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/{id}/resolve".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send resolution if the argument was provided, dont send null values
    if resolution is not None:
        body.update({"resolution": resolution})
    # Only send comment if the argument was provided, dont send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def search_vulnerabilities(
    sortBy: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    userFieldStrategy: str = None,
    user: str = None,
    asset: str = None,
    assetGroup: str = None,
    vulnerabilityID: str = None,
    vulnerabilityDefinition: str = None,
    customer: str = None,
    severity: str = None,
    resolution: str = None,
    minimumCvss: float = None,
    maximumCvss: float = None,
    component: dict = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    subCriteria: dict = None,
    indexStartTimestamp: int = None,
    indexEndTimestamp: int = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    includeRawOutput: bool = None,
    limit: int = 25,
    offset: int = None,
    includeDeleted: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Search Vulnerabilities (DEV)
    
    :param list sortBy: 
    :param list timeFieldStrategy: Defines which timestamps fields will be filtered with start/endTimestamp (default lastSeenTimestamp)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any) (default any)
    :param list userFieldStrategy: Defines which user fields will be filtered with user ids or shortnames (default all)
    :param list user: Retrieve vulnerabilities by these users, identified by their id or username 
    :param list asset: Retrieve vulnerabilities detected on these assets by asset id or shortNames. As assets are customer specific we will resolve the assets for the customers provided in the criteria, if any. If none are provided, we attempt to use the customers the current user has access to. 
    :param list assetGroup: Retrieve vulnerabilities detected on assets who are members of these groups identified by id or shortNames. As asset groups are customer specific we will resolve the groups for the customers provided in the criteria, if any. If none are provided, we attempt to use the customers the current user has access to. 
    :param list vulnerabilityID: Retrieve vulnerabilities by their external ID e.g. CVE-XXXX 
    :param list vulnerabilityDefinition: Retrieve vulnerabilities by their vulnerability definition id or name 
    :param list customer: Retrieve vulnerabilities by Customer id or name 
    :param str severity: Retrieve vulnerabilities with this severity 
    :param str resolution: Retrieve vulnerabilities with this resolution 
    :param float minimumCvss: Retrieve Vulnerabilities with at least this CVSS score 
    :param float maximumCvss: Retrieve Vulnerabilities with at most this CVSS score 
    :param list component: Retrieve vulnerabilities by component 
    :param list includeFlags: Explicitly retrieve Vulnerabilities that contain these flags 
    :param list excludeFlags: Explicitly filter out Vulnerabilities that contain these flags 
    :param list subCriteria: Set additional criteria that are applied with logical OR by default 
    :param int indexStartTimestamp: Limit search to indices created on or after this timestamp. Must be in the range [6 months ago - today]. 
    :param int indexEndTimestamp: Limit search to indices created on or before this timestamp. Must be in the range [6 months ago - today]. 
    :param int startTimestamp: Restrict to a time frame based on the set timeFieldStrategy (start timestamp) (default 0)
    :param int endTimestamp: Restrict to a time frame based on the set timeFieldStrategy (end timestamp) (default 0)
    :param bool includeRawOutput: Whether to include raw output in the result objects (default false)
    :param int limit: Limit the results to the specified amount. If the sum of offset and limit is greater than 10'000 the results will likely be incomplete as 10'000 exceeds the search engine's maximum result window. (default 25)
    :param int offset: Skip specified amount of results. If the sum of offset and limit is greater than 10'000 the results will likely be incomplete as 10'000 exceeds the search engine's maximum result window. (default 0)
    :param bool includeDeleted: Whether to include deleted Vulnerabilities (default false)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/search".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, dont send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send userFieldStrategy if the argument was provided, dont send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send user if the argument was provided, dont send null values
    if user is not None:
        body.update({"user": user})
    # Only send asset if the argument was provided, dont send null values
    if asset is not None:
        body.update({"asset": asset})
    # Only send assetGroup if the argument was provided, dont send null values
    if assetGroup is not None:
        body.update({"assetGroup": assetGroup})
    # Only send vulnerabilityID if the argument was provided, dont send null values
    if vulnerabilityID is not None:
        body.update({"vulnerabilityID": vulnerabilityID})
    # Only send vulnerabilityDefinition if the argument was provided, dont send null values
    if vulnerabilityDefinition is not None:
        body.update({"vulnerabilityDefinition": vulnerabilityDefinition})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send severity if the argument was provided, dont send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send resolution if the argument was provided, dont send null values
    if resolution is not None:
        body.update({"resolution": resolution})
    # Only send minimumCvss if the argument was provided, dont send null values
    if minimumCvss is not None:
        body.update({"minimumCvss": minimumCvss})
    # Only send maximumCvss if the argument was provided, dont send null values
    if maximumCvss is not None:
        body.update({"maximumCvss": maximumCvss})
    # Only send component if the argument was provided, dont send null values
    if component is not None:
        body.update({"component": component})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send includeRawOutput if the argument was provided, dont send null values
    if includeRawOutput is not None:
        body.update({"includeRawOutput": includeRawOutput})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send indexStartTimestamp if the argument was provided, dont send null values
    if indexStartTimestamp is not None:
        body.update({"indexStartTimestamp": indexStartTimestamp})
    # Only send indexEndTimestamp if the argument was provided, dont send null values
    if indexEndTimestamp is not None:
        body.update({"indexEndTimestamp": indexEndTimestamp})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def search_vulnerability_sources(
    sortBy: str = None,
    source: str = None,
    keywords: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    subCriteria: dict = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    includeDeleted: bool = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Search VulnerabilitySource with specified criteria (DEV)
    
    :param list sortBy: 
    :param list source: Restrict to specified Vulnerability source (ID or short name) 
    :param list keywords: Search for keywords against fields defined by keywordFieldStrategy 
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords (default all supported fields) (default all)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched (default match all keywords) (default all)
    :param list timeFieldStrategy: Defines which timestamps will be included in the search (default lastUpdatedTimestamp) (default lastUpdatedTimestamp)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any) (default any)
    :param list subCriteria: Set additional criteria which are applied with logical OR by default 
    :param int startTimestamp: Restrict to a time frame based on the set timeFieldStrategy (start timestamp) (default 0)
    :param int endTimestamp: Restrict to a time frame based on the set timeFieldStrategy (end timestamp) (default 0)
    :param bool includeDeleted: Whether include deleted results (default false)
    :param int limit: Limit maximum amount of results (default 25)
    :param int offset: Skip specified amount of results (default 0)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/source/search".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send source if the argument was provided, dont send null values
    if source is not None:
        body.update({"source": source})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordFieldStrategy if the argument was provided, dont send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, dont send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, dont send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def search_vulnerability_sources_simplified(
    keywords: str = None,
    keywordField: str = None,
    timeField: str = None,
    source: str = None,
    sortBy: str = None,
    limit: int = 25,
    keywordMatch: str = "all",
    startTimestamp: str = "0",
    endTimestamp: str = "0",
    timeMatch: str = "any",
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Search VulnerabilitySources with specified query parameters (DEV)
    
    :param list keywords: Search by keywords
    :param list keywordField: Set field strategy for keyword search
    :param list timeField: Set field strategy for time range search
    :param list source: Search by sources (ID or short name)
    :param list sortBy: Sort search result
    :param int limit: Maximum number of returned results
    :param str keywordMatch: Set match strategy for keyword search
    :param str startTimestamp: Start timestamp for time range search
    :param str endTimestamp: End timestamp for time range search
    :param str timeMatch: Set match strategy for time range search
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/source".format(limit=limit,
        keywordMatch=keywordMatch,
        startTimestamp=startTimestamp,
        endTimestamp=endTimestamp,
        timeMatch=timeMatch,
        offset=offset,
        keywords=keywords,
        keywordField=keywordField,
        timeField=timeField,
        source=source,
        sortBy=sortBy)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send keywordMatch if the argument was provided, dont send null values
    if keywordMatch is not None:
        query_parameters.update({"keywordMatch": keywordMatch})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    # Only send timeMatch if the argument was provided, dont send null values
    if timeMatch is not None:
        query_parameters.update({"timeMatch": timeMatch})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send keywordField if the argument was provided, dont send null values
    if keywordField is not None:
        query_parameters.update({"keywordField": keywordField})
    # Only send timeField if the argument was provided, dont send null values
    if timeField is not None:
        query_parameters.update({"timeField": timeField})
    # Only send source if the argument was provided, dont send null values
    if source is not None:
        query_parameters.update({"source": source})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def update_vulnerability(
    id: str,
    vulnerabilityDefinition: str = None,
    addComponents: dict = None,
    deleteComponents: str = None,
    cvss: float = None,
    severity: str = None,
    rawOutput: str = None,
    ttl: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Updates an existing Vulnerability (DEV)
    
    :param str id: vulnerability ID
    :param str vulnerabilityDefinition: Assign vulnerability definition. Only allowed when there was no vulnerability definition assigned. 
    :param list addComponents: Specify components to be added with the vulnerability. 
    :param list deleteComponents: Specify IDs of the components to be deleted from the vulnerability. 
    :param float cvss: Update CVSS score of vulnerability (range from 0 to 10). 
    :param str severity: Update severity level of vulnerability. 
    :param str rawOutput: Update raw output from vulnerability scan. Will be sanitized as html. 
    :param int ttl: Time to live duration of this vulnerability since last seen, 0 means won't expire. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/{id}".format(id=id)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send vulnerabilityDefinition if the argument was provided, dont send null values
    if vulnerabilityDefinition is not None:
        body.update({"vulnerabilityDefinition": vulnerabilityDefinition})
    # Only send addComponents if the argument was provided, dont send null values
    if addComponents is not None:
        body.update({"addComponents": addComponents})
    # Only send deleteComponents if the argument was provided, dont send null values
    if deleteComponents is not None:
        body.update({"deleteComponents": deleteComponents})
    # Only send cvss if the argument was provided, dont send null values
    if cvss is not None:
        body.update({"cvss": cvss})
    # Only send severity if the argument was provided, dont send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send rawOutput if the argument was provided, dont send null values
    if rawOutput is not None:
        body.update({"rawOutput": rawOutput})
    # Only send ttl if the argument was provided, dont send null values
    if ttl is not None:
        body.update({"ttl": ttl})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def update_vulnerability_definition(
    idOrVulnerabilityID: str,
    name: str = None,
    description: str = None,
    solution: str = None,
    conclusion: str = None,
    addReferences: str = None,
    deleteReferences: str = None,
    exploitAvailable: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Updates an existing Vulnerability definition, also require to have read & write permission of vulnerability source that the definition is belonging to. (DEV)
    
    :param str idOrVulnerabilityID: Vulnerability definition ID or identifier of vulnerability
    :param str name: Update name of the vulnerability definition. Will be sanitized as text. 
    :param str description: Update description of the vulnerability definition. Will be sanitized as html. 
    :param str solution: Update how to fix the vulnerability. Will be sanitized as html. 
    :param str conclusion: Update short summary of the vulnerability. Will be sanitized as html. 
    :param list addReferences: Add references to the vulnerability definition (e.g. CVE number). Will be sanitized as html. 
    :param list deleteReferences: Delete references from the vulnerability definition. Will be sanitized as html first before check against existing references. 
    :param bool exploitAvailable: Update whether an exploit is available for the vulnerability. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/definition/{idOrVulnerabilityID}".format(idOrVulnerabilityID=idOrVulnerabilityID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send solution if the argument was provided, dont send null values
    if solution is not None:
        body.update({"solution": solution})
    # Only send conclusion if the argument was provided, dont send null values
    if conclusion is not None:
        body.update({"conclusion": conclusion})
    # Only send addReferences if the argument was provided, dont send null values
    if addReferences is not None:
        body.update({"addReferences": addReferences})
    # Only send deleteReferences if the argument was provided, dont send null values
    if deleteReferences is not None:
        body.update({"deleteReferences": deleteReferences})
    # Only send exploitAvailable if the argument was provided, dont send null values
    if exploitAvailable is not None:
        body.update({"exploitAvailable": exploitAvailable})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def update_vulnerability_source(
    source: str,
    shortName: str = None,
    name: str = None,
    readPermission: str = None,
    writePermission: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Updates an existing VulnerabilitySource (DEV)
    
    :param str source: VulnerabilitySource ID or short name
    :param str shortName: Update short name of vulnerability source  => [a-zA-Z0-9_\-\.]*
    :param str name: Update name of vulnerability source  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str readPermission: Update the permission required to allow read access of source & vulnerability definition belong to the source  => [a-zA-Z0-9_\-\.]*
    :param str writePermission: Update the permission required to allow write access (create/update/delete) of source & vulnerability definition belong to the source  => [a-zA-Z0-9_\-\.]*
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/source/{source}".format(source=source)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send readPermission if the argument was provided, dont send null values
    if readPermission is not None:
        body.update({"readPermission": readPermission})
    # Only send writePermission if the argument was provided, dont send null values
    if writePermission is not None:
        body.update({"writePermission": writePermission})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()

