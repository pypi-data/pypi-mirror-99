"""Autogenerated API"""
from argus_api import session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module
from requests import Response

log = logging.getLogger(__name__)


@register_command(
    extending=("assets", "v2", "asset"),
    module=argus_cli_module
)
def add_asset(
    customer: str = None,
    shortName: str = None,
    name: str = None,
    description: str = None,
    owner: str = None,
    criticality: dict = None,
    assetDefinition: str = None,
    components: dict = None,
    ttl: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Creates a new Asset (DEV)
    
    :param str customer: ID or short name of customer, if not specified then current user's customer will be assigned 
    :param str shortName: Short name of asset  => [a-zA-Z0-9_\-\.]*
    :param str name: Name of asset  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str description: Description of asset. May use HTML, which will be sanitized 
    :param str owner: ID or username of user who owns the asset. When username is specified, it should exist within current user's domain 
    :param dict criticality: 
    :param str assetDefinition: ID or short name of asset definition, it should exist within current user's domain 
    :param list components: Specify components to be added with the asset 
    :param int ttl: Time to live duration of this asset since last seen, 0 means won't expire. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/asset".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send owner if the argument was provided, dont send null values
    if owner is not None:
        body.update({"owner": owner})
    # Only send criticality if the argument was provided, dont send null values
    if criticality is not None:
        body.update({"criticality": criticality})
    # Only send assetDefinition if the argument was provided, dont send null values
    if assetDefinition is not None:
        body.update({"assetDefinition": assetDefinition})
    # Only send components if the argument was provided, dont send null values
    if components is not None:
        body.update({"components": components})
    # Only send ttl if the argument was provided, dont send null values
    if ttl is not None:
        body.update({"ttl": ttl})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "asset"),
    module=argus_cli_module
)
def add_asset_definition(
    domain: str = None,
    shortName: str = None,
    name: str = None,
    component: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Creates a new AssetDefinition (DEV)
    
    :param str domain: ID or name of domain, if not specified current user domain will be assigned 
    :param str shortName: Asset definition short name, required and unique per domain  => [a-zA-Z0-9_\-\.]*
    :param str name: Asset definition name  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param list component: Component definitions (ID or short name) to be included for the asset definition 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/asset/definition".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send component if the argument was provided, dont send null values
    if component is not None:
        body.update({"component": component})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "asset"),
    module=argus_cli_module
)
def delete_asset(
    idOrShortName: str,
    customer: str = None,
    forceIndex: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Delete asset (DEV)
    
    :param str idOrShortName: Asset ID or short name
    :param str customer: Customer ID or short name (default is user's customer), only used when short name was provided
    :param bool forceIndex: Whether to force an Elasticsearch index refresh such that the Asset is immediately no longer searchable.
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/asset/{idOrShortName}".format(idOrShortName=idOrShortName,
        customer=customer,
        forceIndex=forceIndex)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send forceIndex if the argument was provided, dont send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "asset"),
    module=argus_cli_module
)
def delete_asset_definition(
    definition: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Marks a AssetDefinition as deleted (DEV)
    
    :param str definition: AssetDefinition ID or short name
    :param str domain: Domain ID or name (default is user's domain), only used when definition is short name
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/asset/definition/{definition}".format(definition=definition,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "asset"),
    module=argus_cli_module
)
def get_asset(
    idOrShortName: str,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Get Asset (DEV)
    
    :param str idOrShortName: Asset ID or short name
    :param str customer: Customer ID or short name (default is user's customer), only used when short name was provided
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/asset/{idOrShortName}".format(idOrShortName=idOrShortName,
        customer=customer)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "asset"),
    module=argus_cli_module
)
def get_asset_definition(
    definition: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Get AssetDefinition (DEV)
    
    :param str definition: AssetDefinition ID or short name
    :param str domain: Domain ID or name (default is user's domain), only used when definition is short name
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/asset/definition/{definition}".format(definition=definition,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "asset"),
    module=argus_cli_module
)
def get_vulnerability_by_asset(
    asset: str,
    customer: str = None,
    includeRawOutput: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Get Vulnerabilities belong to the Asset. (DEV)
    
    :param str asset: Asset ID or short name.
    :param str customer: Customer ID or short name (default is user's customer) to help resolve asset, only used when asset's short name was provided.
    :param bool includeRawOutput: Whether include raw output, default not include
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/asset/{asset}/vulnerability".format(asset=asset,
        customer=customer,
        includeRawOutput=includeRawOutput)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send includeRawOutput if the argument was provided, dont send null values
    if includeRawOutput is not None:
        query_parameters.update({"includeRawOutput": includeRawOutput})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "asset"),
    module=argus_cli_module
)
def get_vulnerability_by_asset_and_vulnerability_id(
    asset: str,
    vulnerabilityID: str,
    customer: str = None,
    includeRawOutput: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Get Vulnerabilities belong to the Asset and have same identifier of vulnerability. (DEV)
    
    :param str asset: Asset ID or short name.
    :param str vulnerabilityID: Identifier of vulnerability (e.g. CVE-2015-3429)
    :param str customer: Customer ID or short name (default is user's customer) to help resolve asset, only used when asset's short name was provided.
    :param bool includeRawOutput: Whether include raw output, default not include
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/asset/{asset}/vulnerability/{vulnerabilityID}".format(asset=asset,
        vulnerabilityID=vulnerabilityID,
        customer=customer,
        includeRawOutput=includeRawOutput)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send includeRawOutput if the argument was provided, dont send null values
    if includeRawOutput is not None:
        query_parameters.update({"includeRawOutput": includeRawOutput})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "asset"),
    module=argus_cli_module
)
def list_assets(
    customer: str = None,
    asset: str = None,
    parent: str = None,
    keywords: str = None,
    timeFieldStrategy: str = None,
    sortBy: str = None,
    limit: int = 25,
    startTimestamp: str = "0",
    endTimestamp: str = "0",
    offset: int = None,
    includeDeleted: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Basic Asset search.If keywords are present, they must all must be present in at least one of the keyword fields.Check the documentation for the KeywordFieldStrategy field for more details.If start/end timestamps are present, the range must be valid for at least one of the requested time stamp fields.Check the documentation for the TimestampFieldStrategy field for more details.Limit and offset added together cannot exceed 10'000 (DEV)
    
    :param list customer: Customer ids or short names
    :param list asset: Asset ids or short names
    :param list parent: Asset parent group ids or short names
    :param list keywords: Limit search by asset keywords
    :param list timeFieldStrategy: Which time field(s) to filter by timestamp start/end
    :param list sortBy: Field(s) to sort by - refer to the search POST endpoint to see which fields are permitted
    :param int limit: Limit results
    :param str startTimestamp: Lower bound timestamp filter value
    :param str endTimestamp: Upper bound timestamp filter value
    :param int offset: Offset results
    :param bool includeDeleted: Include deleted
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/asset".format(limit=limit,
        startTimestamp=startTimestamp,
        endTimestamp=endTimestamp,
        customer=customer,
        asset=asset,
        parent=parent,
        keywords=keywords,
        offset=offset,
        includeDeleted=includeDeleted,
        timeFieldStrategy=timeFieldStrategy,
        sortBy=sortBy)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send asset if the argument was provided, dont send null values
    if asset is not None:
        query_parameters.update({"asset": asset})
    # Only send parent if the argument was provided, dont send null values
    if parent is not None:
        query_parameters.update({"parent": parent})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        query_parameters.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "asset"),
    module=argus_cli_module
)
def search_asset_definitions(
    sortBy: str = None,
    definition: str = None,
    domain: str = None,
    keywords: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    subCriteria: dict = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    includeDeleted: bool = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Search AssetDefinitions with specified criteria (DEV)
    
    :param list sortBy: 
    :param list definition: Restrict to specified Asset definitions (ID or short name) 
    :param list domain: Restrict to specified domains (domain ID or name) 
    :param list keywords: Search for keywords against fields defined by keywordFieldStrategy 
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords (default all supported fields) (default all)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched (default match all keywords) (default all)
    :param list timeFieldStrategy: Defines which timestamps will be included in the search (default lastUpdatedTimestamp) (default lastUpdatedTimestamp)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any) (default any)
    :param list subCriteria: Set additional criteria which are applied with logical OR by default 
    :param int startTimestamp: Restrict to a time frame based on the set timeFieldStrategy (start timestamp) (default 0)
    :param int endTimestamp: Restrict to a time frame based on the set timeFieldStrategy (end timestamp) (default 0)
    :param bool includeDeleted: Whether include deleted results (default false)
    :param int limit: Limit maximum amount of results (default 25)
    :param int offset: Skip specified amount of results (default 0)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/asset/definition/search".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send definition if the argument was provided, dont send null values
    if definition is not None:
        body.update({"definition": definition})
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordFieldStrategy if the argument was provided, dont send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, dont send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, dont send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "asset"),
    module=argus_cli_module
)
def search_asset_definitions_simplified(
    keywords: str = None,
    keywordField: str = None,
    timeField: str = None,
    definition: str = None,
    domain: str = None,
    sortBy: str = None,
    limit: int = 25,
    keywordMatch: str = "all",
    startTimestamp: str = "0",
    endTimestamp: str = "0",
    timeMatch: str = "any",
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Search AssetDefinitions with specified query parameters (DEV)
    
    :param list keywords: Search by keywords
    :param list keywordField: Set field strategy for keyword search
    :param list timeField: Set field strategy for time range search
    :param list definition: Search by definitions (ID or short name)
    :param list domain: Search by domains (domain ID or name)
    :param list sortBy: Sort search result
    :param int limit: Maximum number of returned results
    :param str keywordMatch: Set match strategy for keyword search
    :param str startTimestamp: Start timestamp for time range search
    :param str endTimestamp: End timestamp for time range search
    :param str timeMatch: Set match strategy for time range search
    :param int offset: Skip a number of results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/asset/definition".format(limit=limit,
        keywordMatch=keywordMatch,
        startTimestamp=startTimestamp,
        endTimestamp=endTimestamp,
        timeMatch=timeMatch,
        offset=offset,
        keywords=keywords,
        keywordField=keywordField,
        timeField=timeField,
        definition=definition,
        domain=domain,
        sortBy=sortBy)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send keywordMatch if the argument was provided, dont send null values
    if keywordMatch is not None:
        query_parameters.update({"keywordMatch": keywordMatch})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    # Only send timeMatch if the argument was provided, dont send null values
    if timeMatch is not None:
        query_parameters.update({"timeMatch": timeMatch})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send keywordField if the argument was provided, dont send null values
    if keywordField is not None:
        query_parameters.update({"keywordField": keywordField})
    # Only send timeField if the argument was provided, dont send null values
    if timeField is not None:
        query_parameters.update({"timeField": timeField})
    # Only send definition if the argument was provided, dont send null values
    if definition is not None:
        query_parameters.update({"definition": definition})
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "asset"),
    module=argus_cli_module
)
def search_assets(
    sortBy: str = None,
    keywords: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    userFieldStrategy: str = None,
    user: str = None,
    customer: str = None,
    asset: str = None,
    assetDefinition: str = None,
    parent: str = None,
    ancestor: str = None,
    component: dict = None,
    criticality: dict = None,
    minimumTotalCvss: float = None,
    maximumTotalCvss: float = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    subCriteria: dict = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    limit: int = 25,
    offset: int = None,
    includeDeleted: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Search Assets (DEV)
    
    :param list sortBy: 
    :param list keywords: Search for keywords against fields defined by a KeywordFieldStrategy 
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords (default all supported fields) (default all)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched (default match all keywords) (default any)
    :param list timeFieldStrategy: Defines which timestamps fields will be filtered with start/endTimestamp (default lastUpdatedTimestamp)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any) (default any)
    :param list userFieldStrategy: Defines which user fields to filter with the submitted user value(s) (default all)
    :param list user: Search for Assets by associated user IDs or short names defined by the UserFieldStrategy 
    :param list customer: Search for Assets with these Customer IDs or short names 
    :param list asset: Search for Assets with these Asset IDs or short names 
    :param list assetDefinition: Search for Assets with these AssetDefinition IDs or short names 
    :param list parent: Search for Assets with these parent AssetGroup IDs or short names 
    :param str ancestor: Search for Assets in the hierarchy below this ancestor AssetGroup identified by its ID or short name.<br />This will resolve all descendant Asset Groups and expand the search to return Assets belonging to them in the hierarchy below this 'ancestor' group 
    :param list component: Search for Assets by their components using AND search mode i.e. all criteria must match.<br />If you want different behaviour try using subcriteria 
    :param list criticality: Search for Assets by Confidentiality, Availability, and Integrity. 
    :param float minimumTotalCvss: Search for Assets with at least this CVSS score 
    :param float maximumTotalCvss: Search for Assets with at most this CVSS score 
    :param list includeFlags: Explicitly search for Assets that contain these flags 
    :param list excludeFlags: Explicitly filter out Assets that contain these flags 
    :param list subCriteria: Set additional criteria that are applied with logical OR by default 
    :param int startTimestamp: Restrict to a time frame based on the set timeFieldStrategy (start timestamp) (default 0)
    :param int endTimestamp: Restrict to a time frame based on the set timeFieldStrategy (end timestamp) (default 0)
    :param int limit: Limit the results to the specified amount (default 25)
    :param int offset: Skip specified amount of results (default 0)
    :param bool includeDeleted: Whether to include deleted Assets (default false)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: requests.Response object or dictionary translated from JSON
    """

    route = "/assets/v2/asset/search".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': None
    }
    if json:
        headers['content'] = 'application/json'

    body = body or {}
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordFieldStrategy if the argument was provided, dont send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, dont send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, dont send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send userFieldStrategy if the argument was provided, dont send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send user if the argument was provided, dont send null values
    if user is not None:
        body.update({"user": user})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send asset if the argument was provided, dont send null values
    if asset is not None:
        body.update({"asset": asset})
    # Only send assetDefinition if the argument was provided, dont send null values
    if assetDefinition is not None:
        body.update({"assetDefinition": assetDefinition})
    # Only send parent if the argument was provided, dont send null values
    if parent is not None:
        body.update({"parent": parent})
    # Only send ancestor if the argument was provided, dont send null values
    if ancestor is not None:
        body.update({"ancestor": ancestor})
    # Only send component if the argument was provided, dont send null values
    if component is not None:
        body.update({"component": component})
    # Only send criticality if the argument was provided, dont send null values
    if criticality is not None:
        body.update({"criticality": criticality})
    # Only send minimumTotalCvss if the argument was provided, dont send null values
    if minimumTotalCvss is not None:
        body.update({"minimumTotalCvss": minimumTotalCvss})
    # Only send maximumTotalCvss if the argument was provided, dont send null values
    if maximumTotalCvss is not None:
        body.update({"maximumTotalCvss": maximumTotalCvss})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("assets", "v2", "asset"),
    module=argus_cli_module
)
def update_asset(
    idOrShortName: str,
    customer: str = None,
    shortName: str = None,
    name: str = None,
    description: str = None,
    owner: str = None,
    criticality: dict = None,
    addComponents: dict = None,
    deleteComponents: str = None,
    ttl: int = None,
    forceIndex: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Updates an existing Asset (DEV)
    
    :param str idOrShortName: Asset ID or short name
    :param str customer: Customer ID or short name (default is user's customer), only used when asset short name was provided
    :param str shortName: Update short name of asset  => [a-zA-Z0-9_\-\.]*
    :param str name: Update name of asset  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str description: Update description of asset. Support HTML, which will be sanitized 
    :param str owner: Update owner of asset, specified by user ID or username. When username is specified, it should exist within current user's domain 
    :param dict criticality: 
    :param list addComponents: Specify components to be added with the asset 
    :param list deleteComponents: Specify IDs of the components to be deleted from the asset 
    :param int ttl: Time to live duration of this asset since last seen, 0 means won't expire. 
    :param bool forceIndex: Whether to force an Elasticsearch index refresh such that changes to the Asset are immediately searchable.
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/asset/{idOrShortName}".format(idOrShortName=idOrShortName,
        customer=customer,
        forceIndex=forceIndex)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})
    # Only send owner if the argument was provided, dont send null values
    if owner is not None:
        body.update({"owner": owner})
    # Only send criticality if the argument was provided, dont send null values
    if criticality is not None:
        body.update({"criticality": criticality})
    # Only send addComponents if the argument was provided, dont send null values
    if addComponents is not None:
        body.update({"addComponents": addComponents})
    # Only send deleteComponents if the argument was provided, dont send null values
    if deleteComponents is not None:
        body.update({"deleteComponents": deleteComponents})
    # Only send ttl if the argument was provided, dont send null values
    if ttl is not None:
        body.update({"ttl": ttl})

    query_parameters = {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send forceIndex if the argument was provided, dont send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("assets", "v2", "asset"),
    module=argus_cli_module
)
def update_asset_definition(
    definition: str,
    domain: str = None,
    shortName: str = None,
    name: str = None,
    addComponent: str = None,
    deleteComponent: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Updates an existing AssetDefinition (DEV)
    
    :param str definition: AssetDefinition ID or short name
    :param str domain: Domain ID or name (default is user's domain), only used when definition is short name
    :param str shortName: Update asset definition short name  => [a-zA-Z0-9_\-\.]*
    :param str name: Update asset definition name  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param list addComponent: Component definitions (ID or short name) to be added to the asset definition, they have to belong to same domain as asset definition. 
    :param list deleteComponent: Component definitions ((ID or short name)) to be deleted from the asset definition 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/assets/v2/asset/definition/{definition}".format(definition=definition,
        domain=domain)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send addComponent if the argument was provided, dont send null values
    if addComponent is not None:
        body.update({"addComponent": addComponent})
    # Only send deleteComponent if the argument was provided, dont send null values
    if deleteComponent is not None:
        body.update({"deleteComponent": deleteComponent})

    query_parameters = {}
    # Only send domain if the argument was provided, dont send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()

