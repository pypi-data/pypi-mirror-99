"""Autogenerated API"""
from argus_api import session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def acknowledge_sensor(
    sensorID: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Acknowledge a sensor by its ID (DEV)
    
    :param int sensorID: ID of sensor to acknowledge
    :param str comment: Any comments to append to the request  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/acknowledge".format(sensorID=sensorID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send comment if the argument was provided, dont send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def acknowledge_sensors(
    sensorID: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Acknowledge Sensors by their ID Any comment will be applied to ALL specified sensors. (DEV)
    
    :param list sensorID: ID of sensors to acknowledge
    :param str comment: Any comments to append to the request. NB: Each sensor specified in the request will receive the same comment.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/acknowledge".format(sensorID=sensorID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send comment if the argument was provided, dont send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    # Only send sensorID if the argument was provided, dont send null values
    if sensorID is not None:
        query_parameters.update({"sensorID": sensorID})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def add_comment(
    sensorID: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Add comment to a sensor (DEV)
    
    :param int sensorID: SensorID
    :param str comment: 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/comment".format(sensorID=sensorID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send comment if the argument was provided, dont send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def bulk_cancel_sensor_downtime(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Cancels downtime for supplied sensorIDs (DEV)
    
    :param list sensorID: Cancel downtime for these Sensor IDs
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/downtime".format(sensorID=sensorID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send sensorID if the argument was provided, dont send null values
    if sensorID is not None:
        query_parameters.update({"sensorID": sensorID})

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def bulk_schedule_sensor_downtime(
    fromTime: int = None,
    toTime: int = None,
    keepDowntimeOnUpdate: bool = None,
    comment: str = None,
    sensorIDs: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Schedules downtime for provided sensorIDs (DEV)
    
    :param int fromTime: Timestamp in epoch ms from which the requested change takes effect 
    :param int toTime: Timestamp in epoch ms until which the requested change takes effect 
    :param bool keepDowntimeOnUpdate: Flag to maintain existing Downtime configurations 
    :param str comment: Any comments to append to the request  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param list sensorIDs: List of SensorIDs 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/downtime".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send fromTime if the argument was provided, dont send null values
    if fromTime is not None:
        body.update({"fromTime": fromTime})
    # Only send toTime if the argument was provided, dont send null values
    if toTime is not None:
        body.update({"toTime": toTime})
    # Only send keepDowntimeOnUpdate if the argument was provided, dont send null values
    if keepDowntimeOnUpdate is not None:
        body.update({"keepDowntimeOnUpdate": keepDowntimeOnUpdate})
    # Only send comment if the argument was provided, dont send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send sensorIDs if the argument was provided, dont send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def cancel_sensor_downtime(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Cancels downtime for supplied sensorID (DEV)
    
    :param int sensorID: 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/downtime".format(sensorID=sensorID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def create_sensor(
    sslTerminating: bool = None,
    location: str = None,
    customer: str = None,
    application: str = None,
    information: str = None,
    hostname: str = None,
    ipAddress: str = None,
    additionalData: str = None,
    reportingSeverity: str = None,
    clusterSensorID: int = None,
    expectedUpdateTime: int = None,
    scheduledDowntimeFromTime: int = None,
    scheduledDowntimeUntilTime: int = None,
    active: bool = None,
    monitored: bool = None,
    monitoredOnlyDaytime: bool = None,
    initialTuning: bool = None,
    overrideDefaultUpdateTime: bool = None,
    sharedCustomerData: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Creates a Sensor (DEV)
    
    :param bool sslTerminating: 
    :param str location: Sensor location ID or short name 
    :param str customer: Sensor customer ID or short name 
    :param str application: Sensor type id or short name 
    :param str information: Sensor information 
    :param str hostname: Sensor hostname. One of hostname or IPaddress must be defined.  => Sanitize by regex ([\p{Alnum}\._-]+)
    :param str ipAddress: Sensor's IP address, one of hostname or ipAddress must be assigned  => format:ip
    :param str additionalData: Any additional data 
    :param str reportingSeverity: If specified overwrite the ReportingSeverity level for this Sensor's Application 
    :param int clusterSensorID: Cluster sensor 0 if does not exist (default 0)
    :param int expectedUpdateTime: When the Sensor is expected to be updated, 0 if not known/never (default 0)
    :param int scheduledDowntimeFromTime: Time from which the Sensor will be offline, 0 if not scheduled (default 0)
    :param int scheduledDowntimeUntilTime: Time until which the Sensor will be offline, 0 if not scheduled (default 0)
    :param bool active: Sensor active flag (default false)
    :param bool monitored: Sensor monitored flag (default false)
    :param bool monitoredOnlyDaytime: Sensor is monitored only daytime flag (default false)
    :param bool initialTuning: Sensor's initial tuning status (default false)
    :param bool overrideDefaultUpdateTime: Override default update time (default false)
    :param bool sharedCustomerData: Sensor's shared customer data flag (default false)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send sslTerminating if the argument was provided, dont send null values
    if sslTerminating is not None:
        body.update({"sslTerminating": sslTerminating})
    # Only send location if the argument was provided, dont send null values
    if location is not None:
        body.update({"location": location})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send application if the argument was provided, dont send null values
    if application is not None:
        body.update({"application": application})
    # Only send clusterSensorID if the argument was provided, dont send null values
    if clusterSensorID is not None:
        body.update({"clusterSensorID": clusterSensorID})
    # Only send expectedUpdateTime if the argument was provided, dont send null values
    if expectedUpdateTime is not None:
        body.update({"expectedUpdateTime": expectedUpdateTime})
    # Only send scheduledDowntimeFromTime if the argument was provided, dont send null values
    if scheduledDowntimeFromTime is not None:
        body.update({"scheduledDowntimeFromTime": scheduledDowntimeFromTime})
    # Only send scheduledDowntimeUntilTime if the argument was provided, dont send null values
    if scheduledDowntimeUntilTime is not None:
        body.update({"scheduledDowntimeUntilTime": scheduledDowntimeUntilTime})
    # Only send information if the argument was provided, dont send null values
    if information is not None:
        body.update({"information": information})
    # Only send hostname if the argument was provided, dont send null values
    if hostname is not None:
        body.update({"hostname": hostname})
    # Only send ipAddress if the argument was provided, dont send null values
    if ipAddress is not None:
        body.update({"ipAddress": ipAddress})
    # Only send additionalData if the argument was provided, dont send null values
    if additionalData is not None:
        body.update({"additionalData": additionalData})
    # Only send active if the argument was provided, dont send null values
    if active is not None:
        body.update({"active": active})
    # Only send monitored if the argument was provided, dont send null values
    if monitored is not None:
        body.update({"monitored": monitored})
    # Only send monitoredOnlyDaytime if the argument was provided, dont send null values
    if monitoredOnlyDaytime is not None:
        body.update({"monitoredOnlyDaytime": monitoredOnlyDaytime})
    # Only send initialTuning if the argument was provided, dont send null values
    if initialTuning is not None:
        body.update({"initialTuning": initialTuning})
    # Only send overrideDefaultUpdateTime if the argument was provided, dont send null values
    if overrideDefaultUpdateTime is not None:
        body.update({"overrideDefaultUpdateTime": overrideDefaultUpdateTime})
    # Only send sharedCustomerData if the argument was provided, dont send null values
    if sharedCustomerData is not None:
        body.update({"sharedCustomerData": sharedCustomerData})
    # Only send reportingSeverity if the argument was provided, dont send null values
    if reportingSeverity is not None:
        body.update({"reportingSeverity": reportingSeverity})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def create_sensor_interface(
    sensorID: int,
    interfaceName: str = None,
    location: str = None,
    customer: str = None,
    active: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Adds an interface to a sensor (DEV)
    
    :param int sensorID: ID of sensor to which we want to add the interface
    :param str interfaceName: Name of the sensor interface  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str location: Location ID or short name of the sensor interface. 
    :param str customer: Customer id or shortname of the interface (default null)
    :param bool active: Status of the sensor interface (default false)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/interface".format(sensorID=sensorID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send interfaceName if the argument was provided, dont send null values
    if interfaceName is not None:
        body.update({"interfaceName": interfaceName})
    # Only send location if the argument was provided, dont send null values
    if location is not None:
        body.update({"location": location})
    # Only send active if the argument was provided, dont send null values
    if active is not None:
        body.update({"active": active})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def delete_sensor(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Delete sensor by ID (DEV)
    
    :param int sensorID: ID of sensor to delete
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}".format(sensorID=sensorID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def delete_sensor_comment(
    sensorID: int,
    timestamp: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Deletes a comment (DEV)
    
    :param int sensorID: Delete comment from this sensor
    :param int timestamp: Delete comment made at this timestamp
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/comment/{timestamp}".format(sensorID=sensorID,
        timestamp=timestamp)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def disable_monitoring(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Disable sensor monitoring (DEV)
    
    :param int sensorID: ID for sensor to disable monitoring
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/monitoring/disable".format(sensorID=sensorID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def disable_monitoring_bulk(
    sensorIDs: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Bulk disable sensor monitoring (DEV)
    
    :param list sensorIDs: List of sensorIDs for which to update monitoring 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/monitoring/disable".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send sensorIDs if the argument was provided, dont send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def disable_sensor(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Deactivates a sensor (DEV)
    
    :param int sensorID: 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/disable".format(sensorID=sensorID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def disable_sensors(
    sensorIDs: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Bulk deactivation of Sensors (DEV)
    
    :param list sensorIDs: List of SensorIDs 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/disable".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send sensorIDs if the argument was provided, dont send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def enable_monitoring(
    sensorID: int,
    daytime: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Enable sensor monitoring (DEV)
    
    :param int sensorID: ID for sensor to enable monitoring
    :param bool daytime: Daytime only monitoring flag
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/monitoring/enable".format(sensorID=sensorID,
        daytime=daytime)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send daytime if the argument was provided, dont send null values
    if daytime is not None:
        query_parameters.update({"daytime": daytime})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def enable_monitoring_bulk(
    sensorIDs: int = None,
    daytime: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Bulk enable sensor monitoring (DEV)
    
    :param list sensorIDs: List of sensorIDs for which to update monitoring 
    :param bool daytime: Daytime only monitoring flag
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/monitoring/enable".format(daytime=daytime)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send sensorIDs if the argument was provided, dont send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})
    # Only send daytime if the argument was provided, dont send null values
    if daytime is not None:
        body.update({"daytime": daytime})

    query_parameters = {}
    # Only send daytime if the argument was provided, dont send null values
    if daytime is not None:
        query_parameters.update({"daytime": daytime})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def enable_sensor(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Activates a sensor (DEV)
    
    :param int sensorID: 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/enable".format(sensorID=sensorID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def enable_sensors(
    sensorIDs: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Bulk activation of sensors (DEV)
    
    :param list sensorIDs: List of SensorIDs 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/enable".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send sensorIDs if the argument was provided, dont send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def get_comment(
    sensorID: int,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch comments for sensor (DEV)
    
    :param int sensorID: SensorID
    :param int limit: Limit results
    :param int offset: Offset results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/comment".format(limit=limit,
        sensorID=sensorID,
        offset=offset)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def get_comment_1(
    sensorID: int,
    timestamp: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch comment by timestamp for sensor (DEV)
    
    :param int sensorID: SensorID
    :param int timestamp: Timestamp
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/comment/{timestamp}".format(sensorID=sensorID,
        timestamp=timestamp)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def get_interface(
    sensorID: int,
    interface: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Deletes one of a Sensor's interfaces by its ID or name (DEV)
    
    :param int sensorID: ID of the sensor to which the interface belongs
    :param str interface: ID of the interface
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises Sensor,Interface,OrLocationNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/interface/{interface}".format(sensorID=sensorID,
        interface=interface)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def get_interface_1(
    sensorID: int,
    interfaceNameOrID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Gets one of a Sensor's interfaces (DEV)
    
    :param int sensorID: ID of the sensor to which the interface belongs
    :param str interfaceNameOrID: ID or name of the Interface
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises SensorOrInterfaceNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/interface/{interfaceNameOrID}".format(sensorID=sensorID,
        interfaceNameOrID=interfaceNameOrID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def get_sensor_1(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch sensor by ID (PUBLIC)
    
    :param int sensorID: ID of sensor to fetch
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}".format(sensorID=sensorID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def get_sensor_comments(
    sensorID: int,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Fetch sensor comments by sensor ID (PUBLIC)
    
    :param int sensorID: ID of sensor to fetch comments for
    :param int limit: Limit results
    :param int offset: Offset results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/comments".format(limit=limit,
        sensorID=sensorID,
        offset=offset)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def get_sensor_status(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Gets status for a sensor (DEV)
    
    :param int sensorID: ID of sensor whose status we want to fetch
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/status".format(sensorID=sensorID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def list_sensor_interfaces(
    sensorID: int,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Gets a Sensor's interfaces (DEV)
    
    :param int sensorID: ID of the sensor to which the interface belongs
    :param int limit: Limit results
    :param int offset: Offset results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises SensorNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/interface".format(limit=limit,
        sensorID=sensorID,
        offset=offset)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def list_sensors_1(
    customerID: int = None,
    applicationName: str = None,
    keywords: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List sensors (PUBLIC)
    
    :param list customerID: Limit search to these customer IDs
    :param list applicationName: Limit search to these applications by name
    :param list keywords: Limit search by sensor hostname or IP address
    :param int limit: Limit results
    :param int offset: Offset results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor".format(limit=limit,
        customerID=customerID,
        applicationName=applicationName,
        keywords=keywords,
        offset=offset)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        query_parameters.update({"customerID": customerID})
    # Only send applicationName if the argument was provided, dont send null values
    if applicationName is not None:
        query_parameters.update({"applicationName": applicationName})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def remove_acknowledgement_sensor(
    sensorID: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Remove acknowledgement for a sensor by its ID.  (DEV)
    
    :param int sensorID: ID of sensor to remove acknowledgment
    :param str comment: Any comments to append to the request  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/removeacknowledgement".format(sensorID=sensorID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send comment if the argument was provided, dont send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def remove_acknowledgement_sensors(
    sensorID: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Bulk remove acknowledgement for Sensors by their IDs. Any comment will be applied to ALL specified sensors. (DEV)
    
    :param list sensorID: ID of sensors to remove acknowledgement
    :param str comment: Any comments to append to the request. NB: Each sensor specified in the request will receive the same comment.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/removeacknowledgement".format(sensorID=sensorID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send comment if the argument was provided, dont send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    # Only send sensorID if the argument was provided, dont send null values
    if sensorID is not None:
        query_parameters.update({"sensorID": sensorID})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def schedule_sensor_downtime(
    sensorID: int,
    fromTime: int = None,
    toTime: int = None,
    keepDowntimeOnUpdate: bool = None,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Schedules downtime for supplied sensorID (DEV)
    
    :param int sensorID: 
    :param int fromTime: Timestamp in epoch ms from which the requested change takes effect 
    :param int toTime: Timestamp in epoch ms until which the requested change takes effect 
    :param bool keepDowntimeOnUpdate: Flag to maintain existing Downtime configurations 
    :param str comment: Any comments to append to the request  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/downtime".format(sensorID=sensorID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send fromTime if the argument was provided, dont send null values
    if fromTime is not None:
        body.update({"fromTime": fromTime})
    # Only send toTime if the argument was provided, dont send null values
    if toTime is not None:
        body.update({"toTime": toTime})
    # Only send keepDowntimeOnUpdate if the argument was provided, dont send null values
    if keepDowntimeOnUpdate is not None:
        body.update({"keepDowntimeOnUpdate": keepDowntimeOnUpdate})
    # Only send comment if the argument was provided, dont send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def search_sensors(
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    customerID: int = None,
    keywords: str = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    sortBy: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    sensorID: int = None,
    locationName: str = None,
    applicationName: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Search sensors (PUBLIC)
    
    :param int limit: Limit results 
    :param int offset: Offset results 
    :param bool includeDeleted: Also include deleted objects (where implemented) 
    :param list customerID: Limit result to objects belonging to these customers 
    :param list keywords: Search for sensors matching this hostname or IP-address 
    :param int startTimestamp: Search objects from this timestamp 
    :param int endTimestamp: Search objects until this timestamp 
    :param list sortBy: Order results by these properties (prefix with - to sort descending) 
    :param list includeFlags: Search objects with these flags set 
    :param list excludeFlags: Exclude objects with these flags set 
    :param list sensorID: Search for specific sensors by ID 
    :param list locationName: Search for sensors bound to any of these locations 
    :param list applicationName: Search for sensors by application type 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/search".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send sensorID if the argument was provided, dont send null values
    if sensorID is not None:
        body.update({"sensorID": sensorID})
    # Only send locationName if the argument was provided, dont send null values
    if locationName is not None:
        body.update({"locationName": locationName})
    # Only send applicationName if the argument was provided, dont send null values
    if applicationName is not None:
        body.update({"applicationName": applicationName})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def update_interface(
    sensorID: int,
    interface: str,
    newInterfaceName: str = None,
    location: str = None,
    active: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Update Interface by ID (DEV)
    
    :param int sensorID: ID of the Sensor to which the Interface belongs
    :param str interface: ID of the Interface we want to update
    :param str newInterfaceName: New name of the sensor interface. Must be unique per sensor.  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str location: New Location ID or short name of the sensor interface. 
    :param bool active: New Status of the sensor interface 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/interface/{interface}".format(sensorID=sensorID,
        interface=interface)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send newInterfaceName if the argument was provided, dont send null values
    if newInterfaceName is not None:
        body.update({"newInterfaceName": newInterfaceName})
    # Only send location if the argument was provided, dont send null values
    if location is not None:
        body.update({"location": location})
    # Only send active if the argument was provided, dont send null values
    if active is not None:
        body.update({"active": active})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def update_sensor(
    sensorID: int,
    sslTerminating: bool = None,
    location: str = None,
    clusterSensorID: int = None,
    information: str = None,
    hostname: str = None,
    ipAddress: str = None,
    additionalData: str = None,
    application: str = None,
    expectedUpdateTime: int = None,
    reportingSeverity: str = None,
    initialTuning: bool = None,
    overrideDefaultUpdateTime: bool = None,
    sharedCustomerData: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Update sensor by ID (DEV)
    
    :param int sensorID: ID of sensor to update
    :param bool sslTerminating: 
    :param str location: ID or shortname of the Sensor's location 
    :param int clusterSensorID: Cluster sensorID, set to 0 if removing cluster 
    :param str information: Sensor information 
    :param str hostname: Sensor hostname  => Sanitize by regex ([\p{Alnum}\._-]+)
    :param str ipAddress: Sensor's IP address, one of hostname or ipAddress must be assigned  => format:ip
    :param str additionalData: Additional identifier 
    :param str application: ID or shortname of Sensor type 
    :param int expectedUpdateTime: Expected updated time, only set if overrideDefaultUpdateTime is true 
    :param str reportingSeverity: If specified overwrite the ReportingSeverity level for this Sensor's Application 
    :param bool initialTuning: Sensor's initial tuning status (default null)
    :param bool overrideDefaultUpdateTime: Sensor's override default update time flag (default null)
    :param bool sharedCustomerData: Sensor's shared customer data flag (default null)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}".format(sensorID=sensorID)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send sslTerminating if the argument was provided, dont send null values
    if sslTerminating is not None:
        body.update({"sslTerminating": sslTerminating})
    # Only send location if the argument was provided, dont send null values
    if location is not None:
        body.update({"location": location})
    # Only send clusterSensorID if the argument was provided, dont send null values
    if clusterSensorID is not None:
        body.update({"clusterSensorID": clusterSensorID})
    # Only send information if the argument was provided, dont send null values
    if information is not None:
        body.update({"information": information})
    # Only send hostname if the argument was provided, dont send null values
    if hostname is not None:
        body.update({"hostname": hostname})
    # Only send ipAddress if the argument was provided, dont send null values
    if ipAddress is not None:
        body.update({"ipAddress": ipAddress})
    # Only send additionalData if the argument was provided, dont send null values
    if additionalData is not None:
        body.update({"additionalData": additionalData})
    # Only send application if the argument was provided, dont send null values
    if application is not None:
        body.update({"application": application})
    # Only send expectedUpdateTime if the argument was provided, dont send null values
    if expectedUpdateTime is not None:
        body.update({"expectedUpdateTime": expectedUpdateTime})
    # Only send initialTuning if the argument was provided, dont send null values
    if initialTuning is not None:
        body.update({"initialTuning": initialTuning})
    # Only send overrideDefaultUpdateTime if the argument was provided, dont send null values
    if overrideDefaultUpdateTime is not None:
        body.update({"overrideDefaultUpdateTime": overrideDefaultUpdateTime})
    # Only send sharedCustomerData if the argument was provided, dont send null values
    if sharedCustomerData is not None:
        body.update({"sharedCustomerData": sharedCustomerData})
    # Only send reportingSeverity if the argument was provided, dont send null values
    if reportingSeverity is not None:
        body.update({"reportingSeverity": reportingSeverity})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()

