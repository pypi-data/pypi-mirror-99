"""Autogenerated API"""
from argus_api import session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(
    extending=("sensors", "v1", "type"),
    module=argus_cli_module
)
def add_sensor_type(
    shortName: str = None,
    name: str = None,
    url: str = None,
    department: str = None,
    reportingSeverity: str = None,
    expectedSensorUpdateTime: int = None,
    monitorCollectionOnly: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Create a new sensor type (DEV)
    
    :param str shortName: Short name of sensor type, needs to be unique  => [a-zA-Z0-9_\-\.]*
    :param str name: Name of sensor type  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str url: URL of sensor type  => ((https?|ftp|gopher|telnet|file):((/)|(\\))+[\w\d:\#@%/;$()~_?\\+-=\\\.&]*)
    :param str department: Department that the sensor type belongs to (default none)
    :param str reportingSeverity: Flag to determine escalation workflow for Sensors of this type (default medium)
    :param int expectedSensorUpdateTime: Expected maximum update time duration in millis of sensor which belong to the type (default 0)
    :param bool monitorCollectionOnly: Flag to determine whether sensors of this type are monitored by analysis or only by collection (default false)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/type".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send url if the argument was provided, dont send null values
    if url is not None:
        body.update({"url": url})
    # Only send expectedSensorUpdateTime if the argument was provided, dont send null values
    if expectedSensorUpdateTime is not None:
        body.update({"expectedSensorUpdateTime": expectedSensorUpdateTime})
    # Only send department if the argument was provided, dont send null values
    if department is not None:
        body.update({"department": department})
    # Only send monitorCollectionOnly if the argument was provided, dont send null values
    if monitorCollectionOnly is not None:
        body.update({"monitorCollectionOnly": monitorCollectionOnly})
    # Only send reportingSeverity if the argument was provided, dont send null values
    if reportingSeverity is not None:
        body.update({"reportingSeverity": reportingSeverity})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "type"),
    module=argus_cli_module
)
def delete_sensor_type(
    idOrShortName: str,
    newType: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Delete a sensor type and update existing Sensors of that type to a new sensor type (DEV)
    
    :param str idOrShortName: Sensor type ID or short name
    :param str newType: Sensor type delete request
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/type/{idOrShortName}".format(idOrShortName=idOrShortName,
        newType=newType)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send newType if the argument was provided, dont send null values
    if newType is not None:
        query_parameters.update({"newType": newType})

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "type"),
    module=argus_cli_module
)
def get_sensor_type(
    idOrShortName: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Get sensor type by ID or short name (DEV)
    
    :param str idOrShortName: Sensor type ID or short name
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/type/{idOrShortName}".format(idOrShortName=idOrShortName)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "type"),
    module=argus_cli_module
)
def get_sensor_types(
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Get all sensor types (DEV)
    
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/type".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("sensors", "v1", "type"),
    module=argus_cli_module
)
def update_sensor_type(
    idOrShortName: str,
    shortName: str = None,
    name: str = None,
    url: str = None,
    expectedSensorUpdateTime: int = None,
    department: str = None,
    monitorCollectionOnly: bool = None,
    reportingSeverity: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Update a sensor type (DEV)
    
    :param str idOrShortName: Sensor type ID or short name
    :param str shortName: Update short name of sensor type, needs to be unique  => [a-zA-Z0-9_\-\.]*
    :param str name: Update name of sensor type  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str url: Update url of sensor type  => ((https?|ftp|gopher|telnet|file):((/)|(\\))+[\w\d:\#@%/;$()~_?\\+-=\\\.&]*)
    :param int expectedSensorUpdateTime: Update expected sensor update time for the sensor type 
    :param str department: Update department of sensor type 
    :param bool monitorCollectionOnly: Flag to determine whether sensors of this type are monitored by analysis or only by collection 
    :param str reportingSeverity: Flag to determine escalation workflow for Sensors of this type 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/sensors/v1/type/{idOrShortName}".format(idOrShortName=idOrShortName)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send url if the argument was provided, dont send null values
    if url is not None:
        body.update({"url": url})
    # Only send expectedSensorUpdateTime if the argument was provided, dont send null values
    if expectedSensorUpdateTime is not None:
        body.update({"expectedSensorUpdateTime": expectedSensorUpdateTime})
    # Only send department if the argument was provided, dont send null values
    if department is not None:
        body.update({"department": department})
    # Only send monitorCollectionOnly if the argument was provided, dont send null values
    if monitorCollectionOnly is not None:
        body.update({"monitorCollectionOnly": monitorCollectionOnly})
    # Only send reportingSeverity if the argument was provided, dont send null values
    if reportingSeverity is not None:
        body.update({"reportingSeverity": reportingSeverity})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()

