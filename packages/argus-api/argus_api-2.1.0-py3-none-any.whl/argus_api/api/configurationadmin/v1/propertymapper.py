"""Autogenerated API"""
from argus_api import session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(
    extending=("configurationadmin", "v1", "propertymapper"),
    module=argus_cli_module
)
def create_property_mapper(
    name: str = None,
    shortName: str = None,
    configuration: str = None,
    description: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Create new property mapper (DEV)
    
    :param str name: Name of the property mapper configuration  => [a-zA-Z0-9_\-\.]*
    :param str shortName: Unique short name of the property mapper configuration  => [a-zA-Z0-9_\-\.]*
    :param str configuration: The JSON configuration 
    :param str description: The property mapper description (default null) => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/configurationadmin/v1/propertymapper".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send configuration if the argument was provided, dont send null values
    if configuration is not None:
        body.update({"configuration": configuration})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("configurationadmin", "v1", "propertymapper"),
    module=argus_cli_module
)
def delete_property_mapper(
    idOrShortName: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Delete a property mapper by its id or shortname. This creates a revision with the same contents as the primary version at the time the request is made.The new primary is, however, flagged as deleted. NB: You can only delete the current primary and only if it is not already deleted. (DEV)
    
    :param str idOrShortName: ID or shortname of a property mapper
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/configurationadmin/v1/propertymapper/{idOrShortName}".format(idOrShortName=idOrShortName)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("configurationadmin", "v1", "propertymapper"),
    module=argus_cli_module
)
def get_property_mapper(
    idOrShortName: str,
    includeConfig: bool = True,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Get a property mapper by its id or shortname.Fetching by short name will always return the master revision.Fetching by ID will return the specifically requested property mapper revision. (DEV)
    
    :param str idOrShortName: ID or shortName of a property mapper
    :param bool includeConfig: Whether to include the property mapper config too
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/configurationadmin/v1/propertymapper/{idOrShortName}".format(includeConfig=includeConfig,
        idOrShortName=idOrShortName)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send includeConfig if the argument was provided, dont send null values
    if includeConfig is not None:
        query_parameters.update({"includeConfig": includeConfig})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("configurationadmin", "v1", "propertymapper"),
    module=argus_cli_module
)
def get_property_mapper_revision(
    idOrShortName: str,
    revision: int,
    includeConfig: bool = True,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Get a property mapper by its id or shortname and revision number (DEV)
    
    :param str idOrShortName: ID or shortName of a property mapper
    :param int revision: Property mapper revision number
    :param bool includeConfig: Whether to include the property mapper config too
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/configurationadmin/v1/propertymapper/{idOrShortName}/revisions/{revision}".format(includeConfig=includeConfig,
        idOrShortName=idOrShortName,
        revision=revision)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send includeConfig if the argument was provided, dont send null values
    if includeConfig is not None:
        query_parameters.update({"includeConfig": includeConfig})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("configurationadmin", "v1", "propertymapper"),
    module=argus_cli_module
)
def list_property_mapper_revisions(
    idOrShortName: str,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List a property mapper's - retrieved by its id or shortname - revisions. (DEV)
    
    :param str idOrShortName: ID or shortname of a property mapper
    :param int limit: Limit results
    :param int offset: Offset results
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/configurationadmin/v1/propertymapper/{idOrShortName}/revisions".format(limit=limit,
        idOrShortName=idOrShortName,
        offset=offset)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("configurationadmin", "v1", "propertymapper"),
    module=argus_cli_module
)
def list_property_mappers(
    keyword: str = None,
    keywordField: str = None,
    timestampField: str = None,
    sortBy: str = None,
    limit: int = 25,
    includeConfig: bool = True,
    keywordMatch: str = "all",
    timestampMatch: str = "all",
    offset: int = None,
    includeDeleted: bool = None,
    start: int = None,
    end: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """List primary property mappers matching the provided criteria (DEV)
    
    :param list keyword: Search by keywords
    :param list keywordField: Set field strategy for keyword search
    :param list timestampField: Set field strategy for timestamp filtering
    :param list sortBy: Field(s) to sort by - refer to the search POST endpoint to see which fields are permitted
    :param int limit: Maximum number of hits to return
    :param bool includeConfig: Whether to include the property mapper config too
    :param str keywordMatch: Set match strategy for keyword search
    :param str timestampMatch: Set match strategy for timestamp filtering
    :param int offset: Number of hits to skip in the result set - useful for pagination
    :param bool includeDeleted: Include deleted
    :param int start: Lower bound timestamp filter value
    :param int end: Upper bound timestamp filter value
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/configurationadmin/v1/propertymapper".format(limit=limit,
        includeConfig=includeConfig,
        keywordMatch=keywordMatch,
        timestampMatch=timestampMatch,
        offset=offset,
        includeDeleted=includeDeleted,
        keyword=keyword,
        keywordField=keywordField,
        timestampField=timestampField,
        start=start,
        end=end,
        sortBy=sortBy)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send includeConfig if the argument was provided, dont send null values
    if includeConfig is not None:
        query_parameters.update({"includeConfig": includeConfig})
    # Only send keywordMatch if the argument was provided, dont send null values
    if keywordMatch is not None:
        query_parameters.update({"keywordMatch": keywordMatch})
    # Only send timestampMatch if the argument was provided, dont send null values
    if timestampMatch is not None:
        query_parameters.update({"timestampMatch": timestampMatch})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    # Only send keyword if the argument was provided, dont send null values
    if keyword is not None:
        query_parameters.update({"keyword": keyword})
    # Only send keywordField if the argument was provided, dont send null values
    if keywordField is not None:
        query_parameters.update({"keywordField": keywordField})
    # Only send timestampField if the argument was provided, dont send null values
    if timestampField is not None:
        query_parameters.update({"timestampField": timestampField})
    # Only send start if the argument was provided, dont send null values
    if start is not None:
        query_parameters.update({"start": start})
    # Only send end if the argument was provided, dont send null values
    if end is not None:
        query_parameters.update({"end": end})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("configurationadmin", "v1", "propertymapper"),
    module=argus_cli_module
)
def restore_property_mapper(
    idOrShortName: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Restore a property mapper by its id or shortname. This creates a revision with the same contents as the primary version at the time the request is made.The new primary is, however, no longer flagged as deleted. NB: You can only restore the current primary and only if it is already deleted. (DEV)
    
    :param str idOrShortName: ID or shortname of a property mapper
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/configurationadmin/v1/propertymapper/{idOrShortName}/restore".format(idOrShortName=idOrShortName)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("configurationadmin", "v1", "propertymapper"),
    module=argus_cli_module
)
def rollback_property_mapper(
    idOrShortName: str,
    revision: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Rollback a property mapper to the requested revision. Similar to updating a property mapper, this creates a revision based on the contents of the primary version at the time the request is made. The new primary property mapper will contain the same values as the rollback target version.NB: You cannot rollback to a deleted version or to the current primary. (DEV)
    
    :param str idOrShortName: ID or shortname of a property mapper
    :param int revision: Revision to rollback to
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/configurationadmin/v1/propertymapper/{idOrShortName}/revisions/{revision}/rollback".format(idOrShortName=idOrShortName,
        revision=revision)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("configurationadmin", "v1", "propertymapper"),
    module=argus_cli_module
)
def search_property_mappers(
    sortBy: str = None,
    keywords: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    subCriteria: dict = None,
    idOrShortName: str = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    includeDeleted: bool = None,
    includeConfig: bool = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Search for primary property mappers (DEV)
    
    :param list sortBy: 
    :param list keywords: Search for keywords against fields defined by keywordFieldStrategy 
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords (default all supported fields) (default all)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched (default match all keywords) (default all)
    :param list timeFieldStrategy: Defines which timestamps fields will be filtered with start/endTimestamp (default lastUpdatedTimestamp)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any) (default any)
    :param list subCriteria: Set additional criteria which are applied with logical OR by default 
    :param list idOrShortName: Filter by specific property mapper IDs or shortName. 
    :param int startTimestamp: Restrict to a time frame based on the set timeFieldStrategy (start timestamp) (default 0)
    :param int endTimestamp: Restrict to a time frame based on the set timeFieldStrategy (end timestamp) (default 0)
    :param bool includeDeleted: Whether to include deleted property mappers (default false)
    :param bool includeConfig: Whether to include the property mapper JSON config in the result set (default false)
    :param int limit: Limit maximum amount of results (default 25)
    :param int offset: Skip specified amount of results (default 0)
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/configurationadmin/v1/propertymapper/search".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordFieldStrategy if the argument was provided, dont send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, dont send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, dont send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, dont send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send includeConfig if the argument was provided, dont send null values
    if includeConfig is not None:
        body.update({"includeConfig": includeConfig})
    # Only send subCriteria if the argument was provided, dont send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send idOrShortName if the argument was provided, dont send null values
    if idOrShortName is not None:
        body.update({"idOrShortName": idOrShortName})
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("configurationadmin", "v1", "propertymapper"),
    module=argus_cli_module
)
def update_property_mapper(
    idOrShortName: str,
    name: str = None,
    configuration: str = None,
    description: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Update a property mapper. This creates a revision based on the contents of the primary version at the time the request is made.The new primary property mapper's contents reflects the update request. (DEV)
    
    :param str idOrShortName: ID or shortname of a property mapper
    :param str name: Name of the property mapper configuration  => [a-zA-Z0-9_\-\.]*
    :param str configuration: The JSON configuration 
    :param str description: The property mapper description  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/configurationadmin/v1/propertymapper/{idOrShortName}".format(idOrShortName=idOrShortName)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send configuration if the argument was provided, dont send null values
    if configuration is not None:
        body.update({"configuration": configuration})
    # Only send description if the argument was provided, dont send null values
    if description is not None:
        body.update({"description": description})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()

