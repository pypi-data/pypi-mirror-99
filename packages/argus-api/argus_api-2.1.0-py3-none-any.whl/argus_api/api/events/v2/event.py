"""Autogenerated API"""
from argus_api import session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(
    extending=("events", "v2", "event"),
    module=argus_cli_module
)
def submit_events(
    startTimestamp: int = None,
    endTimestamp: int = None,
    id: dict = None,
    signature: str = None,
    severity: str = None,
    count: int = None,
    location: str = None,
    protocol: str = None,
    source: dict = None,
    destination: dict = None,
    flags: str = None,
    properties: dict = None,
    subEvents: str = None,
    uri: str = None,
    fqdn: str = None,
    aggregationKey: str = None,
    associatedCaseID: int = None,
    associatedCaseIDs: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Submit event to central storage. (DEV)
    
    :param int startTimestamp: 
    :param int endTimestamp: 
    :param dict id: 
    :param str signature: Event signature. If set, the system will automatically assign alarm and attack category based on this value. 
    :param str severity: Event severity. When creating a new event, the default severity is low. 
    :param int count: Number of occurrences this event represents. The value must be at least 1, which is the default. 
    :param str location: The sensor location (id or shortname) where this event was observed. If set, this location must be resolvable for the current user, and must either belong to the same customer as this event, or be a global location. 
    :param str protocol: The protocol id or well-known name. Numeric protocol ID must be between 0 and 255. Protocol name must be well known (icmp, tcp, udp, esp, ah) 
    :param dict source: 
    :param dict destination: 
    :param list flags: Event flags requested by the client for this event. On updating an existing event, existing flags will be retained, and flags in the update will be added. Flags that have a PARTIAL flag have custom handling. If FINALIZED flag is set, additional updates to this event will be ignored. 
    :param dict properties: Custom properties for this event. Each property key may have multiple values. On updating an existing event, setting an existing property will overwrite existing value. 
    :param list subEvents: IDs (on form TYPE/timestamp/customer/UUID) for subevents to this event. Subevents may not be stored yet. System will validate that all subevents have the same customer as this event. 
    :param str uri: URI observed in this event. 
    :param str fqdn: FQDN (fqdn) observed in this event. 
    :param str aggregationKey: Client specified aggregation key for this event. 
    :param int associatedCaseID: Associated case ID. If set, the associated case must be readable for the current user, and must belong to the same customer as this event. 
    :param list associatedCaseIDs: Add one or more case associations to an event, not required. If set, the associated case must be readable for the current user, and must belong to the same customer as this event. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/events/v2/event".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send id if the argument was provided, dont send null values
    if id is not None:
        body.update({"id": id})
    # Only send signature if the argument was provided, dont send null values
    if signature is not None:
        body.update({"signature": signature})
    # Only send severity if the argument was provided, dont send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send count if the argument was provided, dont send null values
    if count is not None:
        body.update({"count": count})
    # Only send location if the argument was provided, dont send null values
    if location is not None:
        body.update({"location": location})
    # Only send protocol if the argument was provided, dont send null values
    if protocol is not None:
        body.update({"protocol": protocol})
    # Only send source if the argument was provided, dont send null values
    if source is not None:
        body.update({"source": source})
    # Only send destination if the argument was provided, dont send null values
    if destination is not None:
        body.update({"destination": destination})
    # Only send flags if the argument was provided, dont send null values
    if flags is not None:
        body.update({"flags": flags})
    # Only send properties if the argument was provided, dont send null values
    if properties is not None:
        body.update({"properties": properties})
    # Only send subEvents if the argument was provided, dont send null values
    if subEvents is not None:
        body.update({"subEvents": subEvents})
    # Only send uri if the argument was provided, dont send null values
    if uri is not None:
        body.update({"uri": uri})
    # Only send fqdn if the argument was provided, dont send null values
    if fqdn is not None:
        body.update({"fqdn": fqdn})
    # Only send aggregationKey if the argument was provided, dont send null values
    if aggregationKey is not None:
        body.update({"aggregationKey": aggregationKey})
    # Only send associatedCaseID if the argument was provided, dont send null values
    if associatedCaseID is not None:
        body.update({"associatedCaseID": associatedCaseID})
    # Only send associatedCaseIDs if the argument was provided, dont send null values
    if associatedCaseIDs is not None:
        body.update({"associatedCaseIDs": associatedCaseIDs})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()


@register_command(
    extending=("events", "v2", "event"),
    module=argus_cli_module
)
def submit_events_bulk(
    events: dict = None,
    onError: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
  ) -> dict:
    """Submit a bulk of events to central storage. (DEV)
    
    :param list events: Events to submit in this bulk. 
    :param str onError: Define how validation errors on single events should be handled. Using mode dropInvalid, invalid events will be ignored and reported in the response. The default mode is rejectAll, which will cause a 412 error on the entire request on a valiation failure for any event. 
    :param json:
    :param verify: path to a certificate bundle or boolean indicating whether SSL
    verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """

    route = "/events/v2/event/bulk".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send events if the argument was provided, dont send null values
    if events is not None:
        body.update({"events": events})
    # Only send onError if the argument was provided, dont send null values
    if onError is not None:
        body.update({"onError": onError})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json()

