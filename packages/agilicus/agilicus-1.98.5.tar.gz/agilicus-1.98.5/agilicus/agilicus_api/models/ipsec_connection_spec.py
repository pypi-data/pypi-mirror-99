# coding: utf-8

"""
    Agilicus API

    Agilicus API endpoints  # noqa: E501

    The version of the OpenAPI document: 2021.03.17
    Contact: dev@agilicus.com
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from agilicus_api.configuration import Configuration


class IpsecConnectionSpec(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'ike_version': 'str',
        'remote_ipv4_address': 'str',
        'remote_dns_ipv4_address': 'str',
        'remote_healthcheck_ipv4_address': 'str',
        'ike_cipher_encryption_algorithm': 'CipherEncryptionAlgorithm',
        'ike_cipher_integrity_algorithm': 'CipherIntegrityAlgorithm',
        'ike_cipher_diffie_hellman_group': 'CipherDiffieHellmanGroup',
        'esp_cipher_encryption_algorithm': 'CipherEncryptionAlgorithm',
        'esp_cipher_integrity_algorithm': 'CipherIntegrityAlgorithm',
        'esp_cipher_diffie_hellman_group': 'CipherDiffieHellmanGroup',
        'esp_lifetime': 'int',
        'ike_lifetime': 'int',
        'ike_rekey': 'bool',
        'ike_reauth': 'bool',
        'ike_authentication_type': 'str',
        'ike_preshared_key': 'str',
        'ike_chain_of_trust_certificates': 'str',
        'ike_certificate_dn': 'str',
        'local_ipv4_block': 'str',
        'remote_ipv4_ranges': 'list[IpsecConnectionIpv4Block]'
    }

    attribute_map = {
        'ike_version': 'ike_version',
        'remote_ipv4_address': 'remote_ipv4_address',
        'remote_dns_ipv4_address': 'remote_dns_ipv4_address',
        'remote_healthcheck_ipv4_address': 'remote_healthcheck_ipv4_address',
        'ike_cipher_encryption_algorithm': 'ike_cipher_encryption_algorithm',
        'ike_cipher_integrity_algorithm': 'ike_cipher_integrity_algorithm',
        'ike_cipher_diffie_hellman_group': 'ike_cipher_diffie_hellman_group',
        'esp_cipher_encryption_algorithm': 'esp_cipher_encryption_algorithm',
        'esp_cipher_integrity_algorithm': 'esp_cipher_integrity_algorithm',
        'esp_cipher_diffie_hellman_group': 'esp_cipher_diffie_hellman_group',
        'esp_lifetime': 'esp_lifetime',
        'ike_lifetime': 'ike_lifetime',
        'ike_rekey': 'ike_rekey',
        'ike_reauth': 'ike_reauth',
        'ike_authentication_type': 'ike_authentication_type',
        'ike_preshared_key': 'ike_preshared_key',
        'ike_chain_of_trust_certificates': 'ike_chain_of_trust_certificates',
        'ike_certificate_dn': 'ike_certificate_dn',
        'local_ipv4_block': 'local_ipv4_block',
        'remote_ipv4_ranges': 'remote_ipv4_ranges'
    }

    def __init__(self, ike_version=None, remote_ipv4_address=None, remote_dns_ipv4_address=None, remote_healthcheck_ipv4_address=None, ike_cipher_encryption_algorithm=None, ike_cipher_integrity_algorithm=None, ike_cipher_diffie_hellman_group=None, esp_cipher_encryption_algorithm=None, esp_cipher_integrity_algorithm=None, esp_cipher_diffie_hellman_group=None, esp_lifetime=None, ike_lifetime=None, ike_rekey=None, ike_reauth=None, ike_authentication_type=None, ike_preshared_key=None, ike_chain_of_trust_certificates=None, ike_certificate_dn=None, local_ipv4_block=None, remote_ipv4_ranges=None, local_vars_configuration=None):  # noqa: E501
        """IpsecConnectionSpec - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._ike_version = None
        self._remote_ipv4_address = None
        self._remote_dns_ipv4_address = None
        self._remote_healthcheck_ipv4_address = None
        self._ike_cipher_encryption_algorithm = None
        self._ike_cipher_integrity_algorithm = None
        self._ike_cipher_diffie_hellman_group = None
        self._esp_cipher_encryption_algorithm = None
        self._esp_cipher_integrity_algorithm = None
        self._esp_cipher_diffie_hellman_group = None
        self._esp_lifetime = None
        self._ike_lifetime = None
        self._ike_rekey = None
        self._ike_reauth = None
        self._ike_authentication_type = None
        self._ike_preshared_key = None
        self._ike_chain_of_trust_certificates = None
        self._ike_certificate_dn = None
        self._local_ipv4_block = None
        self._remote_ipv4_ranges = None
        self.discriminator = None

        if ike_version is not None:
            self.ike_version = ike_version
        if remote_ipv4_address is not None:
            self.remote_ipv4_address = remote_ipv4_address
        if remote_dns_ipv4_address is not None:
            self.remote_dns_ipv4_address = remote_dns_ipv4_address
        if remote_healthcheck_ipv4_address is not None:
            self.remote_healthcheck_ipv4_address = remote_healthcheck_ipv4_address
        if ike_cipher_encryption_algorithm is not None:
            self.ike_cipher_encryption_algorithm = ike_cipher_encryption_algorithm
        if ike_cipher_integrity_algorithm is not None:
            self.ike_cipher_integrity_algorithm = ike_cipher_integrity_algorithm
        if ike_cipher_diffie_hellman_group is not None:
            self.ike_cipher_diffie_hellman_group = ike_cipher_diffie_hellman_group
        if esp_cipher_encryption_algorithm is not None:
            self.esp_cipher_encryption_algorithm = esp_cipher_encryption_algorithm
        if esp_cipher_integrity_algorithm is not None:
            self.esp_cipher_integrity_algorithm = esp_cipher_integrity_algorithm
        if esp_cipher_diffie_hellman_group is not None:
            self.esp_cipher_diffie_hellman_group = esp_cipher_diffie_hellman_group
        if esp_lifetime is not None:
            self.esp_lifetime = esp_lifetime
        if ike_lifetime is not None:
            self.ike_lifetime = ike_lifetime
        if ike_rekey is not None:
            self.ike_rekey = ike_rekey
        if ike_reauth is not None:
            self.ike_reauth = ike_reauth
        if ike_authentication_type is not None:
            self.ike_authentication_type = ike_authentication_type
        if ike_preshared_key is not None:
            self.ike_preshared_key = ike_preshared_key
        if ike_chain_of_trust_certificates is not None:
            self.ike_chain_of_trust_certificates = ike_chain_of_trust_certificates
        if ike_certificate_dn is not None:
            self.ike_certificate_dn = ike_certificate_dn
        if local_ipv4_block is not None:
            self.local_ipv4_block = local_ipv4_block
        if remote_ipv4_ranges is not None:
            self.remote_ipv4_ranges = remote_ipv4_ranges

    @property
    def ike_version(self):
        """Gets the ike_version of this IpsecConnectionSpec.  # noqa: E501

        The IKE version  # noqa: E501

        :return: The ike_version of this IpsecConnectionSpec.  # noqa: E501
        :rtype: str
        """
        return self._ike_version

    @ike_version.setter
    def ike_version(self, ike_version):
        """Sets the ike_version of this IpsecConnectionSpec.

        The IKE version  # noqa: E501

        :param ike_version: The ike_version of this IpsecConnectionSpec.  # noqa: E501
        :type: str
        """
        allowed_values = ["ikev1", "ikev2"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and ike_version not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `ike_version` ({0}), must be one of {1}"  # noqa: E501
                .format(ike_version, allowed_values)
            )

        self._ike_version = ike_version

    @property
    def remote_ipv4_address(self):
        """Gets the remote_ipv4_address of this IpsecConnectionSpec.  # noqa: E501

        remote peer IPv4 address  # noqa: E501

        :return: The remote_ipv4_address of this IpsecConnectionSpec.  # noqa: E501
        :rtype: str
        """
        return self._remote_ipv4_address

    @remote_ipv4_address.setter
    def remote_ipv4_address(self, remote_ipv4_address):
        """Sets the remote_ipv4_address of this IpsecConnectionSpec.

        remote peer IPv4 address  # noqa: E501

        :param remote_ipv4_address: The remote_ipv4_address of this IpsecConnectionSpec.  # noqa: E501
        :type: str
        """

        self._remote_ipv4_address = remote_ipv4_address

    @property
    def remote_dns_ipv4_address(self):
        """Gets the remote_dns_ipv4_address of this IpsecConnectionSpec.  # noqa: E501

        remote peer DNS IPv4 address  # noqa: E501

        :return: The remote_dns_ipv4_address of this IpsecConnectionSpec.  # noqa: E501
        :rtype: str
        """
        return self._remote_dns_ipv4_address

    @remote_dns_ipv4_address.setter
    def remote_dns_ipv4_address(self, remote_dns_ipv4_address):
        """Sets the remote_dns_ipv4_address of this IpsecConnectionSpec.

        remote peer DNS IPv4 address  # noqa: E501

        :param remote_dns_ipv4_address: The remote_dns_ipv4_address of this IpsecConnectionSpec.  # noqa: E501
        :type: str
        """

        self._remote_dns_ipv4_address = remote_dns_ipv4_address

    @property
    def remote_healthcheck_ipv4_address(self):
        """Gets the remote_healthcheck_ipv4_address of this IpsecConnectionSpec.  # noqa: E501

        Remote peer healthcheck IPv4 address. The remote peer address must respond to ping (ICMP). This is used to validate the health of the connection.   # noqa: E501

        :return: The remote_healthcheck_ipv4_address of this IpsecConnectionSpec.  # noqa: E501
        :rtype: str
        """
        return self._remote_healthcheck_ipv4_address

    @remote_healthcheck_ipv4_address.setter
    def remote_healthcheck_ipv4_address(self, remote_healthcheck_ipv4_address):
        """Sets the remote_healthcheck_ipv4_address of this IpsecConnectionSpec.

        Remote peer healthcheck IPv4 address. The remote peer address must respond to ping (ICMP). This is used to validate the health of the connection.   # noqa: E501

        :param remote_healthcheck_ipv4_address: The remote_healthcheck_ipv4_address of this IpsecConnectionSpec.  # noqa: E501
        :type: str
        """

        self._remote_healthcheck_ipv4_address = remote_healthcheck_ipv4_address

    @property
    def ike_cipher_encryption_algorithm(self):
        """Gets the ike_cipher_encryption_algorithm of this IpsecConnectionSpec.  # noqa: E501


        :return: The ike_cipher_encryption_algorithm of this IpsecConnectionSpec.  # noqa: E501
        :rtype: CipherEncryptionAlgorithm
        """
        return self._ike_cipher_encryption_algorithm

    @ike_cipher_encryption_algorithm.setter
    def ike_cipher_encryption_algorithm(self, ike_cipher_encryption_algorithm):
        """Sets the ike_cipher_encryption_algorithm of this IpsecConnectionSpec.


        :param ike_cipher_encryption_algorithm: The ike_cipher_encryption_algorithm of this IpsecConnectionSpec.  # noqa: E501
        :type: CipherEncryptionAlgorithm
        """

        self._ike_cipher_encryption_algorithm = ike_cipher_encryption_algorithm

    @property
    def ike_cipher_integrity_algorithm(self):
        """Gets the ike_cipher_integrity_algorithm of this IpsecConnectionSpec.  # noqa: E501


        :return: The ike_cipher_integrity_algorithm of this IpsecConnectionSpec.  # noqa: E501
        :rtype: CipherIntegrityAlgorithm
        """
        return self._ike_cipher_integrity_algorithm

    @ike_cipher_integrity_algorithm.setter
    def ike_cipher_integrity_algorithm(self, ike_cipher_integrity_algorithm):
        """Sets the ike_cipher_integrity_algorithm of this IpsecConnectionSpec.


        :param ike_cipher_integrity_algorithm: The ike_cipher_integrity_algorithm of this IpsecConnectionSpec.  # noqa: E501
        :type: CipherIntegrityAlgorithm
        """

        self._ike_cipher_integrity_algorithm = ike_cipher_integrity_algorithm

    @property
    def ike_cipher_diffie_hellman_group(self):
        """Gets the ike_cipher_diffie_hellman_group of this IpsecConnectionSpec.  # noqa: E501


        :return: The ike_cipher_diffie_hellman_group of this IpsecConnectionSpec.  # noqa: E501
        :rtype: CipherDiffieHellmanGroup
        """
        return self._ike_cipher_diffie_hellman_group

    @ike_cipher_diffie_hellman_group.setter
    def ike_cipher_diffie_hellman_group(self, ike_cipher_diffie_hellman_group):
        """Sets the ike_cipher_diffie_hellman_group of this IpsecConnectionSpec.


        :param ike_cipher_diffie_hellman_group: The ike_cipher_diffie_hellman_group of this IpsecConnectionSpec.  # noqa: E501
        :type: CipherDiffieHellmanGroup
        """

        self._ike_cipher_diffie_hellman_group = ike_cipher_diffie_hellman_group

    @property
    def esp_cipher_encryption_algorithm(self):
        """Gets the esp_cipher_encryption_algorithm of this IpsecConnectionSpec.  # noqa: E501


        :return: The esp_cipher_encryption_algorithm of this IpsecConnectionSpec.  # noqa: E501
        :rtype: CipherEncryptionAlgorithm
        """
        return self._esp_cipher_encryption_algorithm

    @esp_cipher_encryption_algorithm.setter
    def esp_cipher_encryption_algorithm(self, esp_cipher_encryption_algorithm):
        """Sets the esp_cipher_encryption_algorithm of this IpsecConnectionSpec.


        :param esp_cipher_encryption_algorithm: The esp_cipher_encryption_algorithm of this IpsecConnectionSpec.  # noqa: E501
        :type: CipherEncryptionAlgorithm
        """

        self._esp_cipher_encryption_algorithm = esp_cipher_encryption_algorithm

    @property
    def esp_cipher_integrity_algorithm(self):
        """Gets the esp_cipher_integrity_algorithm of this IpsecConnectionSpec.  # noqa: E501


        :return: The esp_cipher_integrity_algorithm of this IpsecConnectionSpec.  # noqa: E501
        :rtype: CipherIntegrityAlgorithm
        """
        return self._esp_cipher_integrity_algorithm

    @esp_cipher_integrity_algorithm.setter
    def esp_cipher_integrity_algorithm(self, esp_cipher_integrity_algorithm):
        """Sets the esp_cipher_integrity_algorithm of this IpsecConnectionSpec.


        :param esp_cipher_integrity_algorithm: The esp_cipher_integrity_algorithm of this IpsecConnectionSpec.  # noqa: E501
        :type: CipherIntegrityAlgorithm
        """

        self._esp_cipher_integrity_algorithm = esp_cipher_integrity_algorithm

    @property
    def esp_cipher_diffie_hellman_group(self):
        """Gets the esp_cipher_diffie_hellman_group of this IpsecConnectionSpec.  # noqa: E501


        :return: The esp_cipher_diffie_hellman_group of this IpsecConnectionSpec.  # noqa: E501
        :rtype: CipherDiffieHellmanGroup
        """
        return self._esp_cipher_diffie_hellman_group

    @esp_cipher_diffie_hellman_group.setter
    def esp_cipher_diffie_hellman_group(self, esp_cipher_diffie_hellman_group):
        """Sets the esp_cipher_diffie_hellman_group of this IpsecConnectionSpec.


        :param esp_cipher_diffie_hellman_group: The esp_cipher_diffie_hellman_group of this IpsecConnectionSpec.  # noqa: E501
        :type: CipherDiffieHellmanGroup
        """

        self._esp_cipher_diffie_hellman_group = esp_cipher_diffie_hellman_group

    @property
    def esp_lifetime(self):
        """Gets the esp_lifetime of this IpsecConnectionSpec.  # noqa: E501

        Absolute time after which an IPsec security association expires, in minutes.   # noqa: E501

        :return: The esp_lifetime of this IpsecConnectionSpec.  # noqa: E501
        :rtype: int
        """
        return self._esp_lifetime

    @esp_lifetime.setter
    def esp_lifetime(self, esp_lifetime):
        """Sets the esp_lifetime of this IpsecConnectionSpec.

        Absolute time after which an IPsec security association expires, in minutes.   # noqa: E501

        :param esp_lifetime: The esp_lifetime of this IpsecConnectionSpec.  # noqa: E501
        :type: int
        """

        self._esp_lifetime = esp_lifetime

    @property
    def ike_lifetime(self):
        """Gets the ike_lifetime of this IpsecConnectionSpec.  # noqa: E501

        Absolute time after which an IKE security association expires, in minutes.   # noqa: E501

        :return: The ike_lifetime of this IpsecConnectionSpec.  # noqa: E501
        :rtype: int
        """
        return self._ike_lifetime

    @ike_lifetime.setter
    def ike_lifetime(self, ike_lifetime):
        """Sets the ike_lifetime of this IpsecConnectionSpec.

        Absolute time after which an IKE security association expires, in minutes.   # noqa: E501

        :param ike_lifetime: The ike_lifetime of this IpsecConnectionSpec.  # noqa: E501
        :type: int
        """

        self._ike_lifetime = ike_lifetime

    @property
    def ike_rekey(self):
        """Gets the ike_rekey of this IpsecConnectionSpec.  # noqa: E501

        Allows control of IKE rekey.  true is enabled, false is disabled.   # noqa: E501

        :return: The ike_rekey of this IpsecConnectionSpec.  # noqa: E501
        :rtype: bool
        """
        return self._ike_rekey

    @ike_rekey.setter
    def ike_rekey(self, ike_rekey):
        """Sets the ike_rekey of this IpsecConnectionSpec.

        Allows control of IKE rekey.  true is enabled, false is disabled.   # noqa: E501

        :param ike_rekey: The ike_rekey of this IpsecConnectionSpec.  # noqa: E501
        :type: bool
        """

        self._ike_rekey = ike_rekey

    @property
    def ike_reauth(self):
        """Gets the ike_reauth of this IpsecConnectionSpec.  # noqa: E501

        Allows control of IKE re-authentication.  true is enabled, false is disabled.   # noqa: E501

        :return: The ike_reauth of this IpsecConnectionSpec.  # noqa: E501
        :rtype: bool
        """
        return self._ike_reauth

    @ike_reauth.setter
    def ike_reauth(self, ike_reauth):
        """Sets the ike_reauth of this IpsecConnectionSpec.

        Allows control of IKE re-authentication.  true is enabled, false is disabled.   # noqa: E501

        :param ike_reauth: The ike_reauth of this IpsecConnectionSpec.  # noqa: E501
        :type: bool
        """

        self._ike_reauth = ike_reauth

    @property
    def ike_authentication_type(self):
        """Gets the ike_authentication_type of this IpsecConnectionSpec.  # noqa: E501

        The IKE authentication type.  # noqa: E501

        :return: The ike_authentication_type of this IpsecConnectionSpec.  # noqa: E501
        :rtype: str
        """
        return self._ike_authentication_type

    @ike_authentication_type.setter
    def ike_authentication_type(self, ike_authentication_type):
        """Sets the ike_authentication_type of this IpsecConnectionSpec.

        The IKE authentication type.  # noqa: E501

        :param ike_authentication_type: The ike_authentication_type of this IpsecConnectionSpec.  # noqa: E501
        :type: str
        """
        allowed_values = ["ike_preshared_key", "certificate"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and ike_authentication_type not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `ike_authentication_type` ({0}), must be one of {1}"  # noqa: E501
                .format(ike_authentication_type, allowed_values)
            )

        self._ike_authentication_type = ike_authentication_type

    @property
    def ike_preshared_key(self):
        """Gets the ike_preshared_key of this IpsecConnectionSpec.  # noqa: E501

        ike preshared key  # noqa: E501

        :return: The ike_preshared_key of this IpsecConnectionSpec.  # noqa: E501
        :rtype: str
        """
        return self._ike_preshared_key

    @ike_preshared_key.setter
    def ike_preshared_key(self, ike_preshared_key):
        """Sets the ike_preshared_key of this IpsecConnectionSpec.

        ike preshared key  # noqa: E501

        :param ike_preshared_key: The ike_preshared_key of this IpsecConnectionSpec.  # noqa: E501
        :type: str
        """

        self._ike_preshared_key = ike_preshared_key

    @property
    def ike_chain_of_trust_certificates(self):
        """Gets the ike_chain_of_trust_certificates of this IpsecConnectionSpec.  # noqa: E501

        Chain of trust certficates. Certificates are PEM encoded and are separated by a newline.  ie. A signed by B would be a string where A is first, newline, followed by B.   # noqa: E501

        :return: The ike_chain_of_trust_certificates of this IpsecConnectionSpec.  # noqa: E501
        :rtype: str
        """
        return self._ike_chain_of_trust_certificates

    @ike_chain_of_trust_certificates.setter
    def ike_chain_of_trust_certificates(self, ike_chain_of_trust_certificates):
        """Sets the ike_chain_of_trust_certificates of this IpsecConnectionSpec.

        Chain of trust certficates. Certificates are PEM encoded and are separated by a newline.  ie. A signed by B would be a string where A is first, newline, followed by B.   # noqa: E501

        :param ike_chain_of_trust_certificates: The ike_chain_of_trust_certificates of this IpsecConnectionSpec.  # noqa: E501
        :type: str
        """

        self._ike_chain_of_trust_certificates = ike_chain_of_trust_certificates

    @property
    def ike_certificate_dn(self):
        """Gets the ike_certificate_dn of this IpsecConnectionSpec.  # noqa: E501

        certificate distinguished name (DN)  # noqa: E501

        :return: The ike_certificate_dn of this IpsecConnectionSpec.  # noqa: E501
        :rtype: str
        """
        return self._ike_certificate_dn

    @ike_certificate_dn.setter
    def ike_certificate_dn(self, ike_certificate_dn):
        """Sets the ike_certificate_dn of this IpsecConnectionSpec.

        certificate distinguished name (DN)  # noqa: E501

        :param ike_certificate_dn: The ike_certificate_dn of this IpsecConnectionSpec.  # noqa: E501
        :type: str
        """

        self._ike_certificate_dn = ike_certificate_dn

    @property
    def local_ipv4_block(self):
        """Gets the local_ipv4_block of this IpsecConnectionSpec.  # noqa: E501

        The local IP block that used by the tunnel. A tunnel requires a /30 subnet, within the following IP address ranges    192.168.0.0 -> 192.168.255.252   172.16.0.0 -> 172.31.255.255   # noqa: E501

        :return: The local_ipv4_block of this IpsecConnectionSpec.  # noqa: E501
        :rtype: str
        """
        return self._local_ipv4_block

    @local_ipv4_block.setter
    def local_ipv4_block(self, local_ipv4_block):
        """Sets the local_ipv4_block of this IpsecConnectionSpec.

        The local IP block that used by the tunnel. A tunnel requires a /30 subnet, within the following IP address ranges    192.168.0.0 -> 192.168.255.252   172.16.0.0 -> 172.31.255.255   # noqa: E501

        :param local_ipv4_block: The local_ipv4_block of this IpsecConnectionSpec.  # noqa: E501
        :type: str
        """

        self._local_ipv4_block = local_ipv4_block

    @property
    def remote_ipv4_ranges(self):
        """Gets the remote_ipv4_ranges of this IpsecConnectionSpec.  # noqa: E501

        One or more IP address ranges that define the peer network range.   # noqa: E501

        :return: The remote_ipv4_ranges of this IpsecConnectionSpec.  # noqa: E501
        :rtype: list[IpsecConnectionIpv4Block]
        """
        return self._remote_ipv4_ranges

    @remote_ipv4_ranges.setter
    def remote_ipv4_ranges(self, remote_ipv4_ranges):
        """Sets the remote_ipv4_ranges of this IpsecConnectionSpec.

        One or more IP address ranges that define the peer network range.   # noqa: E501

        :param remote_ipv4_ranges: The remote_ipv4_ranges of this IpsecConnectionSpec.  # noqa: E501
        :type: list[IpsecConnectionIpv4Block]
        """

        self._remote_ipv4_ranges = remote_ipv4_ranges

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, IpsecConnectionSpec):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, IpsecConnectionSpec):
            return True

        return self.to_dict() != other.to_dict()
