#!python

"""
This python script performs Local Digital Image Correlation using SPAM functions
Copyright (C) 2020 SPAM Contributors

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option)
any later version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from __future__ import print_function
import os
import argparse

import spam.DIC
import spam.deformation

import numpy
import scipy.ndimage

import tifffile

import spam.helpers

# Define argument parser object
parser = argparse.ArgumentParser(description="spam-ldic "+spam.helpers.optionsParser.GLPv3descriptionHeader +\
                                             "This script performs Local Digital Image Correlation script between a series of at least two 3D greyscale images"+\
                                             "with independent measurement points spread on a regular grid (with -ns spacing in pixels between points). "+\
                                             "Around each point a cubic subvolume of +-hws (Half-window size) is extracted and correlated"+\
                                             "\nSee for more details: https://ttk.gricad-pages.univ-grenoble-alpes.fr/spam/tutorial-02b-DIC-practice.html",
                                 formatter_class=argparse.RawTextHelpFormatter)

# Parse arguments with external helper function
args = spam.helpers.optionsParser.ldicParser(parser)

if len(args.inFiles) < 2:
    print("\nldic: Did not receive enough input images... you need (at least) two to tango...")
    exit()

if args.MPI:
    try:
        import mpi4py.MPI

        mpiComm = mpi4py.MPI.COMM_WORLD
        mpiSize = mpiComm.Get_size()
        mpiRank = mpiComm.Get_rank()
        mpiStatus = mpi4py.MPI.Status()
        numberOfWorkers = mpiSize - 1

        boss = mpiSize-1

        if mpiSize < 2:
            mpi = False
            if mpiRank == boss:
                print("ldic: I was launched with {} processes, need at least 2 for MPI, using single thread mode".format(mpiSize))
                # exit()
        else:
            mpi = True
            if mpiRank == boss:
                print("ldic: I was launched with {} processes, using MPI parallelisation".format(mpiSize))
    except:
        mpi = False
        mpiRank = None
        boss = "Olga"
else:
    mpi = False
    mpiRank = None
    boss = "Olga"

# The "else" for this "if" last seen around line 380
if mpiRank == boss or not mpi:
    print("Current Settings:")
    argsDict = vars(args)
    for key in sorted(argsDict):
        print("\t{}: {}".format(key, argsDict[key]))

    # Fill in search range as a dictionary
    searchRange = {'xRange': [args.PSR[4], args.PSR[5]],
                   'yRange': [args.PSR[2], args.PSR[3]],
                   'zRange': [args.PSR[0], args.PSR[1]]}

    # Load reference image
    im1 = tifffile.imread(args.inFiles[0].name)

    # Detect unpadded 2D image first:
    if len(im1.shape) == 2:
        im1 = im1[numpy.newaxis, ...]
    if im1.shape[0] == 1:
        twoD = True
    else:
        twoD = False

    if args.MASK1:
        im1mask = tifffile.imread(args.MASK1.name) != 0
        if len(im1mask.shape) == 2:
            im1mask = im1mask[numpy.newaxis, ...]
    else:
        im1mask = None


    firstCorrelation = True


    # Loop over input images
    for im2number in range(1, len(args.inFiles)):
        # Variables to track last correlation in order to ask MPI workers to hang up
        if im2number == len(args.inFiles)-1: lastCorrelation = True
        else: lastCorrelation = False

        # decide on number, in input files list, of the reference image
        if args.SERIES_INCREMENTAL:
            im1number = im2number-1
        else:
            im1number = 0

        # Output file name prefix
        if args.PREFIX is None or len(args.inFiles) > 2:
            args.PREFIX = os.path.splitext(os.path.basename(args.inFiles[im1number].name))[0]+"-"+os.path.splitext(os.path.basename(args.inFiles[im2number].name))[0]

        # If not first correlation and we're interested in loading previous Ffile:
        if not firstCorrelation and args.SERIES_PHIFILE:
            args.PS = 'off'
            args.REG = False
            args.PHIFILE = previousPhiFile

        print("\nCorrelating:", args.PREFIX)

        im2 = tifffile.imread(args.inFiles[im2number].name)
        if len(im2.shape) == 2:
            im2 = im2[numpy.newaxis, ...]

        assert(im1.shape == im2.shape), "\nim1 and im2 must have the same size! Exiting."
        if args.MASK1:
            assert(im1.shape == im1mask.shape), "\nim1 and im1mask must have the same size! Exiting."

        nodePositions, nodesDim = spam.DIC.grid.makeGrid(im1.shape, args.NS)

        # Initialise field of Fs with the identity matrix
        PhiField = numpy.zeros((nodePositions.shape[0], 4, 4))
        for node in range(nodePositions.shape[0]):
            PhiField[node] = numpy.eye(4)
        # define empty rigid displacements for registration:
        if args.REGSUB: rigidDisp = numpy.zeros((nodePositions.shape[0], 3))
        ##################################################################
        # Rough estimates of displacement:
        # Option 1: Do a registration (single-image correlation)
        # Option 2: Load a previous registration
        # Option 3: Perform a displacement-only pixel search
        # Option X: (one day) Perform FFT correlation
        ##################################################################

        # Option 1 -- attempt registration
        #####################################
        registrationSuccessful = False
        if args.REG:
            print("\tldic: Starting registration")
            # Run registration
            regReturns = spam.DIC.correlate.registerMultiscale(im1, im2,
                                                               args.REG_BIN_BEGIN, binStop=args.REG_BIN_END,
                                                               margin=int(args.REG_MARGIN * min(im1.shape)),
                                                               im1mask=im1mask,
                                                               interpolationOrder=1,
                                                               maxIterations=500,
                                                               deltaPhiMin=0.0001,
                                                               updateGradient=args.REG_UPDATE,
                                                               interpolator='C',
                                                               verbose=True)

            if regReturns['returnStatus'] != 2:
                print("spam-ddic: Registration did not converge, try increasing the registration margin?")
            else:
                print("spam-ddic: Registration converged beautifully...")
                registrationSuccessful = True

                print("\tTranslations (px)")
                print("\t\t", spam.deformation.decomposePhi(regReturns['Phi'])['t'])
                print("\tRotations (deg)")
                print("\t\t", spam.deformation.decomposePhi(regReturns['Phi'])['r'])

                regPhi = regReturns['Phi']
                regCentre = (numpy.array(im1.shape)/args.REG_BIN_END - 1) / 2.0

                # Not right in 100% of cases, but disactivate pixelSearch if the registration has converged
                # args.PS = False
                # Also disactive loading further guesses.
                args.PHIFILE = None

                # Make a copy and downscale displacements to final binning level
                regReturnsOutput = regReturns.copy()
                regReturnsOutput['Phi'][0:3,-1] /= float(args.REG_BIN_END)

                # if args.TSV:
                spam.helpers.tsvio.writeRegistrationTSV(args.OUT_DIR + "/" + args.PREFIX + "-bin{:d}".format(args.REG_BIN_END) + "-registration.tsv", regCentre, regReturnsOutput)
                del regReturnsOutput

        # Option 2 - load previous DVC
        #################################
        if args.PHIFILE is not None:
            FfromFile = spam.helpers.tsvio.readCorrelationTSV(args.PHIFILE, fieldBinRatio=args.PHIFILE_BIN_RATIO)

            # We read an F file, also prevent pixel search
            #args.PS = False

            # If the read F-file has only one line -- it's a single point registration!
            if FfromFile['fieldCoords'].shape[0] == 1:
                regPhi = FfromFile['PhiField'][0]
                regCentre = FfromFile['fieldCoords'][0]
                registrationSuccessful = True
                print("\tI read a registration from a file in binning {} at centre {} at this scale".format(args.PHIFILE_BIN_RATIO, regCentre) )

                print("\tTranslations (px)")
                print("\t\t", spam.deformation.decomposePhi(regPhi)['t'])
                print("\tRotations (deg)")
                print("\t\t", spam.deformation.decomposePhi(regPhi)['r'])

            # If the read F-file contains multiple lines it's an F field!
            else:
                # Disactivate the application of registration
                registrationSuccessful = False

                # Replace F components of the current grid to zeros
                for node in range(nodePositions.shape[0]):
                    PhiField[node][:-1] = numpy.zeros((3, 4))

                # Read the coordinates and values of the input F field
                fieldCoords = FfromFile["fieldCoords"]

                # Check if the correction of the input field is asked
                if args.CORRECT_FIELD:
                    fieldValues = spam.deformation.correctPhiField(fileName=args.PHIFILE,
                                                                   fieldBinRatio=args.PHIFILE_BIN_RATIO,
                                                                   correctBadPoints=True,
                                                                   deltaPhiNormMin=args.CORRECT_DELTA_PHI_NORM,
                                                                   pixelSearchCCmin=args.CORRECT_PIXEL_SEARCH_CC,
                                                                   nNeighbours=args.CORRECT_NEIGHBOURS,
                                                                   filterPoints=args.CORRECT_MEDIAN_FILTER,
                                                                   filterPointsRadius=args.CORRECT_MEDIAN_FILTER_RADIUS)
                else:
                    fieldValues = FfromFile["PhiField"]

                # Create the k-d tree of the coordinates of the input F field
                from scipy.spatial import KDTree
                nNeighbours = args.CORRECT_NEIGHBOURS
                fieldTree = KDTree(fieldCoords)

                # Loop over each point of the current grid
                for node in range(nodePositions.shape[0]):
                    # if verbose: print "\nWorking on node {} {:0.2f}%".format( node, (node/float(numberofPoints))*100)

                    # Calculate the distance of the point of the current grid to the points of the input F field
                    distance, indices = fieldTree.query(nodePositions[node], k=nNeighbours)

                    # Check if we've hit the same point in the two grids
                    if numpy.any(distance == 0):

                        # Copy F of that point to the F in the current grid point
                        PhiField[node] = fieldValues[indices][numpy.where(distance == 0)].copy()

                    # If not, consider the closest neighbours
                    else:

                        # Compute the "Inverse Distance Weighting" since the closest points should have the major influence
                        weightSumInv = sum(1/distance)

                        # Loop over each neighbour
                        for neighbour in range(nNeighbours):

                            # Calculate it's weight
                            weightInv = (1/distance[neighbour])/float(weightSumInv)

                            # Fill the F of the current grid point with the weighted F components of the ith nearest neighbour in the input F field
                            PhiField[node][:-1] += fieldValues[indices[neighbour]][:-1]*weightInv

        # Apply registration (just done or loaded) to mesh
        if registrationSuccessful:
            # We have a registration to apply to all points.
            # This is done in 2 steps:
            #   1. by copying the registration's little F to the Fs of all points
            #   2. by calling the decomposePhi function to compute the translation of each point
            for node in range(nodePositions.shape[0]):
                PhiField[node] = regPhi.copy()
                PhiField[node][0:3, -1] = spam.deformation.decomposePhi(regPhi.copy(), PhiCentre=regCentre, PhiPoint=nodePositions[node])["t"]
                #PhiField[node][0:3, -1] = -numpy.array(spam.deformation.decomposePhi(numpy.linalg.inv(regPhi), Phi=regCentre, PhiPoint=nodePositions[node])["t"])

            # Now recompute F to be only rigid, and calculate rigid-body translations for each point
            if args.REGSUB:
                regPhiRigid = spam.deformation.computeRigidPhi(regPhi.copy())
                for node in range(nodePositions.shape[0]):
                    rigidDisp[node] = spam.deformation.decomposePhi(regPhiRigid.copy(),
                                                                    PhiCentre=regCentre,
                                                                    PhiPoint=nodePositions[node])["t"]

            # print "\nInitial PhiField"
            # print PhiField
            # exit()

        # Option 3 - pixel search
        ############################
        if args.PS == 'on' or ( registrationSuccessful == False and args.PS == 'auto'):
            pixelSearchReturns = spam.DIC.grid.pixelSearchOnGrid(im1, im2,
                                                                 nodePositions,
                                                                 args.HWS, searchRange,
                                                                 PhiField=PhiField,
                                                                 im1mask=im1mask,
                                                                 greyThreshold=[args.GREY_LOW_THRESH, args.GREY_HIGH_THRESH])
            PhiField = pixelSearchReturns['PhiField']
            PSCC = pixelSearchReturns['pixelSearchCC']

            if args.PS_FILTER > 0:
                print("\n\n\tMedian-Filtering displacements...")
                PhiField[:, 0, 3] = scipy.ndimage.generic_filter(PhiField[:, 0, 3].reshape(nodesDim), numpy.nanmedian, size=args.PS_FILTER, mode='constant', cval=0.0).ravel()
                PhiField[:, 1, 3] = scipy.ndimage.generic_filter(PhiField[:, 1, 3].reshape(nodesDim), numpy.nanmedian, size=args.PS_FILTER, mode='constant', cval=0.0).ravel()
                PhiField[:, 2, 3] = scipy.ndimage.generic_filter(PhiField[:, 2, 3].reshape(nodesDim), numpy.nanmedian, size=args.PS_FILTER, mode='constant', cval=0.0).ravel()

        if args.GRID_POINT:
            subPixelReturns = spam.DIC.grid.registerOnGrid(im1, im2,
                                                           nodePositions,
                                                           args.HWS,
                                                           PhiField=PhiField,
                                                           margin=args.GRID_POINT_MARGIN,
                                                           maxIterations=args.GRID_POINT_MAX_ITERATIONS,
                                                           deltaPhiMin=args.GRID_POINT_MIN_PHI_CHANGE,
                                                           updateGradient=args.GRID_POINT_UPDATE_GRADIENT,
                                                           im1mask=im1mask,
                                                           minMaskCoverage = args.GRID_POINT_MASK_COVERAGE,
                                                           interpolationOrder=args.GRID_POINT_INTERPOLATION_ORDER,
                                                           greyThreshold=[args.GREY_LOW_THRESH, args.GREY_HIGH_THRESH],
                                                           mpi=mpi)

        # Finished! Get ready for output.
        if args.REGSUB:
            print("\n\tFinished correlations. Subtracting rigid-body motion from displacements of each point")
            PhiFieldMinusRigid = PhiField.copy()
            for node in range(nodePositions.shape[0]):
                PhiFieldMinusRigid[node][0:3,-1] -= rigidDisp[node]

        if args.TSV:
            # Make one big array for writing:
            #   First the node number,
            #   3 node positions,
            #   F[0:3,0:2]
            #   Pixel-search CC
            #   SubPixError, SubPixIterations, SubPixelReturnStatus
            TSVheader = "NodeNumber\tZpos\tYpos\tXpos\tFzz\tFzy\tFzx\tZdisp\tFyz\tFyy\tFyx\tYdisp\tFxz\tFxy\tFxx\tXdisp"
            outMatrix = numpy.array([numpy.array(range(nodePositions.shape[0])),
                                     nodePositions[:, 0], nodePositions[:, 1], nodePositions[:, 2],
                                     PhiField[:, 0, 0],         PhiField[:, 0, 1],         PhiField[:, 0, 2],    PhiField[:, 0, 3],
                                     PhiField[:, 1, 0],         PhiField[:, 1, 1],         PhiField[:, 1, 2],    PhiField[:, 1, 3],
                                     PhiField[:, 2, 0],         PhiField[:, 2, 1],         PhiField[:, 2, 2],    PhiField[:, 2, 3]]).T
            if args.PS == 'on' or ( registrationSuccessful == False and args.PS == 'auto'):
                outMatrix = numpy.hstack([outMatrix, numpy.array([PSCC]).T])
                TSVheader = TSVheader+"\tPSCC"

            if args.GRID_POINT:
                outMatrix = numpy.hstack([outMatrix, numpy.array([subPixelReturns['error'],
                                                                  subPixelReturns['iterations'],
                                                                  subPixelReturns['returnStatus'],
                                                                  subPixelReturns['deltaPhiNorm']]).T])
                TSVheader = TSVheader+"\terror\titerations\treturnStatus\tdeltaPhiNorm"

            numpy.savetxt(args.OUT_DIR+"/"+args.PREFIX+".tsv",
                          outMatrix,
                          fmt='%.7f',
                          delimiter='\t',
                          newline='\n',
                          comments='',
                          header=TSVheader)
            # Hold onto that name if we need to reload
            if args.SERIES_PHIFILE: previousPhiFile = args.OUT_DIR+"/"+args.PREFIX+".tsv"

            if args.REGSUB:
                outMatrix = numpy.array([numpy.array(range(nodePositions.shape[0])),
                                         nodePositions[:, 0], nodePositions[:, 1], nodePositions[:, 2],
                                         PhiFieldMinusRigid[:, 0, 0],         PhiFieldMinusRigid[:, 0, 1],         PhiFieldMinusRigid[:, 0, 2],    PhiFieldMinusRigid[:, 0, 3],
                                         PhiFieldMinusRigid[:, 1, 0],         PhiFieldMinusRigid[:, 1, 1],         PhiFieldMinusRigid[:, 1, 2],    PhiFieldMinusRigid[:, 1, 3],
                                         PhiFieldMinusRigid[:, 2, 0],         PhiFieldMinusRigid[:, 2, 1],         PhiFieldMinusRigid[:, 2, 2],    PhiFieldMinusRigid[:, 2, 3]]).T
                if args.PS == 'on' or ( registrationSuccessful == False and args.PS == 'auto'):
                    outMatrix = numpy.hstack([outMatrix, numpy.array([PSCC]).T])

                if args.GRID_POINT:
                    outMatrix = numpy.hstack([outMatrix, numpy.array([subPixelReturns['error'],
                                                                      subPixelReturns['iterations'],
                                                                      subPixelReturns['returnStatus'],
                                                                      subPixelReturns['deltaPhiNorm']]).T])
                numpy.savetxt(args.OUT_DIR+"/"+args.PREFIX+"-regsub.tsv",
                              outMatrix,
                              fmt='%.7f',
                              delimiter='\t',
                              newline='\n',
                              comments='',
                              header=TSVheader)

        if args.TIFF:
            if nodesDim[0] != 1:
                tifffile.imsave(args.OUT_DIR+"/"+args.PREFIX+"-Zdisp.tif",              PhiField[:, 0, -1].astype('<f4').reshape(nodesDim))
                if args.REGSUB:
                    tifffile.imsave(args.OUT_DIR+"/"+args.PREFIX+"-Zdisp-regsub.tif",   PhiFieldMinusRigid[:, 0, -1].astype('<f4').reshape(nodesDim))
            tifffile.imsave(args.OUT_DIR+"/"+args.PREFIX+"-Ydisp.tif",                  PhiField[:, 1, -1].astype('<f4').reshape(nodesDim))
            tifffile.imsave(args.OUT_DIR+"/"+args.PREFIX+"-Xdisp.tif",                  PhiField[:, 2, -1].astype('<f4').reshape(nodesDim))
            if args.REGSUB:
                tifffile.imsave(args.OUT_DIR+"/"+args.PREFIX+"-Ydisp-regsub.tif",       PhiFieldMinusRigid[:, 1, -1].astype('<f4').reshape(nodesDim))
                tifffile.imsave(args.OUT_DIR+"/"+args.PREFIX+"-Xdisp-regsub.tif",       PhiFieldMinusRigid[:, 2, -1].astype('<f4').reshape(nodesDim))
            if args.PS == 'on' or ( registrationSuccessful == False and args.PS == 'auto'):
                tifffile.imsave(args.OUT_DIR+"/"+args.PREFIX+"-PSCC.tif",               PSCC.astype('<f4').reshape(nodesDim))
            if args.GRID_POINT:
                tifffile.imsave(args.OUT_DIR+"/"+args.PREFIX+"-error.tif",        subPixelReturns['error'].astype('<f4').reshape(nodesDim))
                tifffile.imsave(args.OUT_DIR+"/"+args.PREFIX+"-iterations.tif",   subPixelReturns['iterations'].astype('<f4').reshape(nodesDim))
                tifffile.imsave(args.OUT_DIR+"/"+args.PREFIX+"-returnStatus.tif", subPixelReturns['returnStatus'].astype('<f4').reshape(nodesDim))
                tifffile.imsave(args.OUT_DIR+"/"+args.PREFIX+"-deltaPhiNorm.tif", subPixelReturns['deltaPhiNorm'].astype('<f4').reshape(nodesDim))

        # Collect data into VTK output
        if args.VTK:
            cellData = {}
            if args.PS == 'on' or ( registrationSuccessful == False and args.PS == 'auto'):
                cellData['displacements'] =  PhiField[:, :-1, 3].reshape((nodesDim[0], nodesDim[1], nodesDim[2], 3))
                cellData['PSCC']          = PSCC.reshape(nodesDim)

            if args.GRID_POINT:
                cellData['displacements']         = PhiField[:, :-1, 3].reshape((nodesDim[0], nodesDim[1], nodesDim[2], 3))
                if args.REGSUB:
                    cellData['displacements-regsub'] = PhiFieldMinusRigid[:, :-1, 3].reshape((nodesDim[0], nodesDim[1], nodesDim[2], 3))
                cellData['error']        = subPixelReturns['error'].reshape(nodesDim)
                cellData['iterations']   = subPixelReturns['iterations'].reshape(nodesDim)
                cellData['returnStatus'] = subPixelReturns['returnStatus'].reshape(nodesDim)
                cellData['deltaPhiNorm'] = subPixelReturns['deltaPhiNorm'].reshape(nodesDim)

                cellData['error'       ][numpy.logical_not(numpy.isfinite(cellData['error']))]        = 0
                cellData['iterations'  ][numpy.logical_not(numpy.isfinite(cellData['iterations']))]   = 0
                cellData['returnStatus'][numpy.logical_not(numpy.isfinite(cellData['returnStatus']))] = 0
                cellData['deltaPhiNorm'][numpy.logical_not(numpy.isfinite(cellData['deltaPhiNorm']))] = 0

            # Overwrite nans and infs with 0, rubbish I know
            cellData['displacements'][numpy.logical_not(numpy.isfinite(cellData['displacements']))] = 0
            if args.REGSUB:
                cellData['displacements-regsub'][numpy.logical_not(numpy.isfinite(cellData['displacements-regsub']))] = 0

            # This is perfect in the case where NS = 2xHWS, these cells will all be in the right place
            #   In the case of overlapping of under use of data, it should be approximately correct
            # If you insist on overlapping, then perhaps it's better to save each point as a cube glyph
            #   and actually *have* overlapping
            spam.helpers.writeStructuredVTK(origin=nodePositions[0]-args.HWS, aspectRatio=args.NS, cellData=cellData, fileName=args.OUT_DIR+"/"+args.PREFIX+".vtk")
        firstCorrelation = False

        if args.SERIES_INCREMENTAL:
            # If in incremental mode, current deformed image is next reference image
            im1 = im2.copy()


    # tidy up, send message type -1 to all workers
    if mpi:
        for worker in range(numberOfWorkers ): mpiComm.send( None, dest=worker, tag=5)

    print("\n")

elif mpi:  # We are not the mpi boss, so we are a lukasKanade worker
    import spam.DIC.correlate
    while True:
        m = mpiComm.recv(source=boss, tag=mpi4py.MPI.ANY_TAG, status=mpiStatus)
        tag = mpiStatus.Get_tag()
        # We've recieved a node to process
        if tag == 1:
            pixelSearchReturns = spam.DIC.correlate.pixelSearch(m['im1'],
                                                                m['im2'],
                                                                searchRange=m['searchRangeForThisNode'],
                                                                searchCentre=m['searchCentre'])
            # print "\t\tI am worker {} Sending result for node {}".format( mpiRank, node )
            mpiComm.send([mpiRank, m['nodeNumber'], pixelSearchReturns, m['initialDisplacement']], dest=boss, tag=2)

        elif tag == 3:
            # print "\n\n\t\tI am worker {} working on node {}".format( mpiRank, m )
            lukasKanadeReturns = spam.DIC.correlate.register(m['im1'],
                                                             m['im2'],
                                                             im1mask=m['im1mask'],
                                                             PhiInit=m['PhiInit'],
                                                             margin=m['margin'],
                                                             maxIterations=m['maxIterations'],
                                                             deltaPhiMin=m['deltaPhiMin'],
                                                             updateGradient=m['updateGradient'],
                                                             interpolationOrder=m['interpolationOrder'],
                                                             interpolator=m['interpolator'])
            # print "\t\tI am worker {} Sending result for node {}".format( mpiRank, node )
            mpiComm.send([mpiRank, m['nodeNumber'], lukasKanadeReturns, m['nodeDisplacement']], dest=boss, tag=4)

        elif tag == 5:
            # print("\t\tWorker {}: Quitting, bye!".format(mpiRank))
            exit()

        else:
            print("\t\tWorker {}: Don't recognise tag {}".format(mpiRank, tag))
            # print("\t\tMessage:", message)
