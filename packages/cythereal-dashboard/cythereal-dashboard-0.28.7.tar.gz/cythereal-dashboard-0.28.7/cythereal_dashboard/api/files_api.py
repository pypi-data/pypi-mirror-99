# coding: utf-8

"""
    Cythereal Dashboard API

     The API used exclusively by the MAGIC Dashboard for populating charts, graphs, tables, etc... on the dashboard.  # API Conventions  **All responses** MUST be of type `APIResponse` and contain the following fields:  * `api_version` |  The current api version * `success` | Boolean value indicating if the operation succeeded. * `code` | Status code. Typically corresponds to the HTTP status code.  * `message` | A human readable message providing more details about the operation. Can be null or empty.  **Successful operations** MUST return a `SuccessResponse`, which extends `APIResponse` by adding:  * `data` | Properties containing the response object. * `success` | MUST equal True  When returning objects from a successful response, the `data` object SHOULD contain a property named after the requested object type. For example, the `/alerts` endpoint should return a response object with `data.alerts`. This property SHOULD  contain a list of the returned objects. For the `/alerts` endpoint, the `data.alerts` property contains a list of MagicAlerts objects. See the `/alerts` endpoint documentation for an example.  **Failed Operations** MUST return an `ErrorResponse`, which extends `APIResponse` by adding:  * `success` | MUST equal False.   # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: support@cythereal.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from cythereal_dashboard.api_client import ApiClient


class FilesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_binary(self, binary_id, auth_key, **kwargs):  # noqa: E501
        """Add public binaries to your account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_binary(binary_id, auth_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] binary_id: The SHA1 of the binary to add to your collection. Specify parameter multiple times to add multiple binaries.  Only public binaries will be added. The list of successfully added binaries will be in the 'data' key  (required)
        :param str auth_key: Api key to keep in the POST body used for authentication (required)
        :return: FilesAddedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_binary_with_http_info(binary_id, auth_key, **kwargs)  # noqa: E501
        else:
            (data) = self.add_binary_with_http_info(binary_id, auth_key, **kwargs)  # noqa: E501
            return data

    def add_binary_with_http_info(self, binary_id, auth_key, **kwargs):  # noqa: E501
        """Add public binaries to your account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_binary_with_http_info(binary_id, auth_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] binary_id: The SHA1 of the binary to add to your collection. Specify parameter multiple times to add multiple binaries.  Only public binaries will be added. The list of successfully added binaries will be in the 'data' key  (required)
        :param str auth_key: Api key to keep in the POST body used for authentication (required)
        :return: FilesAddedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['binary_id', 'auth_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_binary" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'binary_id' is set
        if ('binary_id' not in params or
                params['binary_id'] is None):
            raise ValueError("Missing the required parameter `binary_id` when calling `add_binary`")  # noqa: E501
        # verify the required parameter 'auth_key' is set
        if ('auth_key' not in params or
                params['auth_key'] is None):
            raise ValueError("Missing the required parameter `auth_key` when calling `add_binary`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'binary_id' in params:
            query_params.append(('binary_id', params['binary_id']))  # noqa: E501
            collection_formats['binary_id'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'auth_key' in params:
            body_params = params['auth_key']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_query_param']  # noqa: E501

        return self.api_client.call_api(
            '/files/add/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesAddedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_file(self, filedata, **kwargs):  # noqa: E501
        """Upload a file for processing  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_file(filedata, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file filedata: Binary contents of the file (required)
        :param str filename: Name of the file being uploaded
        :param str password: If uploading a password protected zip, this field MUST contain the password. 
        :param list[str] tags: A comma separated list of tags to create (Will not auto tag the file) 
        :param int priority: Analysis priority. Higher priority files are analyzed first. Priorities higher than default may require additional privileges.
        :return: FileUploadResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_file_with_http_info(filedata, **kwargs)  # noqa: E501
        else:
            (data) = self.create_file_with_http_info(filedata, **kwargs)  # noqa: E501
            return data

    def create_file_with_http_info(self, filedata, **kwargs):  # noqa: E501
        """Upload a file for processing  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_file_with_http_info(filedata, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file filedata: Binary contents of the file (required)
        :param str filename: Name of the file being uploaded
        :param str password: If uploading a password protected zip, this field MUST contain the password. 
        :param list[str] tags: A comma separated list of tags to create (Will not auto tag the file) 
        :param int priority: Analysis priority. Higher priority files are analyzed first. Priorities higher than default may require additional privileges.
        :return: FileUploadResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filedata', 'filename', 'password', 'tags', 'priority']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'filedata' is set
        if ('filedata' not in params or
                params['filedata'] is None):
            raise ValueError("Missing the required parameter `filedata` when calling `create_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501
        if 'password' in params:
            query_params.append(('password', params['password']))  # noqa: E501
        if 'priority' in params:
            query_params.append(('priority', params['priority']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'filedata' in params:
            local_var_files['filedata'] = params['filedata']  # noqa: E501
        if 'tags' in params:
            form_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'csv'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_query_param']  # noqa: E501

        return self.api_client.call_api(
            '/files/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileUploadResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_file(self, file_hash, **kwargs):  # noqa: E501
        """Download a file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_file(file_hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_hash: A cryptographic hash of a file. Supported hashes are SHA1. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.download_file_with_http_info(file_hash, **kwargs)  # noqa: E501
        else:
            (data) = self.download_file_with_http_info(file_hash, **kwargs)  # noqa: E501
            return data

    def download_file_with_http_info(self, file_hash, **kwargs):  # noqa: E501
        """Download a file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_file_with_http_info(file_hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_hash: A cryptographic hash of a file. Supported hashes are SHA1. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_hash']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_hash' is set
        if ('file_hash' not in params or
                params['file_hash'] is None):
            raise ValueError("Missing the required parameter `file_hash` when calling `download_file`")  # noqa: E501

        if 'file_hash' in params and not re.search(r'^([a-fA-F0-9]{32}|[a-fA-F0-9]{40}|[a-fA-F0-9]{64}|[a-fA-F0-9]{128})$', params['file_hash']):  # noqa: E501
            raise ValueError("Invalid value for parameter `file_hash` when calling `download_file`, must conform to the pattern `/^([a-fA-F0-9]{32}|[a-fA-F0-9]{40}|[a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'file_hash' in params:
            path_params['file_hash'] = params['file_hash']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_query_param']  # noqa: E501

        return self.api_client.call_api(
            '/files/{file_hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file_details(self, file_hash, **kwargs):  # noqa: E501
        """Get additional details about certain filetypes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_details(file_hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_hash: A cryptographic hash of a file. Supported hashes are SHA1. (required)
        :return: FileDetailsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_file_details_with_http_info(file_hash, **kwargs)  # noqa: E501
        else:
            (data) = self.get_file_details_with_http_info(file_hash, **kwargs)  # noqa: E501
            return data

    def get_file_details_with_http_info(self, file_hash, **kwargs):  # noqa: E501
        """Get additional details about certain filetypes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_details_with_http_info(file_hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_hash: A cryptographic hash of a file. Supported hashes are SHA1. (required)
        :return: FileDetailsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_hash']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_hash' is set
        if ('file_hash' not in params or
                params['file_hash'] is None):
            raise ValueError("Missing the required parameter `file_hash` when calling `get_file_details`")  # noqa: E501

        if 'file_hash' in params and not re.search(r'^([a-fA-F0-9]{32}|[a-fA-F0-9]{40}|[a-fA-F0-9]{64}|[a-fA-F0-9]{128})$', params['file_hash']):  # noqa: E501
            raise ValueError("Invalid value for parameter `file_hash` when calling `get_file_details`, must conform to the pattern `/^([a-fA-F0-9]{32}|[a-fA-F0-9]{40}|[a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'file_hash' in params:
            path_params['file_hash'] = params['file_hash']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_query_param']  # noqa: E501

        return self.api_client.call_api(
            '/files/{file_hash}/details', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileDetailsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file_info(self, file_hash, **kwargs):  # noqa: E501
        """Get file info and analysis status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_info(file_hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_hash: A cryptographic hash of a file. Supported hashes are SHA1. (required)
        :return: FileInfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_file_info_with_http_info(file_hash, **kwargs)  # noqa: E501
        else:
            (data) = self.get_file_info_with_http_info(file_hash, **kwargs)  # noqa: E501
            return data

    def get_file_info_with_http_info(self, file_hash, **kwargs):  # noqa: E501
        """Get file info and analysis status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_info_with_http_info(file_hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_hash: A cryptographic hash of a file. Supported hashes are SHA1. (required)
        :return: FileInfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_hash']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_hash' is set
        if ('file_hash' not in params or
                params['file_hash'] is None):
            raise ValueError("Missing the required parameter `file_hash` when calling `get_file_info`")  # noqa: E501

        if 'file_hash' in params and not re.search(r'^([a-fA-F0-9]{32}|[a-fA-F0-9]{40}|[a-fA-F0-9]{64}|[a-fA-F0-9]{128})$', params['file_hash']):  # noqa: E501
            raise ValueError("Invalid value for parameter `file_hash` when calling `get_file_info`, must conform to the pattern `/^([a-fA-F0-9]{32}|[a-fA-F0-9]{40}|[a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'file_hash' in params:
            path_params['file_hash'] = params['file_hash']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_query_param']  # noqa: E501

        return self.api_client.call_api(
            '/files/{file_hash}/info/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileInfoResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file_status(self, file_hash, **kwargs):  # noqa: E501
        """Get processing status of the file.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_status(file_hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_hash: A cryptographic hash of a file. Supported hashes are SHA1. (required)
        :return: FileStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_file_status_with_http_info(file_hash, **kwargs)  # noqa: E501
        else:
            (data) = self.get_file_status_with_http_info(file_hash, **kwargs)  # noqa: E501
            return data

    def get_file_status_with_http_info(self, file_hash, **kwargs):  # noqa: E501
        """Get processing status of the file.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_status_with_http_info(file_hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_hash: A cryptographic hash of a file. Supported hashes are SHA1. (required)
        :return: FileStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_hash']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_hash' is set
        if ('file_hash' not in params or
                params['file_hash'] is None):
            raise ValueError("Missing the required parameter `file_hash` when calling `get_file_status`")  # noqa: E501

        if 'file_hash' in params and not re.search(r'^([a-fA-F0-9]{32}|[a-fA-F0-9]{40}|[a-fA-F0-9]{64}|[a-fA-F0-9]{128})$', params['file_hash']):  # noqa: E501
            raise ValueError("Invalid value for parameter `file_hash` when calling `get_file_status`, must conform to the pattern `/^([a-fA-F0-9]{32}|[a-fA-F0-9]{40}|[a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'file_hash' in params:
            path_params['file_hash'] = params['file_hash']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_query_param']  # noqa: E501

        return self.api_client.call_api(
            '/files/{file_hash}/status/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileStatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_owned_files(self, **kwargs):  # noqa: E501
        """List files owned by the authenticated user.  # noqa: E501

        List files owned by the authenticated user.  This includes files uploaded by the user and files created from these originally uploaded files. Known issues:   - Upload date is based on the date *any* user uploaded the file, not specifically this user.   - If the user has uploaded a large amount of files (order of 100k), a query without the date     filter will cause the server to time out. The workaround is to filter by date.   - If the user has uploaded a large amount of files on any given date, filtering by this date     will still cause the server to timeout.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_owned_files(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str _date: Return uploads from the given date. If not provided, all owned files from startDate to endDate will be returned Specify date as `YYYY-MM-DD`. 
        :param str start_date: Return uploads from the given date until endDate. Specify date as `YYYY-MM-DD`. 
        :param str end_date: Return uploads from startDate until the given date. Specify date as `YYYY-MM-DD`. 
        :param bool public: Return files that are marked as public. This will return **only** public files, and ignore the user's files. 
        :param bool only_top_level: Will return only uploaded files (no children) when True. 
        :param float page: Page of results to retrieve. Starts at 1.  If not provided, the first page of results will be returned. 
        :param float limit: Limit of files to return for each page. 
        :param str file_type:
        :return: OwnedFilesListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_owned_files_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_owned_files_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_owned_files_with_http_info(self, **kwargs):  # noqa: E501
        """List files owned by the authenticated user.  # noqa: E501

        List files owned by the authenticated user.  This includes files uploaded by the user and files created from these originally uploaded files. Known issues:   - Upload date is based on the date *any* user uploaded the file, not specifically this user.   - If the user has uploaded a large amount of files (order of 100k), a query without the date     filter will cause the server to time out. The workaround is to filter by date.   - If the user has uploaded a large amount of files on any given date, filtering by this date     will still cause the server to timeout.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_owned_files_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str _date: Return uploads from the given date. If not provided, all owned files from startDate to endDate will be returned Specify date as `YYYY-MM-DD`. 
        :param str start_date: Return uploads from the given date until endDate. Specify date as `YYYY-MM-DD`. 
        :param str end_date: Return uploads from startDate until the given date. Specify date as `YYYY-MM-DD`. 
        :param bool public: Return files that are marked as public. This will return **only** public files, and ignore the user's files. 
        :param bool only_top_level: Will return only uploaded files (no children) when True. 
        :param float page: Page of results to retrieve. Starts at 1.  If not provided, the first page of results will be returned. 
        :param float limit: Limit of files to return for each page. 
        :param str file_type:
        :return: OwnedFilesListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['_date', 'start_date', 'end_date', 'public', 'only_top_level', 'page', 'limit', 'file_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_owned_files" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'public' in params:
            query_params.append(('public', params['public']))  # noqa: E501
        if 'only_top_level' in params:
            query_params.append(('only_top_level', params['only_top_level']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'file_type' in params:
            query_params.append(('file_type', params['file_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_query_param']  # noqa: E501

        return self.api_client.call_api(
            '/files/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OwnedFilesListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_file(self, file_hash, **kwargs):  # noqa: E501
        """Remove a top level file from the user's account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_file(file_hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_hash: A cryptographic hash of a file. Supported hashes are SHA1. (required)
        :return: SuccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_file_with_http_info(file_hash, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_file_with_http_info(file_hash, **kwargs)  # noqa: E501
            return data

    def remove_file_with_http_info(self, file_hash, **kwargs):  # noqa: E501
        """Remove a top level file from the user's account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_file_with_http_info(file_hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_hash: A cryptographic hash of a file. Supported hashes are SHA1. (required)
        :return: SuccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_hash']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_hash' is set
        if ('file_hash' not in params or
                params['file_hash'] is None):
            raise ValueError("Missing the required parameter `file_hash` when calling `remove_file`")  # noqa: E501

        if 'file_hash' in params and not re.search(r'^([a-fA-F0-9]{32}|[a-fA-F0-9]{40}|[a-fA-F0-9]{64}|[a-fA-F0-9]{128})$', params['file_hash']):  # noqa: E501
            raise ValueError("Invalid value for parameter `file_hash` when calling `remove_file`, must conform to the pattern `/^([a-fA-F0-9]{32}|[a-fA-F0-9]{40}|[a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'file_hash' in params:
            path_params['file_hash'] = params['file_hash']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_query_param']  # noqa: E501

        return self.api_client.call_api(
            '/files/{file_hash}/remove', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reprocess_file(self, file_hash, **kwargs):  # noqa: E501
        """Reprocess a previously uploaded file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reprocess_file(file_hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_hash: A cryptographic hash of a file. Supported hashes are SHA1. (required)
        :param int priority: Analysis priority. Higher priority files are analyzed first. Priorities higher than default may require additional privileges.
        :param str password: If uploading a password protected zip, this field MUST contain the password. 
        :return: SuccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reprocess_file_with_http_info(file_hash, **kwargs)  # noqa: E501
        else:
            (data) = self.reprocess_file_with_http_info(file_hash, **kwargs)  # noqa: E501
            return data

    def reprocess_file_with_http_info(self, file_hash, **kwargs):  # noqa: E501
        """Reprocess a previously uploaded file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reprocess_file_with_http_info(file_hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_hash: A cryptographic hash of a file. Supported hashes are SHA1. (required)
        :param int priority: Analysis priority. Higher priority files are analyzed first. Priorities higher than default may require additional privileges.
        :param str password: If uploading a password protected zip, this field MUST contain the password. 
        :return: SuccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_hash', 'priority', 'password']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reprocess_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_hash' is set
        if ('file_hash' not in params or
                params['file_hash'] is None):
            raise ValueError("Missing the required parameter `file_hash` when calling `reprocess_file`")  # noqa: E501

        if 'file_hash' in params and not re.search(r'^([a-fA-F0-9]{32}|[a-fA-F0-9]{40}|[a-fA-F0-9]{64}|[a-fA-F0-9]{128})$', params['file_hash']):  # noqa: E501
            raise ValueError("Invalid value for parameter `file_hash` when calling `reprocess_file`, must conform to the pattern `/^([a-fA-F0-9]{32}|[a-fA-F0-9]{40}|[a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'file_hash' in params:
            path_params['file_hash'] = params['file_hash']  # noqa: E501

        query_params = []
        if 'priority' in params:
            query_params.append(('priority', params['priority']))  # noqa: E501
        if 'password' in params:
            query_params.append(('password', params['password']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_query_param']  # noqa: E501

        return self.api_client.call_api(
            '/files/{file_hash}/reprocess/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
