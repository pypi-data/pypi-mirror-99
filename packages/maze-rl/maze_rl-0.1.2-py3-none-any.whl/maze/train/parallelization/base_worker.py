from abc import abstractmethod
from typing import Tuple, List, Union, Dict, Any

import numpy as np
import torch

from maze.perception.perception_utils import convert_to_torch


class BaseWorkerOutput:
    """Base class for outputs generated by the agent.

    :param observations: Observations collected during the rollout.
    :param actions_taken: Actions taken during the rollout.
    :param rewards: Rewards collected during the rollout.
    :param dones: Dones collected during the rollout.
    :param infos: Infos collected during the rollout.
    """
    def __init__(self, observations: Dict[Union[str, int], Dict[str, torch.Tensor]],
                 actions_taken: Dict[Union[str, int], Dict[str, torch.Tensor]],
                 rewards: torch.Tensor, dones: torch.Tensor, infos: List[Any]):
        self.observations = observations
        self.actions_taken = actions_taken
        self.rewards = rewards
        self.dones = dones
        self.infos = infos

    @staticmethod
    def get_dict_dict_obj_attr_names() -> List[str]:
        """Retrieve the attribute names of the actor output fields that have dict dict structure.

        :return: A list of all attributes having a dict-dict structure.
        """
        return ['observations', 'actions_taken']

    @staticmethod
    def get_tensor_obj_attr_names() -> List[str]:
        """Retrieve the attribute names of the actor output fields that have tensor structure.

        :return: A list of all attributes having a tensor structure.
        """
        return ['rewards', 'dones']

    @staticmethod
    def get_list_obj_attr_names() -> List[str]:
        """Retrieve the attribute names of the actor output fields that have list structure.

        :return: A list of all attributes having a list structure.
        """
        return ['infos']

    def to(self, device: str) -> None:
        """Cast all elements to the given device.

        :param device: The device to put the output on (cpu or cuda).
        """
        for field_name in self.get_dict_dict_obj_attr_names() + self.get_tensor_obj_attr_names():
            setattr(self, field_name, convert_to_torch(getattr(self, field_name), device=device, cast=None,
                                                       in_place=False))

    def __str__(self):
        out = 'ActorOutput:'
        for name in self.get_dict_dict_obj_attr_names():
            out += f' {name}: ' + str({k: {kk: vv.shape for kk, vv in v.items()}
                                       for k, v in getattr(self, name).items()})
        for name in self.get_tensor_obj_attr_names():
            out += f' {name}: ' + str(getattr(self, name).shape)
        for name in self.get_tensor_obj_attr_names():
            out += f' {name}: ' + str(len(getattr(self, name)))
        return out


class BaseWorker:
    """This class holds a policy as well an env in order to step through the env, by producing action from the policy
    and recoding the rollout to be processed by the learner.
    """

    @abstractmethod
    def rollout(self) -> Union[Tuple[BaseWorkerOutput, List], Tuple[np.ndarray, List]]:
        """Interface to performs an agent rollout, that is sample actions, step through the env for a maximum of
        n_rollout_steps and collect data.

        :return: This rollout as an ActorOutput or array of ActorOutputs
        """

    @abstractmethod
    def update_policy(self, state_dict: Dict) -> None:
        """Update the policy with the given state dict.

        :param state_dict: State dict to load.
        """
