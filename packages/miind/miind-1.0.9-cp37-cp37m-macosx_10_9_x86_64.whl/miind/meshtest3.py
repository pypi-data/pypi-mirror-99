import unittest

from aexpdevelop import *
from miind.bary import isinsidequadrilateral
from matplotlib.path import Path
from scipy.spatial import KDTree
import miind.mesh as mesh

mesh.MAX_NEIGHBOURS=16
TEST_MESH = 'aexp.mesh'

class MeshTest(unittest.TestCase):

    if not os.path.exists(TEST_MESH):
        GenerateTestMesh()
    m = mesh.Mesh(TEST_MESH)

    def setup(self):
        return

    def tearDown(self):
        return

        
    def testMeshSlicing(self):
        ''' Just a check of the slicing order used in the parsing of a mesh. Replace the 'x' by 'print statements when needed.'''
        a = np.array([1,2,3, 4,5,6, 7, 8, 9, 10,11,12, 13,14,15])
        a.shape = (5,3)
        x =  a
        for l in a[0::2,:]:
            x = l
        for m in a[1::2,:]:
            x = m


    def testInside2(self):
        data = np.array([[-56.9872066344, 0.554565985372], [-58.4625502211, 0.199160622028], [-58.4375907348, 0.656613945886], [-56.9662529743, 1.00948787166]])
        point= np.array([-57.3,0.73])
        self.assertTrue(isinsidequadrilateral(data,point))


    def testKDTree(self):
        '''Just a check to see if we feed the right data format to KDTree.'''
        ver=np.zeros(10)
        ver.shape=(5,2)
        ver[0,0] = 0
        ver[0,1] = 0
        
        ver[1,0] = 1
        ver[1,1] = 1
        
        ver[2,0] = -1
        ver[2,1] = -1

        ver[3,0] = 0
        ver[3,1] = 10
    
        ver[4,0] = 100
        ver[4,1] = 0
        
        tree = KDTree(ver)
        
        points = np.array([[1,1.1],[1000,0.]])
        res=tree.query(points)
        self.assertTrue(res[1][0] == 1 and res[1][1] == 4)


    def testQuery(self):
        ''' This shows how the closest mesh point to a given (v,w) pair can be found. The query gives the distance [0] and the index [1]
        of the closest mesh point to (v,w). The index can be used to get the point from the data array.'''
        close = MeshTest.m.query([-50,0.5])
        point = MeshTest.m.data[close[1]]

        self.assertAlmostEqual(point[0], -49.6416200889 )
        self.assertAlmostEqual(point[1],  0.39109939 )
    


    def testNeighbours(self):

        close = MeshTest.m.query([-50,0.5])
        point = MeshTest.m.data[close[1]]

        ns =  MeshTest.m.neighbours[(point[0],point[1])]
        
        self.assertTrue(ns[0] == [7, 15] ) 
        self.assertTrue(ns[1] == [7, 16] ) 
        self.assertTrue(ns[2] == [8, 15] ) 
        self.assertTrue(ns[3] == [8, 16] ) 

    def testInBin(self):
        '''This is essentially how the bin is found that contains a tuple (v,w).
        Beware!!! It is almost always sufficient to find the closest neighbour,
        and test the bins that contains this neighbour for whether the point is
        contained. This does not always work, and testtransition.py contains 
        a counter example. For this reason in transition.py the number of neighbours
        is increased.'''

        point = [-70, -5]

        close = MeshTest.m.query(point)
        point_cl = MeshTest.m.data[close[1]]

        ns =  MeshTest.m.neighbours[(point_cl[0],point_cl[1])]


        self.assertFalse (MeshTest.m.isinbin(6,2,point))
        self.assertFalse(MeshTest.m.isinbin(6,3,point))
        self.assertTrue(MeshTest.m.isinbin(7,2,point))
        self.assertFalse(MeshTest.m.isinbin(6,3,point))


    def testShowGrid(self):
        m=mesh.Mesh('aexp.mesh')
        mesh.display_mesh(m,m.dimensions(),True)

    def testBBox(self):
        '''Test whether the right bounding box is generated. Consult the
        plot generated by mesh.py to check these values.'''
        close = MeshTest.m.query([-50,0.5])
        point = MeshTest.m.data[close[1]]
        ns    = MeshTest.m.neighbours[(point[0],point[1])]
        i = ns[0][0]
        j = ns[0][1]

    
        self.assertTrue(i == 7)
        self.assertTrue(j == 15)
    
        box =  MeshTest.m.bbox(i,j)
    
        self.assertAlmostEqual(box[0][0],-50.555337890395002)
        self.assertAlmostEqual(box[0][1], -0.61602201398800005)
        self.assertAlmostEqual(box[1][0], -49.641620088925002)
        self.assertAlmostEqual(box[1][1], 0.39109939538600003)
    
 
    def testBin(self):
        ''' For selected (v, w) tuple query which bin they're from.'''
        
        self.assertTrue(MeshTest.m.bin_from_point([-70,-5])     == [7,2]  )
        self.assertTrue(MeshTest.m.bin_from_point([-57.3,0.73]) == [16,8] )

    def testStationaryBin(self):
        '''Create a simple test grid that shows how a stationary point (reversal bin) should be added to a mesh.'''
        f=open('teststat.mesh','w')
        f.write('xxx\n') # first line doesn't matter any more
        f.write('1e-3\n')  # some made up resolution
        f.write('-3. -3. -2.5 -1.  1.   2.5  3.  3. \n')
        f.write(' 0.  1.  2.   3.  3.   2.   1.  0. \n')
        f.write('-2. -2. -1.5 -1.  1.  1.5  2.  2.\n')
        f.write(' 0.  1.  2.   2.  2.   2.   1.  0.\n')
        f.close()

        m=mesh.Mesh('teststat.mesh')

        # this is a mesh where a stationary cell is entered
        q=mesh.Quadrilateral([-1.,-1.,1.,1.],[0.,0.5,0.5,0.])
        m.insert_stationary(q)

        # it is legal to enter more than one stationary cell
        q2=mesh.Quadrilateral([-1.,-1.,1.,1.],[0.5,1.0,1.0,0.5])
        m.insert_stationary(q2)
        mesh.display_mesh(m,m.dimensions(),label=True)

    def testBlockedGrid(self):
        '''Test a grid that is built of two group of cells that are not necessarily related. The two block are split by a single line containing the
        string 'closed\n'. '''

        f=open('blocktest.mesh','w')
        f.write('xxx\n')   # first line doesn't matter any more
        f.write('1e-3\n')  # some made up resolution
        f.write(' 0.  1.  2. \n')
        f.write(' 0.  0.  0. \n')
        f.write(' 0.  1.  2. 3.\n')
        f.write(' 1.  1.  1. 1.\n')
        f.write(' 0.  1.  2. 3.\n')
        f.write(' 2.  2.  2. 2.\n')
        f.write('closed\n')
        f.write(' 0. 1.\n')
        f.write(' 3. 3.\n')
        f.write(' 0. 1.\n')
        f.write(' 4. 4.\n')
        f.close()

        m=mesh.Mesh('blocktest.mesh')
        mesh.display_mesh(m,m.dimensions(),True)


    def testInversionStrip(self):
        '''Define two diagonal strips in the conventional way. Define a third strip by inversion.'''
        
        # the first strip is demarcated by y = -nx + 3, y = -nx + 4, x = 0 and y = 0

        n = 5.
        vs = np.linspace(0.,3./n,4)
        wlow  = -n*vs + 3.
        whigh = -n*vs + 4.
        
        # the second strip is demarcated by y = nx + 3, y = nx + 4, x = 0 and y = 0

        negvs = np.linspace(0.,-3./n,4)
        negvlow  = n*negvs + 3.
        negvhigh = n*negvs + 4.

        # a strip in the center, partly covered by the side strip
        invs = np.arange(1./(2.*n),4./n,1./n)
        
        with open('inversion.mesh','w') as f:
            f.write('xxx\n')   # first line doesn't matter any more
            f.write('1e-3\n')  # some made up resolution
            for v in vs:
                f.write(str(v) + ' ')
            f.write('\n')
            for w in wlow:
                f.write(str(w) + ' ' )
            f.write('\n')
            for v in vs:
                f.write(str(v) + ' ')
            f.write('\n')
            for w in whigh:
                f.write(str(w) + ' ' )
            f.write('\n')
            f.write('closed\n')
            for v in negvs:
                f.write(str(v) + ' ')
            f.write('\n')
            for w in negvlow:
                f.write(str(w) + ' ' )
            f.write('\n')
            for v in negvs:
                f.write(str(v) + ' ')
            f.write('\n')
            for w in negvhigh:
                f.write(str(w) + ' ' )
            f.write('\n')
            f.write('inversion\n')
        
            for v in invs:
                f.write(str(v) + ' ' )
            f.write('\n')

            for w in range(3,-1,-1):
                f.write(str(float(w)) + ' ')

            f.write('\n')
            for v in invs:
                f.write(str(-v) + ' ' )
            f.write('\n')

            for w in range(3,-1,-1):
                f.write(str(float(w)) + ' ')
            f.write('\n')

    def testReadInversionMesh(self):
        m=mesh.Mesh('inversion.mesh')
            
            
if __name__ == '__main__':
    meshSuite = unittest.TestLoader().loadTestsFromTestCase(MeshTest)
    unittest.main()
