import os
import sys
import miind.include as include
import miind.algorithms as algorithms
import miind.nodes as nodes
import miind.connections as connections
import miind.reporting as reporting
import miind.simulation as simulation
import miind.variables as variables
import xml.etree.ElementTree as ET
import argparse

XML_EXTENSION = '.xml'

# Nothing too fancy for the weight type

WEIGHTTYPES = ['double', 'DelayedConnection', 'CustomConnectionParameters']

def generate_preamble(outfile):
    outfile.write('//Machine-generated by miind.py. Edit at your own risk.\n\n')
    for inc in include.lib_includes:
        outfile.write(inc +'\n')

    return

def define_network_type(type):
    if type ==  "DelayedConnection":
        s = "MPILib::" + type
    elif type == "CustomConnectionParameters":
        s = "MPILib::" + type
    else:
        s = "double"
    return 'typedef MPILib::MPINetwork<' + s + ', MPILib::utilities::CircularDistribution> Network;\n'

def abstract_type(type):
    if type ==  "DelayedConnection":
        s = "MPILib::" + type
    elif type == "CustomConnectionParameters":
        s = "MPILib::" + type
    else:
        s = "double"
    return 'MPILib::MiindTvbModelAbstract<' + s + ', MPILib::utilities::CircularDistribution>'

def define_abstract_type(type):
    if type ==  "DelayedConnection":
        s = "MPILib::" + type
    elif type == "CustomConnectionParameters":
        s = "MPILib::" + type
    else:
        s = "double"
    return 'define_python_MiindTvbModelAbstract<' + s + ', MPILib::utilities::CircularDistribution>();\n'


def generate_closing(outfile, steps, t_step, weighttype, tree, prog_name):

    outfile.write('\t}\n')
    outfile.write('\t\n')
    outfile.write('\treport_handler = new MPILib::report::handler::InactiveReportHandler();\n')
    outfile.write('\t\n')
    outfile.write('\tSimulationRunParameter par_run( *report_handler,(_simulation_length/_time_step)+1,0,\n')
    name=tree.find('SimulationRunParameter/name_log')
    log_name = name.text
    outfile.write('\t\t\t_simulation_length,_time_step,_time_step,\"' + log_name + '\");\n')
    outfile.write('\t\n')
    outfile.write('\tnetwork.configureSimulation(par_run);\n')
    outfile.write('\t}\n')

    outfile.write('\n\nprivate:\n\n')
    outfile.write('\tunsigned long _count;\n')
    outfile.write('\tstd::vector<MPILib::NodeId> _display_nodes;\n');
    outfile.write('\tstd::vector<MPILib::NodeId> _rate_nodes;\n');
    outfile.write('\tstd::vector<MPILib::Time> _rate_node_intervals;\n');
    outfile.write('\tstd::vector<MPILib::NodeId> _density_nodes;\n');
    outfile.write('\tstd::vector<MPILib::Time> _density_node_start_times;\n');
    outfile.write('\tstd::vector<MPILib::Time> _density_node_end_times;\n');
    outfile.write('\tstd::vector<MPILib::Time> _density_node_intervals;\n');
    outfile.write('\n')
    for t in  algorithms.RATEFUNCTIONS:
        outfile.write(t)

    outfile.write('\n\n')

    outfile.write('};\n\n')

def parse_xml(infile, outfile):
    tree=ET.fromstring(infile.read())
    m=tree.find('WeightType')
    s = m.text
    return define_network_type(s), tree

def constructor_override(outfile,tree,typ):

    t_begin = tree.find('SimulationRunParameter/t_begin')
    t_end = tree.find('SimulationRunParameter/t_end')

    variable_list = tree.findall('Variable')
    variables.parse_variables(variable_list,outfile)

    outfile.write('\tMiindModel(int num_nodes):\n')
    outfile.write('\t\tMiindTvbModelAbstract(num_nodes, ' + t_end.text + '),_count(0){\n')
    outfile.write('}\n\n')

    outfile.write('\tMiindModel():\n')
    outfile.write('\t\tMiindTvbModelAbstract(1, ' + t_end.text + '),_count(0){\n')
    outfile.write('}\n\n')

    if len(variable_list) > 0:
        outfile.write('\tMiindModel(int num_nodes, \n')
        variables.parse_variables_as_parameters(variable_list,outfile)
        outfile.write('):\n')
        outfile.write('\t\tMiindTvbModelAbstract(num_nodes, ' + t_end.text + '),_count(0)\n')
        variables.parse_variables_as_constructor_defaults(variable_list, outfile)
        outfile.write('{\n')
        outfile.write('}\n\n')

    if len(variable_list) > 0:
        outfile.write('\tMiindModel( \n')
        variables.parse_variables_as_parameters(variable_list,outfile)
        outfile.write('):\n')
        outfile.write('\t\tMiindTvbModelAbstract(1, ' + t_end.text + '),_count(0)\n')
        variables.parse_variables_as_constructor_defaults(variable_list, outfile)
        outfile.write('{\n')
        outfile.write('}\n\n')

def function_overrides(outfile,tree,typ):
    outfile.write('\n\tvoid endSimulation(){\n')
    outfile.write('\t\t'+ abstract_type(typ) +'::endSimulation();\n')
    outfile.write('\t}\n')

    node_list = tree.findall('Nodes/Node')
    nodemap = node_name_to_node_id(node_list)

    outfile.write('\tvoid startSimulation(){\n')
    outfile.write('\t\tstd::vector<MPILib::NodeId> density_nodes;\n')
    outfile.write('\t\tstd::vector<MPILib::Time> density_node_start_times;\n')
    outfile.write('\t\tstd::vector<MPILib::Time> density_node_end_times;\n')
    outfile.write('\t\tstd::vector<MPILib::Time> density_node_intervals;\n')
    outfile.write('\t\tstd::vector<MPILib::NodeId> rate_nodes;\n')
    outfile.write('\t\tstd::vector<MPILib::Time> rate_node_intervals;\n')
    outfile.write('\t\tstd::vector<MPILib::NodeId> display_nodes;\n')
    outfile.write('\t\tfor(unsigned int i=0; i<_num_nodes; i++) {\n')
    outfile.write(reporting.define_display_nodes(tree,nodemap,unscoped_vectors=True,looped_definition=True))
    outfile.write(reporting.define_rate_nodes(tree,nodemap,unscoped_vectors=True,looped_definition=True))
    outfile.write(reporting.define_density_nodes(tree,nodemap,unscoped_vectors=True,looped_definition=True))
    outfile.write('\t\t}\n')
    outfile.write('\n')
    outfile.write('\t\t_rate_nodes = rate_nodes;\n')
    outfile.write('\t\t_rate_node_intervals = rate_node_intervals;\n')
    outfile.write('\t\t_display_nodes = display_nodes;\n')
    outfile.write('\t\t_density_nodes = density_nodes;\n')
    outfile.write('\t\t_density_node_start_times = density_node_start_times;\n')
    outfile.write('\t\t_density_node_end_times = density_node_end_times;\n')
    outfile.write('\t\t_density_node_intervals = density_node_intervals;\n')
    outfile.write('\t\t\n')
    outfile.write('\t\tif (_display_nodes.size() > 0)\n')
    outfile.write('\t\t\tTwoDLib::Display::getInstance()->animate(true, _display_nodes,_time_step);\n')

    outfile.write('\t\t'+ abstract_type(typ) +'::startSimulation();\n')
    outfile.write('\t}\n\n')

    t_step = tree.find('SimulationRunParameter/t_step')
    outfile.write('\t\tstd::vector<double> evolveSingleStep(std::vector<double> activity){\n')
    outfile.write('\t\tnetwork.reportNodeActivities(_rate_nodes, _rate_node_intervals, (_count * ' + t_step.text + '));\n')
    outfile.write('\t\tif (_display_nodes.size() > 0)\n')
    outfile.write('\t\t\tTwoDLib::Display::getInstance()->updateDisplay(_count);\n')
    outfile.write('\t\tTwoDLib::GridReport<'+typ+'>::getInstance()->reportDensity(_density_nodes,_density_node_start_times,_density_node_end_times,_density_node_intervals,(_count * _time_step));\n')
    outfile.write('\t\t_count++;\n')
    outfile.write('\t\treturn '+ abstract_type(typ) +'::evolveSingleStep(activity);\n')
    outfile.write('\t}\n\n')

def generate_opening(outfile, tree, typ):
    outfile.write('class MiindModel : public ' + abstract_type(typ) + ' {\n')
    outfile.write('public:\n\n')
    constructor_override(outfile, tree,typ)
    function_overrides(outfile,tree,typ)
    outfile.write('\n')
    outfile.write('\tvoid init()\n')
    outfile.write('\t{\n')
    t_step = tree.find('SimulationRunParameter/t_step')
    outfile.write('\t\t_time_step = ' + t_step.text + ';\n')
    outfile.write('\t\tfor(int i=0; i<_num_nodes; i++) {\n')

def matrix_transform_name(fn):
    '''Identifies matrix transform files mentioned in an XML file. For example used in placing the right model file in
    the same directory as an XML file.'''
    infile = open(fn)
    tree=ET.fromstring(infile.read())
    ma = tree.findall('Algorithms/Algorithm')

    tmatnames = []
    for a in ma:
        if a.attrib['type'] in ['GridAlgorithm','GridAlgorithmGroup','GridJumpAlgorithm','GridSomaDendriteAlgorithm']:
            tmatnames.append(a.attrib['transformfile'])
    return tmatnames

def python_wrapper(outfile, prog_name, variable_list, num_outputs):
    addition = """
static MiindModel *model;

static PyObject *miind_init(PyObject *self, PyObject *args)
{{
    if (model) {{
        delete model;
        model = NULL;
    }}

{variable_constructors}

    Py_INCREF(Py_None);
    return Py_None;
}}

static PyObject *miind_getTimeStep(PyObject *self, PyObject *args)
{{
    return Py_BuildValue("d", model->getTimeStep());
}}

static PyObject *miind_getSimulationLength(PyObject *self, PyObject *args)
{{
    return Py_BuildValue("d", model->getSimulationLength());
}}

static PyObject *miind_startSimulation(PyObject *self, PyObject *args)
{{
    model->startSimulation();
    Py_INCREF(Py_None);
    return Py_None;
}}

static PyObject *miind_evolveSingleStep(PyObject *self, PyObject *args)
{{
    PyObject *float_list;
    int pr_length;

    if (!PyArg_ParseTuple(args, "O", &float_list))
        return NULL;
    pr_length = PyObject_Length(float_list);
    if (pr_length < 0)
        return NULL;

    std::vector<double> activities(pr_length);

    for (int index = 0; index < pr_length; index++) {{
        PyObject *item;
        item = PyList_GetItem(float_list, index);
        if (!PyFloat_Check(item))
            activities[index] = 0.0;
        activities[index] = PyFloat_AsDouble(item);
    }}

    std::vector<double> out_activities = model->evolveSingleStep(activities);

    PyObject* tuple = PyTuple_New(model->getNumNodes() * {num_external_outputs});

    for (int index = 0; index < model->getNumNodes() * {num_external_outputs}; index++) {{
        PyTuple_SetItem(tuple, index, Py_BuildValue("d", out_activities[index]));
    }}

    return tuple;
}}

static PyObject *miind_endSimulation(PyObject *self, PyObject *args)
{{
    model->endSimulation();
    Py_INCREF(Py_None);
    return Py_None;
}}

static PyMethodDef MiindModelMethods[] = {{
    {{"init",  miind_init, METH_VARARGS, "Init Miind Model."}},
    {{"getTimeStep",  miind_getTimeStep, METH_VARARGS, "Get time step."}},
    {{"getSimulationLength",  miind_getSimulationLength, METH_VARARGS, "Get sim time."}},
    {{"startSimulation",  miind_startSimulation, METH_VARARGS, "Start simulation."}},
    {{"evolveSingleStep",  miind_evolveSingleStep, METH_VARARGS, "Evolve one time step."}},
    {{"endSimulation",  miind_endSimulation, METH_VARARGS, "Clean up."}},
    {{NULL, NULL, 0, NULL}}        /* Sentinel */
}};

static struct PyModuleDef miindmodule = {{
    PyModuleDef_HEAD_INIT,
    "lib{name}",   /* name of module */
    NULL, /* module documentation, may be NULL */
    -1,       /* size of per-interpreter state of the module,
                 or -1 if the module keeps state in global variables. */
    MiindModelMethods
}};

PyMODINIT_FUNC
PyInit_lib{name}(void)
{{
    return PyModule_Create(&miindmodule);
}}
"""
    context = { "name" : prog_name, "variable_constructors" : variables.parse_variable_python_def(variable_list), "num_external_outputs" : num_outputs }

    outfile.write(addition.format(**context))

def model_name(fn):
    '''Identifies model files mentioned in an XML file. For example used in placing the right model file in
    the same directory as an XML file.'''
    infile = open(fn)
    tree=ET.fromstring(infile.read())
    ma = tree.findall('Algorithms/Algorithm')

    modelnames = []
    for a in ma:
        if a.attrib['type'] in ['GridAlgorithm','GridAlgorithmGroup','GridJumpAlgorithm','GridSomaDendriteAlgorithm','MeshAlgorithm','MeshAlgorithmGroup']:
            modelnames.append(a.attrib['modelfile'])
    return modelnames

def matrix_names(fn):
    '''Find the file names of all MatrixFiles, mentioned in an XML file.'''
    infile = open(fn)
    tree=ET.fromstring(infile.read())
    ma = tree.findall('Algorithms/Algorithm/MatrixFile')
    matrixnames = []
    for a in ma:
        matrixnames.append(a.text)
    return matrixnames

def node_name_to_node_id(nodes):
     '''Create a map from name to NodeId from node elements. Return this map.'''
     d ={}
     for i,node in enumerate(nodes):
          d[node.attrib['name']] = i
     return d

def generate_outputfile(infile, outfile, prog_name):
    generate_preamble(outfile)
    nettype, tree = parse_xml(infile,outfile)

    algies = tree.findall('Algorithms')
    if len(algies) != 1:
        raise ValueError

    alg_list = algies[0].findall('Algorithm')
    weighttype = tree.find('WeightType')
    generate_opening(outfile, tree, weighttype.text)
    outfile.write('\t// generating algorithms\n')
    algorithms.parse_algorithms(alg_list,weighttype,outfile,for_lib=True)
    node_list = tree.findall('Nodes/Node')
    outfile.write('\t// generating nodes\n')
    nodes.parse_nodes(node_list,weighttype,outfile)
    outfile.write('\t// generating connections\n')
    connection_list = tree.findall('Connections/Connection')
    connections.parse_connections(connection_list,weighttype,outfile)
    connection_list = tree.findall('Connections/IncomingConnection')
    connections.parse_incoming_connections(connection_list,weighttype,outfile)
    outgoing_connection_list = tree.findall('Connections/OutgoingConnection')
    connections.parse_outgoing_connections(outgoing_connection_list,outfile)

    t_end   = tree.find('SimulationRunParameter/t_end')
    t_step = tree.find('SimulationRunParameter/t_step')

    generate_closing(outfile, '(' + t_end.text + ') / ' + t_step.text , t_step.text, weighttype, tree, prog_name)
    variable_list = tree.findall('Variable')
    python_wrapper(outfile, prog_name,variable_list,len(outgoing_connection_list))

    algorithms.reset_algorithms()
    nodes.reset_nodes()
