# Copyright (c) 2017 Sony Corporation. All Rights Reserved.
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# *WARNING*
# THIS FILE IS AUTO-GENERATED BY CODE GENERATOR.
# PLEASE DO NOT EDIT THIS FILE BY HAND!
# If you want to modify this file, edit following files.
# - build-tools/code_generator/generator/generate_python_src_nnabla_utils_save_function_py.py
# - build-tools/code_generator/templates/python_src_nnabla_utils_save_function_py_template.py
'''
.. note::
    This module is auto-generated from

    - :file:`python/src/nnabla/utils/save_function.py`
    - :file:`build-tools/code_generator/generate.py`
'''


def _create_function_nntxt(f, name, function):
    f.name = name
    f.type = function['type']
    f.input.extend(function['inputs'])
    f.output.extend(function['outputs'])
    if f.type == 'Affine':
        f.affine_param.base_axis = function['args']['base_axis']
        pass
    elif f.type == 'RNN':
        f.rnn_param.num_layers = function['args']['num_layers']
        f.rnn_param.nonlinearity = function['args']['nonlinearity']
        f.rnn_param.dropout = function['args']['dropout']
        f.rnn_param.bidirectional = bool(function['args']['bidirectional'])
        f.rnn_param.training = bool(function['args']['training'])
        pass
    elif f.type == 'LSTM':
        f.lstm_param.num_layers = function['args']['num_layers']
        f.lstm_param.dropout = function['args']['dropout']
        f.lstm_param.bidirectional = bool(function['args']['bidirectional'])
        f.lstm_param.training = bool(function['args']['training'])
        pass
    elif f.type == 'GRU':
        f.gru_param.num_layers = function['args']['num_layers']
        f.gru_param.dropout = function['args']['dropout']
        f.gru_param.bidirectional = bool(function['args']['bidirectional'])
        f.gru_param.training = bool(function['args']['training'])
        pass
    elif f.type == 'Convolution':
        f.convolution_param.base_axis = function['args']['base_axis']
        f.convolution_param.pad.dim.extend(function['args']['pad'])
        f.convolution_param.stride.dim.extend(function['args']['stride'])
        f.convolution_param.dilation.dim.extend(function['args']['dilation'])
        f.convolution_param.group = function['args']['group']
        f.convolution_param.channel_last = bool(function['args']['channel_last'])
        pass
    elif f.type == 'FusedConvolution':
        f.fused_convolution_param.base_axis = function['args']['base_axis']
        f.fused_convolution_param.pad.dim.extend(function['args']['pad'])
        f.fused_convolution_param.stride.dim.extend(function['args']['stride'])
        f.fused_convolution_param.dilation.dim.extend(function['args']['dilation'])
        f.fused_convolution_param.group = function['args']['group']
        f.fused_convolution_param.channel_last = bool(function['args']['channel_last'])
        f.fused_convolution_param.decay_rate = function['args']['decay_rate']
        f.fused_convolution_param.eps = function['args']['eps']
        f.fused_convolution_param.batch_stat = bool(function['args']['batch_stat'])
        f.fused_convolution_param.nonlinearity = function['args']['nonlinearity']
        f.fused_convolution_param.nonlinearity_args = function['args']['nonlinearity_args']
        pass
    elif f.type == 'DepthwiseConvolution':
        f.depthwise_convolution_param.base_axis = function['args']['base_axis']
        f.depthwise_convolution_param.pad.dim.extend(function['args']['pad'])
        f.depthwise_convolution_param.stride.dim.extend(function['args']['stride'])
        f.depthwise_convolution_param.dilation.dim.extend(function['args']['dilation'])
        f.depthwise_convolution_param.multiplier = function['args']['multiplier']
        pass
    elif f.type == 'Deconvolution':
        f.deconvolution_param.base_axis = function['args']['base_axis']
        f.deconvolution_param.pad.dim.extend(function['args']['pad'])
        f.deconvolution_param.stride.dim.extend(function['args']['stride'])
        f.deconvolution_param.dilation.dim.extend(function['args']['dilation'])
        f.deconvolution_param.group = function['args']['group']
        f.deconvolution_param.channel_last = bool(function['args']['channel_last'])
        f.deconvolution_param.output_padding.dim.extend(function['args']['output_padding'])
        pass
    elif f.type == 'DepthwiseDeconvolution':
        f.depthwise_deconvolution_param.base_axis = function['args']['base_axis']
        f.depthwise_deconvolution_param.pad.dim.extend(function['args']['pad'])
        f.depthwise_deconvolution_param.stride.dim.extend(function['args']['stride'])
        f.depthwise_deconvolution_param.dilation.dim.extend(function['args']['dilation'])
        f.depthwise_deconvolution_param.divisor = function['args']['divisor']
        pass
    elif f.type == 'DeformableConvolution':
        f.deformable_convolution_param.base_axis = function['args']['base_axis']
        f.deformable_convolution_param.pad.dim.extend(function['args']['pad'])
        f.deformable_convolution_param.stride.dim.extend(function['args']['stride'])
        f.deformable_convolution_param.dilation.dim.extend(function['args']['dilation'])
        f.deformable_convolution_param.group = function['args']['group']
        f.deformable_convolution_param.deformable_group = function['args']['deformable_group']
        f.deformable_convolution_param.channel_last = bool(function['args']['channel_last'])
        pass
    elif f.type == 'AdaptiveSeparableConvolution':
        pass
    elif f.type == 'MaxPooling':
        f.max_pooling_param.kernel.dim.extend(function['args']['kernel'])
        f.max_pooling_param.stride.dim.extend(function['args']['stride'])
        f.max_pooling_param.ignore_border = bool(function['args']['ignore_border'])
        f.max_pooling_param.pad.dim.extend(function['args']['pad'])
        f.max_pooling_param.channel_last = bool(function['args']['channel_last'])
        pass
    elif f.type == 'AveragePooling':
        f.average_pooling_param.kernel.dim.extend(function['args']['kernel'])
        f.average_pooling_param.stride.dim.extend(function['args']['stride'])
        f.average_pooling_param.ignore_border = bool(function['args']['ignore_border'])
        f.average_pooling_param.pad.dim.extend(function['args']['pad'])
        f.average_pooling_param.channel_last = bool(function['args']['channel_last'])
        f.average_pooling_param.including_pad = bool(function['args']['including_pad'])
        pass
    elif f.type == 'GlobalAveragePooling':
        pass
    elif f.type == 'SumPooling':
        f.sum_pooling_param.kernel.dim.extend(function['args']['kernel'])
        f.sum_pooling_param.stride.dim.extend(function['args']['stride'])
        f.sum_pooling_param.ignore_border = bool(function['args']['ignore_border'])
        f.sum_pooling_param.pad.dim.extend(function['args']['pad'])
        f.sum_pooling_param.channel_last = bool(function['args']['channel_last'])
        pass
    elif f.type == 'Unpooling':
        f.unpooling_param.kernel.dim.extend(function['args']['kernel'])
        f.unpooling_param.channel_last = bool(function['args']['channel_last'])
        pass
    elif f.type == 'Embed':
        pass
    elif f.type == 'Sigmoid':
        pass
    elif f.type == 'Swish':
        pass
    elif f.type == 'Tanh':
        pass
    elif f.type == 'ReLU':
        f.relu_param.inplace = bool(function['args']['inplace'])
        pass
    elif f.type == 'LeakyReLU':
        f.leaky_relu_param.alpha = function['args']['alpha']
        f.leaky_relu_param.inplace = bool(function['args']['inplace'])
        pass
    elif f.type == 'Softmax':
        f.softmax_param.axis = function['args']['axis']
        pass
    elif f.type == 'LogSoftmax':
        f.log_softmax_param.axis = function['args']['axis']
        pass
    elif f.type == 'ELU':
        f.elu_param.alpha = function['args']['alpha']
        pass
    elif f.type == 'SELU':
        f.selu_param.scale = function['args']['scale']
        f.selu_param.alpha = function['args']['alpha']
        pass
    elif f.type == 'CReLU':
        f.crelu_param.axis = function['args']['axis']
        pass
    elif f.type == 'CELU':
        f.celu_param.alpha = function['args']['alpha']
        f.celu_param.axis = function['args']['axis']
        pass
    elif f.type == 'PReLU':
        f.prelu_param.base_axis = function['args']['base_axis']
        pass
    elif f.type == 'GELU':
        pass
    elif f.type == 'Mish':
        pass
    elif f.type == 'ReLU6':
        pass
    elif f.type == 'HardSigmoid':
        pass
    elif f.type == 'HardTanh':
        pass
    elif f.type == 'LogSigmoid':
        pass
    elif f.type == 'SoftPlus':
        pass
    elif f.type == 'SoftSign':
        pass
    elif f.type == 'TanhShrink':
        pass
    elif f.type == 'Sinc':
        pass
    elif f.type == 'FusedBatchNormalization':
        f.fused_batch_normalization_param.axes.extend(function['args']['axes'])
        f.fused_batch_normalization_param.decay_rate = function['args']['decay_rate']
        f.fused_batch_normalization_param.eps = function['args']['eps']
        f.fused_batch_normalization_param.batch_stat = bool(function['args']['batch_stat'])
        f.fused_batch_normalization_param.nonlinearity = function['args']['nonlinearity']
        pass
    elif f.type == 'BatchNormalization':
        f.batch_normalization_param.axes.extend(function['args']['axes'])
        f.batch_normalization_param.decay_rate = function['args']['decay_rate']
        f.batch_normalization_param.eps = function['args']['eps']
        f.batch_normalization_param.batch_stat = bool(function['args']['batch_stat'])
        f.batch_normalization_param.no_scale = bool(function['args']['no_scale'])
        f.batch_normalization_param.no_bias = bool(function['args']['no_bias'])
        pass
    elif f.type == 'GroupNormalization':
        f.group_normalization_param.num_groups = function['args']['num_groups']
        f.group_normalization_param.channel_axis = function['args']['channel_axis']
        f.group_normalization_param.batch_axis.extend(function['args']['batch_axis'])
        f.group_normalization_param.eps = function['args']['eps']
        f.group_normalization_param.no_scale = bool(function['args']['no_scale'])
        f.group_normalization_param.no_bias = bool(function['args']['no_bias'])
        pass
    elif f.type == 'InstanceNormalization':
        f.instance_normalization_param.channel_axis = function['args']['channel_axis']
        f.instance_normalization_param.batch_axis.extend(function['args']['batch_axis'])
        f.instance_normalization_param.eps = function['args']['eps']
        f.instance_normalization_param.no_scale = bool(function['args']['no_scale'])
        f.instance_normalization_param.no_bias = bool(function['args']['no_bias'])
        pass
    elif f.type == 'LayerNormalization':
        f.layer_normalization_param.batch_axis.extend(function['args']['batch_axis'])
        f.layer_normalization_param.eps = function['args']['eps']
        f.layer_normalization_param.no_scale = bool(function['args']['no_scale'])
        f.layer_normalization_param.no_bias = bool(function['args']['no_bias'])
        pass
    elif f.type == 'NormNormalization':
        f.norm_normalization_param.p = function['args']['p']
        f.norm_normalization_param.axes.extend(function['args']['axes'])
        f.norm_normalization_param.eps = function['args']['eps']
        pass
    elif f.type == 'SyncBatchNormalization':
        f.sync_batch_normalization_param.comm = function['args']['comm']
        f.sync_batch_normalization_param.group = function['args']['group']
        f.sync_batch_normalization_param.axes.extend(function['args']['axes'])
        f.sync_batch_normalization_param.decay_rate = function['args']['decay_rate']
        f.sync_batch_normalization_param.eps = function['args']['eps']
        f.sync_batch_normalization_param.batch_stat = bool(function['args']['batch_stat'])
        pass
    elif f.type == 'TensorNormalization':
        f.tensor_normalization_param.axes.extend(function['args']['axes'])
        f.tensor_normalization_param.eps = function['args']['eps']
        f.tensor_normalization_param.no_scale = bool(function['args']['no_scale'])
        f.tensor_normalization_param.no_bias = bool(function['args']['no_bias'])
        pass
    elif f.type == 'WeightNormalization':
        f.weight_normalization_param.dim = function['args']['dim']
        f.weight_normalization_param.eps = function['args']['eps']
        pass
    elif f.type == 'WeightStandardization':
        f.weight_standardization_param.channel_axis = function['args']['channel_axis']
        f.weight_standardization_param.eps = function['args']['eps']
        pass
    elif f.type == 'SpectralNorm':
        f.spectral_norm_param.dim = function['args']['dim']
        f.spectral_norm_param.itr = function['args']['itr']
        f.spectral_norm_param.eps = function['args']['eps']
        f.spectral_norm_param.test = bool(function['args']['test'])
        pass
    elif f.type == 'MeanSubtraction':
        f.mean_subtraction_param.base_axis = function['args']['base_axis']
        f.mean_subtraction_param.update_running_mean = bool(function['args']['update_running_mean'])
        pass
    elif f.type == 'ClipGradByValue':
        pass
    elif f.type == 'ClipGradByNorm':
        f.clip_grad_by_norm_param.clip_norm = function['args']['clip_norm']
        f.clip_grad_by_norm_param.axes.extend(function['args']['axes'])
        pass
    elif f.type == 'Sum':
        f.sum_param.axes.extend(function['args']['axes'])
        f.sum_param.keep_dims = bool(function['args']['keep_dims'])
        pass
    elif f.type == 'Mean':
        f.mean_param.axes.extend(function['args']['axes'])
        f.mean_param.keep_dims = bool(function['args']['keep_dims'])
        pass
    elif f.type == 'Max':
        f.max_param.axes.extend(function['args']['axes'])
        f.max_param.keep_dims = bool(function['args']['keep_dims'])
        f.max_param.with_index = bool(function['args']['with_index'])
        f.max_param.only_index = bool(function['args']['only_index'])
        pass
    elif f.type == 'Min':
        f.min_param.axes.extend(function['args']['axes'])
        f.min_param.keep_dims = bool(function['args']['keep_dims'])
        f.min_param.with_index = bool(function['args']['with_index'])
        f.min_param.only_index = bool(function['args']['only_index'])
        pass
    elif f.type == 'Norm':
        f.norm_param.p = function['args']['p']
        f.norm_param.axes.extend(function['args']['axes'])
        f.norm_param.keep_dims = bool(function['args']['keep_dims'])
        pass
    elif f.type == 'Prod':
        f.prod_param.axes.extend(function['args']['axes'])
        f.prod_param.keep_dims = bool(function['args']['keep_dims'])
        pass
    elif f.type == 'ReduceSum':
        pass
    elif f.type == 'ReduceMean':
        pass
    elif f.type == 'Add2':
        f.add2_param.inplace = bool(function['args']['inplace'])
        pass
    elif f.type == 'AddN':
        pass
    elif f.type == 'BcAdd2':
        f.bc_add2_param.inplace = bool(function['args']['inplace'])
        pass
    elif f.type == 'Sub2':
        f.sub2_param.inplace = bool(function['args']['inplace'])
        pass
    elif f.type == 'Mul2':
        f.mul2_param.inplace = bool(function['args']['inplace'])
        pass
    elif f.type == 'MulN':
        pass
    elif f.type == 'Div2':
        f.div2_param.inplace = bool(function['args']['inplace'])
        pass
    elif f.type == 'Pow2':
        f.pow2_param.inplace = bool(function['args']['inplace'])
        pass
    elif f.type == 'AddScalar':
        f.add_scalar_param.val = function['args']['val']
        f.add_scalar_param.inplace = bool(function['args']['inplace'])
        pass
    elif f.type == 'MulScalar':
        f.mul_scalar_param.val = function['args']['val']
        f.mul_scalar_param.inplace = bool(function['args']['inplace'])
        pass
    elif f.type == 'PowScalar':
        f.pow_scalar_param.val = function['args']['val']
        f.pow_scalar_param.inplace = bool(function['args']['inplace'])
        pass
    elif f.type == 'RSubScalar':
        f.r_sub_scalar_param.val = function['args']['val']
        pass
    elif f.type == 'RDivScalar':
        f.r_div_scalar_param.val = function['args']['val']
        pass
    elif f.type == 'RPowScalar':
        f.r_pow_scalar_param.val = function['args']['val']
        pass
    elif f.type == 'Sign':
        f.sign_param.alpha = function['args']['alpha']
        pass
    elif f.type == 'Minimum2':
        pass
    elif f.type == 'Maximum2':
        pass
    elif f.type == 'MinimumScalar':
        f.minimum_scalar_param.val = function['args']['val']
        pass
    elif f.type == 'MaximumScalar':
        f.maximum_scalar_param.val = function['args']['val']
        pass
    elif f.type == 'LogicalAnd':
        pass
    elif f.type == 'LogicalOr':
        pass
    elif f.type == 'LogicalXor':
        pass
    elif f.type == 'Equal':
        pass
    elif f.type == 'NotEqual':
        pass
    elif f.type == 'GreaterEqual':
        pass
    elif f.type == 'Greater':
        pass
    elif f.type == 'LessEqual':
        pass
    elif f.type == 'Less':
        pass
    elif f.type == 'LogicalAndScalar':
        f.logical_and_scalar_param.val = bool(function['args']['val'])
        pass
    elif f.type == 'LogicalOrScalar':
        f.logical_or_scalar_param.val = bool(function['args']['val'])
        pass
    elif f.type == 'LogicalXorScalar':
        f.logical_xor_scalar_param.val = bool(function['args']['val'])
        pass
    elif f.type == 'EqualScalar':
        f.equal_scalar_param.val = function['args']['val']
        pass
    elif f.type == 'NotEqualScalar':
        f.not_equal_scalar_param.val = function['args']['val']
        pass
    elif f.type == 'GreaterEqualScalar':
        f.greater_equal_scalar_param.val = function['args']['val']
        pass
    elif f.type == 'GreaterScalar':
        f.greater_scalar_param.val = function['args']['val']
        pass
    elif f.type == 'LessEqualScalar':
        f.less_equal_scalar_param.val = function['args']['val']
        pass
    elif f.type == 'LessScalar':
        f.less_scalar_param.val = function['args']['val']
        pass
    elif f.type == 'LogicalNot':
        pass
    elif f.type == 'IsNaN':
        pass
    elif f.type == 'IsInf':
        pass
    elif f.type == 'ResetNaN':
        f.reset_nan_param.val = function['args']['val']
        pass
    elif f.type == 'ResetInf':
        f.reset_inf_param.val = function['args']['val']
        pass
    elif f.type == 'Where':
        pass
    elif f.type == 'Constant':
        f.constant_param.val = function['args']['val']
        f.constant_param.shape.dim.extend(function['args']['shape'])
        pass
    elif f.type == 'Arange':
        f.arange_param.start = function['args']['start']
        f.arange_param.stop = function['args']['stop']
        f.arange_param.step = function['args']['step']
        pass
    elif f.type == 'Abs':
        pass
    elif f.type == 'Exp':
        pass
    elif f.type == 'Log':
        pass
    elif f.type == 'Identity':
        pass
    elif f.type == 'BatchMatmul':
        f.batch_matmul_param.transpose_a = bool(function['args']['transpose_a'])
        f.batch_matmul_param.transpose_b = bool(function['args']['transpose_b'])
        pass
    elif f.type == 'Round':
        pass
    elif f.type == 'Ceil':
        pass
    elif f.type == 'Floor':
        pass
    elif f.type == 'Sin':
        pass
    elif f.type == 'Cos':
        pass
    elif f.type == 'Tan':
        pass
    elif f.type == 'Sinh':
        pass
    elif f.type == 'Cosh':
        pass
    elif f.type == 'ASin':
        pass
    elif f.type == 'ACos':
        pass
    elif f.type == 'ATan':
        pass
    elif f.type == 'ATan2':
        pass
    elif f.type == 'ASinh':
        pass
    elif f.type == 'ACosh':
        pass
    elif f.type == 'ATanh':
        pass
    elif f.type == 'Concatenate':
        f.concatenate_param.axis = function['args']['axis']
        pass
    elif f.type == 'Split':
        f.split_param.axis = function['args']['axis']
        pass
    elif f.type == 'Stack':
        f.stack_param.axis = function['args']['axis']
        pass
    elif f.type == 'Slice':
        f.slice_param.start.extend(function['args']['start'])
        f.slice_param.stop.extend(function['args']['stop'])
        f.slice_param.step.extend(function['args']['step'])
        pass
    elif f.type == 'Pad':
        f.pad_param.pad_width.extend(function['args']['pad_width'])
        f.pad_param.mode = function['args']['mode']
        f.pad_param.constant_value = function['args']['constant_value']
        pass
    elif f.type == 'Transpose':
        f.transpose_param.axes.extend(function['args']['axes'])
        pass
    elif f.type == 'Broadcast':
        f.broadcast_param.shape.dim.extend(function['args']['shape'])
        pass
    elif f.type == 'BroadcastTo':
        f.broadcast_to_param.axis = function['args']['axis']
        pass
    elif f.type == 'Tile':
        f.tile_param.reps.extend(function['args']['reps'])
        pass
    elif f.type == 'OneHot':
        f.one_hot_param.shape.dim.extend(function['args']['shape'])
        pass
    elif f.type == 'Flip':
        f.flip_param.axes.extend(function['args']['axes'])
        pass
    elif f.type == 'Shift':
        f.shift_param.shifts.extend(function['args']['shifts'])
        f.shift_param.border_mode = function['args']['border_mode']
        pass
    elif f.type == 'Sort':
        f.sort_param.axis = function['args']['axis']
        f.sort_param.reverse = bool(function['args']['reverse'])
        f.sort_param.with_index = bool(function['args']['with_index'])
        f.sort_param.only_index = bool(function['args']['only_index'])
        pass
    elif f.type == 'Reshape':
        f.reshape_param.shape.dim.extend(function['args']['shape'])
        f.reshape_param.inplace = bool(function['args']['inplace'])
        pass
    elif f.type == 'MatrixDiag':
        pass
    elif f.type == 'MatrixDiagPart':
        pass
    elif f.type == 'BatchInv':
        pass
    elif f.type == 'BatchDet':
        pass
    elif f.type == 'BatchLogdet':
        pass
    elif f.type == 'Assign':
        pass
    elif f.type == 'Gather':
        f.gather_param.axis = function['args']['axis']
        f.gather_param.batch_dims = function['args']['batch_dims']
        pass
    elif f.type == 'GatherNd':
        pass
    elif f.type == 'ScatterNd':
        f.scatter_nd_param.shape.extend(function['args']['shape'])
        pass
    elif f.type == 'ScatterAdd':
        f.scatter_add_param.axis = function['args']['axis']
        pass
    elif f.type == 'PackPaddedSequence':
        f.pack_padded_sequence_param.batch_first = bool(function['args']['batch_first'])
        pass
    elif f.type == 'PadPackedSequence':
        f.pad_packed_sequence_param.batch_first = bool(function['args']['batch_first'])
        f.pad_packed_sequence_param.padding_value = function['args']['padding_value']
        f.pad_packed_sequence_param.total_length = function['args']['total_length']
        pass
    elif f.type == 'Interpolate':
        f.interpolate_param.output_size.extend(function['args']['output_size'])
        f.interpolate_param.mode = function['args']['mode']
        f.interpolate_param.align_corners = bool(function['args']['align_corners'])
        f.interpolate_param.half_pixel = bool(function['args']['half_pixel'])
        f.interpolate_param.half_pixel_for_nn = bool(function['args']['half_pixel_for_nn'])
        f.interpolate_param.channel_last = bool(function['args']['channel_last'])
        pass
    elif f.type == 'FFT':
        f.fft_param.signal_ndim = function['args']['signal_ndim']
        f.fft_param.normalized = bool(function['args']['normalized'])
        pass
    elif f.type == 'IFFT':
        f.ifft_param.signal_ndim = function['args']['signal_ndim']
        f.ifft_param.normalized = bool(function['args']['normalized'])
        pass
    elif f.type == 'STFT':
        f.stft_param.window_size = function['args']['window_size']
        f.stft_param.stride = function['args']['stride']
        f.stft_param.fft_size = function['args']['fft_size']
        f.stft_param.window_type = function['args']['window_type']
        f.stft_param.center = bool(function['args']['center'])
        f.stft_param.pad_mode = function['args']['pad_mode']
        pass
    elif f.type == 'ISTFT':
        f.istft_param.window_size = function['args']['window_size']
        f.istft_param.stride = function['args']['stride']
        f.istft_param.fft_size = function['args']['fft_size']
        f.istft_param.window_type = function['args']['window_type']
        f.istft_param.center = bool(function['args']['center'])
        pass
    elif f.type == 'Dropout':
        f.dropout_param.p = function['args']['p']
        f.dropout_param.seed = function['args']['seed']
        pass
    elif f.type == 'TopKData':
        f.top_k_data_param.k = function['args']['k']
        f.top_k_data_param.abs = bool(function['args']['abs'])
        f.top_k_data_param.reduce = bool(function['args']['reduce'])
        f.top_k_data_param.base_axis = function['args']['base_axis']
        pass
    elif f.type == 'TopKGrad':
        f.top_k_grad_param.k = function['args']['k']
        f.top_k_grad_param.abs = bool(function['args']['abs'])
        f.top_k_grad_param.base_axis = function['args']['base_axis']
        pass
    elif f.type == 'Rand':
        f.rand_param.low = function['args']['low']
        f.rand_param.high = function['args']['high']
        f.rand_param.shape.dim.extend(function['args']['shape'])
        f.rand_param.seed = function['args']['seed']
        pass
    elif f.type == 'Randint':
        f.randint_param.low = function['args']['low']
        f.randint_param.high = function['args']['high']
        f.randint_param.shape.dim.extend(function['args']['shape'])
        f.randint_param.seed = function['args']['seed']
        pass
    elif f.type == 'Randn':
        f.randn_param.mu = function['args']['mu']
        f.randn_param.sigma = function['args']['sigma']
        f.randn_param.shape.dim.extend(function['args']['shape'])
        f.randn_param.seed = function['args']['seed']
        pass
    elif f.type == 'RandBinomial':
        f.rand_binomial_param.n = function['args']['n']
        f.rand_binomial_param.p = function['args']['p']
        f.rand_binomial_param.shape.dim.extend(function['args']['shape'])
        f.rand_binomial_param.seed = function['args']['seed']
        pass
    elif f.type == 'RandBeta':
        f.rand_beta_param.alpha = function['args']['alpha']
        f.rand_beta_param.beta = function['args']['beta']
        f.rand_beta_param.shape.dim.extend(function['args']['shape'])
        f.rand_beta_param.seed = function['args']['seed']
        pass
    elif f.type == 'RandGamma':
        f.rand_gamma_param.k = function['args']['k']
        f.rand_gamma_param.theta = function['args']['theta']
        f.rand_gamma_param.shape.dim.extend(function['args']['shape'])
        f.rand_gamma_param.seed = function['args']['seed']
        pass
    elif f.type == 'RandomChoice':
        f.random_choice_param.shape.dim.extend(function['args']['shape'])
        f.random_choice_param.replace = bool(function['args']['replace'])
        f.random_choice_param.seed = function['args']['seed']
        pass
    elif f.type == 'RandomCrop':
        f.random_crop_param.shape.dim.extend(function['args']['shape'])
        f.random_crop_param.base_axis = function['args']['base_axis']
        f.random_crop_param.seed = function['args']['seed']
        pass
    elif f.type == 'RandomFlip':
        f.random_flip_param.axes.extend(function['args']['axes'])
        f.random_flip_param.base_axis = function['args']['base_axis']
        f.random_flip_param.seed = function['args']['seed']
        pass
    elif f.type == 'RandomShift':
        f.random_shift_param.shifts.extend(function['args']['shifts'])
        f.random_shift_param.border_mode = function['args']['border_mode']
        f.random_shift_param.constant_value = function['args']['constant_value']
        f.random_shift_param.base_axis = function['args']['base_axis']
        f.random_shift_param.seed = function['args']['seed']
        pass
    elif f.type == 'RandomErase':
        f.random_erase_param.prob = function['args']['prob']
        f.random_erase_param.area_ratios = function['args']['area_ratios']
        f.random_erase_param.aspect_ratios = function['args']['aspect_ratios']
        f.random_erase_param.replacements = function['args']['replacements']
        f.random_erase_param.n = function['args']['n']
        f.random_erase_param.share = bool(function['args']['share'])
        f.random_erase_param.inplace = bool(function['args']['inplace'])
        f.random_erase_param.base_axis = function['args']['base_axis']
        f.random_erase_param.seed = function['args']['seed']
        f.random_erase_param.channel_last = bool(function['args']['channel_last'])
        f.random_erase_param.ste_fine_grained = bool(function['args']['ste_fine_grained'])
        pass
    elif f.type == 'ImageAugmentation':
        f.image_augmentation_param.shape.dim.extend(function['args']['shape'])
        f.image_augmentation_param.pad.dim.extend(function['args']['pad'])
        f.image_augmentation_param.min_scale = function['args']['min_scale']
        f.image_augmentation_param.max_scale = function['args']['max_scale']
        f.image_augmentation_param.angle = function['args']['angle']
        f.image_augmentation_param.aspect_ratio = function['args']['aspect_ratio']
        f.image_augmentation_param.distortion = function['args']['distortion']
        f.image_augmentation_param.flip_lr = bool(function['args']['flip_lr'])
        f.image_augmentation_param.flip_ud = bool(function['args']['flip_ud'])
        f.image_augmentation_param.brightness = function['args']['brightness']
        f.image_augmentation_param.brightness_each = bool(function['args']['brightness_each'])
        f.image_augmentation_param.contrast = function['args']['contrast']
        f.image_augmentation_param.contrast_center = function['args']['contrast_center']
        f.image_augmentation_param.contrast_each = bool(function['args']['contrast_each'])
        f.image_augmentation_param.noise = function['args']['noise']
        f.image_augmentation_param.seed = function['args']['seed']
        pass
    elif f.type == 'SigmoidCrossEntropy':
        pass
    elif f.type == 'BinaryCrossEntropy':
        pass
    elif f.type == 'SoftmaxCrossEntropy':
        f.softmax_cross_entropy_param.axis = function['args']['axis']
        pass
    elif f.type == 'CategoricalCrossEntropy':
        f.categorical_cross_entropy_param.axis = function['args']['axis']
        pass
    elif f.type == 'SquaredError':
        pass
    elif f.type == 'AbsoluteError':
        pass
    elif f.type == 'HuberLoss':
        f.huber_loss_param.delta = function['args']['delta']
        pass
    elif f.type == 'EpsilonInsensitiveLoss':
        f.epsilon_insensitive_loss_param.epsilon = function['args']['epsilon']
        pass
    elif f.type == 'KLMultinomial':
        f.kl_multinomial_param.base_axis = function['args']['base_axis']
        pass
    elif f.type == 'AffineGrid':
        f.affine_grid_param.size.extend(function['args']['size'])
        f.affine_grid_param.align_corners = bool(function['args']['align_corners'])
        pass
    elif f.type == 'WarpByGrid':
        f.warp_by_grid_param.mode = function['args']['mode']
        f.warp_by_grid_param.padding_mode = function['args']['padding_mode']
        f.warp_by_grid_param.align_corners = bool(function['args']['align_corners'])
        f.warp_by_grid_param.channel_last = bool(function['args']['channel_last'])
        pass
    elif f.type == 'WarpByFlow':
        pass
    elif f.type == 'BinarySigmoid':
        pass
    elif f.type == 'BinaryTanh':
        pass
    elif f.type == 'BinaryConnectAffine':
        f.binary_connect_affine_param.base_axis = function['args']['base_axis']
        f.binary_connect_affine_param.quantize_zero_to = function['args']['quantize_zero_to']
        pass
    elif f.type == 'BinaryConnectConvolution':
        f.binary_connect_convolution_param.base_axis = function['args']['base_axis']
        f.binary_connect_convolution_param.pad.dim.extend(function['args']['pad'])
        f.binary_connect_convolution_param.stride.dim.extend(function['args']['stride'])
        f.binary_connect_convolution_param.dilation.dim.extend(function['args']['dilation'])
        f.binary_connect_convolution_param.group = function['args']['group']
        f.binary_connect_convolution_param.quantize_zero_to = function['args']['quantize_zero_to']
        pass
    elif f.type == 'BinaryWeightAffine':
        f.binary_weight_affine_param.base_axis = function['args']['base_axis']
        f.binary_weight_affine_param.quantize_zero_to = function['args']['quantize_zero_to']
        pass
    elif f.type == 'BinaryWeightConvolution':
        f.binary_weight_convolution_param.base_axis = function['args']['base_axis']
        f.binary_weight_convolution_param.pad.dim.extend(function['args']['pad'])
        f.binary_weight_convolution_param.stride.dim.extend(function['args']['stride'])
        f.binary_weight_convolution_param.dilation.dim.extend(function['args']['dilation'])
        f.binary_weight_convolution_param.group = function['args']['group']
        f.binary_weight_convolution_param.quantize_zero_to = function['args']['quantize_zero_to']
        pass
    elif f.type == 'INQAffine':
        f.inq_affine_param.base_axis = function['args']['base_axis']
        f.inq_affine_param.num_bits = function['args']['num_bits']
        f.inq_affine_param.inq_iterations.extend(function['args']['inq_iterations'])
        f.inq_affine_param.selection_algorithm = function['args']['selection_algorithm']
        f.inq_affine_param.seed = function['args']['seed']
        pass
    elif f.type == 'INQConvolution':
        f.inq_convolution_param.base_axis = function['args']['base_axis']
        f.inq_convolution_param.pad.dim.extend(function['args']['pad'])
        f.inq_convolution_param.stride.dim.extend(function['args']['stride'])
        f.inq_convolution_param.dilation.dim.extend(function['args']['dilation'])
        f.inq_convolution_param.group = function['args']['group']
        f.inq_convolution_param.num_bits = function['args']['num_bits']
        f.inq_convolution_param.inq_iterations.extend(function['args']['inq_iterations'])
        f.inq_convolution_param.selection_algorithm = function['args']['selection_algorithm']
        f.inq_convolution_param.seed = function['args']['seed']
        pass
    elif f.type == 'FixedPointQuantize':
        f.fixed_point_quantize_param.sign = bool(function['args']['sign'])
        f.fixed_point_quantize_param.n = function['args']['n']
        f.fixed_point_quantize_param.delta = function['args']['delta']
        f.fixed_point_quantize_param.ste_fine_grained = bool(function['args']['ste_fine_grained'])
        pass
    elif f.type == 'MinMaxQuantize':
        f.min_max_quantize_param.decay = function['args']['decay']
        f.min_max_quantize_param.x_min_max = bool(function['args']['x_min_max'])
        f.min_max_quantize_param.ema = bool(function['args']['ema'])
        f.min_max_quantize_param.ste_fine_grained = bool(function['args']['ste_fine_grained'])
        f.min_max_quantize_param.eps = function['args']['eps']
        pass
    elif f.type == 'Pow2Quantize':
        f.pow2_quantize_param.sign = bool(function['args']['sign'])
        f.pow2_quantize_param.with_zero = bool(function['args']['with_zero'])
        f.pow2_quantize_param.n = function['args']['n']
        f.pow2_quantize_param.m = function['args']['m']
        f.pow2_quantize_param.ste_fine_grained = bool(function['args']['ste_fine_grained'])
        pass
    elif f.type == 'Prune':
        f.prune_param.rate = function['args']['rate']
        pass
    elif f.type == 'QuantizeLinear':
        f.quantize_linear_param.round_mode = function['args']['round_mode']
        f.quantize_linear_param.narrow_range = bool(function['args']['narrow_range'])
        f.quantize_linear_param.dtype = function['args']['dtype']
        pass
    elif f.type == 'DequantizeLinear':
        pass
    elif f.type == 'TopNError':
        f.top_n_error_param.axis = function['args']['axis']
        f.top_n_error_param.n = function['args']['n']
        pass
    elif f.type == 'BinaryError':
        pass
    elif f.type == 'ConfusionMatrix':
        f.confusion_matrix_param.axis = function['args']['axis']
        pass
    elif f.type == 'VATNoise':
        f.vat_noise_param.base_axis = function['args']['base_axis']
        f.vat_noise_param.eps = function['args']['eps']
        pass
    elif f.type == 'Unlink':
        pass
    elif f.type == 'Sink':
        f.sink_param.one_input_grad = bool(function['args']['one_input_grad'])
        pass
    elif f.type == 'NmsDetection2d':
        f.nms_detection2d_param.thresh = function['args']['thresh']
        f.nms_detection2d_param.nms = function['args']['nms']
        f.nms_detection2d_param.nms_per_class = bool(function['args']['nms_per_class'])
        pass
    elif f.type == 'MaxPoolingBackward':
        f.max_pooling_backward_param.kernel.dim.extend(function['args']['kernel'])
        f.max_pooling_backward_param.stride.dim.extend(function['args']['stride'])
        f.max_pooling_backward_param.ignore_border = bool(function['args']['ignore_border'])
        f.max_pooling_backward_param.pad.dim.extend(function['args']['pad'])
        f.max_pooling_backward_param.channel_last = bool(function['args']['channel_last'])
        pass
    elif f.type == 'PatchCorrelation':
        f.patch_correlation_param.patch.dim.extend(function['args']['patch'])
        f.patch_correlation_param.shift.dim.extend(function['args']['shift'])
        f.patch_correlation_param.patch_step.dim.extend(function['args']['patch_step'])
        f.patch_correlation_param.shift_step.dim.extend(function['args']['shift_step'])
        f.patch_correlation_param.padding.dim.extend(function['args']['padding'])
        pass

