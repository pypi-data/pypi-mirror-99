# Publish Templates

Guild uses templates when publishing runs. A template consist of
rendered files and supporting files. Templates provided by Guild are
defined in `guild/templates`. We use sample templates defined in
`guild/tests/samples/templates` in these tests.

Published runs also consist of generated Guild data files, run source
code, and run files. For detail on publishing runs, see the
`publish-runs` tests.

Template support is provided by `guild.publish`.

    >>> from guild import publish

## Simple template

Here's a simple template:

    >>> simple = sample("templates/simple")

    >>> dir(simple)
    ['README.md',
     '_footer.md',
     '_footer_header.html',
     '_header.md',
     'a',
     'b',
     'hello.png']

Files starting with "_" are supporting files that are included by
templates and are not written when the template is generated.

Let's create a template:

    >>> simple_template = publish.Template(simple)

We can see which files are generated by a template using its `files`
attribute:

    >>> simple_template.files
    ['README.md', 'a/A.md', 'b/B.html', 'hello.png']

Note that files starting with "_" are not generated.

Let's create a directory to contain the generated files:

    >>> dest = mkdtemp()

We generate the files by calling the `generate()` method with a
destination (our temp directory created above) and variables used by
the template:

    >>> simple_template.generate(dest, {"a_msg": "whoop"})

Here are the generated files in our temp directory:

    >>> find(dest)
    README.md
    a/A.md
    b/B.html
    hello.png

README.md:

    >>> cat(path(dest, "README.md")) # doctest: +REPORT_UDIFF
    # Report
    <BLANKLINE>
    This is a fancy report!
    <BLANKLINE>
    Hello: ![](hello.png)
    <BLANKLINE>
    [a](a/A.md)
    <BLANKLINE>
    [b](b/B.html)
    <BLANKLINE>
    <hr>
    <BLANKLINE>
    The end.

a/A.md:

    >>> cat(path(dest, "a/A.md"))
    This is A!
    <BLANKLINE>
    A footer says: whoop

b/B.html:

    >>> cat(path(dest, "b/B.html"))
    <p>This is B!</p>

## Sample Run Report

The sample template `run-report` generates a table of run attributes.

The template uses an `env` filter, which is not provided by
default. When we attempt to load the template, we get an error.

    >>> run_report = publish.Template(sample("templates/run-report"))
    Traceback (most recent call last):
    TemplateError: .../samples/templates/run-report/README.md:22:
    no filter named 'env'

To load the template, we must provide the `env` filter. Filters are
functions that accepts one or more arguments, the first of which is
the value the filter is applied to. Here's the `env` filter:

    >>> def env(run):
    ...   env = run["_run"].get("env", {})
    ...   return "\n".join([
    ...     "%s: %s" % (name, val)
    ...     for name, val in sorted(env.items())
    ...   ])

Let's load the template, providing the required filter:

    >>> run_report = publish.Template(
    ...   sample("templates/run-report"),
    ...   filters={"env": env})

To generate the report, we need a run. We'll use one of the sample
runs.

    >>> from guild import run as runlib
    >>> run = runlib.for_dir(
    ...   sample("runs", "360192fdf9b74f2fad5f514e9f2fdadb"))

    >>> from guild import run_util
    >>> formatted_run = run_util.format_run(run)

`formatted_run` contains formatted run attributes along with the
original original run as `_run`:

    >>> formatted_run["_run"] is run
    True

Here's a new target directory:

    >>> dest = mkdtemp()

Let's generate the template:

    >>> run_report.generate(dest, {"run": formatted_run})

The report generates one file, `README.md`:

    >>> find(dest)
    README.md

Here's the README.md:

    >>> cat(path(dest, "README.md")) # doctest: +REPORT_UDIFF
    # Run Report
    <BLANKLINE>
    ## Attributes
    <BLANKLINE>
    | Attribute   | Value                 |
    | ---------   | -----                 |
    | ID          | 360192fdf9b74f2fad5f514e9f2fdadb          |
    | Directory   |          |
    | Model       | mnist       |
    | Operation   | mnist:train   |
    | Package     |          |
    | Status      | pending      |
    | Marked      | no      |
    | Started     | ...     |
    | Stopped     |      |
    | Command     |      |
    | Exit Status |  |
    <BLANKLINE>
    ## Environment
    <BLANKLINE>
    ```
    BAR: abc
    FOO: 123
    ```

## Default Run Template

The publish command uses `guild.publish` facilities as show above via
the function `publish_run()`. By default, `publish_run()` uses Guild's
default template, which is located in
`guild/templates/publish-default`.

Let's illustrate by publishing our sample run to a new directory:

    >>> dest = mkdtemp()

And call `publish_run()`:

    >>> publish.publish_run(run, dest)

Here are the generated files:

    >>> find(dest)
    .guild-nocopy
    360192fdf9b74f2fad5f514e9f2fdadb/README.md
    360192fdf9b74f2fad5f514e9f2fdadb/flags.yml
    360192fdf9b74f2fad5f514e9f2fdadb/run.yml
    360192fdf9b74f2fad5f514e9f2fdadb/runfiles.csv
    360192fdf9b74f2fad5f514e9f2fdadb/scalars.csv
    360192fdf9b74f2fad5f514e9f2fdadb/sourcecode.csv

The publish facility generates a number of run related files (ending
in `.yml`, `.csv`, and `.txt`) that represent the public data for a
run.

Note that `env` is not published. This is to avoid accidentally
publishing secrets, which are often provided via the environment.

Here's the generated template:

    >>> cat(path(dest, "360192fdf9b74f2fad5f514e9f2fdadb/README.md")) # doctest: +REPORT_UDIFF
    [Published runs](../README.md)
    <BLANKLINE>
    # mnist:train
    <BLANKLINE>
    | ID                   | Operation           | Started                  | Time                | Status           | Label                |
    | --                   | ---------           | ---------                | ----                | ------           | -----                |
    | 360192fd | mnist:train | 2017&#8209;09&#8209;30 16:53:05 UTC | &nbsp; | pending | &nbsp; |
    <BLANKLINE>
    [run.yml](run.yml)
    <BLANKLINE>
    ## Contents
    <BLANKLINE>
    - [Flags](#flags)
    - [Scalars](#scalars)
    - [Run Files](#run-files)
    - [Source Code](#source-code)
    - [Output](#output)
    <BLANKLINE>
    ## Flags
    <BLANKLINE>
    There are no flags for this run.
    <BLANKLINE>
    ## Scalars
    <BLANKLINE>
    There are no scalars for this run.
    <BLANKLINE>
    ## Run Files
    <BLANKLINE>
    There are no files for this run.
    <BLANKLINE>
    ## Source Code
    <BLANKLINE>
    There are no source code files for this run.
    <BLANKLINE>
    ## Output
    <BLANKLINE>
    ```
    ```
    <BLANKLINE>
    [output.txt](output.txt)
