# Operation steps

Operations may be defined using a sequence of steps, rather than a
main or exec spec.

We'll use the sample project 'steps' to illustrate the behavior.

    >>> project = Project(sample("projects", "steps"))

Here's the project Guild file:

    >>> gf = guildfile.for_dir(project.cwd)

Here are the suported models:

    >>> pprint(gf.models)
    {'m1': <guild.guildfile.ModelDef 'm1'>,
     'm2': <guild.guildfile.ModelDef 'm2'>,
     'm3': <guild.guildfile.ModelDef 'm3'>,
     'm4': <guild.guildfile.ModelDef 'm4'>,
     'm5': <guild.guildfile.ModelDef 'm5'>,
     'm6': <guild.guildfile.ModelDef 'm6'>}

## Basic steps

Steps are stored as the operation `steps` attribute. They are no
processed by the Guild file as they are merely passed through to
`guild.steps_main` by way of the `steps` run attribute.

Here are the steps for `m1:steps-basic`.

    >>> gf.models["m1"]["steps-basic"].steps
    ['step-1', 'step-2']

Note that the raw data structure is provided rather than any higher
level structured data.

The `steps-basic` operation runs the two operations in the order
specified.

    >>> project.run("m1:steps-basic")
    INFO: [guild] running step-1: m1:step-1
    hello step-1
    INFO: [guild] running step-2: m1:step-2
    hello step-2

In this case, three runs are generated:

    >>> runs = project.list_runs()
    >>> project.print_runs(runs)
    m1:step-2
    m1:step-1
    m1:steps-basic

Here we see that by running `steps-basic`, we generated runs for
`step-1` and `step-2`.

Each run generated by a step is a normal Guild run.

Here are the files generated for `step-1` and `step-2`:

    >>> project.ls(runs[0])
    ['step-2']

    >>> project.ls(runs[1])
    ['step-1']

The stepped run `steps-basic` contains symbolic links to the two
genated runs:

    >>> project.ls(runs[2])
    ['step-1', 'step-2']

    >>> step1_target = basename(realpath(join_path(runs[2].path, "step-1")))
    >>> step1_target == runs[1].id, (step1_target, runs[1].id)
    (True, ...)

    >>> step2_target = basename(realpath(join_path(runs[2].path, "step-2")))
    >>> step2_target == runs[0].id, (step1_target, runs[0].id)
    (True, ...)

## Named steps

Steps can be named, which specifies the name of the link to
create. Names are also used when referring to the step.

The `steps-named` operation illustrates how names are used.

    >>> project.run("m1:steps-named")
    INFO: [guild] running s1: m1:step-1
    hello step-1
    INFO: [guild] running s2: m1:step-2
    hello step-2

Here are the last three runs generated:

    >>> runs = project.list_runs()[:3]
    >>> project.print_runs(runs)
    m1:step-2
    m1:step-1
    m1:steps-named

The links generated in the stepped run reflect the step names:

The stepped run `steps-basic` contains symbolic links to the two
genated runs:

    >>> project.ls(runs[2])
    ['s1', 's2']

    >>> s1_target = basename(realpath(join_path(runs[2].path, "s1")))
    >>> s1_target == runs[1].id, (s1_target, runs[1].id)
    (True, ...)

    >>> s2_target = basename(realpath(join_path(runs[2].path, "s2")))
    >>> s2_target == runs[0].id, (s1_target, runs[0].id)
    (True, ...)

## Repeated steps

If a step is run more than once, the link names for subsequent runs
use an incrementing suffix to avoid name collisions.

    >>> project.run("m1:steps-repeat")
    INFO: [guild] running step-1: m1:step-1
    hello step-1
    INFO: [guild] running step-1: m1:step-1
    hello step-1
    INFO: [guild] running step-1: m1:step-1
    hello step-1

    >>> runs = project.list_runs()[:4]
    >>> project.print_runs(runs)
    m1:step-1
    m1:step-1
    m1:step-1
    m1:steps-repeat

    >>> project.ls(runs[3])
    ['step-1', 'step-1_2', 'step-1_3']

## Stepped operations and flags

Stepped operations may contain flags like any other operation. In the
case of a stepped operation, however, flags are used as arguments to
the operations they run.

We'll illustrate using `hello`, which is an operation that prints a
message specified with the `msg` flag, which defaults to 'hello
world':

    >>> project.run("m1:hello")
    hello world

And with an explicit message:

    >>> project.run("m1:hello", flags={"msg": "hello from test"})
    hello from test

The `steps-hello` operation is a stepped operation that runs `hello`
twice. It defines its own flag `msg`, which defaults to 'hello steps',
and passes that flag value through to its steps.

Here's the default behavior of `steps-hello`:

    >>> project.run("m1:steps-hello")
    INFO: [guild] running hello: m1:hello msg='hello steps'
    hello steps
    INFO: [guild] running hello: m1:hello msg='hello steps (again)'
    hello steps (again)

And with an explicit message:

    >>> project.run("m1:steps-hello", flags={"msg": "hello from test"})
    INFO: [guild] running hello: m1:hello msg='hello from test'
    hello from test
    INFO: [guild] running hello: m1:hello msg='hello from test (again)'
    hello from test (again)

## Running operations across models

A stepped operation may run operations defined in other models. Model
`m2` illustrates this with the `composite` operation.

    >>> project.run("m2:composite")
    INFO: [guild] running hello: m2:hello msg='hello m2, from composite'
    hello m2, from composite
    INFO: [guild] running m1:hello: m1:hello msg='hello m1, from composite'
    hello m1, from composite

And with a `name` flag:

    >>> project.run("m2:composite", flags={"name": "test"})
    INFO: [guild] running hello: m2:hello msg='hello m2, from test'
    hello m2, from test
    INFO: [guild] running m1:hello: m1:hello msg='hello m1, from test'
    hello m1, from test

## Invalid steps

Step config is validated while running the stepped operation, so
invalid step configuration will cause the stepper operation to fail
with an error.

The `m3` model contains various operations that have invalid step
configuration.

    >>> project.run("m3:steps-invalid-bad-opspec-1")
    guild: invalid step data: [1, 2, 3]
    <exit 1>

    >>> project.run("m3:steps-invalid-bad-opspec-2")
    guild: invalid step data: None
    <exit 1>

    >>> project.run("m3:steps-invalid-bad-opspec-3")
    guild: invalid step {'run': '   '}: must define run
    <exit 1>

    >>> project.run("m3:steps-invalid-bad-opspec-4")
    guild: invalid step {}: must define run
    <exit 1>

    >>> project.run("m3:steps-invalid-bad-op")
    INFO: [guild] running not-defined: m3:not-defined
    guild: operation 'not-defined' is not defined for model 'm3'
    Try 'guild operations m3' for a list of available operations.
    <exit 1>

At the moment, steps do not support additional run options and any
provided will cause Guild to print a warning message.

    >>> project.run("m3:ignored-params")
    WARNING: [guild] run parameter run_dir used in 'm1:hello --run-dir /tmp --stage' ignored
    WARNING: [guild] run parameter stage used in 'm1:hello --run-dir /tmp --stage' ignored
    INFO: [guild] running m1:hello: m1:hello
    hello world

## Steps and scalars

The scalar values generated by step operations are available under the
top-level operation via the run index.

We'll use the operations in the `m4` model to illustate.

First let's delete our current runs.

    >>> project.delete_runs()
    Deleted 31 run(s)

Let's run `m4:end-to-end`, which runs the sequence of `prepare`,
`train`, and `evaluate`. This simulates a common end-to-end training
and evaluation scenario.

    >>> project.run("m4:end-to-end")
    INFO: [guild] running prepare: m4:prepare --needed
    prepared data
    INFO: [guild] running train: m4:train loss=1.0
    Resolving prepare dependency
    Using run ... for prepare resource
    loss=1.0
    INFO: [guild] running eval: m4:evaluate acc=0.5
    Resolving prepare dependency
    Using run ... for prepare resource
    Resolving train dependency
    Using run ... for train resource
    acc=0.5

Here are the generated runs:

    >>> project.print_runs(flags=True, status=True)
    m4:evaluate    acc=0.5 prepare=... train=...  completed
    m4:train       loss=1.0 prepare=...           completed
    m4:prepare                                    completed
    m4:end-to-end  acc=0.5 loss=1.0               completed

Let's look at each run in turn.

    >>> end_to_end_run = project.list_runs()[3]
    >>> end_to_end_run.opref.to_opspec()
    'm4:end-to-end'
    >>> project.ls(end_to_end_run)
    ['eval', 'prepare', 'train']

    >>> prepare_run = project.list_runs()[2]
    >>> prepare_run.opref.to_opspec()
    'm4:prepare'
    >>> project.ls(prepare_run)
    ['data']

    >>> train_run = project.list_runs()[1]
    >>> train_run.opref.to_opspec()
    'm4:train'
    >>> project.ls(train_run)
    ['data', 'model']

    >>> evaluate_run = project.list_runs()[0]
    >>> evaluate_run.opref.to_opspec()
    'm4:evaluate'
    >>> project.ls(evaluate_run)
    ['data', 'model']

Helper to format compare results:

    >>> def compare():
    ...     results = project.compare()
    ...     if not results:
    ...         print("<empty>")
    ...         return
    ...     cols = results[0]
    ...     data = (
    ...         [dict(zip(cols, cols))]
    ...         + [dict(zip(cols, row)) for row in results[1:]])
    ...     cli.table(data, cols)

When we compare the runs:

    >>> compare()  # doctest: -WINDOWS
    run  operation      started  time  status     label                          acc   loss
    ...  m4:evaluate    ...      ...   completed  acc=0.5 prepare=... train=...  0.5
    ...  m4:train       ...      ...   completed  loss=1.0 prepare=...                 1.0
    ...  m4:prepare     ...      ...   completed
    ...  m4:end-to-end  ...      ...   completed  acc=0.5 loss=1.0               0.5   1.0

Note that `end-to-end` reflects the `loss` and `acc` of its steps.

BUG: On Windows, stepped runs do not roll up from their steps due to a
bug in Python symlink traversal, which is picked up by the TensorBoard
tfevent generator, which Guild uses.

Here's the same result on Windows. Note the last line - acc and loss are both None.

    >>> compare()  # doctest: +WINDOWS_ONLY
    run  operation      started  time  status     label                          acc   loss
    ...  m4:evaluate    ...      ...   completed  acc=0.5 prepare=... train=...  0.5
    ...  m4:train       ...      ...   completed  loss=1.0 prepare=...                 1.0
    ...  m4:prepare     ...      ...   completed
    ...  m4:end-to-end  ...      ...   completed  acc=0.5 loss=1.0

## Steps and --force-flags

There's currently no way to specify a step operation flag when running
a stepped operation. The stepped operation must explicitly pass
through its flags to steps. This is inconvenient for users who want to
change step operation flags as they have to modify the Guild file.

This will be changed in time so that users can specify operation flags
when running a stepped operation.

E.g.

    $ guild run m5:steps op:msg=hello

However, this is not yet supported.

As a workaround, a user can specify `--force-flags` to force any
non-stepped flags to be passed through to step operations.

We'll use the `m5` model to illustrate.

Let's run the `steps` opertion without flags:

    >>> project.run("m5:steps")
    INFO: [guild] running op: m5:op
    hi from op

And now with an argument for the `msg` flag for `op`:

    >>> project.run("m5:steps", flags={"msg": "hi from test"})
    guild: unsupported flag 'msg'
    Try 'guild run m5:steps --help-op' for a list of flags or use
    --force-flags to skip this check.
    <exit 1>

And the flag specified as `op:msg`:

    >>> project.run("m5:steps", flags={"op:msg": "hi from test"})
    guild: unsupported flag 'op:msg'
    Try 'guild run m5:steps --help-op' for a list of flags or use
    --force-flags to skip this check.
    <exit 1>

Now specify `op:msg` with `--force-flags`.

    >>> project.run(
    ...   "m5:steps",
    ...   flags={"op:msg": "hi from test"},
    ...   force_flags=True)
    INFO: [guild] running op: m5:op msg='hi from test'
    hi from test

You can also include the model in the op qualifier.

    >>> project.run(
    ...   "m5:steps",
    ...   flags={"m5:op:msg": "hi from test"},
    ...   force_flags=True)
    INFO: [guild] running op: m5:op msg='hi from test'
    hi from test

When both variants are provided, the more complete spec is used.

    >>> project.run(
    ...   "m5:steps",
    ...   flags={"m5:op:msg": "model+op", "op:msg": "op"},
    ...   force_flags=True)
    INFO: [guild] running op: m5:op msg=model+op
    model+op

## Steps and labels

Labels specified with `--label` are applied to the parent and the step
runs.

    >>> project.run("m2:composite", label="a label")
    INFO: [guild] running hello: m2:hello --label a label msg='hello m2, from composite'
    hello m2, from composite
    INFO: [guild] running m1:hello: m1:hello --label a label msg='hello m1, from composite'
    hello m1, from composite

The runs:

    >>> project.print_runs(project.list_runs()[:3], labels=True)
    m1:hello      a label
    m2:hello      a label
    m2:composite  a label

The same is true for `--tag`.

    >>> project.run("m2:composite", tags=["a tag"])
    INFO: [guild] running hello: m2:hello --tag a tag msg='hello m2, from composite'
    hello m2, from composite
    INFO: [guild] running m1:hello: m1:hello --tag a tag msg='hello m1, from composite'
    hello m1, from composite

The runs:

    >>> project.print_runs(project.list_runs()[:3], labels=True)
    m1:hello      a tag msg='hello m1, from composite'
    m2:hello      a tag msg='hello m2, from composite'
    m2:composite  a tag name=composite
