from typing import Any
from typing import Int
from typing import Iterator
from typing import List
from typing import Mapping
from typing import Optional

from sqlalchemy.cresultproxy import tuplegetter as tuplegetter
from .row import Row as Row
from .. import exc as exc
from .. import util as util
from ..sql.base import HasMemoized as HasMemoized
from ..sql.base import InPlaceGenerative as InPlaceGenerative
from ..util import collections_abc as collections_abc
from ..util import py2k as py2k

class ResultMetaData:
    @property
    def keys(self): ...

class RMKeyView(collections_abc.KeysView):
    def __init__(self, parent: Any) -> None: ...
    def __len__(self): ...
    def __iter__(self) -> Any: ...
    def __contains__(self, item: Any): ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...

class SimpleResultMetaData(ResultMetaData):
    def __init__(
        self,
        keys: Any,
        extra: Optional[Any] = ...,
        _processors: Optional[Any] = ...,
        _tuplefilter: Optional[Any] = ...,
        _translated_indexes: Optional[Any] = ...,
        _unique_filters: Optional[Any] = ...,
    ) -> None: ...

def result_tuple(fields: Any, extra: Optional[Any] = ...): ...

class ResultInternal(InPlaceGenerative): ...

class _WithKeys:
    def keys(self): ...

class Result(_WithKeys, ResultInternal):
    def __init__(self, cursor_metadata: Any) -> None: ...
    def yield_per(self, num: Any) -> None: ...
    def unique(self, strategy: Optional[object] = ...) -> Result: ...
    def columns(self, *col_expressions: object) -> Result: ...
    def scalars(self, index: Int = ...) -> ScalarResult: ...
    def mappings(self): ...
    def __iter__(self) -> Any: ...
    def __next__(self): ...
    def next(self): ...
    def partitions(self, size: Optional[Int] = ...) -> Iterator[List[Row]]: ...
    def fetchall(self) -> List[Row]: ...
    def fetchone(self) -> Row: ...
    def fetchmany(self, size: Optional[Int] = ...) -> List[Row]: ...
    def all(self) -> List[Row]: ...
    def first(self) -> Row: ...
    def one_or_none(self) -> Optional[Row]: ...
    def scalar_one(self) -> Any: ...
    def scalar_one_or_none(self) -> Optional[Any]: ...
    def one(self) -> Row: ...
    def scalar(self) -> Optional[Any]: ...
    def freeze(self): ...
    def merge(self, *others: Any): ...

class FilterResult(ResultInternal): ...

class ScalarResult(FilterResult):
    def __init__(self, real_result: Any, index: Any) -> None: ...
    def unique(self, strategy: Optional[Any] = ...): ...
    def partitions(self, size: Optional[Int] = ...) -> Iterator[List[Any]]: ...
    def fetchall(self) -> List[Any]: ...
    def fetchmany(self, size: Optional[Int] = ...) -> List[Any]: ...
    def all(self) -> List[Any]: ...
    def __iter__(self) -> Any: ...
    def __next__(self): ...
    def next(self): ...
    def first(self) -> Optional[Any]: ...
    def one_or_none(self) -> Optional[Any]: ...
    def one(self) -> Any: ...

class MappingResult(_WithKeys, FilterResult):
    def __init__(self, result: Any) -> None: ...
    def unique(self, strategy: Optional[Any] = ...): ...
    def columns(self, *col_expressions: object) -> MappingResult: ...
    def partitions(
        self, size: Optional[Int] = ...
    ) -> Iterator[List[Mapping]]: ...
    def fetchall(self) -> List[Mapping]: ...
    def fetchone(self) -> Mapping: ...
    def fetchmany(self, size: Optional[Int] = ...) -> List[Mapping]: ...
    def all(self) -> List[Mapping]: ...
    def __iter__(self) -> Any: ...
    def __next__(self): ...
    def next(self): ...
    def first(self) -> Optional[Mapping]: ...
    def one_or_none(self) -> Optional[Mapping]: ...
    def one(self) -> Mapping: ...

class FrozenResult:
    metadata: Any = ...
    data: Any = ...
    def __init__(self, result: Any) -> None: ...
    def rewrite_rows(self): ...
    def with_new_rows(self, tuple_data: Any): ...
    def __call__(self): ...

class IteratorResult(Result):
    iterator: Any = ...
    raw: Any = ...
    def __init__(
        self, cursor_metadata: Any, iterator: Any, raw: Optional[Any] = ...
    ) -> None: ...

def null_result(): ...

class ChunkedIteratorResult(IteratorResult):
    chunks: Any = ...
    raw: Any = ...
    iterator: Any = ...
    dynamic_yield_per: Any = ...
    def __init__(
        self,
        cursor_metadata: Any,
        chunks: Any,
        source_supports_scalars: bool = ...,
        raw: Optional[Any] = ...,
        dynamic_yield_per: bool = ...,
    ) -> None: ...
    def yield_per(self, num: Any) -> None: ...

class MergedResult(IteratorResult):
    closed: bool = ...
    def __init__(self, cursor_metadata: Any, results: Any) -> None: ...
    def close(self) -> None: ...
