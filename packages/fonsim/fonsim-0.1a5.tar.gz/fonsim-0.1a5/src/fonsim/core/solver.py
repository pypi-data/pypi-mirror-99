""""
Classes with available solvers

A solver takes care of solving the (non-linear)
system of equations generated by the Simulation object.
This object can interact with the Simulation object.

Current solvers:
1. ImplicitEulerNewtonConstantTimeStep
2. ImplicitEulerNewtonAdaptiveTimeStep

2020, July 23
"""

import numpy as np


class ImplicitEulerNewton():
    def __init__(self, simulation):
        """
        ImplicitEulerNewton class

        :param simulation: Simulation object
        """
        self.sim = simulation

    def apply_solver_bias(self, bias=1e-12, step=0):
        """
        Give elements in the solution vector a small positive value, to
        ease starting the simulation

        :param bias: bias value added to the solution vector entries
        :param step: simulation step for which this bias is applied
        :return: None
        """
        for i in range(len(self.sim.phi)):
            self.sim.phi[i][step] += bias

    def get_all_variables(self, simstep):
        """
        :param simstep: simulation step at which variables are queried
        :return: np array with the values of all arguments and component
        states at the desired simulation step
        """
        # Get all argument values
        arguments = self.sim.phi[simstep,:]
        # Get all state values
        states = np.array([])
        for component in self.sim.system.components:
            if len(component.states):
                states = np.append(states, component.state_history[simstep,:])

        return np.append(arguments, states)

    def get_residual(self, simstep, res=None):
        """
        Evaluate the simulation system of equations at the provided
        timestep to get the residual vector

        :param simstep: index of simulation timestep at which the system
        of equations is evaluated
        :param res: optional initialized residual vector that will be
        overwritten by this function in place
        :return: evaluated residual vector
        """
        if res is None:
            res = np.zeros(self.sim.nb_arguments)
        elapsed_time = self.sim.times[simstep]

        # Implicit Euler - evaluate equations and get updated jacobian H
        self.sim.evaluate_equations(simstep-1, res, self.sim.H, 
                                    elapsed_time, self.dt)
        # evaluate network equations (can this be done more elegantly?)
        res[:self.sim.nb_network_equations] = np.dot(self.sim.A,
                                                     self.sim.phi[simstep,:])

        return res

    def newton_solver(self, step, iterations=100, alpha=1.):
        """
        Newton method for solving the system equations and storing the
        solution in the simulation phi vector at an time step

        :param step: step index for which the system will be solved and
        the solution will be stored. The initialization for the solver
        can be done externally by setting self.sim.phi[step] to the
        initial guess
        :param iterations: maximum number of newton solver iterations.
        100 (default) gives good results although it often converges in
        one step and otherwise mostly in less than ten
        :param alpha: correction constant for damped Newton method
        :return: flag indicating exit status of the solver for this step:
            0: maximum amount of iterations reached without convergence
            1: solver converged quickly
            2: solver converged slowly
        """
        # Allocate residual vector
        residual = np.zeros(self.sim.nb_arguments)
        # Newton outer loop
        for i in range(iterations):
            # Get the residual vector
            self.get_residual(step, residual)
            # Solve the linear system
            phi_correction = -np.linalg.solve(self.sim.H, residual)
            # Apply the correction
            self.sim.phi[step,:] = self.sim.phi[step,:] + alpha*phi_correction
            # Look at error
            max_error = np.max(np.abs(residual))
            # the 0.1 is somewhat arbitrary. Better would be to set a max
            # error for each equation, so the units and scale of each
            # equation are taken into account. 0.1 gives ok results
            if max_error < 0.1:
                #print("Outer loop converged in ", i + 1, "steps")
                if i <= np.ceil(.1*iterations):
                    return 1
                else:
                    return 2
        return 0

    def print_report(self, simstep):
        """
        Print a report on the solver status at a certain simulation time
        step.

        :param simstep: index of simulation timestep for which the report
        is generated
        :return: None
        """
        np.set_printoptions(formatter={'float': '{: 0.0f}'.format})
        # display simulation time
        print("t = {}".format(self.sim.times[simstep]))
        # display argument values
        arg_str = ""
        for i in range(self.sim.nb_arguments):
            if i > 0:
                arg_str += ", "
            arg_str += "{} = {}".format(self.sim.arguments[i].short_str(),
                                        self.sim.phi[simstep+1,i])
        print(arg_str)

        # display residuals of non-converging equations
        residuals = self.get_residual(simstep)
        for i in range(len(residuals)):
            if abs(residuals[i]) > 0.1:
                print("eq {}: {} = {}".format(i, 
                      self.sim.equation_to_string(i), residuals[i]))
        # display system jacobian
        print("B:\n", self.sim.H[self.sim.nb_network_equations:,:])


        print()


class ImplicitEulerNewtonConstantTimeStep(ImplicitEulerNewton):
    def __init__(self, simulation, step):
        """
        ImplicitEulerNewtonConstantTimeStep class

        :param simulation: Simulation object
        :param step: fixed time increment
        """
        super().__init__(simulation)

        # stepping
        self.dt = step

    def get_nb_steps_estimate(self):
        """
        :return: number of timesteps the solver needs
        """
        return int(np.ceil(self.sim.duration / self.dt)) + 1

    def run_step(self, simstep):
        """
        Run a single step of the solver.
        Note: Calling it at step n ('simstep' = n)
        results in it writing to the next step,
        aka step n+1

        :param simstep: index of simulation timestep with the last results
        :return: None
        """
        # First estimate for new arguments: arguments of previous step
        self.sim.phi[simstep+1,:] = self.sim.phi[simstep, :]
        if simstep <= 0:
            self.apply_solver_bias(step=1)
        # Update current time
        self.sim.times[simstep+1] = (simstep+1) * self.dt
        # Solve system for arguments
        status = self.newton_solver(simstep+1)
        # Report on solver convergence
        if status == 0 and self.sim.verbose >= 1:
            self.print_report(simstep+1)

        # got the arguments, to finish update the state (with the updated
        # arguments)
        self.sim.update_state(simstep, self.dt)


class ImplicitEulerNewtonAdaptiveTimeStep(ImplicitEulerNewton):
    def __init__(self, simulation, step, step_min, step_max,
                 max_attempts=200):
        """
        ImplicitEulerNewtonAdaptiveTimeStep class

        :param simulation: Simulation object
        :param step: initial time increment
        :param step_min: minimum possible time increment
        :param step_max: maximum possible time increment
        :param max_attempts: maximum allowed number of solver attempts
        within a time increment
        """
        super().__init__(simulation)

        # time stepping
        self.dt = step
        self.dt_min = step_min if step_min is not None else 1e-4*self.dt
        self.dt_max = step_max if step_max is not None else 1.5*self.dt
        self.max_attempts = max_attempts

        # keep track of the average and variance of the changes in arguments
        nb_states = sum([len(c.states) for c in self.sim.system.components])
        self.delta_av = np.zeros(self.sim.nb_arguments+nb_states)
        self.delta_var = np.zeros(self.sim.nb_arguments+nb_states)

    def update_delta_range(self, nb_points, delta):
        """
        Update the average and variance of the changes of simulation
        variables (both arguments and states) over all simulation steps
        with the change at the current step
        
        :param nb_points: amount of steps included in the last metrics
        :param delta: new change in simulation arguments between
        consecutive steps to include in the metrics
        :return: None
        """
        # Sign is irrelevant, only magnitude counts
        delta = np.abs(delta)
        # Calculate variance
        if nb_points > 0:
            self.delta_var = ((nb_points-1)*self.delta_var + \
                             np.power(delta-self.delta_av,2.))/ nb_points
        # Calculate average
        self.delta_av = (nb_points*self.delta_av + delta)/ (nb_points+1)

    def delta_in_range(self, delta):
        """
        Check whether a change in simulation variables (both arguments
        and states) during a step is within an acceptable range compared
        to the other simulation step results or it is abnormally large

        :param delta: vector with change in all the arguments between
        consecutive simulation steps
        :return in_range: True if delta is of an acceptable magnitude and
        False if it represents a change which is abnormally large
        """
        # Sign is irrelevant, only magnitude counts
        delta = np.abs(delta)

        # Loop over arguments
        for var_ind in range(len(delta)):
            # Only look at steps that are too big (too small is not an issue)
            # and compare their deviation from the mean with the variance
            # (rather than standard deviation since this requires taking
            # square roots on a regular basis)
            deviation = delta[var_ind] - self.delta_av[var_ind]
            if deviation > 1.3e154 or (deviation > 0 and \
               deviation**2 > 25*self.delta_var[var_ind]):
                return False

        return True

    def get_nb_steps_estimate(self):
        """
        :return: number of timesteps the solver thinks it will need to
        finish the simulation
        """
        if np.max(self.sim.times) > 0. and np.argmax(self.sim.times) > 0:
            dt_av = np.max(self.sim.times) / np.argmax(self.sim.times)
        else:
            dt_av = self.dt
        return int(np.ceil(self.sim.duration / dt_av)) + 1

    def run_step(self, simstep):
        """
        Run a single step of the solver.
        Note: Calling it at step n ('simstep' = n)
        results in it writing to the next step,
        aka step n+1

        :param simstep: index of timestep with the last simulated results
        :return: list with as elements:
            0: boolean showing solver convergence for the simulation step
            1: string giving more information about the exit status
        """
        # Solve system for arguments
        attempt = 1
        try_decreasing_step = True
        while attempt < self.max_attempts:
            # First estimate for new arguments: values of previous step
            self.sim.phi[simstep+1,:] = self.sim.phi[simstep, :] 
            if simstep <= 0:
                self.apply_solver_bias(step=1)

            # Update current time
            self.sim.times[simstep+1] = self.sim.times[simstep] + self.dt
            # Solve the system at the current time
            status = self.newton_solver(simstep+1, alpha=1.)
            solver_success = status in (1,2)
            # Update the state with the updated arguments
            self.sim.update_state(simstep, self.dt)
            # Calculate how much all variables (arguments and states) 
            # changed in this simulation step
            delta = self.get_all_variables(simstep+1) - \
                    self.get_all_variables(simstep)
            reliable_result = simstep <= 1 or self.delta_in_range(delta)

            # Stepping logic
            if not (solver_success and reliable_result) and \
               self.dt > self.dt_min and try_decreasing_step:
                # No convergence reached, but it is still possible to
                # decrease the time step size and try again
                self.dt = max(self.dt_min, .1*self.dt)
            elif not solver_success:
                # No convergence reached even after decreasing the step
                # size, so increase the step size gradually instead
                try_decreasing_step = False
                self.dt += self.dt_min
            else:
                # Accept found solution
                break
            attempt += 1

        # Solver converged
        if solver_success:
            # Update metrics of what counts as a normal change in 
            # variable values
            self.update_delta_range(simstep, delta)
            # Increase step time if convergence was swift
            if attempt <= 1 and status == 1:
                self.dt = min(self.dt_max, 1.5*self.dt)
            return solver_success
        # Solver did not converge
        else:
            if self.sim.verbose >= 1:
                # Report on solver convergence
                self.print_report(simstep+1)
            return (solver_success, "Solver failed to converge")