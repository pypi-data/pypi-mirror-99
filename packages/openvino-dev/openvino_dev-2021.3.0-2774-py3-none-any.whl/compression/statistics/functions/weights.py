#
# Copyright 2020-2021 Intel Corporation.
#
# This software and the related documents are Intel copyrighted materials,
# and your use of them is governed by the express license under which they
# were provided to you (End User License Agreement for the Intel(R) Software
# Development Products (Version October 2018)). Unless the License provides
# otherwise, you may not use, modify, copy, publish, distribute, disclose or
# transmit this software or the related documents without Intel's prior
# written permission.
#
# This software and the related documents are provided as is, with no
# express or implied warranties, other than those that are expressly
# stated in the License.
from functools import partial

import numpy as np
from ..function_selector import WEIGHTS_STATS_FN, PERTENSOR, PERCHANNEL

w_stats_fn_per_tensor = WEIGHTS_STATS_FN[PERTENSOR]
w_stats_fn_per_channel = WEIGHTS_STATS_FN[PERCHANNEL]


# helper functions to calculate per-filter statistics for weights
def calculate_per_filter_stats(weights, fn):
    """ Calculates per-filter statistics for weights using a specific function
    :param weights: model layer weights
    :param fn: function to calculate per-filter statistics
    :return statistics generated by fn
    """
    t = np.reshape(weights, (weights.shape[0], -1))
    return fn(t, axis=1)


@w_stats_fn_per_tensor.register('max')
def max_per_tensor(weights):
    return np.max(weights)


@w_stats_fn_per_tensor.register('min')
def min_per_tensor(weights):
    return np.min(weights)


@w_stats_fn_per_tensor.register('abs_max')
def abs_max_per_tensor(weights):
    return np.max(np.abs(weights))


@w_stats_fn_per_tensor.register('quantile')
def quantile_per_tensor(weights, q):
    return np.quantile(weights, q=q)


@w_stats_fn_per_tensor.register('abs_quantile')
def abs_quantile_per_tensor(weights, q):
    return np.quantile(np.abs(weights), q=q)


@w_stats_fn_per_channel.register('max')
def max_per_filter(weights):
    return calculate_per_filter_stats(weights, np.max)


@w_stats_fn_per_channel.register('min')
def min_per_filter(weights):
    return calculate_per_filter_stats(weights, np.min)


@w_stats_fn_per_channel.register('abs_max')
def abs_max_per_filter(weights):
    return max_per_filter(np.abs(weights))


@w_stats_fn_per_channel.register('quantile')
def quantile_per_filter(weights, q):
    return calculate_per_filter_stats(weights, partial(np.quantile, q=q))


@w_stats_fn_per_channel.register('abs_quantile')
def abs_quantile_per_filter(weights, q):
    return quantile_per_filter(np.abs(weights), q)
