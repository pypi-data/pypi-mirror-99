#
# Copyright 2020-2021 Intel Corporation.
#
# This software and the related documents are Intel copyrighted materials,
# and your use of them is governed by the express license under which they
# were provided to you (End User License Agreement for the Intel(R) Software
# Development Products (Version October 2018)). Unless the License provides
# otherwise, you may not use, modify, copy, publish, distribute, disclose or
# transmit this software or the related documents without Intel's prior
# written permission.
#
# This software and the related documents are provided as is, with no
# express or implied warranties, other than those that are expressly
# stated in the License.
from functools import partial

import numpy as np
from ..function_selector import ACTIVATIONS_STATS_FN, PERTENSOR, PERCHANNEL

act_stats_fn_per_tensor = ACTIVATIONS_STATS_FN[PERTENSOR]
act_stats_fn_per_channel = ACTIVATIONS_STATS_FN[PERCHANNEL]


# helper functions to calculate statistics for activations
def calculate_per_channel_stats(acts, fn):
    """ Calculates per-channel statistics for activations using a specific function
    :param act: activation
    :param fn: function to calculate per-channel statistics
    :return statistics generated by fn for each activation in the batch
    """
    if len(acts.shape) < 3:
        return acts

    t = acts.reshape(acts.shape[0], acts.shape[1], -1)
    return fn(t, axis=2)


def calculate_per_tensor_stats(acts, fn):
    """ Calculates statistics by whole tensor for activations using a specific function
    :param act: activation
    :param fn: function to calculate per-tensor statistics
    :return statistics generated by fn for each activation in the batch
    """
    if len(acts.shape) < 2:
        return np.atleast_1d(fn(acts))

    t = acts.reshape(acts.shape[0], -1)
    return fn(t, axis=1)


@act_stats_fn_per_tensor.register('max')
def max_per_tensor(acts):
    return calculate_per_tensor_stats(acts, np.max)


@act_stats_fn_per_tensor.register('min')
def min_per_tensor(acts):
    return calculate_per_tensor_stats(acts, np.min)


@act_stats_fn_per_tensor.register('abs_max')
def abs_max_per_tensor(acts):
    return max_per_tensor(np.abs(acts))


@act_stats_fn_per_tensor.register('quantile')
def quantile_per_tensor(acts, q):
    return calculate_per_tensor_stats(acts, partial(np.quantile, q=q))


@act_stats_fn_per_tensor.register('abs_quantile')
def abs_quantile_per_tensor(acts, q):
    return quantile_per_tensor(np.abs(acts), q)


@act_stats_fn_per_channel.register('mean')
def mean_per_channel(acts):
    return calculate_per_channel_stats(acts, np.mean)


@act_stats_fn_per_channel.register('quantile')
def quantile_per_channel(acts, q):
    return calculate_per_channel_stats(acts, partial(np.quantile, q=q))


@act_stats_fn_per_channel.register('max')
def max_per_channel(acts):
    return calculate_per_channel_stats(acts, np.max)


@act_stats_fn_per_channel.register('min')
def min_per_channel(acts):
    return calculate_per_channel_stats(acts, np.min)


@act_stats_fn_per_channel.register('abs_max')
def abs_max_per_channel(acts):
    return max_per_channel(np.abs(acts))


@act_stats_fn_per_channel.register('abs_quantile')
def abs_quantile_per_channel(acts, q):
    return quantile_per_channel(np.abs(acts), q)
