{"version":3,"sources":["../src/index.js"],"names":["RTCAudioSource","nonstandard","NodeWebRtcAudioStreamSource","addStream","readable","bitsPerSample","sampleRate","channelCount","cache","Buffer","alloc","streamEnd","on","buffer","concat","processData","byteLength","length","slice","samples","Int16Array","Uint8Array","onData","numberOfFrames","type","setTimeout"],"mappings":";;;;;;;;;AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAqBC,iBAA3B;;AAEA,MAAMC,2BAAN,SAA0CF,cAA1C,CAAyD;AACvDG,EAAAA,SAAS,CAAEC,QAAF,EAAYC,aAAa,GAAG,EAA5B,EAAgCC,UAAU,GAAG,KAA7C,EAAoDC,YAAY,GAAG,CAAnE,EAAsE;AAC7E,QAAIC,KAAK,GAAGC,MAAM,CAACC,KAAP,CAAa,CAAb,CAAZ;AACA,QAAIC,SAAS,GAAG,KAAhB;AACAP,IAAAA,QAAQ,CAACQ,EAAT,CAAY,MAAZ,EAAoBC,MAAM,IAAI;AAC5BL,MAAAA,KAAK,GAAGC,MAAM,CAACK,MAAP,CAAc,CAACN,KAAD,EAAQK,MAAR,CAAd,CAAR;AACD,KAFD;AAIAT,IAAAA,QAAQ,CAACQ,EAAT,CAAY,KAAZ,EAAmB,MAAM;AACvBD,MAAAA,SAAS,GAAG,IAAZ;AACD,KAFD;;AAIA,UAAMI,WAAW,GAAG,MAAM;AACxB,YAAMC,UAAU,GAAGV,UAAU,GAAGD,aAAb,GAA6B,CAA7B,GAAiC,GAAjC,GAAuCE,YAA1D,CADwB,CAC+C;;AACvE,UAAIC,KAAK,CAACS,MAAN,IAAgBD,UAAhB,IAA8BL,SAAlC,EAA6C;AAC3C,cAAME,MAAM,GAAGL,KAAK,CAACU,KAAN,CAAY,CAAZ,EAAeF,UAAf,CAAf;AACAR,QAAAA,KAAK,GAAGA,KAAK,CAACU,KAAN,CAAYF,UAAZ,CAAR;AACA,cAAMG,OAAO,GAAG,IAAIC,UAAJ,CAAe,IAAIC,UAAJ,CAAeR,MAAf,EAAuBA,MAAtC,CAAhB;AACA,aAAKS,MAAL,CAAY;AACVjB,UAAAA,aADU;AAEVC,UAAAA,UAFU;AAGVC,UAAAA,YAHU;AAIVgB,UAAAA,cAAc,EAAEJ,OAAO,CAACF,MAJd;AAKVO,UAAAA,IAAI,EAAE,MALI;AAMVL,UAAAA;AANU,SAAZ;AAQD;;AACD,UAAI,CAACR,SAAD,IAAcH,KAAK,CAACS,MAAN,IAAgBD,UAAlC,EAA8C;AAC5CS,QAAAA,UAAU,CAAC,MAAMV,WAAW,EAAlB,EAAsB,EAAtB,CAAV,CAD4C,CACR;AACrC;AACF,KAlBD;;AAmBAA,IAAAA,WAAW;AACZ;;AAhCsD;;eAmC1Cb,2B","sourcesContent":["import { nonstandard } from 'wrtc'\n\nconst { RTCAudioSource } = nonstandard\n\nclass NodeWebRtcAudioStreamSource extends RTCAudioSource {\n  addStream (readable, bitsPerSample = 16, sampleRate = 48000, channelCount = 1) {\n    let cache = Buffer.alloc(0)\n    let streamEnd = false\n    readable.on('data', buffer => {\n      cache = Buffer.concat([cache, buffer])\n    })\n\n    readable.on('end', () => {\n      streamEnd = true\n    })\n\n    const processData = () => {\n      const byteLength = sampleRate * bitsPerSample / 8 / 100 * channelCount // node-webrtc audio by default every 10ms, it is 1/100 second\n      if (cache.length >= byteLength || streamEnd) {\n        const buffer = cache.slice(0, byteLength)\n        cache = cache.slice(byteLength)\n        const samples = new Int16Array(new Uint8Array(buffer).buffer)\n        this.onData({\n          bitsPerSample,\n          sampleRate,\n          channelCount,\n          numberOfFrames: samples.length,\n          type: 'data',\n          samples\n        })\n      }\n      if (!streamEnd || cache.length >= byteLength) {\n        setTimeout(() => processData(), 10) // every 10 ms, required by node-webrtc audio\n      }\n    }\n    processData()\n  }\n}\n\nexport default NodeWebRtcAudioStreamSource\n"],"file":"index.js"}