import os
import pickle
import shutil
import copyreg
import pandas as pd
from vowpalwabbit import pyvw
from enum import Enum
from tempfile import TemporaryDirectory
from azureml.studio.core.logger import module_logger, TimeProfile
from azureml.designer.modules.vowpal_wabbit.common.dataset import Dataset
from azureml.designer.modules.vowpal_wabbit.common.entry_param import EntryParam
from azureml.designer.core.model.core_model import CoreModel
from azureml.studio.core.io.model_directory import ModelDirectory
from azureml.studio.core.error import InvalidDirectoryError, PathExistsError
from azureml.studio.internal.error import InvalidModelDirectoryError, ErrorMapping, FailedToCompleteOperationError
from azureml.core.run import Run
from azureml.exceptions import AzureMLException, ServiceException


class DataFormat(Enum):
    VW = "VW"
    SVMLight = "SVMLight"


class VowpalWabbitConstant:
    # part for option
    READABLE_MODEL_OPTION = "--readable_model"
    INVERT_HASH_OPTION = "--invert_hash"
    SAVE_REGRESSOR_OPTION = "--final_regressor"
    INITIAL_REGRESSOR_OPTION = "--initial_regressor"
    RAW_PREDICTION_OPTION = "--raw_predictions"
    PREDICTION_OPTION = "--predictions"
    TEST_OPTION = "--testonly"
    QUIET_OPTION = "--quiet"
    # part for file name
    READABLE_MODEL_FILE_NAME = "model.readable"
    INVERT_HASH_FILE_NAME = "model.invert_hash"
    RAW_PREDICTION_FILE_NAME = "raw_predictions"
    PREDICTION_FILE_NAME = "predictions"
    WRAPPER_MODEL_SAVE_FILE = "_model.pickle"
    VW_MODEL_SAVE_FILE = "_model.vw"
    # part for column names
    PREDICTED_RESULT_COLUMN = "Results"
    LABEL_COLUMN = "Labels"
    RAW_SCORE_COLUMN = "Raw Scores"


class VowpalWabbitModelWrapper(CoreModel, metaclass=EntryParam):
    MODEL_NAME = "Vowpal Wabbit Model"
    _ENTRY_PARAM_LOADER = "entry_param_loader"
    VW_LABEL_SEPARATOR = " | "
    MODEL_VERSION = "0.0.1"

    def __init__(self):
        self._working_directory = TemporaryDirectory()
        self._model_dir = None

    def save(self, save_to: str, overwrite_if_exists=True):
        # upload to the outputs folder
        run = Run.get_context()

        def upload_file_to_output(file_path, file_name=None):
            if not file_name:
                file_name = os.path.basename(file_path)
            if os.path.isfile(file_path):
                module_logger.info(f"Upload {file_name} file to outputs.")
                try:
                    run.upload_file(name=file_name, path_or_stream=file_path)
                except (AzureMLException, ServiceException) as e:
                    module_logger.warning(
                        f"Failed to upload {file_name} file. Reason:{ErrorMapping.get_exception_message(e)}")

        upload_file_to_output(self.readable_model_path)
        upload_file_to_output(self.invert_hash_file_path)

        vw_model_save_path = os.path.join(save_to, VowpalWabbitConstant.VW_MODEL_SAVE_FILE)
        wrapper_model_save_path = os.path.join(save_to, VowpalWabbitConstant.WRAPPER_MODEL_SAVE_FILE)

        # if vw model and wrapper both exists, and not overwrite, just return
        if not overwrite_if_exists:
            if os.path.exists(vw_model_save_path):
                raise PathExistsError(vw_model_save_path)
            if os.path.exists(wrapper_model_save_path):
                raise PathExistsError(wrapper_model_save_path)

        # copy vw model from current temp dir to save path
        # todo: to remove copy logic as soon as DS supports write save_to path directly
        if not os.path.exists(save_to):
            os.mkdir(save_to)
        shutil.copyfile(src=self.vw_model_path, dst=vw_model_save_path)

        # dump model
        with open(wrapper_model_save_path, "wb") as file:
            copyreg.pickle(VowpalWabbitModelWrapper, self._dump_pickle_with_version)
            pickle.dump(self, file)

    @classmethod
    def entry_param_loader(cls, load_from=None):
        if load_from is None:
            module_logger.debug("Load from model from null file path.")
            return None
        if isinstance(load_from, (str, os.PathLike)):
            try:
                module_logger.debug("Load model from disk.")
                model = ModelDirectory.load_instance(load_from_dir=load_from, model_class=cls)
            except InvalidDirectoryError as e:
                raise InvalidModelDirectoryError(
                    arg_name=cls.MODEL_NAME,
                    reason='the model may not be generated by the "Train Vowpal Wabbit Model" module"') from e
        elif isinstance(load_from, ModelDirectory):
            module_logger.debug("Load model from ModelDirectory object.")
            model = load_from.model
        else:
            raise NotImplementedError(
                f"Cannot load {cls.MODEL_NAME} from {load_from} of type {type(load_from)}")

        return model

    @classmethod
    def load(cls, load_from: str):
        model_save_path = os.path.join(load_from, VowpalWabbitConstant.WRAPPER_MODEL_SAVE_FILE)
        try:
            with open(model_save_path, "rb") as f:
                model = pickle.load(f)
        except Exception as e:
            raise InvalidModelDirectoryError(arg_name=cls.MODEL_NAME,
                                             reason='the model may not be generated by '
                                                    'the "Train Vowpal Wabbit Model" module') from e
        if not isinstance(model, cls):
            raise InvalidModelDirectoryError(arg_name=cls.MODEL_NAME,
                                             reason='the model may not be generated by '
                                                    'the "Train Vowpal Wabbit Model" module')
        model.model_dir = load_from
        model.working_dir = TemporaryDirectory()
        if not os.path.isfile(model.vw_model_path):
            raise InvalidModelDirectoryError(arg_name=cls.MODEL_NAME,
                                             reason="Vowpal Wabbit model path is not a file or does not exist")
        return model

    @staticmethod
    def _dump_pickle_with_version(vw_model_wrapper):
        kwargs = vw_model_wrapper.__dict__
        kwargs['version'] = VowpalWabbitModelWrapper.MODEL_VERSION

        return VowpalWabbitModelWrapper._load_pickle_by_version, (kwargs,)

    @staticmethod
    def _load_pickle_by_version(kwargs):
        version = kwargs.get("version", None)
        if version != VowpalWabbitModelWrapper.MODEL_VERSION:
            raise ValueError(f"Unknown {VowpalWabbitModelWrapper.MODEL_NAME} version {version}")
        return VowpalWabbitModelWrapper()

    def predict(self, df: pd.DataFrame, columns_types: dict = None):
        raise NotImplementedError("It's not expected to use predict method of Vowpal Wabbit model. "
                                  "Please use VowpalWabbitPredictor.")

    @property
    def model_dir(self):
        if self._model_dir is None:
            return self.working_dir
        return self._model_dir

    @model_dir.setter
    def model_dir(self, model_dir: str):
        self._model_dir = model_dir

    @property
    def working_dir(self):
        return self._working_directory.name

    @working_dir.setter
    def working_dir(self, working_dir: TemporaryDirectory):
        self._working_directory = working_dir

    @property
    def vw_model_path(self):
        return os.path.join(self.model_dir, VowpalWabbitConstant.VW_MODEL_SAVE_FILE)

    @property
    def readable_model_path(self):
        return os.path.join(self.working_dir, VowpalWabbitConstant.READABLE_MODEL_FILE_NAME)

    @property
    def invert_hash_file_path(self):
        return os.path.join(self.working_dir, VowpalWabbitConstant.INVERT_HASH_FILE_NAME)


class VowpalWabbitCommon:
    def __init__(self, vw_model: VowpalWabbitModelWrapper):
        self.vw_model = vw_model

    @staticmethod
    def _format_arguments(arg_str, option, option_value=None):
        if not option:
            return arg_str
        if arg_str:
            arg_str = f"{arg_str} {option}"
        else:
            arg_str = f"{option}"
        if option_value is not None:
            arg_str = f"{arg_str} {option_value}"

        return arg_str

    @staticmethod
    def _SVMLight_to_VW(example: str):
        """Convert SVMLight format to VW format.

        SVMLight is a simpler format than VW, which can be easily converted to VW format just by adding a pipe symbol
        between the label and the features. For example:
        SVMLight format: 1 1:41 2:187336 14:1 19:9 25:1 31:1 37:1 38:1 40:0 41:0 42:40
        VW format: 1 | 1:41 2:187336 14:1 19:9 25:1 31:1 37:1 38:1 40:0 41:0 42:40
        """
        example = example.strip()
        label_sep_index = example.find(' ')
        if label_sep_index > 0:
            example = (
                    example[:label_sep_index] + VowpalWabbitModelWrapper.VW_LABEL_SEPARATOR +
                    example[1 + label_sep_index:])
        else:
            example = example + VowpalWabbitModelWrapper.VW_LABEL_SEPARATOR

        return example

    @property
    def vw_model_path(self):
        return os.path.join(self.vw_model.model_dir, VowpalWabbitConstant.VW_MODEL_SAVE_FILE)


class VowpalWabbitTrainer(VowpalWabbitCommon):
    def __init__(self, vw_model: VowpalWabbitModelWrapper):
        super().__init__(vw_model)

    def train(self,
              training_data: Dataset,
              data_format,
              output_readable_model_file,
              output_inverted_hash_file,
              arg_str=None,
              pre_trained_model=None):
        arg_str = self._format_arguments(arg_str=arg_str, option=VowpalWabbitConstant.QUIET_OPTION)
        if pre_trained_model:
            module_logger.info("Add pre-trained model option.")
            arg_str = self._format_arguments(arg_str=arg_str, option=VowpalWabbitConstant.INITIAL_REGRESSOR_OPTION,
                                             option_value=pre_trained_model.vw_model_path)
        if output_readable_model_file:
            module_logger.info("Add readable model option.")
            arg_str = self._format_arguments(arg_str=arg_str, option=VowpalWabbitConstant.READABLE_MODEL_OPTION,
                                             option_value=self.vw_model.readable_model_path)
        if output_inverted_hash_file:
            module_logger.info("Add invert hash file option.")
            arg_str = self._format_arguments(arg_str=arg_str, option=VowpalWabbitConstant.INVERT_HASH_OPTION,
                                             option_value=self.vw_model.invert_hash_file_path)
        arg_str = self._format_arguments(arg_str=arg_str, option=VowpalWabbitConstant.SAVE_REGRESSOR_OPTION,
                                         option_value=self.vw_model_path)
        try:
            if isinstance(training_data, str):
                if data_format == DataFormat.VW:
                    with TimeProfile("Train Vowpal Wabbit model from VW format file."):
                        self._train_vw_file(training_data, arg_str)
                elif data_format == DataFormat.SVMLight:
                    with TimeProfile("Train Vowpal Wabbit model from SVMLight format file."):
                        self._train_svmlight_file(training_data, arg_str)
                else:
                    raise ValueError(f"Unknown data format: {data_format}")
            else:
                with TimeProfile("Train Vowpal Wabbit model from DataFrameDirectory dataset."):
                    self._train_dataframe_dataset(training_data, arg_str, data_format)
        except RuntimeError as e:
            error_message = ErrorMapping.get_exception_message(e)
            ErrorMapping.throw(FailedToCompleteOperationError(failed_operation="training VW model",
                                                              reason=error_message))

    def _train_svmlight_file(self, file_name, arg_str):
        vw = pyvw.vw(arg_str=arg_str)

        with open(file_name, "r") as data:
            for example in data:
                example = example.strip()
                if not example:
                    continue
                example = self._SVMLight_to_VW(example)
                vw_example = vw.example(example)
                vw.learn(vw_example)

        vw.finish()

    def _train_vw_file(self, training_data: str, arg_str):
        vw = pyvw.vw(arg_str=arg_str, data=training_data)
        vw.finish()

    def _train_dataframe_dataset(self, training_data, arg_str, data_format: DataFormat):
        # get the first column to be the training examples
        stream_data = training_data.df.iloc[:, 0]
        vw = pyvw.vw(arg_str=arg_str)

        for example in stream_data:
            example = example.strip()
            if not example:
                continue
            if data_format == DataFormat.SVMLight:
                example = self._SVMLight_to_VW(example)
            vw_example = vw.example(example)
            vw.learn(vw_example)

        vw.finish()


class VowpalWabbitPredictor(VowpalWabbitCommon):
    def __init__(self, vw_model: VowpalWabbitModelWrapper):
        super().__init__(vw_model)

    def predict(self,
                test_data,
                arg_str=None,
                include_labels=False,
                include_raw_predictions=False,
                data_format=DataFormat.VW):
        arg_str = self._format_arguments(arg_str=arg_str, option=VowpalWabbitConstant.QUIET_OPTION)
        arg_str = self._format_arguments(arg_str=arg_str, option=VowpalWabbitConstant.INITIAL_REGRESSOR_OPTION,
                                         option_value=self.vw_model_path)
        arg_str = self._format_arguments(arg_str=arg_str, option=VowpalWabbitConstant.TEST_OPTION)
        if include_raw_predictions:
            module_logger.info("Add output raw predictions option.")
            arg_str = self._format_arguments(arg_str=arg_str, option=VowpalWabbitConstant.RAW_PREDICTION_OPTION,
                                             option_value=self.raw_prediction_file_path)

        try:
            if isinstance(test_data, str):
                if data_format == DataFormat.VW:
                    with TimeProfile("Score data from VW format file."):
                        predictions, labels = self._predict_vw_file(test_data, arg_str)
                elif data_format == DataFormat.SVMLight:
                    with TimeProfile("Score data from SVMLight format file."):
                        predictions, labels = self._predict_svmlight_file(test_data, arg_str)
                else:
                    raise ValueError(f"Unknown data format: {data_format}")
            else:
                with TimeProfile("Score data from DataFrameDirectory dataset."):
                    predictions, labels = self._predict_dataframe_dataset(test_data=test_data, arg_str=arg_str,
                                                                          data_format=data_format)
        except RuntimeError as e:
            error_message = ErrorMapping.get_exception_message(e)
            ErrorMapping.throw(FailedToCompleteOperationError(failed_operation="score dataset",
                                                              reason=error_message))

        # return a tuple to follow custom flavor contract
        return self._format_score_results(predictions=predictions, labels=labels,
                                          include_raw_predictions=include_raw_predictions,
                                          include_labels=include_labels)

    def _predict_dataframe_dataset(self, test_data, arg_str, data_format: DataFormat):
        # get the first column to be the samples
        stream_data = test_data.df.iloc[:, 0]
        vw = pyvw.vw(arg_str=arg_str)

        predictions = []
        labels = []
        for example in stream_data:
            example = example.strip()
            if not example:
                continue
            if data_format == DataFormat.SVMLight:
                example = self._SVMLight_to_VW(example)
            labels.append(self._extract_label(example))
            vw_example = vw.example(example)
            predictions.append(vw.predict(vw_example))
            vw.finish_example(vw_example)
        vw.finish()

        return predictions, labels

    def _predict_svmlight_file(self, file_name, arg_str):
        vw = pyvw.vw(arg_str=arg_str)

        predictions = []
        labels = []
        with open(file_name, "r") as data:
            for example in data:
                example = example.strip()
                if not example:
                    continue
                example = self._SVMLight_to_VW(example)
                labels.append(self._extract_label(example))
                vw_example = vw.example(example)
                predictions.append(vw.predict(vw_example))
                vw.finish_example(vw_example)
        vw.finish()

        return predictions, labels

    def _predict_vw_file(self, test_data: str, arg_str):
        prediction_file_path = os.path.join(self.vw_model.working_dir, VowpalWabbitConstant.PREDICTION_FILE_NAME)
        arg_str = self._format_arguments(arg_str, VowpalWabbitConstant.PREDICTION_OPTION, prediction_file_path)
        vw = pyvw.vw(arg_str=arg_str, data=test_data)
        vw.finish()

        module_logger.info("Read predictions from prediction file.")
        with open(prediction_file_path, "r") as prediction_file:
            predictions = [prediction.strip() for prediction in prediction_file]
        try:
            predictions = [float(prediction) for prediction in predictions]
        except ValueError:
            module_logger.info("Predictions are not of numeric type.")

        module_logger.info("Extract labels from test data.")
        with open(test_data, "r") as test_data_file:
            labels = [self._extract_label(example) for example in test_data_file]

        return predictions, labels

    def _format_score_results(self, predictions, labels, include_raw_predictions, include_labels):
        columns = {VowpalWabbitConstant.PREDICTED_RESULT_COLUMN: predictions}
        if include_labels:
            columns[VowpalWabbitConstant.LABEL_COLUMN] = labels
        if include_raw_predictions:
            with open(self.raw_prediction_file_path, "r") as f:
                raw_predictions = [line.strip() for line in f]
            columns[VowpalWabbitConstant.RAW_SCORE_COLUMN] = raw_predictions

        result_df = pd.DataFrame(columns)
        return result_df

    @staticmethod
    def _extract_label(example: str):
        example = example.strip()
        label_sep_index = example.find(' ')
        if label_sep_index > 0:
            label = example[:label_sep_index]
        else:
            label = example

        try:
            label = float(label)
        except ValueError:
            label = None
            module_logger.warning(f"Cannot convert label {label} to float.")

        return label

    @property
    def raw_prediction_file_path(self):
        return os.path.join(self.vw_model.working_dir, VowpalWabbitConstant.RAW_PREDICTION_FILE_NAME)
