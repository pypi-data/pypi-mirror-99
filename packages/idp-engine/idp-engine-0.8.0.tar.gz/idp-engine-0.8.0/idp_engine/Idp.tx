IDP:
    Shebang?
    ( vocabularies=Vocabulary
    | theories=Theory
    | structures=Structure
    | procedures=Procedure) *
    display=Display?
;

Comment:
  /\/\/.*$/
;

Shebang: '#!' /.*$/;

Vocabulary: 'vocabulary' name=ID? '{' (declarations=Declaration)* '}';
  Declaration: Extern | RangeDeclaration | ConstructedTypeDeclaration | SymbolDeclaration;

    Extern: 'extern' 'vocabulary' (name=ID);

    ConstructedTypeDeclaration: /type[ \t]/ name=ID (':=' enumeration=Enumeration)?;

    RangeDeclaration: /type[ \t]/ name=ID ':=' '{' elements*=RangeElement[','] '}';
      RangeElement: fromI=Number ('..' toI=Number)?;

    SymbolDeclaration: annotations=Annotations symbols+=Symbol[','] ':'
          ( '(' sorts*=Symbol[/[*‚®Ø]/] ')' | sorts*=Symbol[/[*‚®Ø]/] )
          ('->' | '‚Üí') out=Symbol;
      Symbol: name=/`?[^\d\W]\w*\b|ùîπ|‚Ñ§|‚Ñù|'(\.|[^'])*'/;

  Annotations: ('[' annotations*=/[^\]]*/ ']')*;

Theory: 'theory' (name=ID ':' vocab_name=ID)? '{' ( definitions=Definition* (constraints=Expression '.')* interpretations=SymbolInterpretation* )* '}';

  Definition: '{' rules*=Rule '}';
  Rule: annotations=Annotations
        (('!'|'‚àÄ') quantees+=Quantee[','] ':' )* symbol=Symbol args=Arguments? ('=' out=SumMinus)?
        (('<-'|'‚Üê') body=Expression)? '.' ;
      Quantee: var=/`?[^\d\W]\w*\b/ ( ('in' | '‚àà') sort=SymbolExpr)? ;

  Expression: IfExpr | Quantification;
    IfExpr: 'if' if_f=Quantification 'then' then_f=Expression 'else' else_f=Expression;

    Quantification: AQuantification | RImplication;
    RImplication:   ARImplication   | Equivalence;
    Equivalence:    AEquivalence    | Implication;
    Implication:    AImplication    | Disjunction;
    Disjunction:    ADisjunction    | Conjunction;
    Conjunction:    AConjunction    | Comparison;
    Comparison:     AComparison     | SumMinus;
    SumMinus:       ASumMinus       | MultDiv;
    MultDiv:        AMultDiv        | Power;
    Power:          APower          | Unary;
    Unary:          AUnary          | Aggregate;
    Aggregate:      AAggregate      | Base;


    AQuantification: q=Quantor quantees+=Quantee[','] ':' f=Expression;
      Quantor: '‚àÄ' | '!' | '‚àÉ' | '?' ;
    ARImplication: sub_exprs=Equivalence (operator=RImplicationOp sub_exprs=Equivalence)+;
    AEquivalence:  sub_exprs=Implication (operator=EquivalenceOp  sub_exprs=Implication)+;
    AImplication:  sub_exprs=Disjunction (operator=ImplicationOp  sub_exprs=Disjunction)+;
    ADisjunction:  sub_exprs=Conjunction (operator=DisjunctionOp  sub_exprs=Conjunction)+;
    AConjunction:  sub_exprs=Comparison  (operator=ConjunctionOp  sub_exprs=Comparison )+;
    AComparison:   sub_exprs=SumMinus    (operator=ComparisonOp   sub_exprs=SumMinus   )+;
    ASumMinus:     sub_exprs=MultDiv     (operator=SumMinusOp     sub_exprs=MultDiv    )+;
    AMultDiv:      sub_exprs=Power       (operator=MultDivOp      sub_exprs=Power      )+;
    APower:        sub_exprs=Unary       (operator='^'            sub_exprs=Unary      );
    AUnary: !INT !IDPFLOAT               (operators+=UnaryOperator  f=Aggregate);
    AAggregate: !Date aggtype=AggType '{' quantees*=Quantee[',']  ':' f=Expression (':'  out=Expression)? '}';
      AggType: '#' | 'card' | 'sum';

    RImplicationOp: '<=' | '‚áê';
    EquivalenceOp: '<=>' | '‚áî';
    ImplicationOp:  '=>' | '‚áí';
    DisjunctionOp:   '|' | '‚à®';
    ConjunctionOp:   '&' | '‚àß';
    ComparisonOp:   '=<' | '>=' | '~=' | '=' | '<' | '>' | '‚â§' | '‚â•' | '‚â†' ;
    SumMinusOp:      '+' | '-';
    MultDivOp:       '*' | '/' | '%';
    UnaryOperator:   '-' | '~' | '¬¨';


    Base:  AppliedSymbol | UnappliedSymbol | Number | Date | Brackets;

      AppliedSymbol: symbol=SymbolExpr args=Arguments
              ( is_enumerated=/is\s+(not\s+)?enumerated/
              | is_enumeration=/(not\s+)?in/ in_enumeration=Enumeration)?;
        SymbolExpr: s=Symbol | eval='$' '(' s=Expression ')';
        Arguments: '(' sub_exprs*=Expression[','] ')';
      UnappliedSymbol: s=Symbol;
      Number: number=IDPFLOAT | number=INT;
        IDPFLOAT: /[+-]?(\d+(\.\d+)?e[+-]?\d+|\.\d+e[+-]?\d+|\d+(\.\d+)?|\.\d+)/;
      Date: iso=/#\d{4}-\d{2}-\d{2}/ | iso='#TODAY';
      Brackets: annotations=Annotations '(' f=Expression ')';


Structure: 'structure' name=ID? (':' vocab_name=ID)?
           '{' interpretations*=SymbolInterpretation '}';
  SymbolInterpretation: name=Symbol ':='
                        ( default=Identifier '.'?
                        | enumeration=FunctionEnum ('else' default=Identifier)?
                        | enumeration=Enumeration
                        | enumeration=CSVEnumeration);
  FunctionEnum: '{' tuples+=FunctionTuple[','] '}';
  FunctionTuple: ( args=Identifier | '(' args*=Identifier[','] ')' )?
                  ('->' | '‚Üí') value=Identifier;
  Enumeration: '{' tuples*=Tuple[','] '}';
  Tuple:  ( args=Identifier | '(' args*=Identifier[','] ')' );
  CSVEnumeration[noskipws]: /\s*/ '{' /\n/ tuples*=CSVTuple[/\n/] / */ '}';
  CSVTuple[noskipws]:  args*=Identifier[/([\t ]*,[\t ]*|[\t ]+)/];
  Identifier: UnappliedSymbol | Number | Date;

Goal: 'goal' name=ID;

View: 'view' viewType=ViewType;
  ViewType: 'normal' | 'expanded';

Display: 'display' '{' (constraints=Expression '.')* '}';

Procedure: 'procedure' name=ID '(' args=ID*')' '{' pystatements=PyStatement* '}';

  PyStatement: Call1 | PyAssignment ;
  Call1: name=ID '(' ( args+=Call0[','] (',' kwargs+=PyAssignment[','])?
                     | kwargs*=PyAssignment[',']) ')'
        ('.' post=PyExpr)?;
  Call0: !PyAssignment pyExpr=PyExpr;
  PyExpr: Call1 | String | Number | ID | PyList;
  String: literal=/"(\.|[^"])*"/;
  PyList: '[' elements*=PyExpr[','] ']';

  PyAssignment: var=ID '=' val=Call0;

