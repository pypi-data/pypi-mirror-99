{% from 'tf1x_utils.j2' import session, check_input_vars, representative_dataset_gen %}

{% macro train_normal(layer_spec, graph_spec) %}        
        
        sess = self._sess                 
        self._variables = {k: v for k, v in locals().items() if can_serialize(v)}
        self._checkpoint_save_path = '{{layer_spec.checkpoint_path}}'

        def train_step(sess):
            if not self._headless:
                _, self._loss_training, self._squared_error_training, \
                    self._squared_variance_training, self._r_squared_training,\
                    self._layer_outputs, self._layer_weights, self._layer_biases, \
                    self._layer_gradients \
                    = sess.run([
                        self._weights, self._loss, self._squared_err,
                        self._squared_var, self._r_sq, 
                        self._layer_output, self._layer_weight, self._layer_bias, self._layer_gradient
                    ])
            else:
                _, self._loss_training, self._squared_error_training, \
                    self._squared_variance_training, self._r_squared_training \
                    = sess.run([
                        self._weights, self._loss, self._squared_err,
                        self._squared_var, self._r_sq 
                    ])
    
        def validation_step(sess):
            if not self._headless:
                self._loss_validation, self._squared_error_validation, \
                    self._squared_variance_validation, self._r_squared_validation, \
                    self._layer_outputs, self._layer_weights, self._layer_biases, \
                    self._layer_gradients \
                    = sess.run([
                        self._loss, self._squared_err,
                        self._squared_var, self._r_sq, 
                        self._layer_output, self._layer_weight, self._layer_bias, self._layer_gradient
                    ])
            else:
                self._loss_validation, self._squared_error_validation, \
                    self._squared_variance_validation, self._r_squared_validation \
                    = sess.run([
                        self._loss, self._squared_err,
                        self._squared_var, self._r_sq 
                    ])

        
        log.info("Entering training loop")

        # Training loop
        self._epoch = 0
        while self._epoch < self._n_epochs and not self._stopped:
            t0 = time.perf_counter()
            self._training_iteration = 0
            self._validation_iteration = 0
            self._status = 'training'
            sess.run(self._trn_init)            
            try:
                while not self._stopped:
                    train_step(sess)
                    yield YieldLevel.SNAPSHOT
                    self._training_iteration += 1
            except tf.errors.OutOfRangeError:
                pass

            self._status = 'validation'
            sess.run(self._val_init)            
            try:
                while not self._stopped:
                    validation_step(sess)
                    yield YieldLevel.SNAPSHOT                    
                    self._validation_iteration += 1
            except tf.errors.OutOfRangeError:
                pass
            log.info(
                f"Finished epoch {self._epoch+1}/{self._n_epochs} - "
                f"loss training, validation: {self.loss_training:.6f}, {self.loss_validation:.6f} - "
                
            )
            log.info(f"Epoch duration: {round(time.perf_counter() - t0, 3)} s")            
            
            self._epoch += 1


        self._variables = {k: v for k, v in locals().items() if can_serialize(v)}            
        self._status = 'finished'
        yield YieldLevel.SNAPSHOT
        self.on_export(self._checkpoint_save_path, 'checkpoint')   
        sess.close()
{% endmacro %}


{% macro test_normal(layer_spec, graph_spec) %}
                  
        sess = self._sess
        self._epoch = 0

        def test_step(sess):
            self._loss_testing, self._squared_error_testing, \
                self._squared_variance_testing, self._r_squared_testing, \
                self._layer_outputs, self._layer_weights, self._layer_gradients \
                = sess.run([
                    self._loss, self._squared_err,
                    self._squared_var, self._r_sq,
                    self._layer_output, self._layer_weight, self._layer_gradient
                ])
        
        # Test loop
        log.info("Entering testing loop")
        self._status = 'testing'

        self._testing_iteration = 0
        sess.run(self._tst_init)                                
        while not self._stopped:
            try:
                test_step(sess)
                yield YieldLevel.SNAPSHOT
                self._testing_iteration += 1
            except tf.errors.OutOfRangeError:
                self._testing_iteration = 0
                sess.run(self._tst_init)
                test_step(sess)   
                yield YieldLevel.SNAPSHOT
        
        self._status = 'finished'
        self._variables = {k: v for k, v in locals().items() if can_serialize(v)}
        yield YieldLevel.SNAPSHOT
        sess.close()
{% endmacro %}

{% macro init_normal(mode) %}
        self._status = 'initializing'

        {% filter remove_lspaces(8) %}
            {% if layer_spec.connection_predictions is not none %}
                output_layer_id = "{{graph_spec.nodes_by_id[layer_spec.connection_predictions.src_id].sanitized_name}}"
            {% else %}
                output_layer_id = None
            {% endif %}
        {% endfilter %}
        {% filter remove_lspaces(8) %}
            {% if layer_spec.connection_labels is not none %}
                target_layer_id = "{{graph_spec.nodes_by_id[layer_spec.connection_labels.src_id].sanitized_name}}"
            {% else %}
                target_layer_id = None
            {% endif %}
        {% endfilter %}

        input_data_nodes = graph.get_direct_data_nodes(output_layer_id)
        label_data_nodes = graph.get_direct_data_nodes(target_layer_id)

        assert len(input_data_nodes) == 1
        assert len(label_data_nodes) == 1
        input_data_node = input_data_nodes[0]
        label_data_node = label_data_nodes[0]

        self._trn_sz_tot = input_data_node.layer.size_training
        self._val_sz_tot = input_data_node.layer.size_validation
        self._tst_sz_tot = input_data_node.layer.size_testing

        input_sample = input_data_node.layer_instance.sample
        label_sample = label_data_node.layer_instance.sample


        # Make training set
        dataset_trn = tf.data.Dataset.zip((
            tf.data.Dataset.from_generator(
                input_data_node.layer_instance.make_generator_training,
                output_shapes={k: v.shape for k, v in input_sample.items()},
                output_types={k: v.dtype for k, v in input_sample.items()}
            ),
            tf.data.Dataset.from_generator(
                label_data_node.layer_instance.make_generator_training,
                output_shapes={k: v.shape for k, v in label_sample.items()},
                output_types={k: v.dtype for k, v in label_sample.items()}
            )
        ))

        # Make validation set
        dataset_val = tf.data.Dataset.zip((
            tf.data.Dataset.from_generator(
                input_data_node.layer_instance.make_generator_validation,
                output_shapes={k: v.shape for k, v in input_sample.items()},
                output_types={k: v.dtype for k, v in input_sample.items()}
            ),
            tf.data.Dataset.from_generator(
                label_data_node.layer_instance.make_generator_validation,
                output_shapes={k: v.shape for k, v in label_sample.items()},
                output_types={k: v.dtype for k, v in label_sample.items()}
            )
        ))

        # Make testing set
        dataset_tst = tf.data.Dataset.zip((
            tf.data.Dataset.from_generator(
                input_data_node.layer_instance.make_generator_testing,
                output_shapes={k: v.shape for k, v in input_sample.items()},
                output_types={k: v.dtype for k, v in input_sample.items()}
            ),
            tf.data.Dataset.from_generator(
                label_data_node.layer_instance.make_generator_testing,
                output_shapes={k: v.shape for k, v in label_sample.items()},
                output_types={k: v.dtype for k, v in label_sample.items()}
            )
        ))
        
        self._export_data_gen = input_data_node.layer_instance.make_generator_training()

        dataset_trn = dataset_trn.batch(self._batch_size)
        dataset_val = dataset_val.batch(self._batch_size)
        dataset_tst = dataset_tst.batch(1)                

        # Make initializers
        with tf.variable_scope('{{layer_spec.sanitized_name}}/train', reuse=tf.AUTO_REUSE):
            is_training = tf.get_variable(name="is_train", dtype=tf.bool, initializer=False)
        
        iterator = tf.data.Iterator.from_structure(dataset_trn.output_types, dataset_trn.output_shapes)

        trn_init = iterator.make_initializer(dataset_trn)
        trn_init = tf.group([trn_init, is_training.assign(True if self._batch_size > 1 else False)])
        
        val_init = iterator.make_initializer(dataset_val)
        val_init = tf.group([val_init, is_training.assign(False)])

        tst_init = iterator.make_initializer(dataset_tst)        
        tst_init = tf.group([tst_init, is_training.assign(False)])

        input_tensor, label_tensor = iterator.get_next()

        # Build the TensorFlow graph

        def build_graph(input_tensor, label_tensor):
            layer_output_tensors = {
                input_data_node.layer_id: input_tensor,
                label_data_node.layer_id: label_tensor
            }

            for dst_node in graph.inner_nodes:
                inputs = {
                    dst_var: layer_output_tensors[src_node.layer_id][src_var]
                    for src_node, src_var, dst_var in graph.get_input_connections(dst_node)
                }
                y = dst_node.layer_instance(
                    inputs,
                    is_training=is_training
                )
                layer_output_tensors[dst_node.layer_id] = y

            return layer_output_tensors

        layer_output_tensors = build_graph(input_tensor, label_tensor)

        output_tensor = None
        target_tensor = None

        for src_node, src_var, dst_var in graph.get_input_connections(graph.active_training_node):
            if dst_var == 'predictions':
                output_tensor = layer_output_tensors[output_layer_id][src_var]
                output_var_name = src_var
            if dst_var == 'labels':
                target_tensor = layer_output_tensors[target_layer_id][src_var]
        # ----
        update_ops = tf.compat.v1.get_collection(tf.GraphKeys.UPDATE_OPS)

        # Create an exportable version of the TensorFlow graph
        
        self._input_tensor_export = {
            key: tf.placeholder(shape=shape, dtype=type_)
            for (key, shape), (_, type_) in zip(dataset_trn.output_shapes[0].items(), dataset_trn.output_types[0].items())            
        }

        self._output_tensor_export = build_graph(
            self._input_tensor_export,
            {                                                                                                                                                                       
                key: tf.placeholder(shape=shape, dtype=type_)
                for (key, shape), (_, type_) in zip(dataset_trn.output_shapes[1].items(), dataset_trn.output_types[1].items())
            }             
        )[output_layer_id]

        # Calculate loss and other important metrics for RegressionLayer
        # Mean estimation for entire dataset included here
        loss_tensor = (tf.reduce_mean(tf.abs(output_tensor - target_tensor)))
        reg_error_tensor = tf.reduce_sum((output_tensor - target_tensor)) 
        squared_error_tensor = (tf.reduce_sum(tf.square(output_tensor - target_tensor)))

        y_bar_numerator = tf.constant(0.0)
        y_bar_numerator += tf.reduce_sum(target_tensor)

        y_bar_denominator = tf.constant(0.0)
        y_bar_denominator += self._batch_size

        y_bar_tensor = y_bar_numerator / y_bar_denominator



        squared_variance_tensor = tf.reduce_sum(tf.square(target_tensor - y_bar_tensor))
        r_squared_tensor = 1 - (tf.truediv(squared_variance_tensor,squared_error_tensor))

        global_step = None
        {% filter remove_lspaces(8) %}        
            {% if layer_spec.optimizer == 'SGD' %}
                optimizer = tf.compat.v1.train.GradientDescentOptimizer(learning_rate={{layer_spec.learning_rate}})
            {% elif layer_spec.optimizer == 'Momentum' %}
                global_step = tf.Variable(0)
                learning_rate_momentum = tf.train.exponential_decay(
                    learning_rate={{layer_spec.learning_rate}},
                    global_step=global_step,
                    decay_steps={{layer_spec.decay_steps}},
                    decay_rate={{layer_spec.decay_rate}},
                    staircase=True
                )
                optimizer = tf.train.MomentumOptimizer(learning_rate=learning_rate_momentum, momentum={{layer_spec.momentum}})
            {% elif layer_spec.optimizer == 'ADAM' %}
                optimizer = tf.train.AdamOptimizer(learning_rate={{layer_spec.learning_rate}}, beta1={{layer_spec.beta1}}, beta2={{layer_spec.beta2}})
            {% elif layer_spec.optimizer == 'adagrad' %}
                optimizer = tf.compat.v1.train.AdagradOptimizer(learning_rate={{layer_spec.learning_rate}})            
            {% elif layer_spec.optimizer == 'RMSprop' %}
                optimizer = tf.compat.v1.train.RMSPropOptimizer(learning_rate={{layer_spec.learning_rate}})                        
            {% else %}
                raise NotImplementedError('Optimizer {{layer_spec.optimizer}} not supported yet')
            {% endif %}
        {% endfilter %}

        layer_weight_tensors = {}
        layer_bias_tensors = {}        
        layer_gradient_tensors = {}
        for node in graph.inner_nodes:
            if not isinstance(node.layer, Tf1xLayer): # In case of pure custom layers...
                continue
            
            layer_weight_tensors[node.layer_id] = node.layer.weights
            layer_bias_tensors[node.layer_id] = node.layer.biases            
            
            if len(node.layer.trainable_variables) > 0:
                gradients = {}
                for name, tensor in node.layer.trainable_variables.items():
                    grad_tensor = tf.gradients(loss_tensor, tensor)
                    if any(x is None for x in grad_tensor):
                        grad_tensor = tf.constant(0)
                    gradients[name] = grad_tensor
                layer_gradient_tensors[node.layer_id] = gradients
                # self._internal_layer_gradients[node.layer_id] = {name: [] for name in node.layer.trainable_variables.keys()} # Initialize
                # self._layer_gradients = self._internal_layer_gradients.copy()

        # trainable_vars = tf.trainable_variables()
        # grads = tf.gradients(loss_tensor, trainable_vars)
        # update_weights = optimizer.apply_gradients(zip(grads, trainable_vars), global_step=global_step)        
        
        update_weights = optimizer.minimize(loss_tensor, global_step=global_step)
        update_weights = tf.group([update_weights, update_ops])
                
        sess = None
        {{session(sess, use_gpu=not layer_spec.use_cpu) | indent(width=8)}}     
        self._sess = sess

        trackable_variables = {}
        trackable_variables.update({x.name: x for x in tf.trainable_variables() if isinstance(x, Trackable)})
        trackable_variables.update({k: v for k, v in locals().items() if isinstance(v, Trackable) and not isinstance(v, tf.python.data.ops.iterator_ops.Iterator)})
        self._checkpoint = tf.train.Checkpoint(**trackable_variables)
        
        sess.run(tf.global_variables_initializer())
        
        checkpoint_directory = '{{layer_spec.checkpoint_path}}'
        use_checkpoint = {{layer_spec.load_checkpoint}}
        if use_checkpoint:
            path = tf.train.latest_checkpoint(checkpoint_directory)
            if path is not None:
                status = self._checkpoint.restore(path)
                status.run_restore_ops(session=self._sess)
            elif path is None and self._mode == 'testing':
                log.error('There are no saved checkpoint files for this model.')
                self._sess.close()


        self._trn_init = trn_init
        self._val_init = val_init
        self._tst_init = tst_init

        self._weights = update_weights
        self._loss = loss_tensor
        self._squared_err = squared_error_tensor
        self._squared_var = squared_variance_tensor
        self._r_sq = r_squared_tensor
        self._layer_output = layer_output_tensors
        self._layer_weight = layer_weight_tensors
        self._layer_bias = layer_bias_tensors
        self._layer_gradient = layer_gradient_tensors
{% endmacro %}



################################################### Main #####################################################
{% macro layer_tf1x_regression(layer_spec, graph_spec) %}                    
class {{layer_spec.sanitized_name}}(RegressionLayer):
    def __init__(self):
        {{ check_input_vars(layer_spec, ['labels', 'predictions'])|indent(width=8)}}        
        self._n_epochs = {{layer_spec.n_epochs}}
        self._batch_size = {{layer_spec.batch_size}}

        self._stopped = False
        self._paused = False
        self._headless = False
        self._status = 'created'
        
        self._loss_training = 0.0
        self._loss_validation = 0.0
        self._loss_testing = 0.0

        self._squared_error_training = 0.0
        self._squared_error_validation = 0.0
        self._squared_error_testing = 0.0

        self._squared_variance_training = 0.0
        self._squared_variance_validation = 0.0
        self._squared_variance_testing = 0.0

        self._r_squared_training = 0.0
        self._r_squared_validation = 0.0               
        self._r_squared_testing = 0.0


        self._variables = {}
        self._layer_outputs = {}
        self._layer_weights = {}
        self._layer_biases = {}        
        self._layer_gradients = {}

        self._training_iteration = 0
        self._validation_iteration = 0
        self._testing_iteration = 0

        self._trn_sz_tot = 0
        self._val_sz_tot = 0
        self._tst_sz_tot = 0

        self._checkpoint = None
            
    def init_layer(self, graph:Graph, mode = 'initializing'):
        """This is the function that makes the training layer runnable. We take all variable initializations for tensors and initializers and wrap them in dictionaries
        to be called in run().
        """
        self._mode = mode
        {% if not layer_spec.distributed -%}
            {{ init_normal() }}
        {% endif %}

        
    def train(self, graph:Graph):
        """Training is done when this function is called. Once the training ends, checkpoint files are saved.
        """
    
        {% if not layer_spec.distributed -%}
            {{ train_normal(layer_spec, graph_spec) }}
        {% endif %} 

    def test(self, graph:Graph):
        """Testing is done when this function is called. 
        """

        {% if not layer_spec.distributed -%}
            {{ test_normal(layer_spec, graph_spec) }}
        {% endif %} 

    def run(self, graph: Graph, mode = 'initializing'):
        """Called as the main entry point for training. Responsible for training the model.

        Args:
            graph: A PerceptiLabs Graph object containing references to all layers objects included in the model produced by this training layer.
        """  
        self.init_layer(graph, mode)
        self._variables = {k: v for k, v in locals().items() if can_serialize(v)} 
        
        if mode == 'training':
            yield from self.train(graph)
        elif mode == 'testing':
            yield from self.test(graph)


    def on_export(self, path: str, mode: str) -> None:
        """Called when the export button is clicked in the frontend.
        It is up to the implementing layer to save the model to disk.
        
        Args:
            path: the directory where the exported model will be stored.
            mode: how to export the model. Made available to frontend via 'export_modes' property."""

        log.debug(f"Export called. Project path = {path}, mode = {mode}")
        
        if mode in ['TFModel', 'TFLite', 'TFQuantized']:
            pb_path = os.path.join(path, '1')
            if os.path.exists(pb_path):
                shutil.rmtree(pb_path)
            
            time.sleep(.0000000000000001) #Force your computer to do a clock cycle to avoid Windows permission exception

            os.makedirs(pb_path, exist_ok=True)
        
        # Export non-compressed model
        if mode in ['TFModel']:
            tf.compat.v1.saved_model.simple_save(self._sess, pb_path, inputs=self._input_tensor_export, outputs=self._output_tensor_export)

        # Export compressed model
        if mode in ['TFLite']:
            frozen_path = os.path.join(pb_path, 'frozen_model.pb')
            converter = tf.lite.TFLiteConverter.from_session(self._sess, list(self._input_tensor_export.values()), list(self._output_tensor_export.values()))
            converter.post_training_quantize = True
            tflite_model = converter.convert()
            with open(frozen_path, "wb") as f:
                f.write(tflite_model)
        
        if mode in ['TFQuantized']:
            {{representative_dataset_gen('self._export_data_gen') | indent(width=12)}}
            tflite_path = os.path.join(pb_path, 'tflite_model.tflite')
            converter = tf.lite.TFLiteConverter.from_session(self._sess, [self._input_tensor_export['output']], [self._output_tensor_export['output']])
            converter.optimizations = [tf.lite.Optimize.DEFAULT]
            converter.representative_dataset = representative_dataset_gen
            converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS_INT8, tf.lite.OpsSet.TFLITE_BUILTINS, tf.lite.OpsSet.SELECT_TF_OPS]
            converter.inference_input_type = tf.uint8
            converter.inference_output_type = tf.uint8
            tflite_model = converter.convert()
            with open(tflite_path, "wb") as f:
                f.write(tflite_model)
            

        # Export checkpoint
        if mode in ['checkpoint']:
            os.makedirs(path, exist_ok=True)
            for fname in os.listdir(path):
                if fname.endswith('.json'):
                    pass
                else:
                    os.remove(os.path.join(path,fname))
            {% filter remove_lspaces(8) %}
                {% if layer_spec.distributed %}
                    self._saver.save(self._sess, os.path.join(path, 'model.ckpt'), global_step=0)
                {% else %}
                    self._checkpoint.save(file_prefix=os.path.join(path, 'model.ckpt'), session=self._sess)
                {% endif %}
            {% endfilter %}
                
    def on_stop(self) -> None:
        """Called when the save model button is clicked in the frontend. 
        It is up to the implementing layer to save the model to disk."""
        self.on_export(self._checkpoint_save_path, 'checkpoint')   
        self._stopped = True

    def on_headless_activate(self) -> None:
        """"Called when the statistics shown in statistics window are not needed.
        Purose is to speed up the iteration speed significantly."""
        self._headless = True

        self._layer_outputs = {} 
        self._layer_weights = {}
        self._layer_biases = {}
        self._layer_gradients = {}

    def on_headless_deactivate(self) -> None:
        """"Called when the statistics shown in statistics window are needed.
        May slow down the iteration speed of the training."""
        import time
        log.info(f"Set to headless_off at time {time.time()}")
        self._headless = False

    @property
    def export_modes(self) -> List[str]:
        """Returns the possible modes of exporting a model."""        
        return [
            'TFModel',
            'TFLite'
            'TFQuantized',
            'checkpoint'            
        ]
        
    @property
    def is_paused(self) -> None:
        """Returns true when the training is paused."""        
        return self._paused

    @property
    def batch_size(self):
        """ Size of the current training batch """        
        return self._batch_size

    @property
    def status(self):
        """Called when the pause button is clicked in the frontend. It is up to the implementing layer to pause its execution."""        
        return self._status
    
    @property
    def epoch(self):
        """The current epoch"""        
        return self._epoch

    @property
    def variables(self):
        """Any variables belonging to this layer that should be rendered in the frontend.
        
        Returns:
            A dictionary with tensor names for keys and picklable for values.
        """
        return self._variables.copy()        

    @property
    def sample(self) -> Dict[str, Dict[str, Picklable]]:
        """Returns a single data sample"""        
        return {'output': np.array(self._loss_training)}

    @property
    def columns(self) -> List[str]: 
        """Column names. Corresponds to each column in a sample """
        return []

    @property
    def size_training(self) -> int:
        """Returns the size of the training dataset"""                                    
        return self._trn_sz_tot

    @property
    def size_validation(self) -> int:
        """Returns the size of the validation dataset"""                                            
        return self._val_sz_tot

    @property
    def size_testing(self) -> int:
        """Returns the size of the testing dataset"""
        return self._tst_sz_tot

    def make_generator_training(self) -> Generator[np.ndarray, None, None]:
        """Returns a generator yielding single samples of training data. In the case of a training layer, this typically yields the model output."""        
        yield from []
        
    def make_generator_validation(self) -> Generator[np.ndarray, None, None]:
        """Returns a generator yielding single samples of validation data. In the case of a training layer, this typically yields the model output."""                
        yield from []
        
    def make_generator_testing(self) -> Generator[np.ndarray, None, None]:
        """Returns a generator yielding single samples of testing data. In the case of a training layer, this typically yields the model output."""                        
        yield from []

    @property
    def loss_training(self) -> float:
        """Returns the current loss of the training phase"""                
        return self._loss_training

    @property
    def loss_validation(self) -> float:
        """Returns the current loss of the validation phase"""                        
        return self._loss_validation        

    @property
    def loss_testing(self) -> float:
        """Returns the current loss of the testing phase"""                
        return self._loss_testing

    @property
    def squared_error_training(self) -> float:
        """Returns the current squared error of the training phase"""
        return self._squared_error_training
    
    @property
    def squared_error_testing(self) -> float:
        """Returns the current squared error of the testing phase"""
        return self._squared_error_testing
    
    @property
    def squared_error_validation(self) -> float:
        """Returns the current squared error of the validation phase"""
        return self._squared_error_validation

    @property
    def squared_variance_training(self) -> float:
        """Returns the current squared variance of the training phase"""
        return self._squared_variance_training

    @property
    def squared_variance_testing(self) -> float:
        """Returns the current squared variance of the testing phase"""
        return self._squared_variance_testing

    @property
    def squared_variance_validation(self) -> float:
        """Returns the current squared variance of the validation phase"""
        return self._squared_variance_validation

    @property
    def r_squared_training(self) -> float:
        """
        Returns the current R^2 estimate of the training phase
        
        ** Note ** 
        The reason this is considered an estimate is because finding the R^2 of a regression 
        model involves comparing the true output values with the mean of the true output values 
        when computing the squared variance. 

        The mean of true output values is not precomputed due to potential memory limitations, 
        but is iterated on as we're going through the dataset. As we approach the end of the 
        data, the mean of the true output approaches its actual value.

        """
        return self._r_squared_training

    @property
    def r_squared_testing(self) -> float:
        """
        Returns the current R^2 estimate of the testing phase 
        
        ** Note ** 
        The reason this is considered an estimate is because finding the R^2 of a regression 
        model involves comparing the true output values with the mean of the true output values 
        when computing the squared variance. 

        The mean of true output values is not precomputed due to potential memory limitations, 
        but is iterated on as we're going through the dataset. As we approach the end of the 
        data, the mean of the true output approaches its actual value.
        
        """
        return self._r_squared_testing

    @property
    def r_squared_validation(self) -> float:
        """
        Returns the current R^2 estimate of the validation phase
    
        ** Note ** 
        The reason this is considered an estimate is because finding the R^2 of a regression 
        model involves comparing the true output values with the mean of the true output values 
        when computing the squared variance. 

        The mean of true output values is not precomputed due to potential memory limitations, 
        but is iterated on as we're going through the dataset. As we approach the end of the 
        data, the mean of the true output approaches its actual value.

        """

        return self._r_squared_validation

    @property
    def layer_weights(self) -> Dict[str, Dict[str, Picklable]]:
        """The weight values of each layer in the input Graph during the training.

        Returns:
            A dictionary of nested dictionaries, where each key is a layer id. The nested dictionaries contain weight name and value pairs. The values must be picklable.
        """        
        return self._layer_weights

    @property
    def layer_biases(self) -> Dict[str, Dict[str, Picklable]]:
        """The bias values of each layer in the input Graph during the training.

        Returns:
            A dictionary of nested dictionaries, where each key is a layer id. The nested dictionaries contain weight name and value pairs. The values must be picklable.
        """        
        return self._layer_biases
    
    @property
    def layer_gradients(self) -> Dict[str, Dict[str, Picklable]]:
        """The gradients with respect to the loss of all trainable variables of each layer in the input Graph.

        Returns:
            A dictionary of nested dictionaries, where each key is a layer id. The nested dictionaries contain gradient name and value pairs. The values must be picklable.
        """        
        return self._layer_gradients
    
    @property
    def layer_outputs(self) -> Dict[str, Dict[str, Picklable]]:
        """The output values of each layer in the input Graph during the training (e.g., tf.Tensors evaluated for each iteration)

        Returns:
            A dictionary of nested dictionaries, where each key is a layer id. The nested dictionaries contain variable name and value pairs. The values must be picklable.
        """
        return self._layer_outputs

    @property
    def training_iteration(self) -> int:
        """The current training iteration"""
        return self._training_iteration

    @property
    def validation_iteration(self) -> int:
        """The current validation iteration"""        
        return self._validation_iteration

    @property
    def testing_iteration(self) -> int:
        """The current testing iteration"""                
        return self._testing_iteration
    
    @property
    def progress(self) -> float:
        """A number indicating the overall progress of the training
        
        Returns:
            A floating point number between 0 and 1
        """        
        n_iterations_per_epoch = np.ceil(self.size_training / self.batch_size) + \
                                 np.ceil(self.size_validation / self.batch_size)
        n_iterations_total = self._n_epochs * n_iterations_per_epoch

        iteration = self.epoch * n_iterations_per_epoch + \
                    self.training_iteration + self.validation_iteration
        
        progress = min(iteration/(n_iterations_total - 1), 1.0) 
        return progress
{% endmacro %} 
