# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from google.protobuf import any_pb2 as google_dot_protobuf_dot_any__pb2
from google.protobuf import empty_pb2 as google_dot_protobuf_dot_empty__pb2
from hansken_extraction_plugin.framework import DataMessages_pb2 as hansken__extraction__plugin_dot_framework_dot_DataMessages__pb2


class ExtractionPluginServiceStub(object):
    """

    The following PlantUML diagram describes the lifecycle of a Extraction Plugin.

    Notes:
    An extraction plugin runs as a server,
    An extraction plugin initializes itself standalone when started,
    Extraction plugins can handle requests in parallel (from multiple extraction
    subprocesses),
    The messages shown in the diagram are pseudo-names. The actual
    implementation uses different message names.

    `process()` opens a bi-directional communication stream between the client.
    Messages are sent over this channel, denoted in the graph with a different
    arrow style (->>, and <<-),
    `process()` is automatically scoped to process a single trace,
    The extraction plugin can handle multiple `process()` calls concurrently.
    A special start message is added that sends the Trace to be processed from
    Hansken to the plugin. This message can not be passed as process() argument,
    since gRPC methods only accept one argument, in this case a message stream.

    @startuml
    autonumber

    collections Hansken
    participant ExtractionPlugin

    group Initialization
    ExtractionPlugin    ->  ExtractionPlugin: setup(config)
    Hansken ->  ExtractionPlugin : pluginInfo()
    Hansken <-- ExtractionPlugin : PluginInfo
    end

    group Process a Trace
    Hansken ->  ExtractionPlugin : process()

    ' messages on communication the stream
    Hansken ->>  ExtractionPlugin : start(Trace, ...)

    Hansken <<-  ExtractionPlugin : request(..)
    Hansken -->> ExtractionPlugin : response

    Hansken <<-  ExtractionPlugin : action(...)

    alt
    Hansken <<-- ExtractionPlugin : finish()
    else exception
    Hansken <<-- ExtractionPlugin : partialFinishWithError(...)
    end

    end
    @enduml

    *
    ExtractionPlugin service definition, that is implemented by the extraction
    plugin server.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.pluginInfo = channel.unary_unary(
                '/org.hansken.extraction.plugin.grpc.ExtractionPluginService/pluginInfo',
                request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
                response_deserializer=hansken__extraction__plugin_dot_framework_dot_DataMessages__pb2.RpcPluginInfo.FromString,
                )
        self.process = channel.stream_stream(
                '/org.hansken.extraction.plugin.grpc.ExtractionPluginService/process',
                request_serializer=google_dot_protobuf_dot_any__pb2.Any.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_any__pb2.Any.FromString,
                )


class ExtractionPluginServiceServicer(object):
    """

    The following PlantUML diagram describes the lifecycle of a Extraction Plugin.

    Notes:
    An extraction plugin runs as a server,
    An extraction plugin initializes itself standalone when started,
    Extraction plugins can handle requests in parallel (from multiple extraction
    subprocesses),
    The messages shown in the diagram are pseudo-names. The actual
    implementation uses different message names.

    `process()` opens a bi-directional communication stream between the client.
    Messages are sent over this channel, denoted in the graph with a different
    arrow style (->>, and <<-),
    `process()` is automatically scoped to process a single trace,
    The extraction plugin can handle multiple `process()` calls concurrently.
    A special start message is added that sends the Trace to be processed from
    Hansken to the plugin. This message can not be passed as process() argument,
    since gRPC methods only accept one argument, in this case a message stream.

    @startuml
    autonumber

    collections Hansken
    participant ExtractionPlugin

    group Initialization
    ExtractionPlugin    ->  ExtractionPlugin: setup(config)
    Hansken ->  ExtractionPlugin : pluginInfo()
    Hansken <-- ExtractionPlugin : PluginInfo
    end

    group Process a Trace
    Hansken ->  ExtractionPlugin : process()

    ' messages on communication the stream
    Hansken ->>  ExtractionPlugin : start(Trace, ...)

    Hansken <<-  ExtractionPlugin : request(..)
    Hansken -->> ExtractionPlugin : response

    Hansken <<-  ExtractionPlugin : action(...)

    alt
    Hansken <<-- ExtractionPlugin : finish()
    else exception
    Hansken <<-- ExtractionPlugin : partialFinishWithError(...)
    end

    end
    @enduml

    *
    ExtractionPlugin service definition, that is implemented by the extraction
    plugin server.
    """

    def pluginInfo(self, request, context):
        """*
        Returns Extraction Plugin information, that is, a full description of the
        extraction plugin, and it expected input and outputs.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def process(self, request_iterator, context):
        """*
        Request from client to server to start processing a trace.
        A trace is fully processed within the scope of this method.

        This request opens a bi-directional communication stream between
        client and server. All calls required for processing a trace are
        handled as messages on this channel.

        First message should be a Start-message from client to server.
        The last message should be a Finish-message from server to client.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_ExtractionPluginServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'pluginInfo': grpc.unary_unary_rpc_method_handler(
                    servicer.pluginInfo,
                    request_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                    response_serializer=hansken__extraction__plugin_dot_framework_dot_DataMessages__pb2.RpcPluginInfo.SerializeToString,
            ),
            'process': grpc.stream_stream_rpc_method_handler(
                    servicer.process,
                    request_deserializer=google_dot_protobuf_dot_any__pb2.Any.FromString,
                    response_serializer=google_dot_protobuf_dot_any__pb2.Any.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'org.hansken.extraction.plugin.grpc.ExtractionPluginService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class ExtractionPluginService(object):
    """

    The following PlantUML diagram describes the lifecycle of a Extraction Plugin.

    Notes:
    An extraction plugin runs as a server,
    An extraction plugin initializes itself standalone when started,
    Extraction plugins can handle requests in parallel (from multiple extraction
    subprocesses),
    The messages shown in the diagram are pseudo-names. The actual
    implementation uses different message names.

    `process()` opens a bi-directional communication stream between the client.
    Messages are sent over this channel, denoted in the graph with a different
    arrow style (->>, and <<-),
    `process()` is automatically scoped to process a single trace,
    The extraction plugin can handle multiple `process()` calls concurrently.
    A special start message is added that sends the Trace to be processed from
    Hansken to the plugin. This message can not be passed as process() argument,
    since gRPC methods only accept one argument, in this case a message stream.

    @startuml
    autonumber

    collections Hansken
    participant ExtractionPlugin

    group Initialization
    ExtractionPlugin    ->  ExtractionPlugin: setup(config)
    Hansken ->  ExtractionPlugin : pluginInfo()
    Hansken <-- ExtractionPlugin : PluginInfo
    end

    group Process a Trace
    Hansken ->  ExtractionPlugin : process()

    ' messages on communication the stream
    Hansken ->>  ExtractionPlugin : start(Trace, ...)

    Hansken <<-  ExtractionPlugin : request(..)
    Hansken -->> ExtractionPlugin : response

    Hansken <<-  ExtractionPlugin : action(...)

    alt
    Hansken <<-- ExtractionPlugin : finish()
    else exception
    Hansken <<-- ExtractionPlugin : partialFinishWithError(...)
    end

    end
    @enduml

    *
    ExtractionPlugin service definition, that is implemented by the extraction
    plugin server.
    """

    @staticmethod
    def pluginInfo(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/org.hansken.extraction.plugin.grpc.ExtractionPluginService/pluginInfo',
            google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            hansken__extraction__plugin_dot_framework_dot_DataMessages__pb2.RpcPluginInfo.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def process(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_stream(request_iterator, target, '/org.hansken.extraction.plugin.grpc.ExtractionPluginService/process',
            google_dot_protobuf_dot_any__pb2.Any.SerializeToString,
            google_dot_protobuf_dot_any__pb2.Any.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
